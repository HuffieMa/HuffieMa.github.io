<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALFA博客</title>
  
  
  <link href="https://www.mahaofei.com/atom.xml" rel="self"/>
  
  <link href="https://www.mahaofei.com/"/>
  <updated>2022-04-09T13:29:20.813Z</updated>
  <id>https://www.mahaofei.com/</id>
  
  <author>
    <name>Huffie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>各大视频音频网站资源下载</title>
    <link href="https://www.mahaofei.com/post/2c340937.html"/>
    <id>https://www.mahaofei.com/post/2c340937.html</id>
    <published>2022-04-08T11:34:53.000Z</published>
    <updated>2022-04-09T13:29:20.813Z</updated>
    
    <content type="html"><![CDATA[<h1>介绍</h1><p>使用<a href="https://github.com/soimort/you-get">You-get工具</a>，这是Github上的一个项目，可以下载大多数主流网站的视频，图片、音频。</p><p>支持的网站包括YouTube、Twitter、Facebook、bilibili、AcFun、niconico、网易云音乐、酷狗音乐、qq音乐、爱奇艺、腾讯视频、抖音、快手、知乎等等。</p><blockquote><p>详细文档参见：<a href="https://github.com/soimort/you-get">https://github.com/soimort/you-get</a></p></blockquote><h1>工具准备</h1><h2 id="1-下载安装python3">1. 下载安装python3</h2><p>网上有很多教程，按照教程安装最新版的python即可。</p><h2 id="2-安装you-get">2. 安装you-get</h2><p>按下<code>win+R</code>输入<code>cmd</code>，打开命令行窗口，使用如下指令安装you-get工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure><p>然后输入下方代码，升级you-get工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407190404.png" alt=""></p><h1>使用方法</h1><h2 id="1-查看可以下载的质量和格式">1. 查看可以下载的质量和格式</h2><p>复制想要下载的视频或音频的网页链接。</p><p>使用<code>--info</code>/<code>-i</code>指令即可查看所有可以下载的文件质量和格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407191446.png" alt=""></p><h2 id="2-下载视频-音频-图片">2. 下载视频/音频/图片</h2><p>直接使用<code>you-get</code>指令会下载defalut下面的第一种格式，并下载到命令行当前所在目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p>如果想要下载特定的格式，找到对应格式下面提示的下载指令，使用下载指令下载就行，例如我要下载此视频的mp4版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407193145.png" alt=""></p><p>可以看到速度还是蛮快的。</p><h2 id="3-设置输出文件夹与文件名">3. 设置输出文件夹与文件名</h2><p>使用<code>--output-dir</code>/<code>-o</code>选项设置路径，使用<code>--output-filename</code>/<code>-O</code>设置下载文件的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv -o E:/Windows/VIDEOS -O 夏天 https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407193428.png" alt=""></p>]]></content>
    
    
    <summary type="html">使用You-get工具，Github上的一个项目，可以下载大多数主流网站的视频，图片、音频。支持的网站包括YouTube、Twitter、Facebook、bilibili、AcFun、niconico、网易云音乐、酷狗音乐、qq音乐、爱奇艺、腾讯视频、抖音、快手、知乎等等。</summary>
    
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="破解方法" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="破解" scheme="https://www.mahaofei.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>华为手机安装谷歌服务</title>
    <link href="https://www.mahaofei.com/post/367f6bb8.html"/>
    <id>https://www.mahaofei.com/post/367f6bb8.html</id>
    <published>2022-03-28T13:06:36.000Z</published>
    <updated>2022-04-09T13:29:20.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链接: <a href="https://pan.baidu.com/s/1_PPC3xveD2xPwsg6JGgZmQ?pwd=wcrp">https://pan.baidu.com/s/1_PPC3xveD2xPwsg6JGgZmQ?pwd=wcrp</a><br>提取码: wcrp</p></blockquote><p>1、荣耀60或60pro教程【本人实测教程】，把这里的文件复制到手机</p><p>2、清除所有之前安装过的谷歌相关软件和系统进程。没装过的跳过这一步</p><p>3、打开 文件管理APP 将下载文件中的【Backup】 文件夹，复制到U盘根目录</p><p>4、很关键的一步，打开系统和更新，设置时间，将时间设置到2020年的任何一天</p><p>5、打开设置–系统和更新–备份和恢复-内部存储恢复-选择20191207的选项进行恢复。恢复完成后桌面会有一个谷歌服务助手，点开点激活，之后不用管它。回到设置–将时间设置为自动设置，恢复到2021年。</p><p>6、打开梯子。</p><p>7、安装0文件(microG)，装完之后打开，点账户account，点sign in，没有反应，就再点account，点sign in，登录谷歌账号（有几个登几个，后边不能再加）。</p><p>8、安装1，3，4，apk文件，然后卸载掉第7步安装的0文件(microG)</p><p>9、回到文件管理，安装2文件Google play服务.apk，拉下通知栏，等待弹出谷歌认证，之后点击验证（等10秒-50秒就会自动弹出来了）。</p><p>10、回到手机桌面，打开Google play商店，Google play商店可以正常打开，将Google play商店从后台关掉</p><p>11、打开手机设置-应用和服务-应用管理-点右上角，显示系统程序，搜索【Google】，</p><p>点开Google play商店，强行停止，后退，</p><p>点开-Google账号管理程序，存储，删除数据，后退，再后退</p><p>点开Google服务框架，存储，删除数据，后退</p><p>然后重启手机。</p><p>12、设置-里面有Google服务</p>]]></content>
    
    
    <summary type="html">以荣耀60或60pro为例【本人实测教程】</summary>
    
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="破解方法" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="破解" scheme="https://www.mahaofei.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>阿里云图床搭建方法</title>
    <link href="https://www.mahaofei.com/post/d05a7f72.html"/>
    <id>https://www.mahaofei.com/post/d05a7f72.html</id>
    <published>2022-03-26T06:37:22.000Z</published>
    <updated>2022-04-09T13:29:20.970Z</updated>
    
    <content type="html"><![CDATA[<p>由于现在一直在CSDN和自己的网站同步写博客记录，可是以前我都是在CSDN编辑器内直接码字上传，但这样的编辑方式很难受，我还是更喜欢像Typora的本地markdown编辑器，这样就需要有一个自己的图床，本地截图粘贴到markdown编辑器内，就会自动上传到自己的图床中。</p><h1>开通阿里云OSS服务</h1><p>首先需要开通<a href="https://www.aliyun.com/product/oss">阿里云OSS服务</a>，登录账号后直接点击立即开通就可以。</p><p>阿里云提供了两种计费方式：</p><ul><li>按量收费：这是默认的计费方式，开通OSS后就是这种方式，不需要提前付款，使用后会直接从账户内扣钱。</li><li>包月包年套餐：点击折扣套餐可以看到各种不同容量和时间的套餐</li></ul><p>由于我在这里只存储写博客用到的图片，每张图片只有几十K，就算是最小的40G套餐我也是远远用不到的，因此我选择按量收费，也就是这里不操作，直接下一步。</p><h1>新建Bucket</h1><p>Bucket相当于存储图片的容器，这里新建Bucket。</p><ul><li>输入Bucket的名称：生成链接后，链接名称的组成部分（*****.oss-cn-beijing.aliyuncs.com）</li><li>区域：选择一个离你最近的就可以</li><li>存储类型：一般选择标准存储</li><li>读写权限：必须选择公共读，否则其他人无法访问图片</li><li>剩余的服务都不需要开启</li></ul><p>打开Bucket列表，在刚创建的bucket下新建一个目录img，用于存放博客图片。</p><p><img src="https://img.mahaofei.com/img/202203260958360.png" alt=""></p><h1>获取阿里云AccessKey</h1><p>鼠标移动到阿里云首页右上角个人头像，点击AccessKey管理。</p><p>进入页面后可能会出现安全提示，点击继续使用AccessKey。</p><p>点击创建AccessKey，通过验证后就可以看到AccessKey了。</p><p>这里的AccessKey ID和AccessKey Secret一定要记录好，而且一定不能公开。</p><h1>下载安装Picgo</h1><p>下面是Picgo项目的Github链接，直接在这里下载就可以。<br><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h1>配置Picgo</h1><p>在Picgo设置里勾选显示阿里云OSS图床（默认已经打开了很多常用图床）</p><p>在图床设置-阿里云OSS设置内，填写自己的信息</p><p><img src="https://img.mahaofei.com/img/202203260959238.png" alt=""></p>]]></content>
    
    
    <summary type="html">由于现在一直在CSDN和自己的网站同步写博客记录，可是以前我都是在CSDN编辑器内直接码字上传，但这样的编辑方式很难受，我还是更喜欢像Typora的本地markdown编辑器，这样就需要有一个自己的图床，本地截图粘贴到markdown编辑器内，就会自动上传到自己的图床中。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="网站" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="网站搭建" scheme="https://www.mahaofei.com/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
    <category term="阿里云" scheme="https://www.mahaofei.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>博途TIA Portal V15 下载与安装教程</title>
    <link href="https://www.mahaofei.com/post/bb559113.html"/>
    <id>https://www.mahaofei.com/post/bb559113.html</id>
    <published>2022-02-04T07:58:00.000Z</published>
    <updated>2022-04-09T13:29:20.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>下载链接：</p><p>阿里云盘：<a href="https://www.aliyundrive.com/s/G5V98sQFqVq">https://www.aliyundrive.com/s/G5V98sQFqVq</a></p><p>百度网盘： <a href="https://pan.baidu.com/s/1X3hMP5n2DlMXB_wiGztarg?pwd=dpzk">https://pan.baidu.com/s/1X3hMP5n2DlMXB_wiGztarg?pwd=dpzk</a></p><p>提取码: dpzk</p></blockquote><h2 id="准备工作">准备工作</h2><p>在安装西门子软件的时候，经常提示要重启，而且重启之后依然提示重启，让人莫名烦恼， 按照以下步骤删除注册表则不会再提示重启。<br><font color="red">注意：删除注册表后不要重启，直接继续安装，（删除此文件对电脑没有任何影响）</font></p><ol><li>在windows系统下，按下组合键：WIN+R，输入“regedit”，打开注册表编辑器<br><img src="https://img.mahaofei.com/img/202203261044325.png" alt="">找到 HEEY_LOCAL_MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\SESSION MANAGE\ 下的 PendingFileRemameOpeaations 键，直接删除该键值。不需要重新启动，继续你的软件安装即可。<br><img src="https://img.mahaofei.com/img/202203261044343.png" alt=""></li></ol><blockquote><p>安装前注意：</p><ul><li>V15 支持WIN11 WIN10  WIN8  WIN7, 但必须都是64位系统</li><li>文件下载完成，安装出现安装过程中出错，则重新安装或修复，如果再次安装仍出现此问题则只能重新安装系统后再装软件，之所以出现这种问题，因为博途软件较庞大，所用到的数据库文件非常复查，系统内含有其他第三方软件可能导致博途安装无法正常成功，所以尽量保持系统的纯净再安装，切记，万不能开始各种杀毒软件，尤其360，否在无法保证是否能成功，或者安装完成能否正常使用。</li></ul></blockquote><h2 id="font-color-red-安装前一定要关闭杀毒软件-font"><font color="red">安装前一定要关闭杀毒软件</font></h2><h2 id="开始安装软件">开始安装软件</h2><h3 id="①-安装STEP7-Professional">① 安装STEP7 Professional</h3><ol><li>将安装包解压，进入<strong>01-STEP7+Wincc Profesional V15</strong>文件夹，运行<strong>TIA_Portal_STEP_7_Pro_WINCC_Pro_V15.exe</strong>，首先安装SETP7 Professional（PLC编程软件+WINCC触摸屏和上位机组态软件）<br><img src="https://img.mahaofei.com/img/202203261045172.png" alt=""></li><li>选择要安装的位置（尽量避免解压在C盘），然后点击下一步等待解压，解压过程5分钟左右<br><img src="https://img.mahaofei.com/img/202203261045963.png" alt=""></li><li>开始正式安装，<strong>直接点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045632.png" alt=""></li><li>语言选择默认勾选中文，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045370.png" alt=""></li><li>默认典型安装即可，<strong>浏览选择安装路径</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045522.png" alt=""></li><li><strong>勾选接受两个条款协议</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045996.png" alt=""></li><li><strong>勾选接受</strong>安全和权限设置，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045675.png" alt=""></li><li>确认安装路径没问题后，<strong>点击安装按钮</strong>，开始进行安装，安装过程约40分钟<br><img src="https://img.mahaofei.com/img/202203261045605.png" alt=""></li><li><strong>选择立即重启</strong>，完成安装（这里需要重启电脑，否则无法进行后续安装）</li></ol><h3 id="②-安装STEP7-Simulation">② 安装STEP7_Simulation</h3><ol><li>进入<strong>02-PLCSIM_V15</strong>文件夹，双击运行<strong>SIMATIC_S7PLCSIM_V15.exe</strong>，开始安装STEP7_simulation（PLC的仿真软件）<br><img src="https://img.mahaofei.com/img/202203261046807.png" alt=""></li><li>开始安装，直接<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046519.png" alt=""></li><li>安装语言默认选择中文，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046465.png" alt=""></li><li><strong>选择安装文件解压路径（不要和上一个程序选择同一路径，否则会出现文件覆盖问题）</strong>，然后<strong>点击下一步</strong>，等待解压，此过程约3分钟<br><img src="https://img.mahaofei.com/img/202203261046214.png" alt=""></li><li>进入安装程序，点击下一步开始安装<br><img src="https://img.mahaofei.com/img/202203261046805.png" alt=""></li><li>默认选择中文，<strong>点击下一步</strong>继续<br><img src="https://img.mahaofei.com/img/202203261046058.png" alt=""></li><li>浏览<strong>选择安装路径</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046718.png" alt=""></li><li><strong>接受条款协议</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261047339.png" alt=""></li><li>接受计算机安全和权限设置，点击下一步<br><img src="https://img.mahaofei.com/img/202203261047195.png" alt=""></li><li><strong>检查安装路径</strong>没问题，<strong>点击安装按钮</strong>开始安装软件12<br><img src="https://img.mahaofei.com/img/202203261047722.png" alt=""></li><li>选择稍后重启，完成安装<br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220326104732524.png" alt="image-20220326104732524"></li></ol><h3 id="③-安装驱动（如果只仿真，不需要连接PLC可跳过安装）">③ 安装驱动（如果只仿真，不需要连接PLC可跳过安装）</h3><ol><li>进入<strong>Startdrive</strong>文件夹中，双击运行<strong>Startdrive_V15.exe</strong>，按步骤进行安装<br><img src="https://img.mahaofei.com/img/202203261047076.png" alt=""></li></ol><h3 id="④-授权">④ 授权</h3><ol><li>在授权文件夹下找到<strong>Sim_EKB_Install_2018_11_14.exe</strong>文件，右键<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202203261047455.png" alt=""></li><li>授权Step7 Professional<br><img src="https://img.mahaofei.com/img/202203261047872.png" alt=""></li><li>授权WinCC，找到TIA Portal  --TIA Portal V15 –WINCC Prof v15，按图找到几个选项后点击安装长密钥<br><img src="https://img.mahaofei.com/img/202203261047560.png" alt=""></li><li>然后关闭程序，重启计算机</li></ol><blockquote><p>如果重启后打开软件授权不成功，则在C盘找到AX NF  ZZ文件夹删除（如果找不到，请打开显示隐藏文件夹）<br><img src="https://img.mahaofei.com/img/202203261048361.png" alt=""><br>如果以上步骤操作完毕仍然无法授权，则需要重装Windows纯净系统，不要再安装任何其他软件和杀毒管家等，直接安装博途</p></blockquote><p>在桌面找到TIA Portal V15软件，双击运行，可正常启动<br><img src="https://img.mahaofei.com/img/202203261048756.png" alt=""><br><img src="https://img.mahaofei.com/img/202203261048505.png" alt=""></p>]]></content>
    
    
    <summary type="html">西门子PLC自动化设计软件博途V15的安装教程。</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="单片机" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    <category term="PLC" scheme="https://www.mahaofei.com/tags/PLC/"/>
    
  </entry>
  
  <entry>
    <title>河北工业大学机械电子工程专业课程资料（个人整理，请勿外传）</title>
    <link href="https://www.mahaofei.com/post/21df2adf.html"/>
    <id>https://www.mahaofei.com/post/21df2adf.html</id>
    <published>2022-01-05T16:00:00.000Z</published>
    <updated>2022-04-09T13:29:21.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公共课">公共课</h2><h3 id="大二上"><em>大二上</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/vNZ6TSj6WJd">线性代数</a></th><th><a href="https://www.aliyundrive.com/s/6QjzPDqcgF1">大学物理</a></th><th><a href="https://www.aliyundrive.com/s/LWNGU81AUWZ">马克思主义基本原理概论</a></th></tr></thead></table><h3 id="大二下"><em>大二下</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/3aFWBAdyhgR">概率论与数理统计</a></th><th><a href="https://www.aliyundrive.com/s/248XLLcHYHp">毛泽东思想和中国特色社会主义理论体系概论</a></th><th>       </th></tr></thead></table><h2 id="专业课">专业课</h2><h3 id="大二下-2"><em>大二下</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/ikNAzyqmWAf">电工电子技术</a></th><th><a href="https://www.aliyundrive.com/s/BBwwM9t2dNc">机械原理</a></th><th><a href="https://www.aliyundrive.com/s/cWbKWUMy2yc">材料力学</a></th></tr></thead><tbody><tr><td><strong><a href="https://www.aliyundrive.com/s/Fs51pUPd4dm">互换性与测量技术</a></strong></td><td></td><td></td></tr></tbody></table><h3 id="大三上"><em>大三上</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/pFNWexCiLqY">机械设计</a></th><th><a href="https://www.aliyundrive.com/s/2CJKUJzjouK">机电传动与控制</a></th><th><a href="https://www.aliyundrive.com/s/YLHZLGZeWSC">液压传动与控制</a></th></tr></thead><tbody><tr><td><strong><a href="https://www.aliyundrive.com/s/BvQ7FgyCAMy">自动控制原理</a></strong></td><td></td><td></td></tr></tbody></table><h3 id="大三下"><em>大三下</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/Z7ZEtnbsPov">传感与检测技术</a></th><th><a href="https://www.aliyundrive.com/s/dL2cZ1g2n5Q">微机原理及应用</a></th><th><a href="https://www.aliyundrive.com/s/3Fj4pxuYNRz">机械制造技术基础</a></th></tr></thead><tbody><tr><td><strong><a href="https://www.aliyundrive.com/s/FEPhcgfyKTq">机械动力学</a></strong></td><td></td><td></td></tr></tbody></table><h3 id="大四上"><em>大四上</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/h2Ayhm17cC6">数控技术</a></th><th><a href="https://www.aliyundrive.com/s/5SzkVMMrZK6">机器人技术及应用</a></th><th><a href="https://www.aliyundrive.com/s/k4BYhySnW6a">机电系统建模仿真</a></th></tr></thead><tbody><tr><td><a href="https://www.aliyundrive.com/s/iExSacLgtt4"><strong>机电系统设计</strong></a></td><td><a href="https://www.aliyundrive.com/s/PWFoXhRDv5Z"><strong>电气控制与PLC</strong></a></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">博主本科期间各课程所用到的资料汇总，包括公共课（如线代、大物），专业课等等。由于多数为本校老师个人制作使用的PPT、知识点资料，因此请仅用于个人学习使用，谢谢。</summary>
    
    
    
    
    <category term="&lt;font color=&quot;white&quot;&gt; WOW &lt;/font&gt;" scheme="https://www.mahaofei.com/tags/font-color-white-WOW-font/"/>
    
  </entry>
  
  <entry>
    <title>PS2020 下载与安装教程（可更改安装位置）</title>
    <link href="https://www.mahaofei.com/post/f43c25b0.html"/>
    <id>https://www.mahaofei.com/post/f43c25b0.html</id>
    <published>2021-12-23T01:15:35.000Z</published>
    <updated>2022-04-09T13:29:20.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阿里云盘链接：<a href="https://www.aliyundrive.com/s/UFEbPAqUVvD">https://www.aliyundrive.com/s/UFEbPAqUVvD</a></p><p>下载后将文件的后缀名改回【.zip】即可正常解压。</p><p>百度网盘链接：<a href="https://pan.baidu.com/s/1-GCMRxMQLGaOBn_dtcgJmw">https://pan.baidu.com/s/1-GCMRxMQLGaOBn_dtcgJmw</a></p><p>提取码：mhf6</p></blockquote><ol><li>打开解压的文件夹，右键【Set-up.exe】，<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230952400-ps2020-1.png" alt=""></li><li>点击右侧按钮<strong>更改安装位置</strong>，安装到除C盘外的区域<br><img src="https://img.mahaofei.com/img/202112230953657-ps2020-2.png" alt=""></li><li><strong>点击继续</strong>，开始安装<br><img src="https://img.mahaofei.com/img/202112230953836-ps2020-3.png" alt=""></li><li>安装过程大约需要3分钟，安装过程自动破解，安装完成就可以直接使用。<br><img src="https://img.mahaofei.com/img/202112230953164-ps2020-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230953914-ps2020-5.png" alt=""></li><li>打开软件，可以正常使用<br><img src="https://img.mahaofei.com/img/202112230953060-ps2020-6.png" alt=""></li></ol>]]></content>
    
    
    <summary type="html">Adobe PhotoShop 2020 下载与安装的教程，专业P图软件，安装可更改位置。资源仅供学习参考！</summary>
    
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="软件安装" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Office2019专业版安装教程</title>
    <link href="https://www.mahaofei.com/post/197d036c.html"/>
    <id>https://www.mahaofei.com/post/197d036c.html</id>
    <published>2021-12-23T01:15:35.000Z</published>
    <updated>2022-04-09T13:29:20.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阿里云盘链接：<a href="https://www.aliyundrive.com/s/PNmJsdoM9AD">https://www.aliyundrive.com/s/PNmJsdoM9AD</a><br>下载完成后将后缀名改回【.zip】即可正常解压</p><p>百度网盘链接：<a href="https://pan.baidu.com/s/15yVE9_3PUWwb9tHZKwzB_w">https://pan.baidu.com/s/15yVE9_3PUWwb9tHZKwzB_w </a><br>提取码：mhf6</p></blockquote><p>安装之前，先到【控制面板-卸载程序】，卸载掉所有Office产品。</p><ol><li><p>解压压缩包，运行【<strong>Setup64.exe</strong>】<br><img src="https://img.mahaofei.com/img/202112230940086-office2019-1.png" alt=""></p></li><li><p>等待20分钟左右安装，只能安装在C盘。</p></li><li><p>安装完成后在开始菜单打开，可以正常使用</p></li><li><p>如果需要激活，可以使用<a href="https://huffie.lanzouw.com/idn0Cuhmwzg">【此工具】</a>进行激活。</p></li></ol>]]></content>
    
    
    <summary type="html">Microsoft Office 2019 专业版，下载与安装过程详解。</summary>
    
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="软件安装" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>PR2020 下载与安装教程（可更改安装位置）</title>
    <link href="https://www.mahaofei.com/post/f5998c06.html"/>
    <id>https://www.mahaofei.com/post/f5998c06.html</id>
    <published>2021-12-23T01:15:35.000Z</published>
    <updated>2022-04-09T13:29:20.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阿里云盘链接：<a href="https://www.aliyundrive.com/s/QYQ5oszJVSq">https://www.aliyundrive.com/s/QYQ5oszJVSq</a></p><p>下载后将文件的后缀名改回【.zip】即可正常解压。</p><p>百度网盘链接：<a href="https://pan.baidu.com/s/1vQgVLG2Im4VKELuOwQ2zyg">https://pan.baidu.com/s/1vQgVLG2Im4VKELuOwQ2zyg</a></p><p>提取码：mhf6</p></blockquote><ol><li><p>打开解压的文件夹，右键【Set-up.exe】，<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230954169-pr2020-1.png" alt=""></p></li><li><p>点击右侧按钮<strong>更改安装位置</strong>，安装到除C盘外的区域<br><img src="https://img.mahaofei.com/img/202112230955092-pr2020-2.png" alt=""></p></li><li><p>安装过程大约需要3分钟，安装过程自动破解，安装完成就可以直接使用。<br><img src="https://img.mahaofei.com/img/202112230955695-pr2020-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230955657-pr2020-4.png" alt=""></p></li><li><p>打开软件，可以正常使用<br><img src="https://img.mahaofei.com/img/202112230955835-pr2020-5.png" alt=""></p></li></ol>]]></content>
    
    
    <summary type="html">Adobe Premiere Pro 2020 下载与安装的教程，视频剪辑软件，安装可更改位置。资源仅供学习参考！</summary>
    
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="软件安装" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>【目标识别】SIFT算法理论部分</title>
    <link href="https://www.mahaofei.com/post/f8e83802.html"/>
    <id>https://www.mahaofei.com/post/f8e83802.html</id>
    <published>2021-12-21T13:31:40.000Z</published>
    <updated>2022-04-09T13:29:21.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍-2">一、介绍</h2><h3 id="1-1-SIFT算法">1.1 SIFT算法</h3><p>SIFT(Scale invariant feature transform)是尺度不变特征变换，是一种用来检测和描述图像局部特征的算法。算法实际上是要在不同尺度空间中寻找极值点，并提取其位置、尺度和旋转不变量，这些关键点不会因光照、仿射变换和噪音而变化。</p><h3 id="1-2-SIFT特征的获取方法">1.2 SIFT特征的获取方法</h3><ol><li><p><strong>尺度空间极值检测</strong></p><p>利用高斯差分函数搜索所有尺度和图像位置，找到对尺度和方向不变的候选关键点。</p></li><li><p><strong>关键点定位</strong></p><p>对每一个候选关键点都需要确定其位置和尺度，并要保证其稳定性。</p></li><li><p><strong>方向分配</strong></p><p>根据局部图像的梯度方向，为每个关键点分配一个或多个方向。</p></li><li><p><strong>关键点描述</strong></p><p>在每个关键点周围区域的选定尺度上测量局部图像的梯度，这些信息表示了允许的局部形状失真和光照变化。</p></li></ol><h3 id="1-3-图像匹配和识别的方法">1.3 图像匹配和识别的方法</h3><ol><li>先从一组目标物体的参考图像中提取SIFT特征并存储在数据库。</li><li>将新图像的每个特征与之前的数据库逐一比较，根据特征向量的欧几里得距离找到匹配特征。</li></ol><h3 id="1-4-如何提高匹配准确率">1.4 如何提高匹配准确率</h3><ol><li><p>利用识别与新图像中对象的位置、比例和方向一致的关键点子集，可以在匹配集中过滤出正确的匹配。几个特征共同作为判断依据匹配出错率远小于单一特征匹配。</p></li><li><p>匹配方法</p><p>①先对物体姿态的放射近似作最小二乘估计，与此姿态一致的其它图像特征被识别出来，异常值被丢弃。</p><p>②给出你和的准确性和可能的错误匹配的数量，对一组特征表明对象存在的概率进行详细计算。</p><p>③通过所有测试的对象匹配可被标为正确且具有高可信度。</p></li></ol><h2 id="二、尺度空间极值检测">二、尺度空间极值检测</h2><p>SIFT算法是在不同的尺度空间上查找关键点，尺度空间的获取需要使用高斯模糊。</p><h3 id="2-1-高斯模糊">2.1 高斯模糊</h3><h4 id="（1）高斯函数">（1）高斯函数</h4><p>高斯模糊使用高斯函数（正态分布）计算模糊模板，并使用该模板与原图像做卷积运算，以此模糊图像。</p><p>N维空间的高斯计算公示：</p><p><img src="https://img.mahaofei.com/img/202112232022082-sift-theory-1.png" alt=""></p><blockquote><ul><li>$\sigma$为正态分布的标准差，$\sigma$越大图像越模糊、越平滑</li><li>$r$为模糊半径，指模板元素到模板中心的距离</li></ul></blockquote><p>二维空间的高斯计算公式：</p><p><img src="https://img.mahaofei.com/img/202112232022463-sift-theory-2.png" alt=""></p><blockquote><ul><li>$\sigma$为正态分布的标准差，$\sigma$越大图像越模糊、越平滑</li><li>m,n为二维模板的大小m*n</li><li>x,y为模板上元素的位置(x,y)</li></ul></blockquote><p>二维高斯函数生成的曲面是从中心开始的正态分布同心圆。每个像素的值都是周围相邻像素的加权平均。原始像素具有最大的权重，边缘像素权重越来越小，因此更高的保留了边缘效果。</p><p>在计算每个像素的离散近似时，$3\sigma$之外的像素都可以视为不起作用，因此图像处理程序只需要计算 $(6\sigma+1)\times(6\sigma+1) $的矩阵就可以了。</p><h4 id="（2）二维高斯模糊">（2）二维高斯模糊</h4><p>根据$\sigma$计算出高斯模板矩阵（大小为$(6\sigma+1)\times(6\sigma+1) $，值根据$G(x,y)$计算）</p><p>对高斯模板矩阵进行归一化处理（确保矩阵元素在$[0,1]$范围内），例如$5\times5$的高斯模板如下图，可以看出高斯模板是中心对称的。</p><p><img src="https://img.mahaofei.com/img/202112232023230-sift-theory-3.png" alt=""></p><p>利用此高斯模板矩阵与原图像做卷积，即可获得原图像的高斯模糊图像。卷积过程示意图如下：</p><p><img src="https://img.mahaofei.com/img/202112232023732-sift-theory-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232024140-sift-theory-5.png" alt=""></p><h4 id="（3）分离高斯模糊">（3）分离高斯模糊</h4><p>二维高斯模糊有两个不足之处：</p><ol><li>使用二维高斯模糊会造成边缘图像缺失，$\sigma$越大，缺失像素越多</li><li>模板变大时，高斯核的卷据运算量会大幅度提高</li></ol><p>解决方法：</p><p>利用高斯函数的可分离性（二维矩阵的变换效果等效于水平方向一维高斯矩阵变换加竖直方向一维高斯矩阵变换）。</p><ol><li>两次一维的高斯卷积将消除二维高斯矩阵所产生的边缘。</li><li>卷积运算只需要O(n×M×N)+O(m×M×N)次计算，而二维矩阵需要O(m×n×M×N)次计算。其中m,n为高斯矩阵的维数。M,N为二维图像的维数。</li></ol><p><img src="https://img.mahaofei.com/img/202112232024414-sift-theory-6.png" alt=""></p><h3 id="2-2-尺度空间">2.2 尺度空间</h3><h4 id="（1）尺度空间的概念">（1）尺度空间的概念</h4><ol><li><p><strong>概念</strong></p><p>在图像信息处理模型中引入一个被视为尺度的参数，通过连续变化尺度参数获得多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为特征向量，实现边缘、角点检测和不同分辨率的特征提取。</p></li><li><p><strong>特点</strong></p><p>将传统的但尺度图像信息处理技术纳入尺度不断变化的动态分析框架中。更容易获取图像的本质特征。尺度空间中各尺度图像的模糊程度逐渐变大，能够模拟人在距离目标由近到远时目标在视网膜上的形成过程。</p></li><li><p><strong>优点</strong></p><p>1）尺度空间算子对图像的分析不受图像的灰度水平和对比度变化的影响，即满足灰度不变性和对比度不变性；</p><p>2）尺度空间算子对图像的分析和图像的位置、大小、角度以及仿射变换无关，即满足平移不变性、尺度不变性、欧几里德不变性以及仿射不变性。</p></li></ol><h4 id="（2）尺度空间的表示">（2）尺度空间的表示</h4><p>尺度空间 $L(x,y,z)$ 定义为变化尺度的高斯函数 $G(x,y,\sigma)$ 与原图像 $I(x,y)$ 的卷积。</p><p><img src="https://img.mahaofei.com/img/202112232025921-sift-theory-7.png" alt=""></p><p>其中$\sigma$为尺度因子，$\sigma$越小对应模糊程度越小，相应的尺度约小。因此大尺度对应图像的概貌特征，小尺度对应图像的细节特征。</p><p><img src="https://img.mahaofei.com/img/202112232025197-sift-theory-8.png" alt=""></p><h4 id="（3）高斯金字塔的构建方法">（3）高斯金字塔的构建方法</h4><p>尺度空间在实现时使用高斯金字塔表示，高斯金字塔构建分为两步：1）对图像做降采样；2）对图像做高斯平滑。</p><p>金字塔模型是指将原始图像不断进行降采样，得到一系列大小不同的图像，由大到小，由下到上。原图像为金字塔的第一层，每次降采样所得到的新图像为金字塔的一层。为了让尺度体现其连续性，高斯金字塔在简单降采样的基础上加上了高斯滤波。</p><p>如上图所示，将图像金字塔每层的一张图像使用不同参数做高斯模糊，Octave表示一幅图像可产生的图像组数，Interval表示一组图像包括的图像层数。另外，降采样时，高斯金字塔上一组图像的初始图像(底层图像)是由前一组图像的倒数第三张图像隔点采样得到的。</p><p>高斯金字塔的层数计算：</p><p><img src="https://img.mahaofei.com/img/202112232025038-sift-theory-9.png" alt=""></p><blockquote><p>M,N：原图像大小<br>t：塔顶图像的最小维度的对数值</p></blockquote><p><img src="https://img.mahaofei.com/img/202112232026124-sift-theory-10.png" alt=""></p><h3 id="2-4-极值检测方法">2.4 极值检测方法</h3><p>由于要在尺度空间中寻找图像的极值点，因此在实际计算中，使用高斯金字塔每组中相邻上下两层图像相减，得到高斯差分图像（Difference of Gaussian ，简称DOG），进行极值检测。即两个相邻尺度的差（这里用常数k区分相邻的尺度）：</p><p>$D(x, y, σ) = (G(x, y, kσ)−G(x, y, σ))∗I(x, y)$</p><p>​$=L(x, y, kσ)−L(x, y, σ)$</p><p>为了寻找高斯差分函数函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。如图所示，中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。</p><p><img src="https://img.mahaofei.com/img/202112232026929-sift-theory-11.png" alt=""></p><p>由于要在相邻尺度进行比较，由于高斯差分金字塔的每一组图像，只能在中间的层进行极值点检测，最上和最下层无法进行。</p><p>为了在每组中检测S个尺度的极值点，则DOG金字塔每组需S+2层图像，而DOG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像，实际计算时S在3到5之间。</p><h3 id="2-5-极值检测的采样频率">2.5 极值检测的采样频率</h3><p>检测局部极大值和极小值，在采样点同层的8个邻域点和上下相邻层的各9个邻域点之中选择，只有大于或这些所有的邻域点才能称为极值。经过检测后绝大多数的采样点都被剔除了。</p><p>其中重要问题就是确定图像和尺度的采样频率，以可靠的检测极值，但事实上极值点可以非常接近，因此需要找到一种平衡效率和完整性的解决方案。</p><h4 id="（1）尺度域的采样频率">（1）尺度域的采样频率</h4><p>经过大量实验数据得到：</p><p>（1）当采样更多尺度时，可重复性没有继续提高，因为这会导致更多的局部极值被检测到，但这些极值平均来说不太稳定，不太可能在被转换后的图像中检测到。</p><p>（2）当采样规模增大时，关键点的数量增加，正确匹配的总数量增加，由于实际使用时物体识别的成功更多取决于正确匹配关键点的数量，而不是正确匹配的百分比，因此使用大量的样本是最好的。但是这会导致计算成本的增加，所以Lowe建议<strong>每组使用3个尺度样本</strong></p><h4 id="（2）空间域的采样频率">（2）空间域的采样频率</h4><p>需要确定在一个尺度内图像域的采样频率，假设极值点可以任意靠近，那么在空间域的采样频率和检测率之间也会有类似的平衡。这里Lowe经过实验，建议选择使用$\sigma=1.6$。</p><p>并且由于在进行极值检测之前进行了差分处理，因此丢弃了最高的空间频率，为了充分利用输入，可以在构建金字塔第一级之前使用线性插值将输入图像的大小增加一倍。</p><h2 id="三、关键点定位">三、关键点定位</h2><h3 id="3-1-关键点的准确定位">3.1 关键点的准确定位</h3><p>离散空间的极值点不是图像真正的极值点。</p><p><img src="https://img.mahaofei.com/img/202112232026016-sift-theory-12.png" alt=""></p><p>为了提高关键点的稳定性，需要对尺度空间函数进行曲线拟合。利用尺度空间函数的Taylor展开式，导数在极值点处为0，求得$x$的偏移量实现对关键点的精确定位。</p><p>将尺度空间函数$D(x,y,\sigma)$进行泰勒展开，使原点与采样点重合。</p><p><img src="https://img.mahaofei.com/img/202112232027590-sift-theory-13.png" alt=""></p><p>对$D(x,y,\sigma)$求导并令其等于零，求得$\hat{x}=−\frac{∂^2D^{-1}}{∂x^2}\frac{∂D}{∂x}$即为$x$的偏移量。</p><h3 id="3-1-消除边缘响应">3.1 消除边缘响应</h3><p>为了稳定，仅去除低对比度的关键点是不够的，还需要消除高斯差分函数带来的边缘响应。在边缘梯度方向的主曲率较大，垂直方向（沿边缘方向）的主曲率较小。主曲率可以通过Hessian矩阵计算：</p><p><img src="https://img.mahaofei.com/img/202112232027721-sift-theory-14.png" alt=""></p><p>其特征值正比于D的主曲率，由于我们只需要特征值的比值$r$，因此可以避免求出特征值的结果。设$\alpha$为较大的特征值，$\beta$为较小的特征值，取$\alpha=r\beta$，利用迹和行列式的特点：</p><p><img src="https://img.mahaofei.com/img/202112232028879-sift-theory-15.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232028531-sift-theory-16.png" alt=""></p><p>因此当两特征值相等时，上式$\frac{Tr(H)^2}{Det(H)}=\frac{(r+1)^2}{r}$有最小值，并且该式随着比值$r$增大而增大，因此要检验主曲率是否在某个阈值以下，只需要检验</p><p>$\frac{Tr(H)^2}{Det(H)}&lt;\frac{(r+1)^2}{r}$。当满足条件时保留特征点，否则剔除。（常用T=1.2）</p><h2 id="四、梯度方向分配">四、梯度方向分配</h2><h3 id="4-1-梯度大小方向求解">4.1 梯度大小方向求解</h3><p>为了使关键点描述子具有旋转不变性，利用图像的局部特征给每一个关键点分配一个基准方向，使描述子对图像旋转具有不变性。对于在高斯差分金字塔中检测出的关键点，采集其所在高斯金字塔图像$3\sigma$邻域窗口的像素的梯度和方向分布特征。梯度的模和方向如下：</p><p><img src="https://img.mahaofei.com/img/202112232029555-sift-theory-17.png" alt=""></p><h3 id="4-2-梯度统计">4.2 梯度统计</h3><p>完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。梯度直方图将0~360°方向分为36份，每个柱子代表10°范围，如图直方图的峰值代表关键点的主方向。</p><p><img src="https://img.mahaofei.com/img/202112232029678-sift-theory-18.png" alt=""></p><p>以直方图中最大值作为该关键点的主方向，为了增强匹配的鲁棒性，只保留峰值大于主方向峰值80％的方向作为该关键点的辅方向。</p><h2 id="五、关键点描述子">五、关键点描述子</h2><p>经过上面的步骤，每一个关键点都拥有位置、尺度、方向三个信息。</p><p>下一步是为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变，使其不随光照、视角等变化而变化。</p><h3 id="5-1-描述符表示">5.1 描述符表示</h3><h4 id="（1）特征向量表示">（1）特征向量表示</h4><p>首先在关键点周围采样图像的梯度大小和方向，利用关键点的尺度选择图像的高斯模糊程度。为了实现方向不变性，描述子的坐标和梯度方向是相对于关键点方向旋转的。</p><p><img src="https://img.mahaofei.com/img/202112232029018-sift-theory-19.png" alt=""></p><p>使用一个$\sigma$等于子窗口宽度的一半的高斯加权函数来为每个采样点的大小赋值。（为了避免随着窗口位置的微小变化导致的描述符的突然变化，同时减少远离描述符中心的梯度影响，这些梯度最容易配准错误）</p><p>描述符由一个包含所有方向直方图条目值的向量构成，Lowe经过实验证明最好的选择是：每个关键点划分4个领域，对应4个描述子，每个描述子使用4x4的方向直方图阵列，每个直方图中有8个梯度方向，因此每个关键点采用4x4x8=128个特征向量。</p><h4 id="（2）归一化处理">（2）归一化处理</h4><p>对特征向量进行修正，减小光照变化对特征向量的影响。</p><ol><li>对比度影响消除</li></ol><blockquote><p>因为图像对比度的变化即每个像素值乘以一个常数，因此归一化会消除对比度的影响。</p></blockquote><p>因此首先将向量归一化为单位长度。</p><ol start="2"><li>照明条件影响消除</li></ol><blockquote><p>图像亮度是每个图像像素加上一个常数，因此亮度变化不会影响图像的梯度，所以描述符对于光照的仿射变化是不变的。（在不考虑非线性光照的情况下）</p></blockquote><p>考虑照明条件变化，可以通过将单位特征向量阈值划为不大于0.2（Lowe实验测得），减少较大梯度的影响，然后重新归一化。此时匹配大梯度不再重要，方向的分布更加重要。</p><h2 id="六、物体识别的应用">六、物体识别的应用</h2><p>目标识别首先通过将每个关键点独立地与从训练图像中提取出的关键点数据库进行匹配来完成。由于模糊的特征和背景影响，一开始匹配肯定是不准确的。所以需要至少有三个特征的聚类首先被识别出来，这些聚类与对象姿态一致，其正确性就比单个特征匹配要高得多。然后对每个聚类进行几何拟合检查，根据拟合结果接受或拒绝。</p><ol><li>从训练图像中识别关键点数据库中的最近邻，找到每个关键点的最佳候选匹配。（最近邻可以使用最小欧式距离）</li><li>如果图像特征在数据库中没有任何正确的匹配，则丢弃。</li><li>如果有多个匹配结果，则定义第二个最近邻为已知来自不同物体。在相似距离内可能会有许多其他错误匹配。我们可以将次近匹配视为在特征空间的这一部分内提供错误匹配密度的估计。</li></ol><h2 id="七、总结">七、总结</h2><p>SIFT特征具有稳定性和不变性，在图像处理和计算机视觉领域有着很重要的作用。</p><p><strong>SIFT算法的主要实现过程</strong></p><ol><li><p><strong>尺度空间极值检测</strong></p></li><li><p><strong>关键点定位</strong></p></li><li><p><strong>方向分配</strong></p></li><li><p><strong>关键点描述和匹配</strong></p></li></ol>]]></content>
    
    
    <summary type="html">SIFT是尺度不变特征转换，是一种用来检测和描述图像局部特征的算法。算法实际上是要在不同尺度空间中寻找极值点，并提取其位置、尺度和旋转不变量，这些关键点不会因光照、仿射变换和噪音而变化。主要实现步骤：（1）尺度空间极值检测；（2）关键点定位；（3）方向分配；（4）关键点描述和匹配。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="算法" scheme="https://www.mahaofei.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5图形界面GUI开发过程记录</title>
    <link href="https://www.mahaofei.com/post/6c1e143c.html"/>
    <id>https://www.mahaofei.com/post/6c1e143c.html</id>
    <published>2021-12-17T08:53:44.000Z</published>
    <updated>2022-04-09T13:29:21.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、PyQT的简介与安装">一、PyQT的简介与安装</h2><h3 id="1-1-常用的图形界面GUI">1.1 常用的图形界面GUI</h3><p>目前主流的python图形界面有Tkinter、PyQT5/PySide2、wxPython等。</p><table><thead><tr><th>图形界面</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Tkinter</td><td>Python标准库、稳定、发布程序较小</td><td>控件少，无法拖拽设计界面</td></tr><tr><td>PyQt5/PySide2</td><td>控件比较丰富、用户多、有designer设计界面</td><td>库比较大，发布出来的程序比较大</td></tr><tr><td>wxPython</td><td>控件比较丰富</td><td>文档少、用户少</td></tr></tbody></table><h3 id="1-2-PyQT5的安装">1.2 PyQT5的安装</h3><p>直接在命令行使用pip工具安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure><p>将PyQt5安装目录下的<code>\plugins\platforms</code>这个路径添加到环境变量Path中。（先找python安装目录<code>Python39</code>或<code>Python38</code>，再找下面的<code>\Lib\site-packages\PyQt5\Qt5</code>）</p><p>如我的路径是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\82785\AppData\Local\Programs\Python\Python39\Lib\site-packages\PyQt5\Qt5\plugins\platforms</span><br></pre></td></tr></table></figure><p><strong>注：设置环境变量后，需要重启电脑，因为新的环境变量要重启后才能被系统识别</strong></p><h2 id="二、PyQt的基本使用">二、PyQt的基本使用</h2><h3 id="2-1-QApplication">2.1 QApplication</h3><p>提供整个图形界面程序的底层管理功能，如初始化、程序入口参数处理、用户事件处理等。</p><ul><li>在创建控件之前，必须先创建QApplication。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = QApplication([])</span><br></pre></td></tr></table></figure><ul><li>在程序末尾，需要添加事件处理循环代码，用于接受输入事件，并分配给相应对象进行处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure><h3 id="2-2-界面控件">2.2 界面控件</h3><p>QMainWindow、QPlainTextEdit、QPushButton是三个控件类，分别是界面的主窗口、文本框、按钮。<code>要想在界面上创建一个控件，就需要在程序代码中创建空间对应的类的实例对象</code>。</p><ul><li>控件是层层嵌套的：<br>创建文本框和按钮时，都需要一个参数window，就是指定父控件对象（主窗口）。<br>而实例化主窗口时，不需要指定父控件，因为主窗口就是最上层控件了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPlainTextEdit(window)</span><br><span class="line">QPushButton(<span class="string">&#x27;文本框&#x27;</span>, window)</span><br></pre></td></tr></table></figure><ul><li>move方法决定了控件的显示位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.move(<span class="number">300</span>, <span class="number">310</span>)<span class="comment"># 主窗口左上角相对屏幕左上角位置</span></span><br><span class="line">textEdit.move(<span class="number">10</span>,<span class="number">25</span>)<span class="comment"># 文本框左上角相对父窗口左上角位置</span></span><br></pre></td></tr></table></figure><ul><li>resize方法决定了控件显示大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.resize(<span class="number">600</span>, <span class="number">400</span>)<span class="comment"># 主窗口宽600像素，高400像素</span></span><br><span class="line">textEdit.resize(<span class="number">200</span>,<span class="number">150</span>)<span class="comment"># 文本框宽200像素，高150像素</span></span><br></pre></td></tr></table></figure><ul><li>show方法将所有放在主窗口的控件显示出来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.show()</span><br></pre></td></tr></table></figure><h3 id="2-3-界面动作处理">2.3 界面动作处理</h3><p>在Qt系统中，当控件被点击、输入文本、拖拽等操作时，会发出信号Signal。</p><p>要想使程序对这些操作进行响应，就要预先在代码中指定处理signal的函数，这样的函数称为slot。</p><p>如定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buttonPress</span>()：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按钮被按下了&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后使用如下代码，让button被按下时，执行buttonPress()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.clicked.connect(buttonPress)</span><br></pre></td></tr></table></figure><h3 id="2-4-窗口封装为类">2.4 窗口封装为类</h3><p>为了模块化、便于使用，以及避免控件中出现的变量名冲突，通常会把<strong>一个窗口和其包含的控件封装到类中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QPushButton,  QPlainTextEdit,QMessageBox</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindows</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.window = QMainWindow()</span><br><span class="line">        self.window.resize(<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">        self.window.move(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        self.window.setWindowTitle(<span class="string">&#x27;示例程序&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.textEdit = QPlainTextEdit(self.window)</span><br><span class="line">        self.textEdit.setPlaceholderText(<span class="string">&quot;文本框提示语&quot;</span>)</span><br><span class="line">        self.textEdit.move(<span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line">        self.textEdit.resize(<span class="number">300</span>, <span class="number">350</span>)</span><br><span class="line"></span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;统计&#x27;</span>, self.window)</span><br><span class="line">        self.button.move(<span class="number">380</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">        self.button.clicked.connect(self.handleCalc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handleCalc</span>(<span class="params">self</span>):</span><br><span class="line">        text = self.textEdit.toPlainText()</span><br><span class="line">        <span class="comment"># 处理程序</span></span><br><span class="line"></span><br><span class="line">app = QApplication([])</span><br><span class="line">mywindow = MyWindows()</span><br><span class="line">mywindow .window.show()</span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h2 id="三、界面设计Qt-Designer">三、界面设计Qt Designer</h2><h3 id="3-1-Qt-Designer的简单介绍">3.1 Qt Designer的简单介绍</h3><p>Qt Designer是一个QT界面生成器，避免了像Tkinter需要将想象的图形界面用代码一行一行写出来。Qt Designer是一种图形化界面设计工具，通过拖拽控件，就可以实现界面布局的设计。</p><p>在python安装目录下的<code>Lib\site-packages\qt5_applications\Qt\bin\designer.exe</code>，这个可执行文件就是Qt Designer程序。</p><p><img src="https://img.mahaofei.com/img/202112232018944-pyqt5-1.png" alt=""></p><p>打开Qt Designer后，界面左侧是控件列表，右侧是对象查看器和属性编辑器。</p><p><img src="https://img.mahaofei.com/img/202112232018814-pyqt5-2.png" alt=""></p><p>创建窗体后，可以直接将左侧的控件，如文本框、按钮等拖入到窗体中，手动调整其大小和位置。在右侧可以修改每个空间的属性。</p><p>创建好图形界面后，点击视图-预览可以查看界面效果，点击保存按钮，即可将图形界面保存为<code>.ui</code>的文件，需要修改界面时可以直接再打开<code>.ui</code>就可以修改界面。</p><h3 id="3-2-布局">3.2 布局</h3><p>简单的控件拖拽布局就不介绍了，这里说一下布局方式。</p><p>常用的布局方式有</p><table><thead><tr><th>布局</th><th>样式</th></tr></thead><tbody><tr><td>水平布局</td><td><img src="https://img.mahaofei.com/img/202112232019148-pyqt5-3.png" alt=""></td></tr><tr><td>垂直布局</td><td><img src="https://img.mahaofei.com/img/202112232019433-pyqt5-4.png" alt=""></td></tr><tr><td>表格布局</td><td><img src="https://img.mahaofei.com/img/202112232020951-pyqt5-5.png" alt=""></td></tr><tr><td>表单布局</td><td><img src="https://img.mahaofei.com/img/202112232020207-pyqt5-6.png" alt=""></td></tr></tbody></table><p>比如点选几个控件，右键设置为水平布局。这样几个空间就组合成了一个大的整体的“控件”。</p><p>再将几个设置好的水平布局选中，右键设置为垂直布局，这样就算是非常快速地制作好了一个非常简单的UI。</p><p><img src="https://img.mahaofei.com/img/202112232021341-pyqt5-7.png" alt=""></p><h3 id="3-3-控件调整">3.3 控件调整</h3><p><strong>（1）控件大小</strong></p><p>主要使用的是<code>sizePolicy</code>这个属性。</p><p>水平策略和垂直策略：</p><p><img src="https://img.mahaofei.com/img/202112232021554-pyqt5-8.png" alt=""></p><p>水平伸缩和垂直伸缩：描述多个部件在水平方向的大小比例，类似于权重。</p><blockquote><p>如两个在同一水平位置的部件的水平伸缩因子分别为1和2，则二者宽带的大小比例为1:2，如果该水平方向再无其他控件，则二者各占布局管理器宽度的1/3和2/3。</p></blockquote><p><strong>（2）控件间距</strong></p><p>上下间距：给控件添加<code>layout</code>属性，通过调整上下的padding和margin来调整间距。</p><p>左右间距：给控件添加<code>layout</code>调整左右的padding和margin来调整间距，或添加<code>horizontal spacer</code>属性调整。</p><h2 id="四、Python程序">四、Python程序</h2><h3 id="4-1-ui文件转换python程序">4.1 ui文件转换python程序</h3><p>使用cmd将目录切换到<code>.ui</code>文件所在目录，使用如下命令生成代码。（请将命令中的name替换成文件名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -o name.py name.ui</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232021448-pyqt5-9.png" alt=""></p><h3 id="4-2-主程序调用ui">4.2 主程序调用ui</h3><p>这时如果尝试运行刚刚生成的python程序是没有用的，因为生成的文件没有程序入口。因此我们需要创建一个主程序用来调用ui程序。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"><span class="comment"># 导入designer工具生成的模块</span></span><br><span class="line"><span class="comment"># 注意导入时filename替换成生成的.py文件名，Ui_file替换成.py文件的类名</span></span><br><span class="line"><span class="keyword">from</span> filename <span class="keyword">import</span> Ui_filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_excel_combine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment"># 将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment"># 程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3 id="4-3-设置按钮、文本框的响应程序">4.3 设置按钮、文本框的响应程序</h3><p>在主程序的MyMainForm类中进行设置，以按钮和文本框为例</p><p><strong>（1）按钮按下处理程序</strong></p><p>例如下面的代码，当按钮被按下时，自动执行括号内的处理函数<code>button_clicked_handle</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buttonname.clicked.connect(button_clicked_handle)</span><br></pre></td></tr></table></figure><p><strong>（2）文本框显示处理程序</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textBrowser.setPlainText(<span class="string">&#x27;显示的字符串&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-4-示例代码">4.4 示例代码</h3><p>我写的代码是合并多个excel数据的程序，其中的GUI部分代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="comment"># 导入designer工具生成的模块</span></span><br><span class="line"><span class="keyword">from</span> excel_combine_ui <span class="keyword">import</span> Ui_excel_combine</span><br><span class="line"></span><br><span class="line">dir_choose = <span class="string">&quot;&quot;</span></span><br><span class="line">filename = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_excel_combine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.cwd = os.getcwd() <span class="comment"># 获取当前程序文件位置</span></span><br><span class="line">        self.sourceButton.clicked.connect(self.slot_source_button)</span><br><span class="line">        self.targetButton.clicked.connect(self.slot_target_button)</span><br><span class="line">        self.combineButton.clicked.connect(self.slot_combine_button)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_source_button</span>(<span class="params">self</span>):</span><br><span class="line">        files, filetype = QFileDialog.getOpenFileNames(self, <span class="string">&quot;选择多个采购申请表&quot;</span>, self.cwd, <span class="string">&quot;All Files (*);;PDF Files (*.pdf);;Text Files (*.txt)&quot;</span>)</span><br><span class="line">        <span class="keyword">global</span> filename</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取消选择\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        filename_print = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            filename.append(file)</span><br><span class="line">            filename_print += file</span><br><span class="line">            filename_print += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.textBrowser.setPlainText(filename_print)</span><br><span class="line">        <span class="comment"># print(&quot;文件筛选器类型：&quot;, filetype)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_target_button</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> dir_choose</span><br><span class="line">        dir_choose = QFileDialog.getExistingDirectory(self, <span class="string">&quot;选择保存目录&quot;</span>, self.cwd)</span><br><span class="line">        <span class="keyword">if</span> dir_choose == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取消选择\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.textBrowser_2.setPlainText(dir_choose)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_combine_button</span>(<span class="params">self</span>):</span><br><span class="line">        wb_template = app.books.<span class="built_in">open</span>(<span class="string">&#x27;采购申请单模板.xls&#x27;</span>)  <span class="comment"># 打开工作簿</span></span><br><span class="line">        combine(wb_template, filename, dir_choose+<span class="string">&#x27;\采购申请表汇总.xls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app1 = QApplication(sys.argv)</span><br><span class="line">    app1.setWindowIcon(QIcon(<span class="string">&#x27;logo.png&#x27;</span>))</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment"># 将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment"># 程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line"></span><br><span class="line">    sys.exit(app1.exec_())</span><br><span class="line">    <span class="comment"># button.clicked.connect(handleCalc) 按钮按下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232022811-pyqt5-10.png" alt=""></p><blockquote><p>更多控件的使用方法可以参考这位博主的文章：<br>链接：<a href="https://blog.csdn.net/weixin_40841247/article/details/88781601">https://blog.csdn.net/weixin_40841247/article/details/88781601</a></p></blockquote><h2 id="五、发布程序">五、发布程序</h2><h3 id="5-1-安装pyinstaller">5.1 安装pyinstaller</h3><p>要将写好的python程序打包成exe可执行程序需要使用pyinstaller，使用pip命令安装pyInstaller：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><h3 id="5-2-打包exe">5.2 打包exe</h3><ol><li><p>打开cmd窗口，进入写好的python程序所在的目录</p></li><li><p>使用如下的命令打包exe，例如我的主程序是<code>main.py</code>，我用到的包有<code>PyQt5</code>和<code>xlwings</code>，我的图标文件是<code>logo.ico</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller main.py --noconsole --hidden-import <span class="string">&quot;PyQt5.QtXml&quot;</span>,<span class="string">&quot;xlwings&quot;</span> --icon=<span class="string">&quot;logo.ico&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232022909-pyqt5-11.png" alt=""></p><p>由于pyInstaller只能分析出需要哪些代码文件。 而程序动态打开的资源文件，比如图片、excel、ui这些，它是不会帮你打包的。</p><p>而我的程序需要从调用xls表格文件，手动拷贝到dist/main目录中。</p><p>然后，再双击运行 main.exe，即可成功。</p><h3 id="5-3-改进：减少打包程序的大小">5.3 改进：减少打包程序的大小</h3><p>刚刚使用命令行直接打包，发现打包出来的程序非常大。原因是打包时系统会将很多原本用不到的依赖库一并打包起来。经过在网上查找方法，发现可以使用虚拟环境，原理是新建一个虚拟环境，然后在虚拟环境中安装程序的依赖库，然后在虚拟环境中完成打包。</p><p><strong>（1）使用pipenv创建虚拟环境</strong></p><p>创建python虚拟环境，需要系统已经安装好python虚拟环境。打开cmd。</p><ol><li>安装pipenv</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure><ol start="2"><li>进入一个空目录，初始化虚拟python环境（注意python版本需要与系统安装的版本一致）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --python 3.9</span><br></pre></td></tr></table></figure><ol start="3"><li>进入虚拟环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><p><strong>（2）安装程序依赖</strong></p><p>在虚拟环境中，只安装python程序使用到的库，尽可能减少打包程序的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line">pip install pyqt5</span><br><span class="line">pip install xlwings</span><br></pre></td></tr></table></figure><p><strong>（3）虚拟环境中打包程序</strong></p><p>在虚拟环境中直接使用pyinstaller打包程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller main.py --noconsole --hidden-import <span class="string">&quot;PyQt5.QtXml&quot;</span>,<span class="string">&quot;xlwings&quot;</span> --icon=<span class="string">&quot;logo.ico&quot;</span></span><br></pre></td></tr></table></figure><p>这样打包完成后的程序就小了很多。</p>]]></content>
    
    
    <summary type="html">由于最近实验室需要处理很多表格，因此使用python做了一个工具辅助处理。程序使用pyqt5作为图形界面，记录了从安装pyqt5，到设计界面，再到调用控件的代码，最后打包exe文件的全过程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>g2o图优化简介与基本使用方法</title>
    <link href="https://www.mahaofei.com/post/7851485c.html"/>
    <id>https://www.mahaofei.com/post/7851485c.html</id>
    <published>2021-10-24T03:03:18.000Z</published>
    <updated>2022-04-09T13:29:21.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、g2o简介">一、g2o简介</h3><p>g2o（General Graphic Optimization）是一个基于图优化的库，将非线性优化与图论结合起来的理论，我们可以利用g2o求解任何可以表示为图优化的最小二乘问题。</p><blockquote><p>图优化就是把优化问题表现成图的方式。图由顶点和边组成，其中顶点表示优化变量，边表示误差项，对任意一个非线性?&gt; 最小二乘问题，我们都可以构建与之对应的图。<br>（注：这里的图是图论意义上的图，可以用概率论里面的定义，贝叶斯图或因子图。）</p></blockquote><h3 id="二、g2o安装">二、g2o安装</h3><p>首先安装g2o的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qt5-qmake qt5-default libqglviewer-dev-qt5 libsuitesparse-dev libcxsparse3 libcholmod3 </span><br></pre></td></tr></table></figure><p>然后到github下clone此工程，然后编译安装，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o.git</span><br><span class="line"><span class="built_in">cd</span> g2o/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>g2o的头文件在<code>/usr/local/g2o</code>下，库文件在<code>/usr.local/lib</code>下。</p><h3 id="三、利用g2o拟合曲线">三、利用g2o拟合曲线</h3><h4 id="1-拟合步骤">1. 拟合步骤</h4><p><strong>① 定义顶点和边的类型（优化变量与误差项）</strong><br><strong>② 构建图</strong><br><strong>③ 选择优化算法</strong><br><strong>④ 调用g2o进行优化，返回结果</strong></p><h3 id="2-实验-拟合曲线">2. 实验-拟合曲线</h3><p>此示例程序还依赖opencv、Eigen、Ceres库，需要预先安装。</p><p><strong>main.cpp文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/g2o_core_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点（优化变量）（参数：维度、数据类型）</span></span><br><span class="line"><span class="comment">// 优化变量维数：3维    数据类型：Eigen::Vector3d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingVertex</span> : <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW     <span class="comment">// 字节对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;           <span class="comment">// 设定被优化变量的原始值、重置成员函数的估计值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);           <span class="comment">// 更新优化变量（估计值）。增量方程计算出增量△x后，通过此函数对估计值进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读盘</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存盘</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的边（误差项）（参数：观测值维度、类型、连接定点类型）</span></span><br><span class="line"><span class="comment">// 边的模型：BaseUnaryEdge   连接顶点个数：1    测量值数据类型：double  顶点类型：CurveFittingVertex</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingEdge</span> : <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="type">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">CurveFittingEdge</span><span class="params">(<span class="type">double</span> x)</span>:BaseUnaryEdge(),_x(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);        <span class="comment">// _vertices[]存储顶点信息</span></span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>,<span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));        <span class="comment">// _error存储computeError()函数计算的误差</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">exp</span>(abc[<span class="number">0</span>] * _x * _x + abc[<span class="number">1</span>] * _x + abc[<span class="number">2</span>]);</span><br><span class="line">        _jacobianOplusXi[<span class="number">0</span>] = -_x * _x * y;</span><br><span class="line">        _jacobianOplusXi[<span class="number">1</span>] = -_x * y;</span><br><span class="line">        _jacobianOplusXi[<span class="number">2</span>] = -y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _x;    <span class="comment">//x值；（y值为_measurement测量值）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义数据参数</span></span><br><span class="line">    <span class="type">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;    <span class="comment">//真实参数值</span></span><br><span class="line">    <span class="type">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;   <span class="comment">//估计参数值</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                            <span class="comment">//数据点个数</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                   <span class="comment">//噪声Sigma值</span></span><br><span class="line">    <span class="type">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">    cv::RNG rng;                            <span class="comment">//随机数产生器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成100个带高斯噪声的数据</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建图优化</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;    <span class="comment">// 配置BlockSolver，每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::LinearSolverDense&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;    <span class="comment">// 创建BlockSolver，并用定义的线性求解器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置梯度下降的方法，创建总求解器solver</span></span><br><span class="line">    <span class="keyword">auto</span> solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(g2o::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(g2o::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;()));</span><br><span class="line">    g2o::SparseOptimizer optimizer;     <span class="comment">//创建系数优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver);     <span class="comment">//设置求解方法</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>); <span class="comment">//打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中加入顶点</span></span><br><span class="line">    CurveFittingVertex *v = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    v-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(ae, be, ce));</span><br><span class="line">    v-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中加入边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]);</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);                     <span class="comment">//定义边的编号（决定在H矩阵中的位置）</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, v);           <span class="comment">//设置连接的顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]);    <span class="comment">//设置观测值</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));    <span class="comment">//信息矩阵：协方差矩阵的逆</span></span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Start optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//记录算法执行时间</span></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">//初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);    <span class="comment">//执行10次</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; s.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d abc_estimate = v-&gt;<span class="built_in">estimate</span>();   <span class="comment">//获取当前值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;estimated model: &quot;</span> &lt;&lt; abc_estimate.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="built_in">project</span>(g2oCurveFitting)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"># OpenCV库</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Eigen库</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"># Ceres库</span><br><span class="line"><span class="built_in">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># g2o库</span><br><span class="line"><span class="built_in">list</span>( APPEND CMAKE_MODULE_PATH /home/huffie/slam/<span class="number">3</span>rdparty/g2o/cmake_modules ) #刚才clone的项目文件夹</span><br><span class="line"><span class="built_in">set</span>(G2O_ROOT /usr/local/include/g2o)</span><br><span class="line"><span class="built_in">find_package</span>(G2O REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;G2O_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(g2oCurveFitting main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting  g2o_stuff   g2o_core )</span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting $&#123;CERES_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">g2o（General Graphic Optimization）是一个基于图优化的库，将非线性优化与图论结合起来的理论，我们可以利用g2o求解任何可以表示为图优化的最小二乘问题。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="SLAM" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/SLAM/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="slam" scheme="https://www.mahaofei.com/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>【Ceres基本使用方法】使用Ceres拟合曲线求解最小二乘问题</title>
    <link href="https://www.mahaofei.com/post/1efb54e0.html"/>
    <id>https://www.mahaofei.com/post/1efb54e0.html</id>
    <published>2021-10-23T03:56:10.000Z</published>
    <updated>2022-04-09T13:29:21.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Ceres简介">一、Ceres简介</h3><p>Ceres是一个最小二乘问题求解库，我们只需要定义待优化的问题，然后交给它计算即可。</p><p><strong>① 基本概念</strong><br>常用的最小二乘问题形式如下：</p><p><img src="https://img.mahaofei.com/img/202112232017086-ceres-introduction-1.png" alt=""></p><ul><li>参数块：$x_1$, … $x_n$等优化变量</li><li>代价函数（残差块/误差项）：$f_i$</li><li>核函数：ρ(·)，目标函数由许多平方项经过核函数求和自称</li></ul><p><strong>② 使用方法</strong></p><ol><li>定义每个参数块。参数块就是简单的向量，也可以是四元数、李代数等特殊的结构。</li><li>定义残差块的计算方式。残差块对参数块进行自定义计算，返回残差值，然后求平方和作为目标函数的值。</li><li>定义雅可比的计算方式。</li><li>把所有的参数块和残差块加入Ceres定义的Problem对象中，调用Solve函数求解</li></ol><h3 id="二、Ceres安装">二、Ceres安装</h3><p>首先下载Ceres的源代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceres-solver/ceres-solver.git</span><br></pre></td></tr></table></figure><p>安装ceres所需要的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libsuitesparse-dev libcxsparse3 libgflags-dev libgoogle-glog-dev libgtest-dev</span><br></pre></td></tr></table></figure><p>然后进入文件夹编译安装ceres，这里耗时比较久大概20min左右。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ceres-solver/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，如果在<code>/usr/local/include/ceres/</code>目录下能找到Ceres的头文件，并且也有库文件<code>/usr/local/lib/libceres.a </code>，说明安装成功了，可以使用Ceres进行优化计算了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /usr/local/include/ceres/</span><br><span class="line">ll /usr/local/lib/libceres.a </span><br></pre></td></tr></table></figure><h3 id="三、使用Ceres拟合曲线">三、使用Ceres拟合曲线</h3><p>此示例程序依赖opencv、Eigen库，需要预先安装。</p><p><strong>main.cpp</strong>文件代码程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建代价函数的计算模型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CURVE_FITTING_COST</span>&#123;</span><br><span class="line">    <span class="built_in">CURVE_FITTING_COST</span>(<span class="type">double</span> x, <span class="type">double</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()，仿函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> T *<span class="type">const</span> abc, <span class="comment">// 模型参数，有3维</span></span></span></span><br><span class="line"><span class="params"><span class="function">            T *residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(_y) - ceres::<span class="built_in">exp</span>(abc[<span class="number">0</span>] * <span class="built_in">T</span>(_x) * <span class="built_in">T</span>(_x) + abc[<span class="number">1</span>] * <span class="built_in">T</span>(_x) + abc[<span class="number">2</span>]); <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义数据参数</span></span><br><span class="line">    <span class="type">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;    <span class="comment">//真实参数值</span></span><br><span class="line">    <span class="type">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;   <span class="comment">//估计参数值</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                            <span class="comment">//数据点个数</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                   <span class="comment">//噪声Sigma值</span></span><br><span class="line">    <span class="type">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">    cv::RNG rng;                            <span class="comment">//随机数产生器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成100个带高斯噪声的数据</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> abc[<span class="number">3</span>] = &#123;ae, be, ce&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建最小二乘问题</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">//添加误差项。使用自动求导，模板参数：误差类型、输出维度、输入维度、维数要与前面struct中一致</span></span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(<span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt;(<span class="keyword">new</span> <span class="built_in">CURVE_FITTING_COST</span>(x_data[i], y_data[i])),<span class="literal">nullptr</span>,abc);</span><br><span class="line">        <span class="comment">//nullptr为核函数不使用为空，abc为待估计参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置并运行求解器</span></span><br><span class="line">    ceres::Solver::Options options;     <span class="comment">//定义配置项</span></span><br><span class="line">    options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;  <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;    <span class="comment">//输出到cout</span></span><br><span class="line">    ceres::Solver::Summary summary; <span class="comment">//定义优化信息</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//计时：求解开始时间</span></span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);  <span class="comment">//开始优化求解！</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//计时：求解结束时间</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);  <span class="comment">//计算求解耗时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s.&quot;</span> &lt;&lt; endl;  <span class="comment">//输出求解耗时</span></span><br><span class="line">    cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl;  <span class="comment">//输出简要优化信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;estimated a, b, c = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a:abc)    <span class="comment">//输出优化变量</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt</strong>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="built_in">project</span>(ceresCurveFitting)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"># OpenCV库</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Ceres库</span><br><span class="line"><span class="built_in">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Eigen库</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件</span><br><span class="line"><span class="built_in">add_executable</span>(ceresCurveFitting main.cpp)</span><br><span class="line"></span><br><span class="line"># 链接库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(ceresCurveFitting $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(ceresCurveFitting $&#123;CERES_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232017359-ceres-introduction-2.png" alt=""></p>]]></content>
    
    
    <summary type="html">Ceres是一个最小二乘问题求解库，我们只需要定义待优化的问题，然后交给它计算即可。使用方法：1. 定义每个参数块。参数块就是简单的向量，也可以是四元数、李代数等特殊的结构……</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="SLAM" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/SLAM/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="slam" scheme="https://www.mahaofei.com/tags/slam/"/>
    
  </entry>
  
  <entry>
    <title>ROS外接usb摄像头标定方法</title>
    <link href="https://www.mahaofei.com/post/130b716a.html"/>
    <id>https://www.mahaofei.com/post/130b716a.html</id>
    <published>2021-10-20T03:20:28.000Z</published>
    <updated>2022-04-09T13:29:21.233Z</updated>
    
    <content type="html"><![CDATA[<p>usb_cam官方文档：<a href="http://wiki.ros.org/camera_calibration">http://wiki.ros.org/camera_calibration</a><br>camera_calibrate官方文档：<a href="http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration">http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration</a><br>棋盘格也在上面的链接中下载。</p><p>摄像头标定的目的是消除相机畸变，具体畸变原理可以参考之前的文章<a href="https://blog.csdn.net/weixin_44543463/article/details/120659447">【相机模型与去畸变方法详解】</a>。usb摄像头在ros系统标定过程大致可以分成几个步骤。①安装usb_camera驱动包；② 运行usb_cam读取usb摄像头图像；③下载打印棋盘格并进行摄像头标定。</p><h3 id="1-安装usb-camera驱动包">1. 安装usb_camera驱动包</h3><ul><li>进入工作空间的src目录（这里工作空间目录可能都不一样，自行修改）</li><li>下载usb_cam源代码</li><li>编译安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ros-drivers/usb_cam.git</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="2-运行usb-cam读取摄像头图像">2. 运行usb_cam读取摄像头图像</h3><p>首先打开一个终端，运行<code>roscore</code></p><p>然后再打开一个终端，运行<code>usb_cam-test.launch</code>启动文件（由于刚才下载的源代码中由测试文件，因此可以直接启动）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/usb_cam/launch</span><br><span class="line">roslaunch usb_cam-test.launch</span><br></pre></td></tr></table></figure><p>默认情况下开启的是电脑自带摄像头，如果需要启动外置摄像头，则修改一下launch文件，将参数第一行的value改为<code>value=&quot;/dev/video1&quot;</code>，然后重新编译一下。</p><blockquote><p>如果更改后启动报错，那么执行<code>ls /dev/video*</code>命令看看外界摄像头是那个，再将launch文件改为对应的video2或video3。<br>比如我的usb摄像头就是 /dev/video2</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;video_device&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/dev/video1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果出现如下错误<br>ERROR: cannot launch node of type [usb_cam/usb_cam_node]: usb_cam<br>ROS path [0]=/opt/ros/kinetic/share/ros<br>ROS path [1]=/opt/ros/kinetic/share<br>首先进入工作空间目录</p></blockquote><h3 id="3-进行摄像头标定">3. 进行摄像头标定</h3><p>再次打开一个终端（前两个分别运行<code>roscore</code>和<code>usb_cam-test</code>）</p><p><strong>① 查看主题名称</strong></p><p>输入<code>rostopic list</code>查看ros中的主题，检查是否有<code>/usb_cam/camera_info</code>和<code>/usb_cam/image_raw</code>两个主题。（主题名可能会不一样，有可能是/usb_cam_node记住自己的这两个主题的名字）</p><p><img src="https://img.mahaofei.com/img/202112232015769-camera-calibrate-1.png" alt=""></p><blockquote><p>如果出现 ImportError: No module named cv2的问题，请参考下面这篇文章<br>文章链接：<a href="https://blog.csdn.net/weixin_44543463/article/details/120717831#pic_center">【ImportError: No module named cv2问题的解决方法（修改python默认版本）】</a></p></blockquote><p><strong>② 执行命令启动标定程序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.03 image:=/usb_cam/image_raw camera:=/usb_cam</span><br></pre></td></tr></table></figure><p>其中的8x6是指的棋盘格内部角点的个数，如下图我下载的棋盘格内部角点是8x6的。如果你是11x8角点的棋盘格，那么命令里面的8x6替换成11x8即可。</p><p><img src="https://img.mahaofei.com/img/202112232016343-camera-calibrate-2.png" alt=""></p><p><strong>③ 变换角度使程序记录样本</strong></p><p>拿着棋盘格纸多变幻几个角度，离远离近，边边角角都采集一些样本，当命令行里看到sample接近50的时候，标定按钮calibrate就会变亮了。</p><p><strong>④ 进行标定并保存</strong><br>点击CALIBRATE按钮进行标定，等待一小段时间后，就可以在命令行中看到标定的结果。<br>标定没有问题的花，点击COMMIT按钮就可以保存了，保存之后，下次再启动usb_camera就会自动使用标定的参数，可以发现摄像头不再畸变了。</p><p><img src="https://img.mahaofei.com/img/202112232016191-camera-calibrate-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232016631-camera-calibrate-4.png" alt=""></p>]]></content>
    
    
    <summary type="html">摄像头标定的目的是消除相机畸变，具体畸变原理可以参考之前的文章。usb摄像头在ros系统标定过程大致可以分成几个步骤。①安装usb_camera驱动包；② 运行usb_cam读取usb摄像头图像；③下载打印棋盘格并进行摄像头标定。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Keil5 C51版 下载与安装教程（51单片机编程软件）</title>
    <link href="https://www.mahaofei.com/post/6c3a51dc.html"/>
    <id>https://www.mahaofei.com/post/6c3a51dc.html</id>
    <published>2021-10-16T16:00:00.000Z</published>
    <updated>2022-04-09T13:29:20.838Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阿里云盘<br>链接：<a href="https://www.aliyundrive.com/s/ttZBZXBNMja">https://www.aliyundrive.com/s/ttZBZXBNMja</a><br>下载完成后将文件后缀名改回【.7z】即可正常解压。</p></blockquote><ol><li>解压安装包，右键【C51-V957.exe】，<strong>以管理员身份运行</strong></li></ol><p><img src="https://img.mahaofei.com/img/202112232002909-keil51-1.png" alt=""></p><ol start="2"><li>莫得选择，<strong>点击next</strong>继续安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232002704-keil51-2.png" alt=""></p><ol start="3"><li><strong>同意</strong>用户协议，<strong>点击next</strong>继续</li></ol><p><img src="https://img.mahaofei.com/img/202112232003825-keil51-3.png" alt=""></p><ol start="4"><li>选择安装路径，<strong>路径不能有中文</strong>，进行安装（注：如果想要安装51和MDK两个版本的Keil，也就是想要编写51单片机和32单片机两种程序，需要安装在两个单独的文件夹中）</li></ol><p><img src="https://img.mahaofei.com/img/202112232003419-keil51-4.png" alt=""></p><ol start="5"><li><strong>信息随便输</strong>，输完直接<strong>点击next</strong>就可以</li></ol><p><img src="https://img.mahaofei.com/img/202112232003599-keil51-5.png" alt=""></p><ol start="6"><li>安装过程很快，大约十几秒，点击finish完成安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232004114-keil51-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232004458-keil51-7.png" alt=""></p><ol start="7"><li>回到桌面，找到【Keil5】的快捷方式，右键<strong>以管理员身份运行</strong>，然后打开【File -&gt; License Management】选项卡</li></ol><p><img src="https://img.mahaofei.com/img/202112232004254-keil51-8.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232004032-keil51-9.png" alt=""></p><ol start="8"><li>在解压的安装包中找到【Crack.exe】文件，<strong>右键以管理员身份运行</strong></li></ol><p><img src="https://img.mahaofei.com/img/202112232005088-keil51-10.png" alt=""></p><ol start="9"><li>在【License Management】中<strong>复制CID</strong>，<strong>粘贴到破解程序</strong>中，target选择C51，<strong>点击Generate</strong>生成激活码</li></ol><p><img src="https://img.mahaofei.com/img/202112232005496-keil51-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232005539-keil51-12.png" alt=""></p><ol start="10"><li><p>将激活码粘贴回【License Management】下方的输入框中，并点击【Add LIC】</p><p><img src="https://img.mahaofei.com/img/202112232006203-keil51-13.png" alt=""></p></li><li><p>可以看到已经成功激活，激活时间到2032年</p><p><img src="https://img.mahaofei.com/img/202112232006493-keil51-14.png" alt=""></p></li></ol>]]></content>
    
    
    <summary type="html">本教程介绍Keil5 51版的下载安装方法，Keil5是一款非常友好和强大的C语言软件开发系统。Keil5提供了清晰直观的操作界面,而且使用起来十分的轻松便捷,并具备编译器、编译器、安装包和调试跟踪功能。</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="单片机" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    <category term="单片机" scheme="https://www.mahaofei.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Keil5 MDK版 下载与安装教程（STM32单片机编程软件）</title>
    <link href="https://www.mahaofei.com/post/1b083906.html"/>
    <id>https://www.mahaofei.com/post/1b083906.html</id>
    <published>2021-10-16T16:00:00.000Z</published>
    <updated>2022-04-09T13:29:20.842Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阿里云盘<br>链接：<a href="https://www.aliyundrive.com/s/42a1npEEsrw">https://www.aliyundrive.com/s/42a1npEEsrw</a><br>下载完成后将文件后缀名改回【.7z】即可正常解压。</p></blockquote><ol><li>解压安装包，<strong>以管理员身份运行</strong>【MDK528.exe】</li></ol><p><img src="https://img.mahaofei.com/img/202112232006461-keilmdk-1.png" alt=""></p><ol start="2"><li>按步骤一直安装就可以，每一步我都在下面截了图，可以对照一下。</li></ol><p><img src="https://img.mahaofei.com/img/202112232007055-keilmdk-2.png" alt=""></p><ol start="3"><li>选择我同意用户协议，然后next</li></ol><p><img src="https://img.mahaofei.com/img/202112232007859-keilmdk-3.png" alt=""></p><ol start="4"><li>选择安装位置，一定要和Keil C51版本安装在<strong>不同的文件夹</strong>中</li></ol><p><img src="https://img.mahaofei.com/img/202112232007389-keilmdk-4.png" alt=""></p><ol start="5"><li>信息随便填</li></ol><p><img src="https://img.mahaofei.com/img/202112232010807-keilmdk-5.png" alt=""></p><ol start="6"><li>等待安装，大约耗时1分钟左右</li></ol><p><img src="https://img.mahaofei.com/img/202112232010318-keilmdk-6.png" alt=""></p><ol start="7"><li>如果安装过程中弹出需要安装某驱动，一定要安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232011061-keilmdk-7.png" alt=""></p><ol start="8"><li>不需要展示新特性，直接下一步点击finish完成即可。</li></ol><p><img src="https://img.mahaofei.com/img/202112232011656-keilmdk-8.png" alt=""></p><ol start="9"><li>出现下面这个包安装界面，直接关闭即可，后续我们手动安装包，要快得多</li></ol><p><img src="https://img.mahaofei.com/img/202112232012974-keilmdk-9.png" alt=""></p><blockquote><p>如果之前安装过Keil51版本，想要两个版本共存，需要加入以下步骤。如果仅安装Keil MDK版，可跳过此部分。</p><ol><li><p>打开C51安装路径，找到 TOOLS.INI  这个文件</p></li><li><p>以记事本打开【TOOLS.INI】这个文件，复制 [C51]（包括）以下的全部内容</p></li><li><p>粘贴至MDK-ARM安装目录下的  TOOLS.INI 文件末尾，保存，关闭。</p></li></ol><p><img src="https://img.mahaofei.com/img/202112232012255-keilmdk-10.png" alt=""></p></blockquote><ol start="10"><li><p>在桌面找到【Keil 5】的快捷方式，右键以管理员身份运行。然后打开【File -&gt; License Management】选项卡。</p><p><img src="https://img.mahaofei.com/img/202112232012315-keilmdk-11.png" alt=""></p></li><li><p>复制右上角的CID</p><p><img src="https://img.mahaofei.com/img/202112232013981-keilmdk-12.png" alt=""></p></li><li><p>打开解压的安装包，找到【keygen.exe】，右键以管理员身份运行</p><p><img src="https://img.mahaofei.com/img/202112232013788-keilmdk-13.png" alt=""></p></li><li><p><strong>粘贴CID</strong>到对应的输入框中，<strong>target选择ARM</strong>，然后点击<strong>Generate生成激活码</strong>。</p><p><img src="https://img.mahaofei.com/img/202112232014581-keilmdk-14.png" alt=""></p></li><li><p>复制生成的激活码，回到Keil中的【License Management】对话框，在下方LIC中粘贴激活码，然后点击Add LIC激活成功。（激活的日期过了也不影响使用）</p><p><img src="https://img.mahaofei.com/img/202112232014618-keilmdk-15.png" alt=""></p></li><li><p>安装剩下的两个库文件，直接双击就可以安装。（两个库文件分别对应STM32F1和F4的芯片）</p><p><img src="https://img.mahaofei.com/img/202112232014820-keilmdk-16.png" alt=""></p></li><li><p>至此安装完成，可以正常使用。</p><p><img src="https://img.mahaofei.com/img/202112232015660-keilmdk-17.png" alt=""></p></li></ol>]]></content>
    
    
    <summary type="html">本教程介绍Keil5 MDK版的下载安装方法，Keil5是一款非常友好和强大的C语言软件开发系统。Keil5提供了清晰直观的操作界面,而且使用起来十分的轻松便捷,并具备编译器、编译器、安装包和调试跟踪功能。</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="单片机" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    <category term="单片机" scheme="https://www.mahaofei.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ROS+Gazebo仿真差速小车并实现控制</title>
    <link href="https://www.mahaofei.com/post/fc92db80.html"/>
    <id>https://www.mahaofei.com/post/fc92db80.html</id>
    <published>2021-10-15T11:03:48.000Z</published>
    <updated>2022-04-09T13:29:21.231Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本工程的功能包有两个，分别用于<strong>gazebo仿真</strong>与<strong>键盘控制运动</strong><br>功能包原文件如下：<br>diff_wheeled_robot_control : <a href="https://huffie.lanzouw.com/iXilxvdqola">https://huffie.lanzouw.com/iXilxvdqola</a><br>diff_wheeled_robot_gazebo: <a href="https://huffie.lanzouw.com/ixG3uvdqoyd">https://huffie.lanzouw.com/ixG3uvdqoyd</a></p></blockquote><p><strong>准备工作：</strong><br>如果你是第一次使用gazebo，需要先安装下面的包才可以正常使用：<br>（这里以noetic版本为例，如果你是其他版本的ros，自行更换中间的代码即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-gazebo-ros-pkgs ros-noetic-gazebo-ros ros-noetic-gazebo-msgs ros-noetic-gazebo-plugins ros-noetic-gazebo-ros-control</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行执行  <code>gazebo</code>命令检查是否正确安装，如果看到下面的界面说明安装没有问题。</p><p><img src="https://img.mahaofei.com/img/202112232001567-ros-gazebo-1.png" alt=""></p><p>然后再在命令行中运行下面的命令，检查Gazebo的ROS接口是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore &amp; rosrun gazebo_ros gazebo</span><br></pre></td></tr></table></figure><p>这个命令会运行roscore，同时也会启动gazebo，如果能看到gazebo的界面说明没有问题。</p><h3 id="一、创建小车模型">一、创建小车模型</h3><p><strong>1. 首先创建一个功能包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg diff_wheeled_robot_gazebo roscpp tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><blockquote><p>如果之前没有创建过ROS工作空间，可以先执行如下命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></blockquote><p><strong>2. 创建基本文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> diff_wheeled_robot_gazebo/</span><br><span class="line"><span class="built_in">mkdir</span> urdf meshes launch world</span><br></pre></td></tr></table></figure><p><strong>3. 复制模型文件</strong><br>将<a href="https://huffie.lanzouw.com/ixG3uvdqoyd">提供的gazebo工程包</a>urdf文件夹中的 <code>diff_wheeled_robot.xacro</code> 文件和 <code>wheel.urdf.xacro</code> 文件复制进自己的工程的urdf文件夹内。</p><p>同时将mesh文件夹中万向轮的三维模型 <code>caster_wheel.stl</code> 文件复制进自己工程的meshes文件夹内。</p><p>关于xacro的代码解释，可以参考另一篇机械臂相关内容：<a href="https://blog.csdn.net/weixin_44543463/article/details/120607629">urdf与xacro的使用方法 &amp; 机械臂模型仿真示例</a></p><p><strong>4. 创建launch文件</strong><br>回到上一级，进入launch文件夹，创建一个<code>diff_wheeled_gazebo.launch</code>文件，并在其中添加如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- We resume the logic in empty_world.launch --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg debug)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg use_sim_time)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg headless)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- urdf xml robot description loaded on the Parameter Server--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find diff_wheeled_robot_gazebo)/urdf/diff_wheeled_robot.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Run a python script to the send a service call to gazebo_ros to spawn a URDF robot --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;urdf_spawner&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">args</span>=<span class="string">&quot;-urdf -model diff_wheeled_robot -param robot_description&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5. 编译并启动节点，查看机器人模型</strong><br>首先编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_gazebo diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><p>可以看到已经正常启动Gazebo，并且小车的模型也已经正常加载出来了</p><p><img src="https://img.mahaofei.com/img/202112232001178-ros-gazebo-2.png" alt=""></p><h3 id="二、控制小车移动">二、控制小车移动</h3><p><strong>1. 插件介绍</strong><br>控制小车移动所使用的插件是 <code>libgazebo_ros_diff_drive.so</code> 。此插件的添加代码已经写在了xacro文件中如下：</p><p><img src="https://img.mahaofei.com/img/202112232001660-ros-gazebo-3.png" alt=""></p><p>其中可以指定的参数包括轮子的关节、轮子的间距、车轮直径、里程计的主题等等。这里面最重要的一个参数是控制命令主题 <code>commandTopic</code>，用于驱动车轮的运动。在这里我们可以通过向 <code>/cmd_vel</code> 主题发布数据来控制小车的运动。</p><p><strong>2. 测试运动</strong><br>在gazebo仿真正常运行的情况下，新打开一个终端输入如下指令，可以使小车进行圆周运动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -r 10 /cmd_vel geometry_msgs/Twist <span class="string">&#x27;&#123;linear: &#123;x: 0.5, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 0.5&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232001294-ros-gazebo-4.png" alt=""></p><h3 id="三、键盘控制小车移动">三、键盘控制小车移动</h3><p><strong>1. 创建功能包</strong><br>创建一个功能包用于驱动小车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin/src</span><br><span class="line">catkin_create_pkg diff_wheeled_robot_control rospy tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><p>将<a href="https://huffie.lanzouw.com/iXilxvdqola">control工程包</a>中的<code>launch</code>文件夹和<code>scripts</code>文件夹复制到新创建的功能包中。</p><p><strong>2. 编译启动仿真</strong></p><p>回到工作空间目录进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>启动仿真程序</p><p>首先和之前一样启动小车的仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_gazebo diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><p>然后新打开一个终端启动键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_control keyboard_teleop.launch</span><br></pre></td></tr></table></figure><p>这时候终端窗口内会出现提示，在终端内按下按键即可控制小车</p><p><img src="https://img.mahaofei.com/img/202112232002981-ros-gazebo-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232002842-ros-gazebo-6.png" alt=""></p>]]></content>
    
    
    <summary type="html">利用xacro描述文件创建差速小车模型，通过gazebo仿真此模型，然后利用libgazebo_ros_diff_drive.so插件控制小车的运动，最后实现了通过键盘按键，控制gazebo环境中的小车运动。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>LabVIEW2020下载与安装教程</title>
    <link href="https://www.mahaofei.com/post/38b2093b.html"/>
    <id>https://www.mahaofei.com/post/38b2093b.html</id>
    <published>2021-10-12T16:00:00.000Z</published>
    <updated>2022-04-09T13:29:20.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链接:  <a href="https://pan.baidu.com/s/15mAoxOT_9aMnUQet08Wj4g">https://pan.baidu.com/s/15mAoxOT_9aMnUQet08Wj4g</a><br>提取码: evvm</p></blockquote><p>此教程为Labview2020 中文版的安装教程，英文版安装过程相同。</p><ol><li>打开解压后的文件夹，<strong>进入安装包目录</strong>，双击运行【<strong>Install.exe</strong>】开始安装。<br><img src="https://img.mahaofei.com/img/202112230940458-labview2020-1.png" alt=""></li><li>接受许可协议，<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230941389-labview2020-2.png" alt=""></li><li>直接<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230941226-labview2020-3.png" alt=""></li><li>莫得选择，继续<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230942373-labview2020-4.png" alt=""></li><li><strong>等待十多秒</strong>安装相关组件，然后会<strong>弹出选择菜单</strong>，按照默认选择<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202112230942043-labview2020-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230942214-labview2020-6.png" alt=""></li><li><strong>我接受，然后下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943289-labview2020-7.png" alt=""></li><li>还是莫得选择，继续<strong>接受，然后下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943520-labview2020-8.png" alt=""></li><li>核对信息，正常安装不会有问题，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943878-labview2020-9.png" alt=""></li><li><strong>等待安装</strong>，安装过程耗时分钟左右<br><img src="https://img.mahaofei.com/img/202112230944483-labview2020-10.png" alt=""></li><li><strong>选择yes</strong><br><img src="https://img.mahaofei.com/img/202112230944354-labview2020-11.png" alt=""></li><li>选择<strong>不加入用户体验改进计划</strong>，<strong>确定</strong><br><img src="https://img.mahaofei.com/img/202112230944025-labview2020-12.png" alt=""></li><li>在弹出的登陆页面<strong>点击取消</strong><br><img src="https://img.mahaofei.com/img/202112230944296-labview2020-13.png" alt=""></li><li>不需要重启，<strong>点击右上角x关闭安装程序即可</strong><br><img src="https://img.mahaofei.com/img/202112230945782-labview2020-14.png" alt=""></li><li>打开安装包，找到【<strong>NI License Acticator 1.2</strong>】，右键<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230945417-labview2020-15.png" alt=""></li><li>将<strong>全部选项右键激活</strong><br><img src="https://img.mahaofei.com/img/202112230945106-labview2020-16.png" alt=""></li><li>至此完成安装，在开始菜单找到安装好的程序启动<br><img src="https://img.mahaofei.com/img/202112230946133-labview2020-17.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112230946156-labview2020-18.png" alt=""></p>]]></content>
    
    
    <summary type="html">LabVIEW2020 中文版安装教程，提供阿里云盘链接与详细安装教程。资源仅供学习参考，请勿用于商业用途！</summary>
    
    
    
    <category term="嵌入式" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="LabVIEW" scheme="https://www.mahaofei.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/LabVIEW/"/>
    
    
    <category term="软件安装" scheme="https://www.mahaofei.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    <category term="LabVIEW" scheme="https://www.mahaofei.com/tags/LabVIEW/"/>
    
  </entry>
  
  <entry>
    <title>ImportError No module named cv2问题的解决方法（修改python默认版本）</title>
    <link href="https://www.mahaofei.com/post/cad41dc4.html"/>
    <id>https://www.mahaofei.com/post/cad41dc4.html</id>
    <published>2021-10-12T02:14:12.000Z</published>
    <updated>2022-04-09T13:29:21.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述-2">问题描述</h3><p>在调用opencv安装包时，会出现 <strong>ImportError: No module named cv2</strong> 的问题：</p><p><img src="https://img.mahaofei.com/img/202112231958111-no-module-1.png" alt=""></p><h3 id="产生原因">产生原因</h3><p>我确定我已经安装了opencv，但为什么还是显示没有此模块。查阅资料后发现是因为安装opencv是会安装到它默认的python版本，而这个python版本与系统默认使用的版本不一致，才会导致找不到模块。</p><p>例如我的电脑里安装了python2.7和python3.8两个版本，ubuntu系统启动程序默认使用python2.7，而opencv则安装在python3.8环境中。</p><h3 id="解决方法-2">解决方法</h3><blockquote><p>首先确定你是不是真的没有安装opencv的python支持，可以运行如下代码安装：</p><p>sudo pip3 install opencv-python</p><p>如果安装完还不能解决问题，看以下步骤</p></blockquote><p>更改系统的默认python版本，改为所使用的高版本。</p><p>可以先使用<code>ls /usr/bin/python*</code>查看系统中存在的python版本</p><p><img src="https://img.mahaofei.com/img/202112231958436-no-module-2.png" alt=""></p><p>然后移除软连接，更改python默认版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /user/bin/python</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/python3.5 /usr/bin/python</span><br></pre></td></tr></table></figure><p> <br>再次启动之前的程序，正常启动，不再显示ImportError: No module named cv2了！</p><p><img src="https://img.mahaofei.com/img/202112231959476-no-module-3.png" alt=""></p>]]></content>
    
    
    <summary type="html">在调用opencv安装包时，会出现ImportError  No module named cv2的问题。我确定我已经安装了opencv，查阅资料后发现是因为安装opencv是会安装的python版本，与系统默认使用的版本不一致，才会导致找不到模块。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="OpenCV" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/OpenCV/"/>
    
    
    <category term="bugs" scheme="https://www.mahaofei.com/tags/bugs/"/>
    
    <category term="OpenCV" scheme="https://www.mahaofei.com/tags/OpenCV/"/>
    
    <category term="C++" scheme="https://www.mahaofei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>urdf与xacro的使用方法 &amp; 机械臂模型仿真示例</title>
    <link href="https://www.mahaofei.com/post/2a57a647.html"/>
    <id>https://www.mahaofei.com/post/2a57a647.html</id>
    <published>2021-10-10T02:23:20.000Z</published>
    <updated>2022-04-09T13:29:21.230Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要创建机器人的三维模型，原因在于机器人机器人仿真工具可以帮助我们体现发现设计中的一些关键错误。<br>而模型仿真的含义，在于我们创建的是机器人模型，因此不一定和实际机器人长得一模一样。但因为是仿真，所以模型必须具备所有的真实硬件特点。</p><h3 id="一、机器人建模的工具">一、机器人建模的工具</h3><p>ROS提供了许多功能包帮助我们进行机器人的建模，并使用ROS进行仿真。例如urdf、kdl_parser、robot_state_publisher、collada_urdf等等。</p><blockquote><p><strong>urdf是一种机器人模型的描述格式，基于XML规范，通过树状结构进行链接，因此机器人只能通过关节进行刚性连接</strong></p></blockquote><p><strong>1. robot_mode</strong><br>robot_model是一个包含了许多功能包的功能包集，包括如urdf等功能包。可以辅助我们创建机器人三维模型。</p><p><strong>2. 有关URDF的功能包</strong></p><ul><li><strong>joint_state_publisher</strong>：读取机器人模型描述文件、发布各关节信息、可使用RViz仿真、验证各关节旋转平移关系。</li><li><strong>kdl_parser</strong>：发布关节状态、正向/逆向运动学分析。</li><li><strong>robot_state_publisher</strong>：读取当前机器人关节状态，发布机器人的位姿状态。</li></ul><p><strong>3. xacro</strong><br>xacro相当于urdf的升级版本，可以让urdf更易读。并且xacro可以被用来描述复杂的机器人模型。</p><h3 id="二、URDF模型">二、URDF模型</h3><h4 id="2-1-URDF模型介绍">2.1 URDF模型介绍</h4><p><strong>1. URDF介绍</strong><br>URDF是一种机器人模型的描述文件，通过创建<code>.urdf</code>的文件，并使用xml标签来描述机器人模型。</p><p><strong>2. URDF常用标签</strong></p><ul><li><strong>robot</strong>：概述整个机器人模型，定义机器人的名字，连接件和关节。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;name of robot&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>link</strong>：描述机器人某个刚体的外观属性<code>&lt;visual /&gt;</code>，包括大小、形状、颜色，也可以描述动态特性如惯性参数<code>&lt;inertial&gt;</code>、碰撞特性<code>&lt;collision&gt;</code>。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;name of link&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">visual</span>&gt;</span>............<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inertial</span>&gt;</span>..........<span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collision</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>joint</strong>：代表机器人的关节，可以机器人的定义运动学和动力学参数，也可以限制机器人的运动和速度。不同的关节标签代表了不同的关节类型如下</li></ul><table><thead><tr><th>joint标签</th><th>代表关节类型</th></tr></thead><tbody><tr><td><code>&lt;revolute&gt;</code></td><td>旋转副（有角度限制）</td></tr><tr><td><code>&lt;continuous&gt;</code></td><td>旋转副（无限旋转）</td></tr><tr><td><code>&lt;prismatic&gt;</code></td><td>移动副</td></tr><tr><td><code>&lt;fixed&gt;</code></td><td>固定副</td></tr><tr><td><code>&lt;float&gt;</code></td><td>浮动副</td></tr><tr><td><code>&lt;planar&gt;</code></td><td>平面副</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;name of joint&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calibration</span>&gt;</span>......<span class="tag">&lt;/<span class="name">calibration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span> <span class="attr">......</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span> <span class="attr">......</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>gazebo</strong>：包含了Gazebo仿真器的一些仿真参数，可以使用此标签引入gazebo插件、gazebo物理属性设置等等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Black<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-创建功能包">2.2 创建功能包</h4><p><strong>1. 首先进入catkin工作空间中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br></pre></td></tr></table></figure><blockquote><p>如果之前没有创建过ROS工作空间，可以先执行如下命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>2. 创建功能包</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg robot_description_pkg roscpp tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><p><strong>3. 创建基本文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> robot_description_pkg</span><br><span class="line"><span class="built_in">mkdir</span> urdf meshes launch</span><br></pre></td></tr></table></figure><p>urdf文件夹主要用来保存机器人模型的描述文件；meshes文件用来保存模型文件；launch文件夹保存驱动文件，我们会需要创建启动文件启动RViz来展示机器人模型。</p><h4 id="2-3-创建URDF模型">2.3 创建URDF模型</h4><p>以一个平移与倾斜机构为例，如下图所示</p><p><strong>1. 创建urdf文件</strong><br>进入刚才创建的urdf文件夹下，新建一个<code>pan_tilt.urdf</code>文件，并输入以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;pan_tilt&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义了base_link --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;visual&gt;标签描述了在仿真环境的外观，包括几何外形&lt;geometry&gt;（圆柱形cylinder）等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.2&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 0 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义了关节pan_joint，以及其关节类型：旋转副（有限制） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 旋转副连接的两个刚体分别为base_link和pan_link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;pan_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;pan_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.1&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;300&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-3.14&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;3.14&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span>=<span class="string">&quot;50&quot;</span> <span class="attr">friction</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;pan_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.4&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.09&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 1 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;tilt_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;pan_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;tilt_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;300&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-4.64&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;-1.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span>=<span class="string">&quot;50&quot;</span> <span class="attr">friction</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;tilt_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.4&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 1.5 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 检查urdf文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf pan_tilt.urdf</span><br></pre></td></tr></table></figure><p>如果urdf文件没有问题，会输出如下信息</p><p><img src="https://img.mahaofei.com/img/202112231956685-urdf-xacro-1.png" alt=""></p><p><strong>3. 创建launch文件</strong><br>进入之前创建的launch文件夹，创建<code>view_demo.launch</code>文件，并添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description_pkg)/urdf/pan_tilt.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_description_pkg)/urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. 启动节点查看仿真模型</strong><br>首先编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch robot_description_pkg view_demo.launch </span><br></pre></td></tr></table></figure><p>打开后会发现出现Unknown frame map的提示，这时候只需要将<code>Fixed Frame</code>改为<code>base_link</code>即可。</p><p><img src="https://img.mahaofei.com/img/202112231957653-urdf-xacro-2.png" alt=""></p><p>然后在左下角点击<code>Add</code>，添加<code>RobotModel</code>就可以正常看到机器人模型了。</p><p><img src="https://img.mahaofei.com/img/202112231957351-urdf-xacro-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231957826-urdf-xacro-4.png" alt=""></p><h3 id="三、Xacro模型">三、Xacro模型</h3><p>URDF模型虽然简单，但存在一些问题，例如代码重用性不好（重复代码只能复制），模块化不好（不能引用其它URDF文件）等等。<br>而xacro是urdf的Plus版本，它通过创建macro来描述模型，macro可以被复用，也可以被其他文件引用，让代码更可读。</p><h4 id="3-1-Xacro的使用示例">3.1 Xacro的使用示例</h4><p>将经常改变的部分参数值统一定义在文件开头，这样改变参数值更简单，而不用在代码中一个一个参数找，然后代替它们。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;pan_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;pan_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231957996-urdf-xacro-5.png" alt=""></p><h4 id="3-2-数学表达式">3.2 数学表达式</h4><p>在xacro标签的<code>$&#123;&#125;</code>中可以使用数学表达式进行基本的运算，支持的数学运算包括+，-，×，÷。求幂和模运算不支持。</p><h4 id="3-3-xacro到URDF的转换">3.3 xacro到URDF的转换</h4><p>如果编写完成了xacro的模型文件，可以使用下面的命令完成到urdf的转换。其中<code>&gt;</code>两侧分别是转换前后的xacro和urdf文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro.py filename.xacro &gt; newfilename.urdf</span><br></pre></td></tr></table></figure><h3 id="四、实例：7自由度机械臂">四、实例：7自由度机械臂</h3><h4 id="4-1-7自由度机械臂介绍">4.1 7自由度机械臂介绍</h4><p>我们知道确定机械臂末端的位姿需要6个自由度（3坐标+3方向），因此七自由度机械臂属于冗驱机构，即我们可以通过针对同一个位姿得到不同的关节配置，这样可以有效提高机器人柔性和功能性，并且更容易避免碰撞。</p><h4 id="4-2-创建前的准备工作">4.2 创建前的准备工作</h4><p><strong>① 机械臂清单明细</strong></p><table><thead><tr><th>项目</th><th>参数</th></tr></thead><tbody><tr><td>自由度</td><td>7</td></tr><tr><td>机械臂长度</td><td>50cm</td></tr><tr><td>臂展</td><td>35cm</td></tr><tr><td>刚体数</td><td>12</td></tr><tr><td>关节数</td><td>11</td></tr></tbody></table><p><strong>② 关节列表</strong></p><table><thead><tr><th>序号</th><th>关节名称</th><th>关节类型</th><th>角度限制</th></tr></thead><tbody><tr><td>1</td><td>bottom_joint</td><td>固定（Fixed）</td><td>–</td></tr><tr><td>2</td><td>shoulder_pan_joint</td><td>旋转（Revolute）</td><td>-150~114</td></tr><tr><td>3</td><td>shoulder_pitch_joint</td><td>旋转（Revolute）</td><td>-67~109</td></tr><tr><td>4</td><td>elbow_roll_joint</td><td>旋转（Revolute）</td><td>-150~41</td></tr><tr><td>5</td><td>elbow_pitch_joint</td><td>旋转（Revolute）</td><td>-92~110</td></tr><tr><td>6</td><td>wrist_roll_joint</td><td>旋转（Revolute）</td><td>-150~150</td></tr><tr><td>7</td><td>wrist_pitch_joint</td><td>旋转（Revolute）</td><td>92-113</td></tr><tr><td>8</td><td>gripper_roll_joint</td><td>旋转（Revolute）</td><td>-150~150</td></tr><tr><td>9</td><td>finger_joint1</td><td>移动（Prismatic）</td><td>0~3cm</td></tr><tr><td>10</td><td>finger_joint2</td><td>移动（Prismatic）</td><td>0~3cm</td></tr></tbody></table><h4 id="4-3-模型代码详解">4.3 模型代码详解</h4><p>代码中主要由几部分组成<br><strong>① 常量定义</strong><br>定义常用的数学常量以及各机械臂刚体的参数值，例如下面的代码片段就分别为数学常量的定义以及肩部刚体的参数值定义。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constants --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;M_SCALE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001 0.001 0.001&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;M_PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.14159&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Shoulder pan link properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shoulder_pan_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shoulder_pan_len&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>② 惯性矩阵定义</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;mass&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mass&#125;&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 传动件配置</strong><br>通过使用<code>&lt;transmission&gt;</code>标签定义连接执行器的关节，它可以定义电机的类型、参数，硬件接口的类型以及ROS控制器的接口等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;transmission_block&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;motor1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④ 引用其他xacro文件</strong><br>通过使用<code>&lt;xacro:include&gt;</code>标签，可以引用其他xacro文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find mastering_ros_robot_description_pkg)/urdf/sensors/xtion_pro_live.urdf.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑤ 插入简单模型</strong><br>与urdf一样，使用mesh标签插入一些基础的形状如圆柱体、长方体等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;bottom_link&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot; 0 0 -0.04&quot;</span>  <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 0.02&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Brown&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot; 0 0 -0.04&quot;</span>  <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 0.02&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-4-在rviz中仿真">4.4 在rviz中仿真</h4><p><strong>① 将xacro文件转换为urdf模型</strong><br>首先进入到存放xacro文件的目录下，运行如下代码从<code>.xacro</code>文件生成<code>.urdf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro seven_dof_arm.xacro &gt; seven_dof_arm.xacro.urdf</span><br></pre></td></tr></table></figure><p>然后可以检查urdf文件是否正确生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf seven_dof_arm.xacro.urdf</span><br></pre></td></tr></table></figure><p><strong>② 编辑launch文件</strong><br>进入launch文件夹，编辑launch文件如下，基本与上一小节一样，这里不再过多赘述</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description_pkg)/urdf/seven_dof_arm.xacro.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_description_pkg)/urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 编译运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">roslaunch robot_description_pkg view_arm.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231958358-urdf-xacro-6.png" alt=""></p><blockquote><p>功能包文件<br>链接：<a href="https://huffie.lanzouw.com/ieTZMv5t3fi">https://huffie.lanzouw.com/ieTZMv5t3fi</a></p></blockquote>]]></content>
    
    
    <summary type="html">为什么要创建机器人的三维模型，原因在于机器人机器人仿真工具可以帮助我们体现发现设计中的一些关键错误。而模型仿真的含义，在于我们创建的是机器人模型，因此不一定和实际机器人长得一模一样。但因为是仿真，所以模型必须具备所有的真实硬件特点。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>相机模型与去畸变方法详解</title>
    <link href="https://www.mahaofei.com/post/6e0a2557.html"/>
    <id>https://www.mahaofei.com/post/6e0a2557.html</id>
    <published>2021-10-09T09:32:15.000Z</published>
    <updated>2022-04-09T13:29:21.246Z</updated>
    
    <content type="html"><![CDATA[<p>相机我们都熟悉，可以将三维空间的点集映射到二维平面中。而这映射过程，就需要我们使用几何模型去描述。</p><p>最简单最基础的模型就是针孔相机模型，它描述了相机的基本投影与成像的惯性。</p><p>但是我们常用的相机都是存在透镜的，因为透镜的缘故，光线投影成像时就会产生畸变，这时就需要畸变模型进行更准确的描述了。</p><p>此外，在许多场合还会需要利用摄像头实现测距功能，因此这里也介绍了双目相机模型和RGB-D深度相机模型。</p><h3 id="一、针孔相机模型">一、针孔相机模型</h3><p>实际物体的各点转换为图像上像素的过程可概括为<br>① 首先获得世界坐标系下实际点的坐标<br>② 将世界坐标系的坐标转换成相机坐标系下的坐标<br>③ 相机坐标系的坐标映射为图像上的某一个像素点</p><h4 id="1-1-成像原理">1.1 成像原理</h4><p>我们中学都做过小孔成像的物理实验，现实的空间点经过小孔投影后，在平面上会成一个倒立的像。而且实际点到光轴的距离X，与图像上对应点到中心的距离X’，其比值与实际点到小孔的垂直距离以及焦距有关。</p><p><img src="https://img.mahaofei.com/img/202112231944496-camera-models-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231944774-camera-models-2.png" alt=""></p><p>这样，我们可以在成像平面上可以得到真实物体的等比例放缩后的图像。不过相机中，我们最后获得的是一个个像素，因此还需要对所成的像进行采样和量化。</p><h4 id="1-2-实际坐标与像素坐标的关系">1.2 实际坐标与像素坐标的关系</h4><p>我们设在成像平面上固定一个像素坐标系ouv，<strong>原点o在图像左上角，u轴与x轴同向平行，v轴与y轴反向平行</strong>。这样像素坐标系和物理成像之间差了一个缩放和原点的平移。设像素坐标在u轴缩放了α倍，在v轴缩放了β倍，则关系式如下：</p><p><img src="https://img.mahaofei.com/img/202112231945301-camera-models-3.png" alt=""></p><p>将两个等式中的X’和Y’用上面的关系式替换为X与Y的表达式</p><p><img src="https://img.mahaofei.com/img/202112231945240-camera-models-4.png" alt=""></p><p>改写成矩阵形式更加简洁形象</p><p><img src="https://img.mahaofei.com/img/202112231946066-camera-models-5.png" alt=""></p><p>这样，就得到了<strong>实际点P与像素点(u,v)之间的对应关系</strong>，并且由中间量组成的矩阵称为相机的内参数矩阵K。这个内参数矩阵通常相机厂商会提供，如果没有则需要自己进行相机标定。</p><h4 id="1-3-如何获得实际坐标">1.3 如何获得实际坐标</h4><p>我们通常说的某个点的空间位置是以世界坐标系为基础描述的，但是在相机模型中，我们需要实际点相对于相机的位置关系。而且由于相机是在运动的，因此利用变化矩阵的相关知识可以得到下面的式子</p><p><img src="https://img.mahaofei.com/img/202112231946623-camera-models-6.png" alt=""></p><p>其中相机的R，t就是相机的外参，外参会随相机运动而变化，内参则不会发生改变。</p><h3 id="二、畸变相机模型">二、畸变相机模型</h3><h4 id="2-1-两种常见畸变的介绍">2.1 两种常见畸变的介绍</h4><p>实际的相机为了获得更好的成像效果，通常会在相机前方加入透镜，透镜的加入会使得光线传播收到影响，即真实世界的直线在图像中变成了曲线，这种叫径向畸变。径向畸变又分为桶形畸变和枕形畸变。</p><p><img src="https://img.mahaofei.com/img/202112231948890-camera-models-7.png" alt=""></p><p>同时由于安装误差，透镜和成像平面不会完全平行，也会使投影位置发生变化，这种叫切向畸变。</p><h4 id="2-2-去畸变方法">2.2 去畸变方法</h4><p><strong>① 对于径向畸变</strong><br>径向畸变可以看做坐标点沿长度方向发生了变化，即坐标点距离原点距离变了。通常使用的模型如下，假设畸变成多项式关系，使用三个参数k1, k2, k3表达畸变。</p><p><img src="https://img.mahaofei.com/img/202112231948919-camera-models-8.png" alt=""></p><p>其中 [$x_{distorted}$, $y_{distorted}$] 是畸变后的点的归一化坐标。r表示点p与坐标系原点的距离。<br><strong>② 对于切向畸变</strong><br>切向畸变可以看做坐标点沿切线方向发生了变化，即水平夹角变了。通常使用p1, p2两个参数表达切向畸变，具体公式如下。</p><p><img src="https://img.mahaofei.com/img/202112231949498-camera-models-9.png" alt=""></p><p><strong>③ 综合方法</strong><br>结合上面两种径向畸变和切向畸变的公式，可以得到综合的去畸变公式，也就是说我们通过五个畸变系数就可以确定点在像素平面的正确位置。</p><p><img src="https://img.mahaofei.com/img/202112231949756-camera-models-10.png" alt=""></p><h4 id="2-3-示例程序">2.3 示例程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">string image_file = <span class="string">&quot;./distorted.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//定义畸变系数</span></span><br><span class="line">        <span class="type">double</span> k1 = <span class="number">-0.28340811</span>, k2 = <span class="number">0.07395907</span>, p1 = <span class="number">0.00019359</span>, p2 = <span class="number">1.76187114e-05</span>;</span><br><span class="line">        <span class="comment">//相机内参</span></span><br><span class="line">        <span class="type">double</span> fx = <span class="number">458.654</span>, fy = <span class="number">457.296</span>, cx = <span class="number">367.215</span>, cy = <span class="number">248.375</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入图像，灰度图</span></span><br><span class="line">        Mat image = <span class="built_in">imread</span>(image_file, <span class="number">0</span>);</span><br><span class="line">        Mat image_undistort = <span class="built_in">Mat</span>(image.rows, image.cols, CV_8UC1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个像素，计算后去畸变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; image.rows; v++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; image.cols; u++)&#123;</span><br><span class="line">                <span class="comment">//根据公式计算去畸变图像上点(u, v)对应在畸变图像的坐标(u_distorted, v(distorted))，建立对应关系</span></span><br><span class="line">                        <span class="type">double</span> x = (u - cx) / fx;</span><br><span class="line">                        <span class="type">double</span> y = (v - cy) / fx;</span><br><span class="line">                        <span class="type">double</span> r = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">                        <span class="type">double</span> x_distorted = x*(<span class="number">1</span>+k1*r*r+k2*r*r*r*r)+<span class="number">2</span>*p1*x*y+p2*(r*r+<span class="number">2</span>*x*x);</span><br><span class="line">                        <span class="type">double</span> y_distorted = y*(<span class="number">1</span>+k1*r*r+k2*r*r*r*r)+<span class="number">2</span>*p2*x*y+p1*(r*r+<span class="number">2</span>*x*x);</span><br><span class="line">                        <span class="type">double</span> u_distorted = fx * x_distorted + cx;</span><br><span class="line">                        <span class="type">double</span> v_distorted = fy * y_distorted + cy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将畸变图像上点的坐标，赋值到去畸变图像中（最近邻插值）</span></span><br><span class="line">                        <span class="keyword">if</span> (u_distorted &gt;= <span class="number">0</span> &amp;&amp; v_distorted &gt;=<span class="number">0</span> &amp;&amp; u_distorted &lt; image.rows &amp;&amp; v_distorted &lt; image.cols)&#123;</span><br><span class="line">                                image_undistort.<span class="built_in">at</span>&lt;uchar&gt;(v, u) = image.<span class="built_in">at</span>&lt;uchar&gt;((<span class="type">int</span>)v_distorted, (<span class="type">int</span>)u_distorted);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                image_undistort.<span class="built_in">at</span>&lt;uchar&gt;(v, u) = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Distorted Image&quot;</span>, image);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Undistorted Image&quot;</span>, image_undistort);</span><br><span class="line">        <span class="built_in">waitKey</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231950737-camera-models-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231950996-camera-models-12.png" alt=""></p>]]></content>
    
    
    <summary type="html">首先介绍了针孔相机的成像原理以及实际坐标和像素坐标的转换方法。然后根据实际相机存在的一些问题，引入了畸变模型，并给出了去畸变的公式方法以及详细示例程序。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="SLAM" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/SLAM/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="slam" scheme="https://www.mahaofei.com/tags/slam/"/>
    
  </entry>
  
</feed>
