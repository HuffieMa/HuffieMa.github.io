<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALFA博客</title>
  
  <subtitle>无限进步！！！</subtitle>
  <link href="https://www.mahaofei.com/atom.xml" rel="self"/>
  
  <link href="https://www.mahaofei.com/"/>
  <updated>2022-07-18T13:38:46.000Z</updated>
  <id>https://www.mahaofei.com/</id>
  
  <author>
    <name>Huffie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PDF去水印方法总结</title>
    <link href="https://www.mahaofei.com/post/cc430c5f.html"/>
    <id>https://www.mahaofei.com/post/cc430c5f.html</id>
    <published>2022-07-18T13:38:46.000Z</published>
    <updated>2022-07-18T13:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1>自动去水印</h1><p>使用福昕pdf编辑器，打开【页面管理 - 水印 - 全部移除】，大部分后期添加的水印就可以被自动去除了。</p><p><img src="https://img.mahaofei.com/img/20220718214014.png" alt=""></p><h1>去除背景形式的水印</h1><p>使用福昕pdf编辑器，打开【页面管理 - 背景 - 全部移除】，部分水印以背景的方式添加，也可以通过这种方法去除。</p><p><img src="https://img.mahaofei.com/img/20220718214108.png" alt=""></p><h1>去除文字格式水印</h1><p>使用福昕pdf编辑器，打开【编辑 - 编辑文本】，这时整个pdf文件的文字都已经可以编辑了。</p><p><img src="https://img.mahaofei.com/img/20220718215020.png" alt=""></p><p>选中复制需要删除的文字，在右上角打开【搜索 &amp; 替换】窗口，将要删除的文字复制进去。</p><p><img src="https://img.mahaofei.com/img/20220718215146.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220718215309.png" alt=""></p><p>查找内容为【要删除的文字】，替换内容为【空格】，选择全部替换即可。</p><p><img src="https://img.mahaofei.com/img/20220718215409.png" alt=""></p><h1>覆盖水印</h1><p>原理是使用白色方框覆盖水印图片，达到去除水印的目的。</p><p><img src="https://img.mahaofei.com/img/20220718214324.png" alt=""></p><p>在需要覆盖的区域画框：</p><p><img src="https://img.mahaofei.com/img/20220718214403.png" alt=""></p><p>点击浏览，选择一张纯白颜色图像文件，然后点击高级，将比例设置为不按比例，随后确定。</p><p><img src="https://img.mahaofei.com/img/20220718214503.png" alt=""></p><p>可以看到水印已经被白色方框覆盖了（这个边框只有在编辑时才有，正常查看以及打印时是没有的）</p><p><img src="https://img.mahaofei.com/img/20220718214710.png" alt=""></p><p>右键白色方框，选择放置到多个页面</p><p><img src="https://img.mahaofei.com/img/20220718214745.png" alt=""></p><p>我这里所有页面的同一位置都有水印，大家可以根据自己需要设置，点击确定后可以看到所有页面的同一位置都被白色方框覆盖了。</p><p><img src="https://img.mahaofei.com/img/20220718214845.png" alt=""></p><p>如果还有其它水印可以如法炮制，流程一样。</p>]]></content>
    
    
    <summary type="html">使用福昕PDF编辑器进行去水印操作，包括常规水印、背景水印、文字水印，以及其它水印的去除方法。</summary>
    
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="软件技巧" scheme="https://www.mahaofei.com/categories/%E6%8A%80%E5%B7%A7/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="技巧" scheme="https://www.mahaofei.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>记录Ubuntu安装后的系统配置、常用软件安装过程</title>
    <link href="https://www.mahaofei.com/post/cdee659e.html"/>
    <id>https://www.mahaofei.com/post/cdee659e.html</id>
    <published>2022-07-06T10:21:11.000Z</published>
    <updated>2022-07-06T10:21:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、系统配置</h1><h2 id="1-1-系统更新">1.1 系统更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h2 id="1-2-安装openssh-server">1.2 安装openssh-server</h2><p>Ubuntu远程连接的基础功能包。<br>如果不安装此包直接使用Putty连接，会报错Network error Connection refused。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><h2 id="1-3-安装net-tools">1.3 安装net-tools</h2><p>安装net-tools后即可使用<code>ifconfig</code>查看本机IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure><h2 id="1-4-安装vim">1.4 安装vim</h2><p>常用的文件编辑工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><h2 id="1-5-启动自动登录">1.5 启动自动登录</h2><p>由于我的ubuntu机器通常只接电源不接显示器，而使用远程桌面进行控制，这样不仅方便鼠标键盘控制，而且便于共享剪切板，互传文件等。</p><p>打开设置-&gt;用户Users-&gt;右上角解锁Unlock-&gt;输入密码-&gt;点击自动登录</p><h2 id="1-6-关闭屏幕自动锁定">1.6 关闭屏幕自动锁定</h2><p>打开设置-&gt;隐私Privacy-&gt;屏幕Screen-&gt;设置黑屏延迟Blank ScreenDelay和自动屏幕锁定Automatic Screen Loock</p><p><img src="https://img.mahaofei.com/img/20220706201442.png" alt=""></p><h2 id="1-7-打开远程桌面">1.7 打开远程桌面</h2><p>打开设置-&gt;共享Sharing-&gt;远程桌面Remote Desktop-&gt;打开远程桌面和远程控制开关todesk</p><p><img src="https://img.mahaofei.com/img/How-to-Enable-Remote-19.png" alt=""></p><p>通过windows的远程桌面连接即可实现局域网内的远程桌面。</p><h1>二、软件安装</h1><h2 id="2-1-安装clash">2.1 安装clash</h2><p>进入<a href="https://github.com/Dreamacro/clash/releases">clash的Github页面</a>，下载对应的版本。</p><ul><li>正常电脑使用：<a href="https://github.com/Dreamacro/clash/releases/download/v1.11.0/clash-linux-amd64-v1.11.0.gz">clash-linux-amd64-v1.11.0.gz</a></li><li>树莓派则使用：<a href="https://github.com/Dreamacro/clash/releases/download/v1.11.0/clash-linux-armv8-v1.11.0.gz">clash-linux-armv8-v1.11.0.gz</a></li></ul><ol><li>解压文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">gunzip clash-linux-armv8-v1.11.0.gz</span><br><span class="line"><span class="built_in">mv</span> clash-linux-armv8-v1.11.0 clash</span><br><span class="line"><span class="built_in">mkdir</span> Clash</span><br><span class="line"><span class="built_in">mv</span> clash ./Clash</span><br><span class="line"><span class="built_in">cd</span> Clash</span><br></pre></td></tr></table></figure><ol start="2"><li>下载config.yaml和Country.mmdb</li></ol><p>下载clash的配置文件，从代理商那里复制订阅链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O config.yaml https://******.***/******/token=************</span><br></pre></td></tr></table></figure><p>下载Country.mmdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb</span><br></pre></td></tr></table></figure><ol start="3"><li>为clash添加可执行权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x clash </span><br></pre></td></tr></table></figure><ol start="4"><li>启动clash</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clash -d .</span><br></pre></td></tr></table></figure><p>可以看到出现一串INFO[0000]信息，说明启动成功。</p><ol start="5"><li>打开设置-&gt;网络-&gt;网络代理，配置 HTTP、HTTPS、Socket 代理</li></ol><p><img src="https://img.mahaofei.com/img/20220706190515.png" alt=""></p><ol start="6"><li>打开<a href="http://clash.razord.top/">http://clash.razord.top/</a>进行节点切换</li></ol><p>Host: <code>127.0.0.1</code>，端口: <code>9090</code></p><ol start="7"><li>配置开机自动启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">touch</span> /etc/systemd/system/clash.service</span><br><span class="line">sudo vi /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure><p>文件内填入以下文本（修改其中的ExecStart项）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=clash daemon  </span><br><span class="line">[Service] </span><br><span class="line">Type=simple </span><br><span class="line">User=root </span><br><span class="line">ExecStart=/home/username/Downloads/Clash/clash -d /home/username/Downloads/Clash/ </span><br><span class="line">Restart=on-failure  </span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> clash</span><br><span class="line">sudo systemctl start clash</span><br><span class="line">sudo systemctl status clash</span><br></pre></td></tr></table></figure><h2 id="2-4-安装VNC">2.4 安装VNC</h2><p>教程：<a href="https://www.mahaofei.com/post/c1d87973.html">https://www.mahaofei.com/post/c1d87973.html</a></p><h2 id="2-2-安装Todesk">2.2 安装Todesk</h2><p>ToDesk官网链接：<a href="http://www.hellodesk.cn/linux.html">http://www.hellodesk.cn/linux.html</a></p><ul><li>常规主机按需下载：<a href="https://dl.todesk.com/linux/todesk_4.1.0_amd64.deb">https://dl.todesk.com/linux/todesk_4.1.0_amd64.deb</a></li><li>树莓派Ubuntu下载Arm64版本：<a href="https://dl.todesk.com/linux/todesk_4.1.0_aarch64.deb">https://dl.todesk.com/linux/todesk_4.1.0_aarch64.deb</a></li></ul><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ./todesk_4.1.0_aarch64.deb</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todesk</span><br></pre></td></tr></table></figure><h2 id="2-3-安装搜狗输入法">2.3 安装搜狗输入法</h2><p>官方链接：<a href="https://shurufa.sogou.com/linux?r=pinyin">https://shurufa.sogou.com/linux?r=pinyin</a></p><p>官方教程：<a href="https://shurufa.sogou.com/linux/guide">https://shurufa.sogou.com/linux/guide</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、系统配置&lt;/h1&gt;
&lt;h2 id=&quot;1-1-系统更新&quot;&gt;1.1 系统更新&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Linux" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Linux/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Ubuntu" scheme="https://www.mahaofei.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>COLMAP+OpenMVS实现物体三维重建mesh模型</title>
    <link href="https://www.mahaofei.com/post/227160b0.html"/>
    <id>https://www.mahaofei.com/post/227160b0.html</id>
    <published>2022-07-05T13:21:12.000Z</published>
    <updated>2022-07-05T13:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、环境准备</h1><p><strong>(1) COLMAP</strong></p><p>进入<a href="https://demuc.de/colmap/">COLMAP官网</a>，打开<a href="https://demuc.de/colmap/">下载页面</a>，下载<a href="https://github.com/colmap/colmap/releases">COLMAP程序</a>。</p><p><strong>(2) OpenMVS</strong></p><p>OpenMVS可以自己从源码下载进行编译。如果觉得编译openmvs可能要费点时间，那也可以直接下载编译好的可执行程序。</p><p>Github源码：<a href="https://github.com/cdcseacave/openMVS">https://github.com/cdcseacave/openMVS</a><br>可执行程序：<a href="https://github.com/cdcseacave/openMVS_sample">https://github.com/cdcseacave/openMVS_sample</a></p><h1>二、COLMAP重建得到稠密点云</h1><ol><li><strong>新建一个文件夹</strong>，在其中<strong>新建images文件夹</strong>，以及一个<strong>Database.db的空文件</strong>，注意文件路径不要出现中文。<strong>images文件夹中放入需要重建的图片</strong>，图片越多重建时间越长，图片过少可能会重建失败，我这里以96张图片为例，生成稠密点云05。</li></ol><p>本文使用DTU数据集进行测试。</p><p>自建数据集要求：</p><ul><li>尽量使用单反相机或专业数码相机进行数据采集，如果要用手机进行采集，请使用单摄像头的手机进行数据采集。</li><li>尽量选择纹理丰富的外界环境进行数据采集，避免玻璃围墙、瓷砖和打蜡地板等强反光材料环境</li><li>尽量选择光照明亮，且光照条件变化不剧烈的环境，最好选择室内环境。如室内客厅，开启客厅大灯进行灯光补偿。</li><li>尽量围绕重建物体或环境采集较多的影像，且在采集过程中控制快门速度，避免模糊。</li></ul><p><img src="https://img.mahaofei.com/img/20220627202501.png" alt=""></p><ol start="2"><li>打开colmap程序(COLMAP.bat)，<strong>点击File-New Project</strong>，在Database栏点击open，选择刚才新建的Database.db文件，在Images栏选择刚才新建的存放图片的images文件夹，点击save保存。</li></ol><p><img src="https://img.mahaofei.com/img/20220627203432.png" alt=""></p><ol start="3"><li>点击<strong>Processing-Feature Extraction</strong>，默认参数即可，点击Extract，等待程序运行完毕可看到右侧有log信息输出。</li></ol><p><img src="https://img.mahaofei.com/img/20220627203638.png" alt=""></p><ol start="4"><li>点击<strong>Processing-Feature matching</strong>，默认参数即可，点击Run，等待程序运行完毕可看到右侧有log信息输出。</li></ol><p><img src="https://img.mahaofei.com/img/20220627203803.png" alt=""></p><ol start="5"><li>点击<strong>Reconstruncion-Start reconstruction</strong>，等待执行完毕，即可得到重建的结果。</li></ol><p><img src="https://img.mahaofei.com/img/20220627210221.png" alt=""></p><ol start="6"><li>在之前images的同级目录下，<strong>新建一个文件夹dense</strong>。点击<strong>Reconstruncion-Dense reconstrction</strong>，点击select，选择刚才新建的dense文件夹用来保存稠密点云结果。依次点击<strong>Undistorion、Stereo、Fusion</strong>，执行完毕。</li></ol><p><img src="https://img.mahaofei.com/img/20220702085342.png" alt=""></p><ol start="7"><li><p>在程序中点击<strong>File-export model as txt</strong>，选择dense文件夹下的sparse文件夹（由于openmvs支支持txt格式的，所以需要将重建的文件转成txt文件）</p></li><li><p>检查camera.txt内的相机模型是否为Pinhole，如果不是则直接改成pinhole，不管之前选的是不是这里都可以直接改就行。</p></li></ol><h1>三、OpenMVS重建得到mesh模型</h1><p>以编译好的openmvs_sample为例，我们要把colmap生成的稠密点云以及图片路径信息等转换成openmvs的.mvs文件。</p><ol><li>打开命令提示窗口CMD，进入openmvs_sample下的bin目录，执行命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interfaceCOLMAP.exe -i E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense -o E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\scene.mvs --image-folder E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\images</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220702185742.png" alt=""></p><p>可以看到dense文件夹下生成了scene.mvs文件（-o为输出文件目录，默认是在当前文件夹下，也可以指定其它路径）。</p><ol start="2"><li>执行命令重建</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReconstructMesh.exe -i E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\scene.mvs -o E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\mesh.mvs</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220702190554.png" alt=""></p><ol start="3"><li>执行命令添加纹理（这一步比较占用计算机资源，本人电脑较老，运行时蓝屏重启了，大家酌情尝试一下）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextureMesh.exe -i E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\mesh.mvs</span><br></pre></td></tr></table></figure><p>可以看到文件夹内新生成了四个文件，可以使用meshlab打开其中的.ply文件（三维mesh模型），下图为Solidworks打开的样子（未添加纹理）。</p><p><img src="https://img.mahaofei.com/img/mesh%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B.png" alt=""></p>]]></content>
    
    
    <summary type="html">COLMAP 是一种通用的运动结构(SfM)和多视图立体(MVS)工具，具有图形和命令行界面。OpenMVS是目前的三维重建的框架中，复原效果较好的，而且提供自动化的脚本。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>Python复习笔记5——常用模块</title>
    <link href="https://www.mahaofei.com/post/eaf704aa.html"/>
    <id>https://www.mahaofei.com/post/eaf704aa.html</id>
    <published>2022-07-02T02:45:23.000Z</published>
    <updated>2022-07-02T02:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、内建模块</h1><h2 id="1-1-datetime日期时间">1.1 datetime日期时间</h2><p><strong>（1）导入模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure><p>仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code></p><p><strong>（2）获取日期时间</strong></p><p>获取当前日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now() <span class="comment"># 获取当前datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(now)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">07.198690</span></span><br></pre></td></tr></table></figure><p>获取指定日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dt)</span><br><span class="line"><span class="number">2015</span>-04-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p><strong>（3）日期时间加减</strong></p><p>加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(hours=<span class="number">10</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now - timedelta(days=<span class="number">1</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br></pre></td></tr></table></figure><p><strong>（4）时区转换</strong></p><p>通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(utc_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> 09:05:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(bj_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">17</span>:05:<span class="number">12.377316</span>+08:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为东京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tokyo_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">18</span>:05:<span class="number">12.377316</span>+09:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p><p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p><p><strong>（5）datetime与timestamp的转换</strong></p><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>。当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>把一个<code>datetime</code>类型转换为timestamp只需要简单调用<code>timestamp()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></span><br><span class="line"><span class="number">1429417200.0</span></span><br></pre></td></tr></table></figure><p>要把timestamp转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(datetime.fromtimestamp(t))</span><br><span class="line"><span class="number">2015</span>-04-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p><strong>（6）datetime与str的转换</strong></p><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间。</p><p>转换方法是通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">&#x27;2015-6-1 18:19:59&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(cday)</span><br><span class="line"><span class="number">2015</span>-06-01 <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure><p>详细的指使符参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">Python官方文档</a></p><p>要把日期格式化为字符串显示给用户，需要转换成str，转换方法是通过<code>strftime()</code>实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%a, %b %d %H:%M&#x27;</span>))</span><br><span class="line">Mon, May 05 <span class="number">16</span>:<span class="number">28</span></span><br></pre></td></tr></table></figure><h2 id="1-2-collections集合">1.2 collections集合</h2><p><strong>（1）namedtuple</strong></p><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>（2）deque</strong></p><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈（代替list存在）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;x&#x27;</span>])</span><br></pre></td></tr></table></figure><p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p><p><strong>（3）OrderedDict</strong></p><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></span><br><span class="line">OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure><p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p><h2 id="1-3-itertools">1.3 itertools</h2><p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p><p><strong>（1）无限迭代器</strong></p><p><code>count()</code>会创建一个无限的迭代器，根本停不下来，只能按<code>Ctrl+C</code>退出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>natuals = itertools.count(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> natuals:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>cycle()</code>会把传入的一个序列无限重复下去，同样停不下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cs = itertools.cycle(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment"># 注意字符串也是序列的一种</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> cs:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="string">&#x27;C&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ns = itertools.repeat(&#x27;A&#x27;, 3)</span><br><span class="line">&gt;&gt;&gt; for n in ns:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p><strong>（2）有限迭代</strong></p><p><code>takewhile()</code>函数根据条件判断来截取出一个有限的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>natuals = itertools.count(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ns = itertools.takewhile(<span class="keyword">lambda</span> x: x &lt;= <span class="number">10</span>, natuals)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(ns)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><code>chain()</code>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.chain(<span class="string">&#x27;ABC&#x27;</span>, <span class="string">&#x27;XYZ&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 迭代效果：&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27; &#x27;X&#x27; &#x27;Y&#x27; &#x27;Z&#x27;</span></span><br></pre></td></tr></table></figure><p><code>groupby()</code>把迭代器中相邻的重复元素挑出来放在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">&#x27;AAABBBCCAAA&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(key, <span class="built_in">list</span>(group))</span><br><span class="line">...</span><br><span class="line">A [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">B [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">C [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">A [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure><h1>二、第三方模块</h1><h2 id="2-1-Pillow">2.1 Pillow</h2><p>Pillow就是PIL的更新版本。由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，即Pillow。</p><blockquote><p>Pillow官方文档：<a href="https://pillow.readthedocs.org/">https://pillow.readthedocs.org/</a></p></blockquote><p><strong>（1）Pillow安装</strong></p><p>若使用Anaconda，则Pillow已默认安装。若自己搭建的python环境，使用以下命令安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow</span><br></pre></td></tr></table></figure><p><strong>（2）图像操作</strong></p><p>导入Pillow</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><p>打开图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个jpg图像文件，注意是当前路径:</span></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>保存图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把缩放后的图像用jpeg格式保存:</span></span><br><span class="line">im.save(<span class="string">&#x27;thumbnail.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>获得图像尺寸</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得图像尺寸:</span></span><br><span class="line">w, h = im.size</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Original image size: %sx%s&#x27;</span> % (w, h))</span><br></pre></td></tr></table></figure><p>缩放图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缩放到50%:</span></span><br><span class="line">im.thumbnail((w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>模糊图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用模糊滤镜:</span></span><br><span class="line">im2 = im.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br></pre></td></tr></table></figure><p><strong>（3）绘图</strong></p><p>创建图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (width, height), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure><p>创建font对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font = ImageFont.truetype(<span class="string">&#x27;Arial.ttf&#x27;</span>, <span class="number">36</span>)</span><br></pre></td></tr></table></figure><p>创建draw对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw = ImageDraw.Draw(image)</span><br></pre></td></tr></table></figure><p>填充像素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw.point((x, y))</span><br></pre></td></tr></table></figure><p>输出文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw.text((x, y), <span class="string">&quot;Text&quot;</span>, font=font)</span><br></pre></td></tr></table></figure><p>示例：生成验证码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机字母:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rndChar</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(random.randint(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机颜色1:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rndColor</span>():</span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">64</span>, <span class="number">255</span>), random.randint(<span class="number">64</span>, <span class="number">255</span>), random.randint(<span class="number">64</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机颜色2:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rndColor2</span>():</span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 240 x 60:</span></span><br><span class="line">width = <span class="number">60</span> * <span class="number">4</span></span><br><span class="line">height = <span class="number">60</span></span><br><span class="line">image = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (width, height), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line"><span class="comment"># 创建Font对象:</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">&#x27;Arial.ttf&#x27;</span>, <span class="number">36</span>)</span><br><span class="line"><span class="comment"># 创建Draw对象:</span></span><br><span class="line">draw = ImageDraw.Draw(image)</span><br><span class="line"><span class="comment"># 填充每个像素:</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        draw.point((x, y), fill=rndColor())</span><br><span class="line"><span class="comment"># 输出文字:</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    draw.text((<span class="number">60</span> * t + <span class="number">10</span>, <span class="number">10</span>), rndChar(), font=font, fill=rndColor2())</span><br><span class="line"><span class="comment"># 模糊:</span></span><br><span class="line">image = image.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">image.save(<span class="string">&#x27;code.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://www.liaoxuefeng.com/files/attachments/966760380198752" alt=""></p>]]></content>
    
    
    <summary type="html">Python具有非常丰富有用的内建模块和第三方模块，可以快速方便的实现很多常用功能。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python复习笔记4——文件和目录操作</title>
    <link href="https://www.mahaofei.com/post/d8e454a.html"/>
    <id>https://www.mahaofei.com/post/d8e454a.html</id>
    <published>2022-07-01T14:15:09.000Z</published>
    <updated>2022-07-01T14:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、文件读写</h1><h2 id="1-1-读文件">1.1 读文件</h2><p><strong>（1）打开文件</strong></p><p>使用Python内置的<code>open()</code>函数，传入文件名和标示符，打开一个文件对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p>标示符<code>'r'</code>表示读，这样，我们就成功地打开了一个文件。</p><p>Python引入了<code>with</code>语句来避免程序出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><p>上面的代码相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p><strong>（2）读文件内容</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>read()</td><td>一次读取文件的全部内容</td></tr><tr><td>read(size)</td><td>每次最多读取size个字节的内容</td></tr><tr><td>readline()</td><td>每次读取一行内容</td></tr><tr><td>readlines()</td><td>一次读取所有内容并按行返回</td></tr></tbody></table><p><strong>（3）关闭文件</strong></p><p>调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p><strong>（4）读取其它编码格式文件</strong></p><p>要读取二进制文件，比如图片、视频等等，用<code>'rb'</code>模式打开文件即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;测试&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-写文件">1.2 写文件</h2><p>调用<code>open()</code>，传入标识符<code>'w'</code>或者<code>'wb'</code>表示写文本文件或写二进制文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。</p><p>所以通常，还是使用<code>with</code>语句写文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>二、文件和目录操作</h1><p>Python内置的<code>os</code>模块可以直接调用操作系统提供的接口函数。</p><h2 id="2-1-目录操作">2.1 目录操作</h2><p><strong>（1）查看目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录的绝对路径:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（2）创建目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael/testdir&#x27;</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（3）删除目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（4）合并与拆分路径</strong></p><p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael/testdir&#x27;</span></span><br></pre></td></tr></table></figure><p>要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（5）获取扩展名</strong></p><p><code>os.path.splitext()</code>可以直接让你得到文件扩展名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;/path/to/file.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-文件操作">2.2 文件操作</h2><p><strong>（1）文件重命名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）文件删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（3）复制与移动文件</strong></p><p><code>os</code>模块中并未提供复制与移动文件的函数，但<code>shutil</code>模块提供了<code>copyfile()</code>的函数，可以看作是<code>os</code>模块的补充。</p><p><code>shutil.copy(src_file, target_path)</code><br><code>shutil.move(src_file, target_path)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">shutil.copy(<span class="string">&#x27;/Users/michael/testdir1/file.txt&#x27;</span>, <span class="string">&#x27;/Users/michael/testdir2&#x27;</span>)</span><br><span class="line">shutil.move(<span class="string">&#x27;/Users/michael/testdir1/file.txt&#x27;</span>, <span class="string">&#x27;/Users/michael/testdir2&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>三、JSON</h1><p>要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，最常用的就是序列化为JSON。</p><p>因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><h2 id="3-1-Python-dict-JSON">3.1 Python dict -&gt; JSON</h2><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。<br><code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p><h2 id="3-2-JSON-Python-dict">3.2 JSON -&gt; Python dict</h2><p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Python-Class-JSON">3.3 Python Class -&gt; JSON</h2><p>由于通常情况下，我们会用<code>class</code>表示对象，如果直接将对象序列化肯定会报错，原因是<code>Student</code>对象不是一个可序列化为JSON的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10603cc50</span>&gt; <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</span><br></pre></td></tr></table></figure><p>但，<code>dumps()</code>方法还提供了一大堆的可选参数，其中<strong>可选参数<code>default</code>就支持通过提供转换函数</strong>，为<code>dumps()</code>传入对象实例以及转换函数，就可以实现序列化。</p><p>精简后的写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</span><br></pre></td></tr></table></figure><p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。</p><h2 id="3-4-JSON-Python-Class">3.4 JSON -&gt; Python Class</h2><p>如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dict2student</span>(<span class="params">d</span>):</span><br><span class="line">    <span class="keyword">return</span> Student(d[<span class="string">&#x27;name&#x27;</span>], d[<span class="string">&#x27;age&#x27;</span>], d[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10cd3c190</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文总结了python读写文件的基本操作，以及常用的os对目录和文件的常用操作，如路径获取、路径拼接、文件重命名、文件移动等。总结了常用的JSON。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python复习笔记3——测试与调试技巧</title>
    <link href="https://www.mahaofei.com/post/ab5ff75c.html"/>
    <id>https://www.mahaofei.com/post/ab5ff75c.html</id>
    <published>2022-06-30T12:02:27.000Z</published>
    <updated>2022-06-30T12:02:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、错误处理</h1><h2 id="1-1-try">1.1 try</h2><p>Python内置了一套<code>try...except...finally...</code>的错误处理机制。</p><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码在计算<code>10 / 0</code>时会产生一个除法运算错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">except</span>: division by zero</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。</p><p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句</p><blockquote><p>常见的错误类型和继承关系参考：<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p></blockquote><h2 id="1-2-记录错误">1.2 记录错误</h2><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息打印出来，然后分析错误原因，同时，让程序继续执行下去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同样是出错，但程序打印完错误信息后会继续执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ERROR:root:division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">13</span>, <span class="keyword">in</span> main</span><br><span class="line">    bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> bar</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line">  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> foo</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="1-3-抛出错误">1.3 抛出错误</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>在<code>bar()</code>函数中，捕获了错误打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去了。这种处理方式较为常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p><p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。</p><h1>二、调试</h1><p>众所周知，程序能一次写完并正常运行的概率几乎不存在。总会有各种各样的bug，因此，需要一整套调试程序的手段来修复bug。</p><h2 id="2-1-print">2.1 print</h2><p>最简单粗暴的方法就是用<code>print()</code>把可能有问题的变量打印出来看看，用<code>print()</code>最大的坏处是将来还得删掉它。</p><h2 id="2-2-断言assert">2.2 断言assert</h2><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：<code>assert 表达式, '打印的信息'</code>，如果断言assert表达式为True，则无效果继续执行，如果断言表达式出错，则打印信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">&#x27;n is zero!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则打印信息。</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>，这样程序中如果到处充斥着<code>assert</code>，和<code>print()</code>相比也好不到哪去。不过，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -O err.py</span><br></pre></td></tr></table></figure><h2 id="2-3-logging">2.3 logging</h2><p>和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line">s = &#x27;0&#x27;</span><br><span class="line">n = int(s)</span><br><span class="line">logging.info(&#x27;n = %d&#x27; % n)</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure><p>它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h2 id="2-4-单步调试与断点">2.4 单步调试与断点</h2><p><strong>（1）pdb</strong></p><p>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pdb err.py</span><br></pre></td></tr></table></figure><p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码。</p><ul><li>输入命令<code>l</code>来查看代码</li><li>输入命令<code>n</code>可以单步执行代码。</li><li>输入命令<code>p 变量名</code>来查看变量</li><li>输入命令<code>q</code>结束调试，退出程序</li></ul><p><strong>（2）pdb.set_trace()</strong></p><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点。</p><p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行。</p><p><strong>（3）IDE</strong></p><p>使用一个支持调试功能的IDE，可以更好的设置断点、单步执行。</p><p>常规使用推荐Visual Studio Code：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>，需要安装Python插件。</p><p>大型项目推荐PyCharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a>。</p><h1>三、测试</h1><h2 id="3-1-单元测试">3.1 单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p><p>比如对函数<code>abs()</code>，我们可以编写出以下几个测试用例：</p><ol><li>输入正数，比如<code>1</code>、<code>1.2</code>、<code>0.99</code>，期待返回值与输入相同；</li><li>输入负数，比如<code>-1</code>、<code>-1.2</code>、<code>-0.99</code>，期待返回值与输入相反；</li><li>输入<code>0</code>，期待返回<code>0</code>；</li><li>输入非数值类型，比如<code>None</code>、<code>[]</code>、<code>&#123;&#125;</code>，期待抛出<code>TypeError</code>。</li></ol><p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p><p><strong>（1）编写单元测试</strong></p><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p><p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStudent</span>(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_80_to_100</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">80</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">        self.assertEqual(s1.get_grade(), <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        self.assertEqual(s2.get_grade(), <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_60_to_80</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">60</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">79</span>)</span><br><span class="line">        self.assertEqual(s1.get_grade(), <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        self.assertEqual(s2.get_grade(), <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_0_to_60</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">        self.assertEqual(s1.get_grade(), <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        self.assertEqual(s2.get_grade(), <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_invalid</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">101</span>)</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(ValueError):</span><br><span class="line">            s1.get_grade()</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(ValueError):</span><br><span class="line">            s2.get_grade()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEqual()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></span><br></pre></td></tr></table></figure><p><strong>（2）运行单元测试</strong></p><p>最简单的运行方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest mydict_test</span><br></pre></td></tr></table></figure><h2 id="3-2-文档测试">3.2 文档测试</h2><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>当我们编写注释时，如果写上这样的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Calculate 1*2*...*n</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(10)</span></span><br><span class="line"><span class="string">    3628800</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p><p>使用doctest进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>运行测试程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br></pre></td></tr></table></figure><p>什么输出也没有。这说明我们编写的doctest运行都是正确的。</p>]]></content>
    
    
    <summary type="html">在程序运行过程中，总会遇到各种各样的错误。有的错误是程序编写有问题造成的，有的错误是用户输入造成的，还有的错误是完全无法在程序运行过程中预测的，Python内置了一套异常处理机制，来帮助我们进行错误处理。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python复习笔记2——面向对象编程</title>
    <link href="https://www.mahaofei.com/post/604a94da.html"/>
    <id>https://www.mahaofei.com/post/604a94da.html</id>
    <published>2022-06-29T08:29:53.000Z</published>
    <updated>2022-06-29T08:29:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><h1>一、类Class和实例Instance</h1><p>面向对象最重要的概念就是类和实例。</p><ul><li>类是抽象的模板</li><li>实例是根据类创建出来的一个个具体的“对象”</li></ul><p>在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong><code>class</code>后面紧接着是类名</strong>，即<code>Student</code>，<strong>类名通常是大写开头的单词</strong>，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><p><strong>创建实例是通过类名+()实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huffie = Student()</span><br></pre></td></tr></table></figure><p>变量<code>bart</code>指向的就是一个<code>Student</code>的实例</p><h1>二、面向对象的三大特性：封装、继承、多态</h1><h2 id="2-1-封装">2.1 封装</h2><p><strong>（1）__init__方法</strong></p><p>通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p><p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huffie = Student(<span class="string">&#x27;huffie&#x27;</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）类的方法</strong></p><p><code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法。</p><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure><p>要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bart.print_score()</span><br></pre></td></tr></table></figure><p><strong>（3）访问限制</strong></p><p>类的内部可以有属性和方法，外部代码通过实例变量的方法来操作数据，这样就隐藏了内部的复杂逻辑。</p><p>但外部代码还是可以自由的修改实例的属性。</p><p>要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>。在Python中，<strong>实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private）</strong>，只有内部可以访问，外部不能访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))</span><br></pre></td></tr></table></figure><p>这样就确保了外部代码不能随意修改对象的属性，使代码更稳定可靠。</p><p>如果外部代码要获取name和score，或者要修改score，可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">        self.__score = score</span><br></pre></td></tr></table></figure><p><strong>（4）类属性和实例属性</strong></p><p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.score = <span class="number">90</span></span><br></pre></td></tr></table></figure><p>给类绑定属性可以直接在class中定义属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br></pre></td></tr></table></figure><p>类属性的特性参考以下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    name = <span class="string">&#x27;Student&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h2 id="2-2-继承">2.2 继承</h2><p>定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p><strong>（1）继承的优点1：子类拥有父类的属性和方法</strong></p><p>继承最大的好处是子类获得了父类的全部功能。即子类自动拥有父类的所有共有属性和方法。</p><p>举例如下，对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。<code>Cat</code>和<code>Dog</code>类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>（2）继承的优点2：子类可以修改父类的方法</strong></p><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-多态">2.3 多态</h2><p>首先说明，<strong>当我们定义一个class的时候，我们实际上就定义了一种数据类型</strong>。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样。</p><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p><p><strong>（1）多态的优点</strong></p><p>当新增子类时，任何依赖父类作为参数的函数或方法都可以不加修改的正常运行。即</p><ul><li>对扩展开放：允许新增<code>父类</code>的子类；</li><li>对修改封闭：不需要修改依赖<code>父类</code>类型的函数。（例如<code>def func(父类)</code>）</li></ul><p><strong>（2）动态语言</strong></p><p>定义一个Animal类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>参考如下依赖<code>Animal</code>类的函数，其中调用了<code>Animal</code>类的方法<code>run</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>即使<code>Timer</code>类和<code>Animal</code>类毫无关系，但只要他们都有<code>run</code>方法就可以使用依赖<code>Animal</code>的函数。</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animal = Animal()</span><br><span class="line">timer = Timer()</span><br><span class="line"></span><br><span class="line">run_twice(animal)</span><br><span class="line">run_twice(timer)</span><br></pre></td></tr></table></figure><h1>三、面向对象高级编程</h1><h2 id="3-1-property">3.1 @property</h2><p>前面介绍了<code>set</code>和<code>get</code>方法用来保证代码的稳定性，但这种调用方式过于复杂。因此…对于追求完美的Python程序员来说，参数的使用必须要简单！</p><p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了。<br>把一个setter方法变成属性，只需要加上<code>@func_name.setter</code>就可以了<br>只定义getter方法，不定义setter方法就是一个只读属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><h2 id="3-2-定制类">3.2 定制类</h2><p><strong>（1）<strong>slot</strong></strong></p><p>定义类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>为实例绑定属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 动态给实例绑定一个属性</span></span><br></pre></td></tr></table></figure><p>为实例绑定方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>): <span class="comment"># 定义一个函数作为实例方法</span></span><br><span class="line"><span class="meta">... </span>    self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br></pre></td></tr></table></figure><p>为类绑定方法，所有实例均可调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure><p>上面可以看到，在定义了实例后可以任意添加实例的属性，但如果我们想要限制实例的属性怎么办。</p><p>Python允许在定义class的时候，<strong>定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 绑定属性&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性&#x27;age&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性&#x27;score&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></span><br></pre></td></tr></table></figure><p>使用<code>__slots__</code>要注意，<strong><code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</strong>。</p><p><strong>（2）<strong>str</strong></strong></p><p>我们先定义一个<code>Student</code>类，打印一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb190</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb190</span>&gt;</span><br></pre></td></tr></table></figure><p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p><p>怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法和<code>__repr__</code>方法，返回一个好看的字符串就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s) from __str__&#x27;</span> % self.name</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s) from __repr__&#x27;</span> % self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Student <span class="built_in">object</span> (name: Michael) <span class="keyword">from</span> __str__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Student <span class="built_in">object</span> (name: Michael) <span class="keyword">from</span> __repr__</span><br></pre></td></tr></table></figure><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p><p>简便写法：<code>__repr__ = __str__</code></p><p><strong>（3）<strong>getattr</strong></strong></p><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。</p><p>要避免这个错误，除了可以加上一个<code>score</code>属性外，Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">&#x27;score&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;\&#x27;Student\&#x27; object has no attribute \&#x27;%s\&#x27;&#x27;</span> % attr)</span><br></pre></td></tr></table></figure><p>当调用不存在的属性或方法时，就会有返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p><strong>（4）<strong>call</strong></strong></p><p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span></span><br><span class="line">My name <span class="keyword">is</span> Michael.</span><br></pre></td></tr></table></figure><p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><h2 id="3-3-枚举类">3.3 枚举类</h2><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，好处是简单，缺点是类型是<code>int</code>，并且仍然是变量。</p><p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure><p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure><p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p><p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">总结了类的基本使用方法；封装、继承、多态的特点与应用实例；以及面向继承的高级特性如多重继承、定制类等概念。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python复习笔记1——Python的高级特性与函数式编程</title>
    <link href="https://www.mahaofei.com/post/88692170.html"/>
    <id>https://www.mahaofei.com/post/88692170.html</id>
    <published>2022-06-28T06:15:00.000Z</published>
    <updated>2022-06-28T06:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Python的高级特性</h1><p>Python中许多功能的实现都有许多方法。在python中并不是代码越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。基于这一思想，python中设计了许多非常有用的高级特性。</p><h2 id="1-1-列表生成式">1.1 列表生成式</h2><p><strong>（1）简单列表生成式</strong></p><p>例如要生成前10个数的平方<code>[1x1, 2x2, 3x3, ..., 10x10]</code>，使用常规办法需要借助循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">L.append(x * x)</span><br></pre></td></tr></table></figure><p>这种方式太过繁琐，而列表生成式可以使用一行语句代替上面的循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure><p>写列表生成式时，<strong>把要生成的元素<code>x*x</code>放到前面，后面跟for循环</strong>，就可以把list创建出来。</p><p><strong>（2）两层循环与多变量循环</strong></p><p>列表生成式支持多重循环，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;]</span></span><br></pre></td></tr></table></figure><p>三层以上的循环就很少用到了。</p><p>由于for循环支持两个甚至多个变量，因此列表生成式也支持同样的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">[k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;y=B&#x27;, &#x27;x=A&#x27;, &#x27;z=C&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>（3）列表生成式的if用法</strong></p><p>for循环加if用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>跟在for后面的if是一个筛选条件。</p><p><strong>（4）列表生成式的if…else用法</strong></p><p>for循环加if…else用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]</span></span><br></pre></td></tr></table></figure><p>for前面的部分是一个表达式，它必须根据for循环得到的x计算出一个结果，作为列表的一个元素。</p><p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据x计算出确定的结果。如果只用if不加else，则考察表达式：<code>x if x % 2 == 0</code>，它无法根据x计算出结果，因此程序会报错。</p><p><strong>综上，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</strong></p><h2 id="1-2-生成器">1.2 生成器</h2><p>由于内存的限制，列表的容量是有限的，如果我们需要创建一个包含100万个元素的列表，但每次仅需要访问前几个元素，这样不仅占用了很大的存储空间，其它绝大多数元素占用的空间都白白浪费了。</p><p>如果元素列表可以按照某种算法推算出来，就可以在循环过程中不断推算列表元素，这样就不必一次创建完成的list，从而节省大量的空间，这种一边循环一边计算的机制，称为生成器generator。</p><p><strong>（1）创建生成器</strong></p><p>创建generator最简单的方法，把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span></span><br></pre></td></tr></table></figure><p>调用生成器generator的元素，可以通过for循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p><strong>（2）使用yield创建生成器</strong></p><p>如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>可以通过<code>next()</code>函数获得generator的下一个返回值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p><p>generator函数和普通函数的执行流程不一样。普通函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>调用该generator函数时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = odd()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>把函数改成generator函数后，我们基本上从来不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for</code>循环来迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> odd():</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><h1>二、函数式编程</h1><h2 id="2-1-高阶函数">2.1 高阶函数</h2><p><strong>（1）变量指向函数</strong></p><p>函数本身也可以赋值给变量，即：变量可以指向函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(-<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>说明变量<code>f</code>现在已经指向了<code>abs</code>函数本身。直接调用<code>abs()</code>函数和调用变量<code>f()</code>完全相同。</p><p><strong>（2）函数名也是变量</strong></p><p>函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span> = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;int&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></table></figure><p>把<code>abs</code>指向<code>10</code>后，就无法通过<code>abs(-10)</code>调用该函数了！因为<code>abs</code>这个变量已经不指向求绝对值函数而是指向一个整数<code>10</code>！（当然实际代码不可能这么写）</p><p><strong>（3）传入函数</strong></p><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure><p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，实现绝对值加法计算。</p><p><strong>（4）map/reduce</strong></p><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p><code>reduce()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>。<br><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p>例如把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure><p><strong>（5）filter</strong></p><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p><code>filter()</code>接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><p><strong>（6）sorted</strong></p><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。</p><p>Python内置的<code>sorted()</code>函数就可以对list进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])</span><br><span class="line">[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p>默认情况下，对字符串排序，是按照ASCII的大小比较的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>])</span><br><span class="line">[<span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</span><br></pre></td></tr></table></figure><p>若要忽略大小写，按照字母序排序，只要我们能用一个key函数把字符串映射为忽略大小写排序即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="2-2-返回函数">2.2 返回函数</h2><p><strong>（1）函数作为返回值</strong></p><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><p>例如如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function lazy_sum.&lt;<span class="built_in">locals</span>&gt;.<span class="built_in">sum</span> at <span class="number">0x101c6ed90</span>&gt;</span><br></pre></td></tr></table></figure><p>调用函数<code>f</code>时，才真正计算求和的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p><strong>（2）闭包</strong></p><p>上面例子中内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量。</p><p>闭包就是<strong>能够读取其他函数内部变量的函数</strong>。</p><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常。但是，如果对外层变量赋值，由于Python解释器会把<code>x</code>当作函数<code>fn()</code>的局部变量，它会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>原因是<code>x</code>作为局部变量并没有初始化，直接计算<code>x+1</code>是不行的。但我们其实是想引用<code>inc()</code>函数内部的<code>x</code>，所以需要在<code>fn()</code>函数内部加一个<code>nonlocal x</code>的声明。加上这个声明后，解释器把<code>fn()</code>的<code>x</code>看作外层函数的局部变量，它已经被初始化了，可以正确计算<code>x+1</code>。</p><h2 id="2-3-匿名函数">2.3 匿名函数</h2><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p>也可以把匿名函数作为返回值返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</span><br></pre></td></tr></table></figure><h2 id="2-4-装饰器">2.4 装饰器</h2><p>假设我们要增强某个函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。（其中<code>__name__</code>属性，可以拿到函数的名字）</p><p>使用log函数时要借助Python的@语法，把decorator置于函数的定义处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2022-6-28&#x27;</span>)</span><br></pre></td></tr></table></figure><p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now = log(now)</span><br></pre></td></tr></table></figure><p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2022</span>-<span class="number">6</span>-<span class="number">28</span></span><br></pre></td></tr></table></figure><p>由于函数有<code>__name__</code>等属性，但经过decorator装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>一个完整的decorator的写法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>带参数的decorator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><h2 id="2-5-偏函数">2.5 偏函数</h2><p>Python的<code>functools</code>模块提供了偏函数（Partial function）功能。把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>例如<code>int()</code>函数提供了额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br></pre></td></tr></table></figure><p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1010101&#x27;</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在python中代码越少越好，越简单越好。基于这一思想，python中设计了许多非常有用的高级特性，如列表生成式，生成器，匿名函数，装饰器等。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>三维重建方法汇总</title>
    <link href="https://www.mahaofei.com/post/cff1c9b1.html"/>
    <id>https://www.mahaofei.com/post/cff1c9b1.html</id>
    <published>2022-06-25T14:00:29.000Z</published>
    <updated>2022-06-25T14:00:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、什么是三维重建</h1><p>三维重建是用相机拍摄真实世界的物体、场景，通过计算机视觉技术进行处理，从而得到物体的三维模型。</p><p>主要涉及技术包括：多视图立体几何、深度图估计、点云处理、网格重建和优化、纹理贴图、马尔可夫随机场、图像分割等。</p><p>主要应用领域包括：增强现实、混合现实、机器人导航、自动驾驶、工业工件尺寸检测、平整度检测等。</p><h1>二、传统三维重建方法</h1><h2 id="2-1-RGBD">2.1 RGBD</h2><h3 id="基础">基础</h3><p>深度相机：可以直接获取被测对象三维信息的相机。</p><p>深度相机主要分为结构光相机和ToF相机。结构光相机是指通过一个红外投影仪向前方投射光栅或激光散斑，再使用相机拍摄是光栅和光斑的形状尺寸，从而得到物体三维信息。ToF是通过测量发射脉冲与接受之间的时间，从而计算目标距离。</p><h3 id="KinectFusion-2011">KinectFusion - 2011</h3><blockquote><p>论文：<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6162880" title="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6162880">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6162880</a><br>代码：<a href="https://github.com/chrdiller/KinectFusionApp" title="https://github.com/chrdiller/KinectFusionApp">https://github.com/chrdiller/KinectFusionApp</a></p></blockquote><p>KinectFusion是第一个使用RGBD相机的三维重建系统，使用的地图是TSDF地图，后续很多实时三维重建系统都是在KinectFusion上扩展的。</p><p>实现流程：首先获取RGBD图像，计算点云以及归一化后的法向量；然后通过ICP算法计算当前帧的相机位姿；之后将当前点云融合到TSDF地图中，最后通过TSDF地图以及当前帧的位姿预测处当前帧的深度图像。</p><p>TSDF地图是一种网格式的地图，先选定要建模的三维空间，按照一定分辨率，将这个空间分成许多小块，存储每个小块内部的信息。每个TSDF体素内，存储了该小块与最近的物体表面的距离。如果小块在最近物体表面的前方，它就有一个正的值；反之，如果该小块位于表面之后，那么这个值就为负。由于物体表面通常是很薄的一层，所以就把值太大的和太小的都取成1和-1，这就得到了截断之后距离，也就是所谓的TSDF。</p><h3 id="BundleFunsion-2016">BundleFunsion - 2016</h3><blockquote><p>论文：<a href="https://arxiv.org/abs/1604.01093">https://arxiv.org/abs/1604.01093</a><br>代码：<a href="https://github.com/niessner/BundleFusion">https://github.com/niessner/BundleFusion</a></p></blockquote><p>大致流程：输入的color+depth的数据流首先需要做帧与帧之间的对应关系匹配，然后做全局位姿优化，将整体的漂移校正过来（上图下方所示），整个重建过程中模型是在不断动态更新的。</p><p>在匹配方面，这里使用的是一种sparse-then-dense的并行全局优化方法。也就是说，先使用稀疏的SIFT特征点来进行比较粗糙的配准，因为稀疏特征点本身就可以用来做loop closure检测和relocalization。然后使用稠密的几何和光度连续性进行更加细致的配准。</p><p>在位姿优化方面。这里使用了一种分层的 local-to-global 的优化方法，如下图所示。总共分为两层，在最低的第一层，每连续10帧组成一个chunk，第一帧作为关键帧，然后对这个chunk内所有帧做一个局部位姿优化。在第二层，只使用所有的chunk的关键帧进行互相关联然后进行全局优化。为什么要分层这么麻烦呢？或者说这样分层有什么好处呢？因为可以剥离出关键帧，减少存储和待处理的数据。并且这种分层优化方法减少了每次优化时的未知量，保证该方法可扩展到大场景而漂移很小。</p><p>在稠密场景重建方面。该算法在特征匹配设置了三道筛选策略。第一种是直接对关键点本身分布的一致性和稳定性进行考验。第二道关卡是对特征匹配对跨越的表面面积进行考验，去掉特别小的，因为跨越面积较小的的话很容易产生歧义。第三道关卡是进行稠密的双边几何和光度验证，去掉重投影误差较大的匹配对。</p><p>特点：GPU下实时鲁棒跟踪，可以解决漂移现象，去除了实施以来。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/51b4d97353b2b296c7f8ef78c724cae1.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f47535ef08447d692dc7d03afaab8693.png" alt=""></p><h2 id="2-2-MVS多帧图像重建">2.2 MVS多帧图像重建</h2><h3 id="基础-2">基础</h3><p>MVS是从一系列图像中重建3D模型。</p><p>流程：图像采集 - 位姿计算 - 模型重建 - 纹理贴图。其中图像采集可以是视频等序列化图像，也可以是非连续图像。在位姿计算中根据是否为序列化图像，有不同的方法进行位姿计算。</p><p>应用：影音娱乐，AR文物，自动驾驶，大型场景三维重建等。</p><p>综述：<a href="https://ieeexplore.ieee.org/document/8637125">Multi-View Stero: A Tutorial</a></p><h3 id="COLMAP-2016">COLMAP - 2016</h3><blockquote><p>论文：<a href="https://ieeexplore.ieee.org/document/7780814">https://ieeexplore.ieee.org/document/7780814</a><br>代码：<a href="https://github.com/colmap/colmap">https://github.com/colmap/colmap</a></p></blockquote><p>SFM通常首先进行特征提取/匹配以及后续的几何校验滤出外点，经过上述步骤可以得到所谓的场景图scene graph，该场景图是后续的增量式的基础（提供数据关联等信息）。增量式重建中需要非常仔细地挑选两帧进行重建，在图像进行注册（即定位当前帧在地图中的位姿）之前，需要进行三角化场景点/滤出外点以及BA优化当前的模型。</p><p>COLMAP算法的创新点在于</p><ul><li>提出了一种多模型几何校验策略：提高了初始化与三角化的鲁棒性；</li><li>后续最优帧选择策略：提升位姿结算鲁棒性与精度；</li><li>提出鲁棒三角化方法：使得重建的场景结构更加完整；</li><li>提出迭代BA，重三角化以及外点滤除策略对重建的完整性与精度都有贡献；</li><li>高效BA参数化方法对稠密图像的重建具有帮助；</li></ul><h3 id="OpenMVS">OpenMVS</h3><blockquote><p>代码：<a href="https://github.com/cdcseacave/openMVS">https://github.com/cdcseacave/openMVS</a></p></blockquote><p>OpenMVS的输入是图像和位姿，其中位姿可以是从COLMAP、SLAM等多种方式计算得到。然后进行稠密重建 - 点云融合 - 初始网格重建 - 网格优化 - 纹理贴图。</p><p>OpenMVS是目前的三维重建的框架中，复原效果比较好的；而且提供自动化的脚本，使用起来也不是很难，可以在github中下载编译安装。</p><h1>三、基于深度学习的三维重建</h1><h2 id="3-1-mesh重建">3.1 mesh重建</h2><h3 id="基于3DMM重建">基于3DMM重建</h3><p>3DMM（3D Morphable Model）可形变模型：任意一张人脸图像都可以根据如下公式重建</p><p>$$S_{model} = S^2+\sum^{m-1}<em>{i=1}\alpha_i S_i, T</em>{model} = T^2+\sum^{m-1}_{i=1}\beta_i T_i$$</p><p><img src="https://pic3.zhimg.com/v2-6c4cbef2157bb3be585894736edd20e6_b.webp" alt=""></p><p>拓展网络：Nonlinear 3D Face Morphable Model</p><ul><li>学习了一个非线性模型，比传统的线性模型具有更大的表示能力；</li><li>弱监督学习：利用大量没有三维扫描的二维图像，共同学习模型和模型拟合算法</li></ul><p>拓展网络：2DASL</p><ul><li>自监督模型，克服3D标注数据不足问题</li></ul><p>拓展网络：PRNet</p><ul><li>以端到端的方式解决了人脸对齐和三维人脸的问题，使其一起完成，而且不受低维解空间的限制</li><li>运行速度超过100FPS的轻量级框架</li></ul><p><img src="https://pic4.zhimg.com/80/v2-690d70ccd148f2dcc9c127709ffdadcb_720w.jpg" alt=""></p><h3 id="IF-Nets">IF-Nets</h3><p>IF-NETS是物体、人体重建网络。该网络可以将稀疏、稠密点云重建为mesh模型。由于数据集的限制（大多数据是CAD模型渲染得到的），真实场景的模型恢复效果一般。</p><h3 id="PifuHD">PifuHD</h3><p>PIFu是人体重建网络。</p><p>算法优点</p><ul><li>同时支持 single-view 和 multi-view；</li><li>高度复杂的形状，如发型、服装，以及它们的变化和变形都可以用统一的方式数字化</li><li>重建精度、细节表现比现有的方法更优；</li><li>与体素表示不同，内存效率更高，可以处理任意拓扑结构，并且生成的表面与输入图像在空间上对齐</li></ul><h2 id="3-1-深度图重建MVSNet">3.1 深度图重建MVSNet</h2><p>网络结构：输入是任意位姿的多张图像，且多张图片之间的关系需要被整体考虑。</p><p>MVSNet本质是借鉴基于两张图片cost volume的双目立体匹配的深度估计方法，扩展到多张图片的深度估计，而基于cost volume的双目立体匹配已经较为成熟，所以MVSNet本质上也是借鉴一个较为成熟的领域，然后提出基于可微分的单应性变换的cost volume用于多视图深度估计。</p><p>过程：</p><p>（1）输入一张r<strong>eference image（为主）</strong> 和几张<strong>source images（辅助）</strong>；</p><p>（2）分别用网络提取出下采样四分之一的32通道的特征图；</p><p>（3）采用立体匹配（即双目深度估计）里提出的cost volume的概念，将几张source images的特征利用<strong>单应性变换( homography warping)<strong>转换到reference image，在转换的过程中，<strong>类似极线搜索</strong>，引入了深度信息。构建</strong>cost volume</strong>可以说是<strong>MVSNet的关键</strong>。</p><p><strong>具体costvolume上一个点是所有图片在这个点和深度值上特征的方差，方差越小，说明在该深度上置信度越高。</strong></p><p>（4）利用3D卷积操作cost volume，先输出每个深度的概率，然后求深度的加权平均得到预测的深度信息，用L1或smoothL1回归深度信息，是一个回归模型。</p><p>（5）利用多张图片之间的重建约束（<em>photometric</em> and <em>geometric</em> consistencies）来选择预测正确的深度信息，重建成三维点云。</p><p><img src="https://pic2.zhimg.com/80/v2-bd6adb618c98e7b8c2cb09f4c1f2b805_720w.jpg" alt=""></p><p>拓展网络：MVS-JDACS-MS<br>在无监督网络框架中引入协同分割和数据增强策略，克服不同视角图像之间天然存在的光照差异干扰。</p><p>拓展网络：MVS-PatchMatchNet<br>一种基于传统PatchMatch算法的高效multi-view stereo框架。</p><h1>四、算法测评网站</h1><p>双目立体匹配：<a href="https://vision.middlebury.edu/stereo/eval3/">https://vision.middlebury.edu/stereo/eval3/</a></p><p><img src="https://img.mahaofei.com/img/20220625201059.png" alt=""></p><p>车载双目立体相关算法：<a href="http://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo">http://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo</a></p><p><img src="https://img.mahaofei.com/img/20220625201353.png" alt=""></p><p>室外场景：<a href="https://www.eth3d.net/low_res_two_view">https://www.eth3d.net/low_res_two_view</a></p><p><img src="https://img.mahaofei.com/img/20220625201519.png" alt=""></p><p>计算机视觉相关论文、模型、数据集、代码汇总：<a href="https://paperswithcode.com/sota">https://paperswithcode.com/sota</a></p><p><img src="https://img.mahaofei.com/img/20220625201724.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220625202144.png" alt=""></p>]]></content>
    
    
    <summary type="html">三维重建是用相机拍摄真实世界的物体、场景，通过计算机视觉技术进行处理，从而得到物体的三维模型。主要涉及技术包括：多视图立体几何、深度图估计、点云处理、网格重建和优化、纹理贴图、马尔可夫随机场、图像分割等。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>RobotStudio实现喷漆、打磨等功能（曲面路径生成与仿真）</title>
    <link href="https://www.mahaofei.com/post/3feb0033.html"/>
    <id>https://www.mahaofei.com/post/3feb0033.html</id>
    <published>2022-06-24T10:54:18.000Z</published>
    <updated>2022-06-24T10:54:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1>任务介绍</h1><p>在Robotstudio中导入一个CAD模型，如汽车外壳等复杂曲面模型。使用Robotstudio进行路径规划，实现机械臂的汽车外壳的喷漆功能。</p><h1>所用环境</h1><p>实现本功能，使用到了ABB公司发布的<code>ABB Machining PowerPac</code>功能包。该功能包可以实现的功能包括打磨产品（规则的方形体）、涂胶、火焰切割、卫浴打磨、复杂的大型曲面体打磨、磨边等。</p><p>下载链接如下：<a href="https://robotapps.blob.core.windows.net/apps/d2d4e3fc-1810-4c05-937d-8154d31fca13machiningpowerpac6.04.zip">https://robotapps.blob.core.windows.net/apps/d2d4e3fc-1810-4c05-937d-8154d31fca13machiningpowerpac6.04.zip</a></p><p>如果链接失效，该插件下载方式如下图，找到插件后，在右侧点击链接下载。<br>（由于插件页面无法上下滚动，所以如果屏幕看不到下面的下载链接，还需要调高屏幕分辨率或者把缩放改成100%，下载后再改回来即可）</p><p><img src="https://img.mahaofei.com/img/2022-06-24-153954.png" alt=""></p><blockquote><p>下载后为压缩包格式，解压后运行其中exe再进行解压，注意这次解压不要选带中文的路径，找到解压后的exe运行即可安装。</p><p>该插件为6.04版本，支持<code>Robotstudio6.04</code>及以上版本使用，低于此版本的使用插件时可能会出现兼容性问题，建议使用Robotstudio 6.08，该版本对于大多数插件都有较好的兼容性。使用时双击插件即可加载，加载成功后在<code>Add-Ins</code>栏中即可看到<code>Machining 6.04</code>插件。</p></blockquote><h1>实现方法</h1><h2 id="1-创建工件坐标与工具">1. 创建工件坐标与工具</h2><p>（1）首先创建工件坐标。</p><p><img src="https://img.mahaofei.com/img/20220624161214.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624172529.png" alt=""></p><p>（2）然后创建工具。</p><p><img src="https://img.mahaofei.com/img/20220624161651.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624163115.png" alt=""></p><p>侧面加工与端面加工，在图中可以直观理解为，使用圆柱的侧面、底面端面加工。</p><p>工具的类型如下：</p><ul><li>T_Cutter：T型刀</li><li>Chamfger_Cutter：倒角铣刀</li><li>Flame_Cutter：火焰切割枪</li><li>Swallow_Cutter：燕尾槽铣刀</li><li>Ball_Cutter：球型铣刀</li><li>None：无形状</li></ul><p><strong>对于喷漆作业来说，选择端面加工；使用T型刀，调整接触圈高度为喷头到工件的距离。</strong></p><p>（3）新建一个空程序组</p><p><img src="https://img.mahaofei.com/img/20220624163500.png" alt=""></p><h2 id="2-提取加工曲面">2. 提取加工曲面</h2><p>（1）新建几何</p><p><img src="https://img.mahaofei.com/img/20220624163756.png" alt=""></p><p>（2）设置曲线类型</p><p><img src="https://img.mahaofei.com/img/20220624182636.png" alt=""></p><p>类型：</p><ul><li>Projection Geometry：投影几何</li><li>Intersection Geometry：交叉口几何</li><li>UV Curve：UV曲线</li><li>Edge Curve：边缘曲线</li><li>Customized Curve：自定义曲线</li></ul><p>对于喷漆来说，我们选择使用Intersection Geometry复杂曲线。</p><p>（3）选择加工区域</p><p><img src="https://img.mahaofei.com/img/20220624173012.png" alt=""></p><p>（4）指定切割平面</p><p><img src="https://img.mahaofei.com/img/20220624182535.png" alt=""></p><h2 id="4-新建操作">4. 新建操作</h2><p>（1）新建一个操作</p><p><img src="https://img.mahaofei.com/img/20220624180205.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624183344.png" alt=""></p><p>（2）设置外轴移动模式为：<strong>固定距离模式</strong></p><p><img src="https://img.mahaofei.com/img/20220624180233.png" alt=""></p><p>（3）点击刀具插补设置，点击可达率，在图表中选择一个100%可达率的角度，然后点击应用。</p><p><img src="https://img.mahaofei.com/img/20220624180319.png" alt=""></p><h2 id="5-模拟仿真">5. 模拟仿真</h2><p><img src="https://img.mahaofei.com/img/20220624183434.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624184458.png" alt=""></p>]]></content>
    
    
    <summary type="html">在Robotstudio中导入一个CAD模型，如汽车外壳等复杂曲面模型。使用Robotstudio进行路径规划，实现机械臂的汽车外壳的喷漆功能。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="RobotStudio" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/RobotStudio/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="RobotStudio" scheme="https://www.mahaofei.com/tags/RobotStudio/"/>
    
  </entry>
  
  <entry>
    <title>深度学习遇到报错Bug解决方法（不定时更新）</title>
    <link href="https://www.mahaofei.com/post/f5eca7d2.html"/>
    <id>https://www.mahaofei.com/post/f5eca7d2.html</id>
    <published>2022-06-11T00:51:26.000Z</published>
    <updated>2022-06-15T08:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面所有问题以及解决方法都是本人亲自遇到，且根据解决方法成功解决的，如果仍然有问题欢迎各位评论区讨论。</p><h1>No module named ‘pycocotools‘</h1><p>参考博客：<a href="https://blog.csdn.net/weixin_42410915/article/details/109368497">超简单解决No module named ‘pycocotools‘</a></p><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple/pycocotools-windows/">各版本pycocotools.whl文件</a></p><p>点击连接中任意一个版本，（我安装的是2.0.0），下载的时候一定要注意对应的python版本，cp36指的是python3.6，cp37和cp38同理。</p><p>下载之后，放入你喜欢的文件夹中，然后启动命令行，进入whl文件所在的目录，输入以下命令即可，注意install后面是你自己下载的whl文件全称</p><p><img src="https://img-blog.csdnimg.cn/20201029204744983.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow</span><br><span class="line">E:</span><br><span class="line">cd E:/windows/Downloads</span><br><span class="line">pip install pycocotools_windows-2.0-cp36-cp36m-win_amd64.whl</span><br></pre></td></tr></table></figure><h1>使用Google Colab时，将Tensorflow版本转换到1.x版本</h1><p>参考博客：<a href="https://blog.csdn.net/qq_44262417/article/details/105222696">https://blog.csdn.net/qq_44262417/article/details/105222696</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">tensorflow_version 1.x</span></span><br></pre></td></tr></table></figure><h1>maskrcnn训练提示：FutureWarning: Input image dtype is bool</h1><p>参考博客：<a href="https://blog.csdn.net/qq_39483453/article/details/118598535">https://blog.csdn.net/qq_39483453/article/details/118598535</a></p><p>scikit-image=0.17.2 的版本存在的问题，修改scikit-image包版本为0.16.2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U scikit-image==0.16.2</span><br></pre></td></tr></table></figure><h1>成功解决AttributeError: ‘str‘ object has no attribute ‘decode‘</h1><p>参考博客：<a href="https://blog.csdn.net/qq_41185868/article/details/82079079">https://blog.csdn.net/qq_41185868/article/details/82079079</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &#x27;h5py&lt;3.0.0&#x27; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h1>TypeError: expected str, bytes or os.PathLike object, not NoneType</h1><p>出现这个问题多半是没有指定路径，上述问题翻译过来是，期望一个字符串或者字节路径，而不是默认值，出现这个问题需要把指定路径的变量赋值即可。这种错误多半出现在运行开源代码时出现。</p><p>检查代码中对应位置的字符串变量，是否传入了确定的值，而非None。</p>]]></content>
    
    
    <summary type="html">在跑深度学习代码，进行训练和预测过程中，肯定会遇到各种报错，本文总结了本人遇到的一些errors总结在这里，不定时更新。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="bugs" scheme="https://www.mahaofei.com/tags/bugs/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>经典实例分割模型Mask RCNN</title>
    <link href="https://www.mahaofei.com/post/ef73cea9.html"/>
    <id>https://www.mahaofei.com/post/ef73cea9.html</id>
    <published>2022-06-11T00:47:32.000Z</published>
    <updated>2022-06-11T00:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Mask RCNN简介</h1><p>区域卷积神经网络 RCNN（Region-Convolutional Neural Networks）为两阶段目标检测器。通过对图像生成候选区域，提取特征，判别特征类别并修正候选框位置。 RCNN系列目前包含两个代表模型：Faster RCNN，Mask RCNN。</p><p>Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。</p><p><img src="https://img.mahaofei.com/img/20220515154938.png" alt=""></p><p>Mask-RCNN使用Resnet101作为主干特征提取网络，也就是图中的CNN部分，其对输入的图像image要求其是正方形且宽高可以整除2的6次方，不足的将会在外侧添加灰色区域。</p><ol><li><strong>Resnet101主干特征提取（CNN）</strong></li></ol><p>一张图像image传入到 <strong>Resnet101(CNN)</strong> 之后，会对其进行特征提取，然后将图像长宽压缩两次、三次、四次、五次来构造特征金字塔，目的是为了实现特征多尺度融合。</p><p><img src="https://img.mahaofei.com/img/20220515161629.png" alt=""></p><p>也就是下图中的左侧部分，分别得到了C2、C3、C4、C5五种特征层（五种尺寸的图像）。</p><p><img src="https://img.mahaofei.com/img/20220515162541.png" alt=""></p><ul><li>P5：对最小的C5(32,32)图像进行二维卷积，然后再次卷积作为一个有效特征层P5(32,32)（下方绿色框）</li><li>P6：将P5(32,32)最大池化得到有效特征层P6(16,16)。</li><li>P4：将C5(32,32)一次卷积的结果上采样得到(64,64)图像，与C4(64,64)进行Add运算，然后再次卷积得到另一个有效特征层P4。</li><li>P3：将C4一次卷积结果上采样，并与C3进行Add运算，然后再次卷积得到有效特征层P3。</li><li>P2：将C3一次卷积结果上采样，并与C2进行Add运算，再次卷积得到有效特征层P2。</li></ul><p>提取到的P2、P3、P4、P5、P6五个有效特征层，就是Resent101的输出feature maps，可以用于接下来RPN建议网络获取建议框。</p><ol start="2"><li><strong>RPN区域建议网络（Region Proposal）</strong></li></ol><p>对有效特征层使用RPN建议网络（region proposal），获得许多建议框regions，这些建议框可能包含物体，可能没包含物体。不管包括没包括，接下来都会利用这些建议框截取P2~P5的图像，得到一个个可能存在目标的截取图像（P6不截取）。</p><ol start="3"><li><strong>ROI区域对齐（ROI Align）</strong></li></ol><p>对于所有建议框截取图像，RoI Align都会将其调整图像尺寸为一个正方形，便于后续特征的匹配操作。这样经过所有ROI Align后的建议框截取图像，</p><ol start="4"><li><strong>FC Layers</strong></li></ol><p>根据截取出的建议框图像，利用Classifier回归模型判断截取的区域是否有物体，然后利用Classifier预测框网络对有效特征层进行解码获得最终的预测框。</p><ol start="5"><li><strong>Mask语义分割网络</strong></li></ol><p>利用获取的最终预测框，再次在有效特征层P2~P5中截取目标图像（这次由于相当于进行了以便筛选，截取出的图像数量会少很多），将这次截取出的图像传给Mask语义分割网络进行语义分割。</p><h1>二、Mask R-CNN实现过程</h1><h2 id="2-1-Resnet101-主干特征提取网络">2.1 Resnet101-主干特征提取网络</h2><p>ResNet101有两个基本的块，分别是<code>Conv Block</code>和<code>Identity Block</code>。其中<code>Conv Block</code>的输入和输出维度不同，不能持续串联，它的作用是改变网络的维度；<code>Identity Block</code>的输入维度和输出维度相同，可以串联，用于加深网络。</p><p><img src="https://img.mahaofei.com/img/20220515195957.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220515195949.png" alt=""></p><p>以coco数据集中输入的shape为例，输入的shape为1024x1024，shape变化如下：</p><p><img src="https://img.mahaofei.com/img/20220515200117.png" alt=""></p><p>我们取出长宽压缩了两次、三次、四次、五次的结果来进行下面特征金字塔结构的构造。</p><p>相关代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> ZeroPadding2D,Conv2D,MaxPooling2D,BatchNormalization,Activation,Add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">identity_block</span>(<span class="params">input_tensor, kernel_size, filters, stage, block,</span></span><br><span class="line"><span class="params">                   use_bias=<span class="literal">True</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</span><br><span class="line">    conv_name_base = <span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line">    bn_name_base = <span class="string">&#x27;bn&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">&#x27;2a&#x27;</span>,</span><br><span class="line">                  use_bias=use_bias)(input_tensor)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2a&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2b&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2b&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">&#x27;2c&#x27;</span>,</span><br><span class="line">                  use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2c&#x27;</span>)(x, training=train_bn)</span><br><span class="line"></span><br><span class="line">    x = Add()([x, input_tensor])</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_out&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv_block</span>(<span class="params">input_tensor, kernel_size, filters, stage, block,</span></span><br><span class="line"><span class="params">               strides=(<span class="params"><span class="number">2</span>, <span class="number">2</span></span>), use_bias=<span class="literal">True</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line"></span><br><span class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</span><br><span class="line">    conv_name_base = <span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line">    bn_name_base = <span class="string">&#x27;bn&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2a&#x27;</span>, use_bias=use_bias)(input_tensor)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2a&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2b&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2b&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base +</span><br><span class="line">                  <span class="string">&#x27;2c&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2c&#x27;</span>)(x, training=train_bn)</span><br><span class="line"></span><br><span class="line">    shortcut = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</span><br><span class="line">                         name=conv_name_base + <span class="string">&#x27;1&#x27;</span>, use_bias=use_bias)(input_tensor)</span><br><span class="line">    shortcut = BatchNormalization(name=bn_name_base + <span class="string">&#x27;1&#x27;</span>)(shortcut, training=train_bn)</span><br><span class="line"></span><br><span class="line">    x = Add()([x, shortcut])</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_out&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_resnet</span>(<span class="params">input_image,stage5=<span class="literal">False</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    x = ZeroPadding2D((<span class="number">3</span>, <span class="number">3</span>))(input_image)</span><br><span class="line">    x = Conv2D(<span class="number">64</span>, (<span class="number">7</span>, <span class="number">7</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;conv1&#x27;</span>, use_bias=<span class="literal">True</span>)(x)</span><br><span class="line">    x = BatchNormalization(name=<span class="string">&#x27;bn_conv1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># Height/4,Width/4,64</span></span><br><span class="line">    C1 = x = MaxPooling2D((<span class="number">3</span>, <span class="number">3</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&quot;same&quot;</span>)(x)</span><br><span class="line">    <span class="comment"># Stage 2</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;a&#x27;</span>, strides=(<span class="number">1</span>, <span class="number">1</span>), train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">    C2 = x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Stage 3</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/8,Width/8,512</span></span><br><span class="line">    C3 = x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;d&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Stage 4</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    block_count = <span class="number">22</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(block_count):</span><br><span class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="built_in">chr</span>(<span class="number">98</span> + i), train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/16,Width/16,1024</span></span><br><span class="line">    C4 = x</span><br><span class="line">    <span class="comment"># Stage 5</span></span><br><span class="line">    <span class="keyword">if</span> stage5:</span><br><span class="line">        x = conv_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">        <span class="comment"># Height/32,Width/32,2048</span></span><br><span class="line">        C5 = x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        C5 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> [C1, C2, C3, C4, C5]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于残差神经网络，可以参考此文章：<a href="https://zhuanlan.zhihu.com/p/349717627">ResNet：残差神经网络</a></p><h2 id="2-2-Feature-Pyramid-FPN构建特征金字塔">2.2 Feature Pyramid-FPN构建特征金字塔</h2><p>上文经过主干特征提取后可以得到长宽压缩了两次C2、三次C3、四次C4、五次C5的结果，用这些结果进行特征金字塔的构造，主要是为了得到P2~P6五个有效特征层。</p><p><img src="https://img.mahaofei.com/img/20220515162541.png" alt=""></p><p>具体过程为：</p><ul><li>P5：对【C5】进行一次256通道的卷积，再进行一次256通道的卷积，得到P5。</li><li>P6：将P5进行最大池化得到P6。</li><li>P4：将【C5一次卷积的结果】进行上采样，再与【C4进行256通道卷积的结果】的进行Add运算，再进行一次256通道的卷积，得到P4。</li><li>P3、P2过程类似P4。</li></ul><p>提取到的P2、P3、P4、P5、P6可以作为RPN网络的有效特征层，利用RPN建议框网络对有效特征层进行下一步的操作，对先验框进行解码获得建议框。</p><p>提取到的P2、P3、P4、P5可以作为Classifier和Mask网络的有效特征层，利用Classifier预测框网络对有效特征层进行下一步的操作，对建议框解码获得最终预测框；利用Mask语义分割网络对有效特征层进行下一步的操作，获得每一个预测框内部的语义分割结果。</p><p>具体代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得Resnet里的压缩程度不同的一些层</span></span><br><span class="line">_, C2, C3, C4, C5 = get_resnet(input_image, stage5=<span class="literal">True</span>, train_bn=config.TRAIN_BN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成特征金字塔的结构</span></span><br><span class="line"><span class="comment"># P5长宽共压缩了5次</span></span><br><span class="line"><span class="comment"># Height/32,Width/32,256</span></span><br><span class="line">P5 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c5p5&#x27;</span>)(C5)</span><br><span class="line"><span class="comment"># P4长宽共压缩了4次</span></span><br><span class="line"><span class="comment"># Height/16,Width/16,256</span></span><br><span class="line">P4 = Add(name=<span class="string">&quot;fpn_p4add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p5upsampled&quot;</span>)(P5),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c4p4&#x27;</span>)(C4)])</span><br><span class="line"><span class="comment"># P4长宽共压缩了3次</span></span><br><span class="line"><span class="comment"># Height/8,Width/8,256</span></span><br><span class="line">P3 = Add(name=<span class="string">&quot;fpn_p3add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p4upsampled&quot;</span>)(P4),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c3p3&#x27;</span>)(C3)])</span><br><span class="line"><span class="comment"># P4长宽共压缩了2次</span></span><br><span class="line"><span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">P2 = Add(name=<span class="string">&quot;fpn_p2add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p3upsampled&quot;</span>)(P3),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c2p2&#x27;</span>)(C2)])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 各自进行一次256通道的卷积，此时P2、P3、P4、P5通道数相同</span></span><br><span class="line"><span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">P2 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p2&quot;</span>)(P2)</span><br><span class="line"><span class="comment"># Height/8,Width/8,256</span></span><br><span class="line">P3 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p3&quot;</span>)(P3)</span><br><span class="line"><span class="comment"># Height/16,Width/16,256</span></span><br><span class="line">P4 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p4&quot;</span>)(P4)</span><br><span class="line"><span class="comment"># Height/32,Width/32,256</span></span><br><span class="line">P5 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p5&quot;</span>)(P5)</span><br><span class="line"><span class="comment"># 在建议框网络里面还有一个P6用于获取建议框</span></span><br><span class="line"><span class="comment"># Height/64,Width/64,256</span></span><br><span class="line">P6 = MaxPooling2D(pool_size=(<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">2</span>, name=<span class="string">&quot;fpn_p6&quot;</span>)(P5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># P2, P3, P4, P5, P6可以用于获取建议框</span></span><br><span class="line">rpn_feature_maps = [P2, P3, P4, P5, P6]</span><br><span class="line"><span class="comment"># P2, P3, P4, P5用于获取mask信息</span></span><br><span class="line">mrcnn_feature_maps = [P2, P3, P4, P5]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-构建RPN建议网络模型">2.3 构建RPN建议网络模型</h2><p>RPN建议网络的模型</p><ul><li>首先进行一次3x3的通道为512的卷积</li><li>然后分别进行一次<code>anchors_per_location x 2</code>的卷积和<code>anchors_per_location x 4</code>的卷积。<ul><li><code>anchors_per_location x 2</code>的卷积用于预测<strong>公共特征层上 每一个网格点上 每一个预测框</strong>内部是否包含物体。</li><li><code>anchors_per_location x 4</code>的卷积用于预测<strong>公共特征层上 每一个网格点上 每一个先验框</strong>的变化情况。</li></ul></li></ul><p>例如输入图片的shape是1024x1024x3时，公共特征层的shape就是256x256x256、128x128x256、64x64x256、32x32x256、16x16x256。这些公共特征层上的每一个点，映射到原始图片上就是间隔不同的网格点，每个网格默认存在3(anchors_per_location)个先验框，这些先验框有不同的大小。</p><p><img src="https://img.mahaofei.com/img/20220516162352.png" alt=""></p><p><strong>anchors_per_location x 4的卷积</strong>的结果会对这些先验框进行调整，获得一个新的框。<br><strong>anchors_per_location x 2的卷积</strong>会判断上述获得的新框是否包含物体。</p><p>到这里我们可以获得了一些有用的框，这些框会利用<strong>anchors_per_location x 2的卷积</strong>判断是否存在物体。</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   五个不同大小的特征层会传入到</span></span><br><span class="line"><span class="comment">#   RPN当中，获得建议框</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rpn_graph</span>(<span class="params">feature_map, anchors_per_location</span>):</span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   利用一个3x3卷积进行特征整合，基础的层</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    shared = Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;rpn_conv_shared&#x27;</span>)(feature_map)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   batch_size, num_anchors, 2</span></span><br><span class="line">    <span class="comment">#   代表这个先验框是否包含物体</span></span><br><span class="line">    <span class="comment">#   anchor_per_location的默认值是3</span></span><br><span class="line">    <span class="comment">#   意味着特征层对图像进行网格的划分后，每个网格上先验框的数量是3</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    x = Conv2D(anchors_per_location * <span class="number">2</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&#x27;valid&#x27;</span>, activation=<span class="string">&#x27;linear&#x27;</span>, name=<span class="string">&#x27;rpn_class_raw&#x27;</span>)(shared)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reshape到最后一个维度是2的维度，是一个分类网络，有非常多先验框</span></span><br><span class="line">    rpn_class_logits = Reshape([-<span class="number">1</span>,<span class="number">2</span>])(x)</span><br><span class="line">    rpn_probs = Activation(<span class="string">&quot;softmax&quot;</span>, name=<span class="string">&quot;rpn_class_xxx&quot;</span>)(rpn_class_logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   batch_size, num_anchors, 4</span></span><br><span class="line">    <span class="comment">#   这个先验框的调整参数</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    x = Conv2D(anchors_per_location * <span class="number">4</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&quot;valid&quot;</span>, activation=<span class="string">&#x27;linear&#x27;</span>, name=<span class="string">&#x27;rpn_bbox_pred&#x27;</span>)(shared)</span><br><span class="line">    rpn_bbox = Reshape([-<span class="number">1</span>, <span class="number">4</span>])(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出包括：</span></span><br><span class="line">    <span class="comment"># 先验框是否真实的包含物体</span></span><br><span class="line">    <span class="comment"># bbox先验框的调整参数</span></span><br><span class="line">    <span class="keyword">return</span> [rpn_class_logits, rpn_probs, rpn_bbox]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立建议框网络模型</span></span><br><span class="line"><span class="comment">#   RPN模型</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_rpn_model</span>(<span class="params">anchors_per_location, depth</span>):</span><br><span class="line">    <span class="comment"># 输入的长和宽都是None，代表输入的有效特征层大小是变化的，256、64等都可以</span></span><br><span class="line">    <span class="comment"># 输入的depth是256</span></span><br><span class="line">    input_feature_map = Input(shape=[<span class="literal">None</span>, <span class="literal">None</span>, depth], name=<span class="string">&quot;input_rpn_feature_map&quot;</span>)</span><br><span class="line">    <span class="comment"># 将输入的图像传入到rpn_graph中</span></span><br><span class="line">    outputs = rpn_graph(input_feature_map, anchors_per_location)</span><br><span class="line">    <span class="keyword">return</span> Model([input_feature_map], outputs, name=<span class="string">&quot;rpn_model&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-4-Anchors先验框的获取">2.4 Anchors先验框的获取</h2><p><strong>先验框就是图像上的一定的区域，这些区域是人为规定好的</strong>，这些区域可能包含物体，可能不包含物体，我们网络的预测结果就会判断哪些先验框是包含物体的，然后对先验框进行调整。</p><p>在MaskRCNN中，建议框网络的预测结果就会对这些先验框进行调整，获得建议框，并判断哪些先验框是包含物体的。</p><p>本节介绍如何获得<strong>先验框</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#  Anchors</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_anchors</span>(<span class="params">scales, ratios, shape, feature_stride, anchor_stride</span>):</span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   获得所有框的长度和比例的组合</span></span><br><span class="line">    <span class="comment">#   相当于在每一个网格点上获得了两个长方形(1:2)、(2:1)和一个正方形</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    scales, ratios = np.meshgrid(np.array(scales), np.array(ratios))</span><br><span class="line">    scales = scales.flatten()</span><br><span class="line">    ratios = ratios.flatten()</span><br><span class="line">    heights = scales / np.sqrt(ratios)</span><br><span class="line">    widths = scales * np.sqrt(ratios)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   生成网格中心</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    shifts_y = np.arange(<span class="number">0</span>, shape[<span class="number">0</span>], anchor_stride) * feature_stride</span><br><span class="line">    shifts_x = np.arange(<span class="number">0</span>, shape[<span class="number">1</span>], anchor_stride) * feature_stride</span><br><span class="line">    shifts_x, shifts_y = np.meshgrid(shifts_x, shifts_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   获得先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    box_widths, box_centers_x = np.meshgrid(widths, shifts_x)</span><br><span class="line">    box_heights, box_centers_y = np.meshgrid(heights, shifts_y)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   更变格式</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment"># 对先验框的中心堆叠，然后reshape，reshape后的结果代表每一个先验框的中心坐标</span></span><br><span class="line">    box_centers = np.stack([box_centers_y, box_centers_x], axis=<span class="number">2</span>).reshape([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 对先验框的高和宽堆叠，然后reshape，reshape后的结果代表每一个先验框的高和宽</span></span><br><span class="line">    box_sizes = np.stack([box_heights, box_widths], axis=<span class="number">2</span>).reshape([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算出(y1, x1, y2, x2)</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    boxes = np.concatenate([box_centers - <span class="number">0.5</span> * box_sizes, box_centers + <span class="number">0.5</span> * box_sizes], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boxes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成特征金字塔先验框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_pyramid_anchors</span>(<span class="params">scales, ratios, feature_shapes, feature_strides,  anchor_stride</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成不同特征层的anchors，并利用concatenate进行堆叠</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   Anchors</span></span><br><span class="line">    <span class="comment">#   [anchor_count, (y1, x1, y2, x2)]</span></span><br><span class="line">    <span class="comment">#   P2对应的scale是32</span></span><br><span class="line">    <span class="comment">#   P3对应的scale是64</span></span><br><span class="line">    <span class="comment">#   P4对应的scale是128</span></span><br><span class="line">    <span class="comment">#   P5对应的scale是256</span></span><br><span class="line">    <span class="comment">#   P6对应的scale是512</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    anchors = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对scales进行for循环，是传入的anchor_scales，是32、64、128、256、512</span></span><br><span class="line">    <span class="comment"># 对应不同特征层上先验框的基础大小，再在此基础上获得调整，获得不同长宽大小的先验框</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scales)):</span><br><span class="line">        <span class="comment"># ratio的值是0.5、1、2，对应每个网格点上三个先验框</span></span><br><span class="line">        <span class="comment"># feature_shapes就是获得的每一个有效特征层的大小，代表我们要将图片分割成多少网格</span></span><br><span class="line">        <span class="comment"># feature_strides对应backbone_strides，是4、8、16、32、64</span></span><br><span class="line">        <span class="comment"># anchor_stride的值为1</span></span><br><span class="line">        anchors.append(generate_anchors(scales[i], ratios, feature_shapes[i], feature_strides[i], anchor_stride))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.concatenate(anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_backbone_shapes</span>(<span class="params">config, image_shape</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array( [[<span class="built_in">int</span>(math.ceil(image_shape[<span class="number">0</span>] / stride)), <span class="built_in">int</span>(math.ceil(image_shape[<span class="number">1</span>] / stride))] <span class="keyword">for</span> stride <span class="keyword">in</span> config.BACKBONE_STRIDES])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用下面的函数获取先验框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_anchors</span>(<span class="params">config, image_shape</span>):</span><br><span class="line">    <span class="comment"># 计算主干特征提取网络获得的有效特征层的shape</span></span><br><span class="line">    <span class="comment"># 为了事先放置先验框，我们需要知道网格大小，因此需要先获得有效特征层的shape</span></span><br><span class="line">    backbone_shapes = compute_backbone_shapes(config, image_shape)</span><br><span class="line">    anchor_cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">tuple</span>(image_shape) <span class="keyword">in</span> anchor_cache:</span><br><span class="line">        <span class="comment"># 将backbone_shapes传入下面的函数</span></span><br><span class="line">        <span class="comment"># 生成特征金字塔的先验框</span></span><br><span class="line">        a = generate_pyramid_anchors(</span><br><span class="line">            config.RPN_ANCHOR_SCALES,</span><br><span class="line">            config.RPN_ANCHOR_RATIOS,</span><br><span class="line">            backbone_shapes,</span><br><span class="line">            config.BACKBONE_STRIDES,</span><br><span class="line">            config.RPN_ANCHOR_STRIDE)</span><br><span class="line">        anchor_cache[<span class="built_in">tuple</span>(image_shape)] = norm_boxes(a, image_shape[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> anchor_cache[<span class="built_in">tuple</span>(image_shape)]</span><br></pre></td></tr></table></figure><h2 id="2-5-先验框调整获得建议框">2.5 先验框调整获得建议框</h2><p>利用<code>ProposalLayer</code>对先验框解码获取建议框。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   对先验框进行解码，获得先验框解码后的建议框的坐标</span></span><br><span class="line">    <span class="comment">#   rpn_rois            : Batch_size, proposal_count, 4</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">    proposal_count = config.POST_NMS_ROIS_TRAINING</span><br><span class="line">    rpn_rois = ProposalLayer(proposal_count=proposal_count, nms_threshold=config.RPN_NMS_THRESHOLD, name=<span class="string">&quot;ROI&quot;</span>, config=config)([rpn_class, rpn_bbox, anchors])</span><br><span class="line">    active_class_ids = Lambda(<span class="keyword">lambda</span> x: parse_image_meta_graph(x)[<span class="string">&quot;active_class_ids&quot;</span>])(input_image_meta)</span><br></pre></td></tr></table></figure><p>输入参数有三个分别是<code>rpn_class</code>、<code>rpn_bbox</code>、<code>anchors</code>，这里的<code>rpn_class</code>代表所有先验框是否包含物体的置信度，<code>rpn_bbox</code>代表所有先验框的调整参数，<code>anchors</code>之前获得的所有先验框。</p><p>其中<code>ProposalLayer</code>的具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   Proposal Layer</span></span><br><span class="line"><span class="comment">#   该部分代码用于将先验框转化成建议框</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProposalLayer</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, proposal_count, nms_threshold, config=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(ProposalLayer, self).__init__(**kwargs)</span><br><span class="line">        self.config = config</span><br><span class="line">        self.proposal_count = proposal_count</span><br><span class="line">        self.nms_threshold = nms_threshold</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   输入的inputs有三个内容</span></span><br><span class="line">        <span class="comment">#   inputs[0]   rpn_class   : Batch_size, num_anchors, 2</span></span><br><span class="line">        <span class="comment">#   inputs[1]   rpn_bbox    : Batch_size, num_anchors, 4</span></span><br><span class="line">        <span class="comment">#   inputs[2]   anchors     : Batch_size, num_anchors, 4</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框内部是否有物体[Batch_size, num_anchors, 1]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        scores = inputs[<span class="number">0</span>][:, :, <span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框的调整参数[batch, num_rois, 4]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        deltas = inputs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框的坐标</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        anchors = inputs[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   RPN_BBOX_STD_DEV[0.1 0.1 0.2 0.2] 改变数量级</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        deltas = deltas * np.reshape(self.config.RPN_BBOX_STD_DEV, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   筛选出得分前6000个的框</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        pre_nms_limit = tf.minimum(self.config.PRE_NMS_LIMIT, tf.shape(anchors)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得这些框的索引</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        ix = tf.nn.top_k(scores, pre_nms_limit, <span class="built_in">sorted</span>=<span class="literal">True</span>, name=<span class="string">&quot;top_anchors&quot;</span>).indices</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框、及其得分与调整参数</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        scores = batch_slice([scores, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)</span><br><span class="line">        deltas = batch_slice([deltas, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)</span><br><span class="line">        pre_nms_anchors = batch_slice([anchors, ix], <span class="keyword">lambda</span> a, x: tf.gather(a, x), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;pre_nms_anchors&quot;</span>])</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   [batch, pre_nms_limit, (y1, x1, y2, x2)]</span></span><br><span class="line">        <span class="comment">#   对先验框进行解码</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        boxes = batch_slice([pre_nms_anchors, deltas], <span class="keyword">lambda</span> x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;refined_anchors&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   [batch, pre_nms_limit, (y1, x1, y2, x2)]</span></span><br><span class="line">        <span class="comment">#   防止超出图片范围</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        window = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=np.float32)</span><br><span class="line">        boxes = batch_slice(boxes, <span class="keyword">lambda</span> x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;refined_anchors_clipped&quot;</span>])</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#---------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   在非极大抑制后</span></span><br><span class="line">        <span class="comment">#   获得一个shape为[batch, NMS_ROIS, 4]的proposals</span></span><br><span class="line">        <span class="comment">#---------------------------------------------------------#</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">nms</span>(<span class="params">boxes, scores</span>):</span><br><span class="line">            indices = tf.image.non_max_suppression(boxes, scores, self.proposal_count, self.nms_threshold, name=<span class="string">&quot;rpn_non_max_suppression&quot;</span>)</span><br><span class="line">            proposals = tf.gather(boxes, indices)</span><br><span class="line">            padding = tf.maximum(self.proposal_count - tf.shape(proposals)[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            proposals = tf.pad(proposals, [(<span class="number">0</span>, padding), (<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">            <span class="keyword">return</span> proposals</span><br><span class="line">        proposals = batch_slice([boxes, scores], nms, self.config.IMAGES_PER_GPU)</span><br><span class="line">        <span class="keyword">return</span> proposals</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_output_shape</span>(<span class="params">self, input_shape</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, self.proposal_count, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>其中利用到了下面的函数对建议框的位置和长宽进行调整</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   利用先验框调整参数调整先验框，获得建议框的坐标</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_box_deltas_graph</span>(<span class="params">boxes, deltas</span>):</span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    height = boxes[:, <span class="number">2</span>] - boxes[:, <span class="number">0</span>]</span><br><span class="line">    width = boxes[:, <span class="number">3</span>] - boxes[:, <span class="number">1</span>]</span><br><span class="line">    center_y = boxes[:, <span class="number">0</span>] + <span class="number">0.5</span> * height</span><br><span class="line">    center_x = boxes[:, <span class="number">1</span>] + <span class="number">0.5</span> * width</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算出调整后的先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    center_y += deltas[:, <span class="number">0</span>] * height</span><br><span class="line">    center_x += deltas[:, <span class="number">1</span>] * width</span><br><span class="line">    height *= tf.exp(deltas[:, <span class="number">2</span>])</span><br><span class="line">    width *= tf.exp(deltas[:, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算左上角和右下角的点的坐标</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    y1 = center_y - <span class="number">0.5</span> * height</span><br><span class="line">    x1 = center_x - <span class="number">0.5</span> * width</span><br><span class="line">    y2 = y1 + height</span><br><span class="line">    x2 = x1 + width</span><br><span class="line"></span><br><span class="line">    result = tf.stack([y1, x1, y2, x2], axis=<span class="number">1</span>, name=<span class="string">&quot;apply_box_deltas_out&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="2-6-利用建议框对共享特征层进行截取">2.6 利用建议框对共享特征层进行截取</h2><p>ROI Align层的作用就是根据建议框对不同的特征层进行截取。主要代码如下，其功能就是根据建议框的大小，判断建议框属于哪一个特征层，然后利用建议框对对应的特征层进行截取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用建议框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]</span></span><br><span class="line">    <span class="comment">#   pool_size 是对共享特征层截取后resize后的局部特征层的大小</span></span><br><span class="line">    <span class="comment">#   rois是初步筛选后的建议框</span></span><br><span class="line">    <span class="comment">#   image_meta是保存了图片的必要信息</span></span><br><span class="line">    <span class="comment">#   feature_maps共享特征层</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_classifier&quot;</span>)([rois, image_meta] + feature_maps)</span><br></pre></td></tr></table></figure><p>其中<code>PyramidROIAlign</code>函数的定义如下：</p><p>首先获取建议框的坐标、图片信息、特征层。然后根据建议框的大小，判断建议框属于哪一个特征层（较大的特征层比如256x256的，网格划分密集，每一个建议框大小比较小，以此判断）。利用循环对于P2~P5五个特征层进行截取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   ROIAlign Layer</span></span><br><span class="line"><span class="comment">#   利用建议框在特征层上截取内容</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyramidROIAlign</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pool_shape, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(PyramidROIAlign, self).__init__(**kwargs)</span><br><span class="line">        self.pool_shape = <span class="built_in">tuple</span>(pool_shape)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得建议框的坐标</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        boxes = inputs[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   image_meta包含了一些必要的图片信息</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_meta = inputs[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   取出所有的特征层[batch, height, width, channels]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        feature_maps = inputs[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得建议框的宽高</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        y1, x1, y2, x2 = tf.split(boxes, <span class="number">4</span>, axis=<span class="number">2</span>)</span><br><span class="line">        h = y2 - y1</span><br><span class="line">        w = x2 - x1</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得输入进来的图像的大小，对image的内容进行分割</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_shape = parse_image_meta_graph(image_meta)[<span class="string">&#x27;image_shape&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   通过建议框的大小找到这个建议框属于哪个特征层，第一层256划分区域多建议框较小32</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_area = tf.cast(image_shape[<span class="number">0</span>] * image_shape[<span class="number">1</span>], tf.float32)</span><br><span class="line">        roi_level = log2_graph(tf.sqrt(h * w) / (<span class="number">224.0</span> / tf.sqrt(image_area)))</span><br><span class="line">        roi_level = tf.minimum(<span class="number">5</span>, tf.maximum(<span class="number">2</span>, <span class="number">4</span> + tf.cast(tf.<span class="built_in">round</span>(roi_level), tf.int32)))</span><br><span class="line">        <span class="comment"># roi_level是每张图片里每个建议框对应的特征层是哪个</span></span><br><span class="line">        roi_level = tf.squeeze(roi_level, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        pooled = []</span><br><span class="line">        box_to_level = []</span><br><span class="line">        <span class="comment"># 分别在P2-P5中进行截取</span></span><br><span class="line">        <span class="keyword">for</span> i, level <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>)):</span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            <span class="comment">#   找到每个特征层对应的建议框</span></span><br><span class="line">            <span class="comment">#   level_boxes存放所有属于该特征层的建议框</span></span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            ix = tf.where(tf.equal(roi_level, level))</span><br><span class="line">            level_boxes = tf.gather_nd(boxes, ix)</span><br><span class="line">            box_to_level.append(ix)</span><br><span class="line">  </span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            <span class="comment">#    获得这些建议框所属的图片</span></span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            box_indices = tf.cast(ix[:, <span class="number">0</span>], tf.int32)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 停止梯度下降</span></span><br><span class="line">            level_boxes = tf.stop_gradient(level_boxes)</span><br><span class="line">            box_indices = tf.stop_gradient(box_indices)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">            <span class="comment">#   利用建议框对特征层进行截取  </span></span><br><span class="line">            <span class="comment">#   [batch * num_boxes, pool_height, pool_width, channels]</span></span><br><span class="line">            <span class="comment">#   box_indices表示是截取哪张图片里的特征层</span></span><br><span class="line">            <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">            pooled.append(tf.image.crop_and_resize(</span><br><span class="line">                feature_maps[i], level_boxes, box_indices, self.pool_shape,</span><br><span class="line">                method=<span class="string">&quot;bilinear&quot;</span>))</span><br><span class="line"></span><br><span class="line">        pooled = tf.concat(pooled, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   将顺序和所属的图片进行堆叠</span></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        box_to_level = tf.concat(box_to_level, axis=<span class="number">0</span>)</span><br><span class="line">        box_range = tf.expand_dims(tf.<span class="built_in">range</span>(tf.shape(box_to_level)[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">        box_to_level = tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># box_to_level[:, 0]表示第几张图</span></span><br><span class="line">        <span class="comment"># box_to_level[:, 1]表示第几张图里的第几个框</span></span><br><span class="line">        sorting_tensor = box_to_level[:, <span class="number">0</span>] * <span class="number">100000</span> + box_to_level[:, <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 进行排序，将同一张图里的某一些聚集在一起</span></span><br><span class="line">        ix = tf.nn.top_k(sorting_tensor, k=tf.shape(</span><br><span class="line">            box_to_level)[<span class="number">0</span>]).indices[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按顺序获得图片的索引</span></span><br><span class="line">        ix = tf.gather(box_to_level[:, <span class="number">2</span>], ix)</span><br><span class="line">        pooled = tf.gather(pooled, ix)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   重新reshape为如下</span></span><br><span class="line">        <span class="comment">#   [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]</span></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        shape = tf.concat([tf.shape(boxes)[:<span class="number">2</span>], tf.shape(pooled)[<span class="number">1</span>:]], axis=<span class="number">0</span>)</span><br><span class="line">        pooled = tf.reshape(pooled, shape)</span><br><span class="line">        <span class="keyword">return</span> pooled</span><br></pre></td></tr></table></figure><h2 id="2-7-局部公用特征层到预测结果">2.7 局部公用特征层到预测结果</h2><p>如何利用调整后的局部特征层获得预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    mrcnn_class_logits, mrcnn_class, mrcnn_bbox =\</span><br><span class="line"></span><br><span class="line">        fpn_classifier_graph(rpn_rois, mrcnn_feature_maps, input_image_meta,</span><br><span class="line"></span><br><span class="line">                                config.POOL_SIZE, config.NUM_CLASSES,</span><br><span class="line"></span><br><span class="line">                                train_bn=config.TRAIN_BN,</span><br><span class="line"></span><br><span class="line">                                fc_layers_size=config.FPN_CLASSIF_FC_LAYERS_SIZE)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立classifier模型，该函数主要实现目标检测功能</span></span><br><span class="line"><span class="comment">#   这个模型的预测结果会调整建议框</span></span><br><span class="line"><span class="comment">#   获得最终的预测框</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fpn_classifier_graph</span>(<span class="params">rois, feature_maps, image_meta,</span></span><br><span class="line"><span class="params">                         pool_size, num_classes, train_bn=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">                         fc_layers_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用建议框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]，调整后的局部特征层</span></span><br><span class="line">    <span class="comment">#   pool_size 是对共享特征层截取后resize后的局部特征层的大小</span></span><br><span class="line">    <span class="comment">#   rois是初步筛选后的建议框</span></span><br><span class="line">    <span class="comment">#   image_meta是保存了图片的必要信息</span></span><br><span class="line">    <span class="comment">#   feature_maps共享特征层</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_classifier&quot;</span>)([rois, image_meta] + feature_maps)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   利用卷积进行特征整合，首先进行7x7的卷积，相当于两次全连接</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, 1, 1, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(fc_layers_size, (pool_size, pool_size), padding=<span class="string">&quot;valid&quot;</span>),  name=<span class="string">&quot;mrcnn_class_conv1&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_class_bn1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, 1, 1, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(fc_layers_size, (<span class="number">1</span>, <span class="number">1</span>)), name=<span class="string">&quot;mrcnn_class_conv2&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_class_bn2&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    shared = Lambda(<span class="keyword">lambda</span> x: K.squeeze(K.squeeze(x, <span class="number">3</span>), <span class="number">2</span>),  name=<span class="string">&quot;pool_squeeze&quot;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   Classifier head</span></span><br><span class="line">    <span class="comment">#   这个的预测结果代表这个先验框内部的物体的种类</span></span><br><span class="line">    <span class="comment">#   mrcnn_probs   : [batch, num_rois, num_classes]，每一张图片里，每一个先验框里面，物体的种类</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    mrcnn_class_logits = TimeDistributed(Dense(num_classes), name=<span class="string">&#x27;mrcnn_class_logits&#x27;</span>)(shared)</span><br><span class="line">    mrcnn_probs = TimeDistributed(Activation(<span class="string">&quot;softmax&quot;</span>), name=<span class="string">&quot;mrcnn_class&quot;</span>)(mrcnn_class_logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   BBox head</span></span><br><span class="line">    <span class="comment">#   这个的预测结果会对先验框进行调整</span></span><br><span class="line">    <span class="comment">#   mrcnn_bbox : [batch, num_rois, num_classes, 4]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Dense(num_classes * <span class="number">4</span>, activation=<span class="string">&#x27;linear&#x27;</span>), name=<span class="string">&#x27;mrcnn_bbox_fc&#x27;</span>)(shared)</span><br><span class="line">    mrcnn_bbox = Reshape((-<span class="number">1</span>, num_classes, <span class="number">4</span>), name=<span class="string">&quot;mrcnn_bbox&quot;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mrcnn_class_logits, mrcnn_probs, mrcnn_bbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立mask模型</span></span><br><span class="line"><span class="comment">#   这个模型会利用预测框对特征层进行ROIAlign</span></span><br><span class="line"><span class="comment">#   根据截取下来的特征层进行语义分割</span></span><br><span class="line"><span class="comment">#----------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fpn_mask_graph</span>(<span class="params">rois, feature_maps, image_meta,</span></span><br><span class="line"><span class="params">                         pool_size, num_classes, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用预测框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, channels</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_mask&quot;</span>)([rois, image_meta] + feature_maps)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv1&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv2&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn2&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv3&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn3&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv4&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn4&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, 2xMASK_POOL_SIZE, 2xMASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2DTranspose(<span class="number">256</span>, (<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, activation=<span class="string">&quot;relu&quot;</span>), name=<span class="string">&quot;mrcnn_mask_deconv&quot;</span>)(x)</span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   反卷积后再次进行一个1x1卷积调整通道，</span></span><br><span class="line">    <span class="comment">#   使其最终数量为numclasses，代表分的类</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, 2xMASK_POOL_SIZE, 2xMASK_POOL_SIZE, numclasses</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(num_classes, (<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>), name=<span class="string">&quot;mrcnn_mask&quot;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="2-8-建议框调整获得预测框">2.8 建议框调整获得预测框</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   detections          : Batch_size, num_detections, 6</span></span><br><span class="line"><span class="comment">#   detection_boxes     : Batch_size, num_detections, 4</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">detections = DetectionLayer(config, name=<span class="string">&quot;mrcnn_detection&quot;</span>)([rpn_rois, mrcnn_class, mrcnn_bbox, input_image_meta])</span><br><span class="line">detection_boxes = Lambda(<span class="keyword">lambda</span> x: x[..., :<span class="number">4</span>])(detections)</span><br></pre></td></tr></table></figure><p>我们的工作都发生在<code>DetectionLayer</code>四个参数分别是rpn_rois建议框、mrcnn_class建议内部物体的置信度、mrcnn_bbox建议框的调整参数、input_image_meta输入图片的基本信息。</p><p>其中<code>DetectionLayer</code>的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   Detection Layer</span></span><br><span class="line"><span class="comment">#   利用classifier的预测结果对建议框进行调整获得预测框</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DetectionLayer</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(DetectionLayer, self).__init__(**kwargs)</span><br><span class="line">        self.config = config</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得的inputs</span></span><br><span class="line">        <span class="comment">#   rpn_rois            : Batch_size, proposal_count, 4</span></span><br><span class="line">        <span class="comment">#   mrcnn_class         : Batch_size, num_rois, num_classes</span></span><br><span class="line">        <span class="comment">#   mrcnn_bbox          : Batch_size, num_rois, num_classes, </span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        rois = inputs[<span class="number">0</span>]</span><br><span class="line">        mrcnn_class = inputs[<span class="number">1</span>]</span><br><span class="line">        mrcnn_bbox = inputs[<span class="number">2</span>]</span><br><span class="line">        image_meta = inputs[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   找到window的小数形式，指出原始的图片在调整后（加灰条）图片中的位置</span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        m = parse_image_meta_graph(image_meta)</span><br><span class="line">        image_shape = m[<span class="string">&#x27;image_shape&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        window = norm_boxes_graph(m[<span class="string">&#x27;window&#x27;</span>], image_shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   对每一张图的结果进行解码</span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        detections_batch = batch_slice(</span><br><span class="line">            [rois, mrcnn_class, mrcnn_bbox, window],</span><br><span class="line">            <span class="keyword">lambda</span> x, y, w, z: refine_detections_graph(x, y, w, z, self.config),</span><br><span class="line">            self.config.IMAGES_PER_GPU)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   最终输出的shape为</span></span><br><span class="line">        <span class="comment">#   Batch_size, num_detections, 6] </span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">        <span class="keyword">return</span> tf.reshape(</span><br><span class="line">            detections_batch,</span><br><span class="line">            [self.config.BATCH_SIZE, self.config.DETECTION_MAX_INSTANCES, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><h1>三、创建自己的数据集</h1><h2 id="3-1-安装labelme">3.1 安装labelme</h2><p>打开cmd窗口，输入<code>activate tensorflow2</code>激活自己的anaconda环境。</p><p>然后安装labelme</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme</span><br></pre></td></tr></table></figure><p>安装完成后直接在命令行输入<code>labelme</code>即可打开。</p><p>使用label进行标注</p><h2 id="3-2-开始训练">3.2 开始训练</h2><p>运行<code>json_to_dataset.py</code>将标注的json图像转换为数据集。</p><p>在<code>dataset.py</code>中的<code>load_shapes</code>中添加自己的分类，同时在最后的循环中也添加自己的分类。</p><p>在<code>train.py</code>的<code>ShapesConfig</code>修改图片大小，<code>IMAGE_MIN_DIM</code>和<code>IMAGE_MAX_DIM</code>两个图片大小可以一样，<code>NUM_CLASSES</code>后面的数字是分的类</p>]]></content>
    
    
    <summary type="html">Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何理解卷积神经网络中的通道channel</title>
    <link href="https://www.mahaofei.com/post/e8acb40e.html"/>
    <id>https://www.mahaofei.com/post/e8acb40e.html</id>
    <published>2022-05-16T08:28:07.000Z</published>
    <updated>2022-05-16T08:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是通道channel">什么是通道channel</h2><blockquote><p><a href="https://blog.csdn.net/sscc_learning/article/details/79814146">【CNN】理解卷积神经网络中的通道 channel</a></p></blockquote><p>首先，是 <a href="https://www.tensorflow.org/tutorials/layers">tensorflow</a> 中给出的，对于输入样本中 <code>channels</code> 的含义。一般的RGB图片，<code>channels</code> 数量是 3 （红、绿、蓝）；而monochrome图片，<code>channels</code> 数量是 1 。</p><p>其次，<a href="http://mxnet.incubator.apache.org/api/python/gluon/nn.html#mxnet.gluon.nn.Conv2D">mxnet</a> 中提到的，一般 <code>channels</code> 的含义是，<strong>每个卷积层中卷积核的数量</strong>。</p><p>举例：假设现有一个为 6×6×3 的图片样本，使用 3×3×3 的卷积核（filter）进行卷积操作。此时输入图片的 channels 为 3 ，而卷积核中的 in_channels 与 需要进行卷积操作的数据的 channels 一致（这里就是图片样本，为3）。</p><p>接下来，进行卷积操作，卷积核中的27个数字与分别与样本对应相乘后，再进行求和，得到第一个结果。依次进行，最终得到 4×4 的结果。</p><p><img src="https://img.mahaofei.com/img/20220624185902.png" alt=""></p><p>上面步骤完成后，由于只有一个卷积核，所以最终得到的结果为 4×4×1 ， out_channels 为 1 。</p><p>在实际应用中，都会使用多个卷积核。这里如果再加一个卷积核，就会得到 4×4×2 的结果。</p><p><img src="https://img.mahaofei.com/img/20220624185923.png" alt=""></p><p><strong>总结</strong></p><ul><li>最初输入的图片样本的 <code>channels</code> ，取决于图片类型，比如RGB；</li><li>卷积操作完成后输出的 <code>out_channels</code> ，取决于卷积核的数量。此时的 <code>out_channels</code> 也会作为下一次卷积时的卷积核的 <code>in_channels</code>；</li><li>卷积核中的 <code>in_channels</code> ，就是上一次卷积的 <code>out_channels</code> ，如果是第一次做卷积，就是1中样本图片的 <code>channels</code> 。</li></ul>]]></content>
    
    
    <summary type="html">一般channels的含义是，每个卷积层中卷积核的数量。最初输入的图片样本的channels，取决于图片类型，比如RGB；卷积操作完成后输出的out_channels，取决于卷积核的数量。此时的out_channels也会作为下一次卷积时的卷积核的in_channels。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.mahaofei.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>卷积是如何计算的</title>
    <link href="https://www.mahaofei.com/post/9c39ef87.html"/>
    <id>https://www.mahaofei.com/post/9c39ef87.html</id>
    <published>2022-05-16T08:26:41.000Z</published>
    <updated>2022-05-20T08:26:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是多卷积核">1 什么是多卷积核</h2><h3 id="1-1-卷积">1.1 卷积</h3><p>从本质上讲，卷积的计算过程其实同全连接一样，也是各个神经元之间的线性组合。只是卷积操作在进行线性组合时选择的是特定位置上的神经元。下面我们首先通过一张动图来直观感受一下卷积的过程。</p><p><img src="https://pic2.zhimg.com/v2-5efbada1d4bb599e6195ce819aa7ebd9_b.webp" alt=""></p><p>如图所示，**卷积操作其实就是每次取一个特定大小的矩阵F（蓝色矩阵中的阴影部分），然后将其对输入X（图中蓝色矩阵）依次扫描并进行内积的运算过程。可以看到，阴影部分每移动一个位置就会计算得到一个卷积值（绿色矩阵中的阴影部分），当F扫描完成后就得到了整个卷积后的结果Y（绿色矩阵）。</p><p>同时，我们将这个特定大小的矩阵F称为<strong>卷积核</strong>，即convolutional kernel或kernel或filter或detector，它可以是一个也可以是多个；将卷积后的结果Y称为<strong>特征图</strong>，即feature map，并且每一个卷积核卷积后都会得到一个对应的特征图；最后，对于输入X)的形状，都会用三个维度来进行表示，即宽（width），高（high）和通道（channel）。例如图中输入X的形状为<code>[7,7,1]</code>。</p><h3 id="2-2-多卷积核"><strong>2.2 多卷积核</strong></h3><p>注意，在上面笔者提到了卷积核的个数还可以是多个，那我们为什么需要多个卷积核进行卷积呢？在<strong>上一篇文章</strong>中我们介绍到：<strong>对于一个卷积核，可以认为其具有识别某一类元素（特征）的能力</strong>；而对于一些复杂的数据来说，仅仅只是通过一类特征来进行辨识往往是不够的。因此，通常来说我们都会通过多个不同的卷积核来对输入进行特征提取得到多个特征图，然再输入到后续的网络中。</p><p><img src="https://vdn1.vzuu.com/SD/d64a45c6-ec4a-11ea-acfd-5ab503a75443.mp4?disable_local_cache=1&amp;bu=078babd7&amp;c=avc.0.0&amp;f=mp4&amp;expiration=1653035766&amp;auth_key=1653035766-0-0-efb78e5addfa03be68c1bf73f4a28bd9&amp;v=hw&amp;pu=078babd7" alt=""></p><p>对于同一个输入，通过两个不同的卷积核对其进行卷积特征提取，最后便能得到两个不同的特征图。从图右边的特征图可以发现，上面的特征图在锐利度方面明显会强于下面的特征图。当然，这也是使用多卷积核进行卷积的意义，探测到多种特征属性以有利于后续的下游任务。</p><h2 id="3-卷积的计算"><strong>3 卷积的计算</strong></h2><p>到此为止， 对于卷积的原理和意义就算是交待完了，并且通过这些动态图片的展示，我们也有了更为直观的了解。但所谓数无形时少直觉，形少数时难入微。因此，下面我们就以单通道（灰度图）和三通道的输入来实际计算一下整个卷积的过程。</p><h3 id="3-1-单通道单卷积核"><strong>3.1 单通道单卷积核</strong></h3><p>如下图所示，现在有一张形状为<code>[5,5,1]</code>的灰度图，我们需要用图3右边的卷积核对其进行卷积处理，同时再考虑到偏置的作用。那么其计算过程是怎么样的呢？</p><p><img src="https://pic3.zhimg.com/80/v2-41ea774397ab503144f2e410e3b91846_720w.jpg" alt=""></p><p>如下图所示，右边为卷积后的特征图（feature map），左边为卷积核对输入图片左上放进行卷积时的示意图。因此，对于这个部分的计算过程有：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cunderbrace%7B1%5Ccdot0%2B2%5Ccdot0%2B0%5Ccdot1-1%5Ccdot0%2B1%5Ccdot1%2B0%5Ccdot1%2B2%5Ccdot1-1%5Ccdot0-2%5Ccdot1%7D_%7Bkernel%7D%5Cunderbrace%7B%5C%3B%5C%3B%2B1%5C%3B%5C%3B%7D_%7Bbias%7D%3D2%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%281%29+%5C%5C" alt=""></p><p><img src="https://pic1.zhimg.com/80/v2-f3cbc9092253d32f9faef27431094794_720w.jpg" alt=""></p><p>同理，对于最右下角部分卷积计算过程有：</p><p><img src="https://www.zhihu.com/equation?tex=2%5Ccdot0%2B1%5Ccdot0%2B0%5Ccdot1%2B0%5Ccdot0%2B0%5Ccdot1%2B0%5Ccdot1-1%5Ccdot1%2B0%5Ccdot0-0%5Ccdot1%2B1%3D0%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%282%29+%5C%5C" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-34b0159c662de8c287e47afa4e05351b_720w.jpg" alt=""></p><p>因此，对于最后卷积的结果，我们得到的将是一个如上图右边所示形状为<code>[3,3,1]</code>的特征图。到此我们就把单通道单卷积的计算过程介绍完了。下面我们再来看单通道多卷积核的例子。</p><h3 id="3-2-单通道多卷积核"><strong>3.2 单通道多卷积核</strong></h3><p>如下图所示，左边依旧为输入矩阵，我们现在要用右边所示的两个卷积核对其进行卷积处理。</p><p><img src="https://pic1.zhimg.com/80/v2-28512602aa1cc0d5cbbd3728f1b71bd0_720w.jpg" alt=""></p><p>以右侧的卷积核为例，其计算过程如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-8d78e0ca38adc64c36aa4a8bb4c605b0_720w.jpg" alt=""></p><p>最后我们便能得到如下右边所示的，形状为<code>[3,3,2]</code>的卷积特征图，其中2表示两个特征通道。</p><p><img src="https://pic2.zhimg.com/80/v2-867e4addafd9d5146d7be731cd94a8d5_720w.jpg" alt=""></p><p>到此，对于单通道的卷积计算过程就介绍完了。但通常情况下，我们遇到得更多的就是对多通道的输入进行卷积处理，例如包含有RGB三个通道的彩色图片等。接下来，笔者就开始介绍多通道的卷积计算过程。</p><h3 id="3-3-多通道单卷积核"><strong>3.3 多通道单卷积核</strong></h3><p>对于多通道的卷积过程，总体上还是还是同之前的一样，都是每次选取特定位置上的神经元进行卷积，然后依次移动直到卷积结束。下面我们先来看看多通道单卷积核的计算过程。</p><p><img src="https://pic3.zhimg.com/80/v2-74b6e3cb4f6f1714e05325c068ece3e6_720w.jpg" alt=""></p><p>如图所示，左边为包含有三个通道的输入，右边为一个卷积核和一个偏置。<strong>注意，强调一下右边的仅仅只是一个卷积核，不是三个</strong>。笔者看到不少人在这个地方都会搞错。因为输入是三个通道，所以在进行卷积的时候，对应的每一个卷积核都必须要有三个通道才能进行卷积。下面我们就来看看具体的计算过程。</p><p><img src="https://pic1.zhimg.com/80/v2-b9b793a795f06aa1830a784ad82ccf14_720w.jpg" alt=""></p><p>如图所示，右边为卷积后的特征图（feature map），左边为一个三通道的卷积核对输入图片左上放进行卷积时的示意图。因此，对于这个部分的计算过程有：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%26%5Cunderbrace%7B%280%5Ccdot2%2B2%5Ccdot0%2B0%5Ccdot0%2B0%5Ccdot1%2B2%5Ccdot0%2B0%5Ccdot1%2B2%5Ccdot0%2B1%5Ccdot3%2B2%5Ccdot0%29%7D_%7Bchannel+%5C%3B1%7D%5C%5C+%2B%26+%5Cunderbrace%7B%280%5Ccdot1%2B0%5Ccdot0%2B0%5Ccdot1%2B1%5Ccdot0%2B0%5Ccdot0%2B0%5Ccdot0%2B1%5Ccdot1%2B0%5Ccdot1%2B0%5Ccdot1%29%7D_%7Bchannel%5C%3B2%7D%5C%5C+%2B%26+%5Cunderbrace%7B%281%5Ccdot0%2B1%5Ccdot0%2B0%5Ccdot1%2B0%5Ccdot1%2B1%5Ccdot1%2B0%5Ccdot1%2B0%5Ccdot1%2B1%5Ccdot1%2B1%5Ccdot0%29%7D_%7Bchannel+3%7D%5C%5C+%2B%26%5Cunderbrace%7B%5C%3B%5C%3B1%5C%3B%5C%3B%7D_%7B%5C%3B%5C%3Bbias%5C%3B%5C%3B%7D%5C%5C+%3D%263%2B1%2B2%2B1%3D7+%5Cend%7Baligned%7D%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%283%29+%5C%5C" alt=""></p><p>同理，对于其它部分的卷积计算过程也类似于上述计算步骤。由此我们便能得到如图10右边所示卷积后的形状为<code>[3,3,1]</code>的特征图。</p><h3 id="3-4-多通道多卷积核"><strong>3.4 多通道多卷积核</strong></h3><p>在介绍完多通道单卷积核的计算过程后，我们再来看看多通道多卷积核的计算过程。</p><p><img src="https://pic2.zhimg.com/80/v2-a49ca8fccf9423b68350a2948c58df69_720w.jpg" alt=""></p><p>如图所示，左边依旧为输入矩阵，我们现在要用右边所示的<strong>两个卷积核</strong>对其进行卷积处理。对于第二个卷积核，其计算过程也和式子(3)类似，都是将每个通道上的卷积结果进行相加，最后再加上偏置。因此，最后我们便能得到如图12右边所示的，形状为<code>[3,3,2]</code>的卷积特征图，其中2表示两个特征通道。</p><p><img src="https://pic2.zhimg.com/80/v2-1ba1b27de724a353656802d32d41c891_720w.jpg" alt=""></p><p>同时，从上面单通道卷积核多通道卷积的计算过程可以发现：</p><p>（1）原始输入有多少个通道，其对应的<strong>一个卷积核</strong>就必须要有多少个通道，这样才能与输入进行匹配，也才能完成卷积操作。换句话说，如果输入数据的形状为<code>[n,n,c]</code>，那么对应每个卷积核的通道数也必须为<code>c</code>。</p><p>（2）用<code>k</code>个卷积核对输入进行卷积处理，那么最后得到的特征图一定就会包含有<code>k</code>个通道。例如，输入为<code>[n,n,c]</code>，且用<code>k</code>个卷积核对其进行卷积，则卷积核的形状必定为<code>[w1,w2,c,k]</code>，最终得到的特征图形状必定为<code>[h1,h2,k]</code>；其中<code>w1,w2</code>为卷积核的宽度，<code>h1,h2</code>为卷积后特征图的宽度。</p>]]></content>
    
    
    <summary type="html">卷积操作其实就是每次取一个特定大小的矩阵，然后将其对输入矩阵依次扫描并进行内积的运算过程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.mahaofei.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>深度学习环境配置CUDA+TensorFlow2+Keras</title>
    <link href="https://www.mahaofei.com/post/a858b698.html"/>
    <id>https://www.mahaofei.com/post/a858b698.html</id>
    <published>2022-05-16T03:03:16.000Z</published>
    <updated>2022-05-20T03:03:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Anaconda</h1><p>Anaconda是管理各个python包的工具，这里我们主要使用的是numpy，以及其他的一些常用包。</p><p>Anaconda官网链接：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p><p>各个系统版本的Anaconda安装程序都可以直接下载安装即可，相关使用方法可以参考<a href="https://www.mahaofei.com/post/8543c9d.html">该文章</a></p><h1>CUDA</h1><ol><li>首先<strong>查看自己电脑GPU对应的cuda版本</strong>，如图所示<strong>打开 NVIDIA控制面板-&gt;帮助-&gt;系统信息-&gt;组件</strong>（可在控制中心或右下角通知栏打开），我这里GPU对应的cuda版本是11.6.106，所以安装的cuda不能超过这个版本。</li></ol><p><img src="https://img.mahaofei.com/img/20220515111335.png" alt=""></p><p>或者在cmd命令行输入<code>nvidia-smi</code>也可以查看CUDA版本。</p><ol start="2"><li><strong>进入<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a>网站</strong>选择低于刚才查到的版本的cudatoolkit，本文选择CUDA Toolkit 11.0 Update 3，<strong>下载安装包</strong>约2.7G。</li></ol><blockquote><p>注意：这里选择的cuda版本会决定后面安装cudnn和tensorflow-gpu的版本，三者是相关的，如果版本不匹配将无法使用，具体匹配版本参考<a href="https://tensorflow.google.cn/install/source_windows">https://tensorflow.google.cn/install/source_windows</a>，下表为节选。</p></blockquote><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">Python 版本</th><th style="text-align:left">编译器</th><th style="text-align:left">构建工具</th><th style="text-align:left">cuDNN</th><th style="text-align:left">CUDA</th></tr></thead><tbody><tr><td style="text-align:left">tensorflow_gpu-2.6.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.5.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.4.0</td><td style="text-align:left">3.6-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">8.0</td><td style="text-align:left">11.0</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.3.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.2.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 2.0.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.1.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 0.27.1-0.29.1</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.0.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.15.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.14.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.24.1-0.25.2</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.13.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2015 update 3</td><td style="text-align:left">Bazel 0.19.0-0.21.0</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/20220515141105.png" alt=""></p><ol start="3"><li>双击下载的<strong>exe安装包</strong>，选择<strong>临时解压</strong>位置，然后点击ok，解压时间两分钟左右。</li></ol><p><img src="https://img.mahaofei.com/img/20220515140740.png" alt=""></p><ol start="4"><li><strong>同意许可协议</strong>，然后选择<strong>自定义安装</strong>选项，然后点击<strong>下一步</strong></li></ol><p><img src="https://img.mahaofei.com/img/20220515141240.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220515141310.png" alt=""></p><ol start="5"><li>选择驱动程序组件，一定要<strong>勾选CUDA</strong>，然后点击<strong>下一步</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141348.png" alt=""></p><ol start="6"><li>选择自己电脑上的一个安装位置，然后<strong>开始安装</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141701.png" alt=""></p><ol start="7"><li><p><strong>等待安装结束</strong>，本电脑18年笔记本机械硬盘安装<strong>耗时约5分钟</strong></p></li><li><p><strong>检查环境变量</strong>，一般安装完成后会自动配置好环境变量，打开<strong>设置-系统-系统信息-高级系统设置-环境变量</strong>进行检查，如果没有则需要自行添加（注意添加时修改成自己的安装路径）</p></li></ol><ul><li>系统变量中是否有<strong>CUDA</strong>和<strong>NVCUDASAMPLES</strong>两组环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142616.png" alt=""></p><ul><li>打开系统变量的Path，查看是否有以下环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142701.png" alt=""></p><ol start="9"><li>CUDA安装完成</li></ol><h1>cnDNN</h1><ol><li>打开<a href="https://developer.nvidia.com/rdp/cudnn-archive">cudnn官网</a>，根据上面的表格查看自己应该下载的cuDNN版本，我的CUDA版本为11.0，对应cuDNN版本为8.0，注意看清cuDNN后面有对应的CUDA版本，一个cuDNN可能对应多个版本的CUDA，下载时会要求先注册NVIDIA账号。</li></ol><p><img src="https://img.mahaofei.com/img/20220515140956.png" alt=""></p><ol start="2"><li>解压文件，将解压后的文件移动到CUDA对应的安装目录中</li></ol><p><img src="https://img.mahaofei.com/img/20220515143854.png" alt=""></p><ol start="3"><li>cuDNN安装完成</li></ol><h1>安装TensorFlow</h1><ol><li>打开cmd命令行界面（建议以管理员身份打开），切换opentuna的pip镜像源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://opentuna.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><ol start="2"><li>创建虚拟环境，后面跟的是电脑安装的python版本，注意是否与</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow2 python=3.8</span><br></pre></td></tr></table></figure><ol start="3"><li>激活虚拟环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflow2</span><br></pre></td></tr></table></figure><ol start="4"><li>安装tensorflow，具体版本号根据上面的表格对应。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-gpu==2.3.0</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220515145711.png" alt=""></p><ol start="5"><li>验证安装是否成功，打开cmd界面，输入以下命令，查看输出是否Successfly</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220515154240.png" alt=""></p><p>如果出现<code>Could not load dynamic library 'cudart64_110.dll'</code>不要慌，说明安装完成之后没有重启电脑，重启再运行就好了。</p><h1>Keras</h1><ol><li>TensorFlow与Keras版本对应参考下表</li></ol><table><thead><tr><th>Tensorflow</th><th>Keras</th></tr></thead><tbody><tr><td>TensorFlow 2.0.0</td><td>Keras 2.3.1</td></tr><tr><td>TensorFlow 2.1.0</td><td>Keras 2.3.1</td></tr><tr><td>TensorFlow 2.2.0</td><td>Keras 2.3.1</td></tr><tr><td>TensorFlow 2.4.0</td><td>Keras 2.4.3</td></tr><tr><td>TensorFlow 2.6.0</td><td>Keras 2.6.0</td></tr></tbody></table><ol start="2"><li>运行仍然在Anaconda的<strong>tensorflow2环境中运行下面的指令</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras==2.4.3</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220515151729.png" alt=""></p>]]></content>
    
    
    <summary type="html">Anaconda + CUDA + TensorFlow2 + Keras的深度学习环境搭建过程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="环境搭建" scheme="https://www.mahaofei.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>深度学习环境配置Pytorch</title>
    <link href="https://www.mahaofei.com/post/20d30e4e.html"/>
    <id>https://www.mahaofei.com/post/20d30e4e.html</id>
    <published>2022-05-16T03:03:16.000Z</published>
    <updated>2022-05-20T03:03:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Anaconda</h1><p>Anaconda是管理各个python包的工具，这里我们主要使用的是numpy，以及其他的一些常用包。</p><p>Anaconda官网链接：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p><p>各个系统版本的Anaconda安装程序都可以直接下载安装即可，相关使用方法可以参考<a href="https://www.mahaofei.com/post/8543c9d.html">该文章</a></p><h1>CUDA</h1><ol><li>首先<strong>查看自己电脑GPU对应的cuda版本</strong>，如图所示<strong>打开 NVIDIA控制面板-&gt;帮助-&gt;系统信息-&gt;组件</strong>（可在控制中心或右下角通知栏打开），我这里GPU对应的cuda版本是11.6.106，所以安装的cuda不能超过这个版本。</li></ol><p><img src="https://img.mahaofei.com/img/20220515111335.png" alt=""></p><p>或者在cmd命令行输入<code>nvidia-smi</code>也可以查看CUDA版本。</p><ol start="2"><li><strong>进入<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a>网站</strong>选择低于刚才查到的版本的cudatoolkit，本文选择CUDA Toolkit 11.0 Update 3，<strong>下载安装包</strong>约2.7G。</li></ol><blockquote><p>注意：这里选择的cuda版本会决定后面安装cudnn和tensorflow-gpu的版本，三者是相关的，如果版本不匹配将无法使用，具体匹配版本参考<a href="https://tensorflow.google.cn/install/source_windows">https://tensorflow.google.cn/install/source_windows</a>，下表为节选。</p></blockquote><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">Python 版本</th><th style="text-align:left">编译器</th><th style="text-align:left">构建工具</th><th style="text-align:left">cuDNN</th><th style="text-align:left">CUDA</th></tr></thead><tbody><tr><td style="text-align:left">tensorflow_gpu-2.6.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.5.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.4.0</td><td style="text-align:left">3.6-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">8.0</td><td style="text-align:left">11.0</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.3.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.2.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 2.0.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.1.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 0.27.1-0.29.1</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.0.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.15.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.14.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.24.1-0.25.2</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.13.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2015 update 3</td><td style="text-align:left">Bazel 0.19.0-0.21.0</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/20220515141105.png" alt=""></p><ol start="3"><li>双击下载的<strong>exe安装包</strong>，选择<strong>临时解压</strong>位置，然后点击ok，解压时间两分钟左右。</li></ol><p><img src="https://img.mahaofei.com/img/20220515140740.png" alt=""></p><ol start="4"><li><strong>同意许可协议</strong>，然后选择<strong>自定义安装</strong>选项，然后点击<strong>下一步</strong></li></ol><p><img src="https://img.mahaofei.com/img/20220515141240.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220515141310.png" alt=""></p><ol start="5"><li>选择驱动程序组件，一定要<strong>勾选CUDA</strong>，然后点击<strong>下一步</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141348.png" alt=""></p><ol start="6"><li>选择自己电脑上的一个安装位置，然后<strong>开始安装</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141701.png" alt=""></p><ol start="7"><li><p><strong>等待安装结束</strong>，本电脑18年笔记本机械硬盘安装<strong>耗时约5分钟</strong></p></li><li><p><strong>检查环境变量</strong>，一般安装完成后会自动配置好环境变量，打开<strong>设置-系统-系统信息-高级系统设置-环境变量</strong>进行检查，如果没有则需要自行添加（注意添加时修改成自己的安装路径）</p></li></ol><ul><li>系统变量中是否有<strong>CUDA</strong>和<strong>NVCUDASAMPLES</strong>两组环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142616.png" alt=""></p><ul><li>打开系统变量的Path，查看是否有以下环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142701.png" alt=""></p><ol start="9"><li>CUDA安装完成</li></ol><h1>Pytorch</h1><p><strong>（1）创建Pytorch环境</strong></p><p>使用anaconda创建一个pytorch的虚拟环境，主要是为了区分不同的项目，比如tensorflow和pytorch使用的各种包环境等都是不同的，新建一个环境可以处理项目之间不兼容的问题。</p><ol><li><p>打开<code>Anaconda Prompt</code></p></li><li><p>新建一个虚拟环境</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=3.8</span><br></pre></td></tr></table></figure><p>这里创建一个pytorch环境，语句中pytorch是环境名，叫什么都可以，python版本这里3.8和3.9都可以。</p><p>使用<code>conda info --envs</code>命令可以看到所有环境，使用<code>conda activate pytorch</code>可以激活刚才创建的pytorch环境。</p><p>前面从（base）变为（pytorch）时表示此时已经切换到pytorch环境。</p><p><img src="https://img.mahaofei.com/img/20220705182340.png" alt=""></p><p><strong>（2）安装pytorch</strong></p><p>进入PyTorch官网：<a href="https://pytorch.org/">https://pytorch.org/</a>，可以看到pytorch安装页面。</p><p>这里默认已经根据你的电脑情况选择了一部分信息，只需要选择CUDA版本即可，刚才查看了我的电脑cuda版本是11.6.106，所以这里选择CUDA 11.6。</p><p><img src="https://img.mahaofei.com/img/20220705182724.png" alt=""></p><p>这里提示了安装前电脑需要安装cudatoolkit，上一节我们已经安装了，所以直接在conda的pytorch环境中运行下面给出的安装代码即可。</p><p>进入虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></table></figure><p>安装pytorch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.6 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><blockquote><p>如果下载报错，注意关掉自己的科学上网工具，然后到<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">清华大学镜像站</a>按步骤添加一下索引。<br>如果仍报错且自己能够科学上网，那么可以使用命令<code>conda config --remove-key channels</code>删除清华源，并删除<code>C:/用户/xxx/.condarc</code>文件，使用科学上网+默认源下载。</p></blockquote><h1>测试</h1><p>打开Anaconda Prompt命令行，进入pytorch环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></table></figure><p>输入<code>python</code>，进入python交互界面</p><p>输入下面命令进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="built_in">print</span>(torch.__version__) <span class="comment"># pytorch版本</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># cuda版本</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看cuda是否可用</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220705205436.png" alt=""></p>]]></content>
    
    
    <summary type="html">常用深度学习环境 Pytorch 的安装教程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="环境搭建" scheme="https://www.mahaofei.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Latex基本语法</title>
    <link href="https://www.mahaofei.com/post/15b7fde1.html"/>
    <id>https://www.mahaofei.com/post/15b7fde1.html</id>
    <published>2022-04-26T07:27:12.000Z</published>
    <updated>2022-04-26T07:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 公式插入</h1><h2 id="行内公式">行内公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>f(x)=x<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$f(x)=x$</p><h2 id="行间公式">行间公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>f(x)=x<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$f(x)=x$$</p><h1>2. 数学运算符号</h1><h2 id="乘法除法">乘法除法</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>a <span class="keyword">\times</span> b<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>a <span class="keyword">\div</span> b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$a \times b$<br>$a \div b$</p><h2 id="除法分式">除法分式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\frac{a}{b}$</p><h2 id="根号开方">根号开方</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>[m]&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\sqrt{3}$<br>$\sqrt[m]{n}$</p><h2 id="求导导数偏导">求导导数偏导</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x&#125;<span class="built_in">$</span> <span class="comment">%求导</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> x&#125;<span class="built_in">$</span>   <span class="comment">%偏导</span></span><br><span class="line"><span class="built_in">$</span>f<span class="built_in">^</span>&#123;&#x27;&#125;(x)<span class="built_in">$</span>     <span class="comment">%求导撇</span></span><br><span class="line"><span class="built_in">$</span>f<span class="built_in">^</span>&#123;&#x27;&#x27;&#125;(x)<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;y&#125;<span class="built_in">$</span>      <span class="comment">%求导点</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\ddot</span>&#123;y&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\dddot</span>&#123;y&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\nabla</span>&#123;f&#125;<span class="built_in">$</span>    <span class="comment">%全微分</span></span><br></pre></td></tr></table></figure><p>$\frac{\mathrm{d}y}{\mathrm{d}x}$</p><p>$\frac{\partial f}{\partial x}$</p><p>$f^{‘}(x)$<br>$f^{’'}(x)$</p><p>$\dot{y}$<br>$\ddot{y}$<br>$\dddot{y}$</p><p>$\nabla{f}$</p><h2 id="绝对值">绝对值</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>|x<span class="built_in">_</span>n|<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\lvert</span> x<span class="built_in">_</span>n<span class="keyword">\rvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$|x_n|$<br>$\lvert x_n\rvert$</p><h2 id="累计求和">累计求和</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\sum_{i=1}^{n}$</p><h2 id="累计求积">累计求积</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\prod_{i=1}^{n}$</p><h2 id="积分">积分</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\int_{i=1}^{n}$</p><h1>3. 字母附加符号</h1><h2 id="上下标">上下标</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">^</span>&#123;&#125; <span class="comment">%上标$x^&#123;2&#125;$</span></span><br><span class="line"><span class="built_in">_</span>&#123;&#125; <span class="comment">%下标$x_&#123;1&#125;$</span></span><br></pre></td></tr></table></figure><p>$x^{2}$<br>$x_{1}$</p><h2 id="向量">向量</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;a&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\overrightarrow</span>&#123;AB&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\vec{a}$<br>$\overrightarrow{AB}$</p><h2 id="省略号">省略号</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cdots</span><span class="built_in">$</span>   <span class="comment">%省略号...$1,2,3,\cdots,n$</span></span><br></pre></td></tr></table></figure><p>$1,2,3,\cdots,n$</p><h2 id="大括号">大括号</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underbrace</span>&#123;n&#125;<span class="built_in">_</span>&#123;m&#125;<span class="built_in">$</span> <span class="comment">% 大括号 \underbrace&#123;1,2,3,\cdots,n&#125;_&#123;m&#125;</span></span><br></pre></td></tr></table></figure><p>$\underbrace{1,2,3,\cdots,n}_{m}$</p><h2 id="横线">横线</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overline</span>&#123;m+n&#125;<span class="built_in">$</span> <span class="comment">%m+n公式上面加上横杠 </span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\underline</span>&#123;m+n&#125;<span class="built_in">$</span><span class="comment">%m+n公式下面加上横杠</span></span><br></pre></td></tr></table></figure><p>$\overline{m+n}$</p><p>$\underline{m+n}$</p><h1>4. 特殊字母</h1><h2 id="希腊字母表">希腊字母表</h2><table><thead><tr><th>小写希腊字母</th><th>代码</th><th>大写希腊字母</th><th>代码</th></tr></thead><tbody><tr><td>$\alpha$</td><td>\alpha</td><td></td><td></td></tr><tr><td>$\beta$</td><td>\beta</td><td></td><td></td></tr><tr><td>$\gamma$</td><td>\gamma</td><td>$\Gamma$</td><td>\Gamma</td></tr><tr><td>$\delta$</td><td>\delta</td><td>$\Delta$</td><td>\Delta</td></tr><tr><td>$\epsilon$</td><td>\epsilon</td><td></td><td></td></tr><tr><td>$\varepsilon$</td><td>\varepsilon</td><td></td><td></td></tr><tr><td>$\zeta$</td><td>\zeta</td><td></td><td></td></tr><tr><td>$\eta$</td><td>\eta</td><td></td><td></td></tr><tr><td>$\theta$</td><td>\theta</td><td>$\Theta$</td><td>\Theta</td></tr><tr><td>$\vartheta$</td><td>\vartheta</td><td></td><td></td></tr><tr><td>$\iota$</td><td>\iota</td><td></td><td></td></tr><tr><td>$\kappa$</td><td>\kappa</td><td></td><td></td></tr><tr><td>$\lambda$</td><td>\lambda</td><td>$\Lambda$</td><td>\Lambda</td></tr><tr><td>$\mu$</td><td>\mu</td><td></td><td></td></tr><tr><td>$\nu$</td><td>\nu</td><td></td><td></td></tr><tr><td>$\xi$</td><td>\xi</td><td>$\Xi$</td><td>\Xi</td></tr><tr><td>$\pi$</td><td>\pi</td><td>$\Pi$</td><td>\Pi</td></tr><tr><td>$\varpi$</td><td>\varpi</td><td></td><td></td></tr><tr><td>$\rho$</td><td>\rho</td><td></td><td></td></tr><tr><td>$\varrho$</td><td>\varrho</td><td></td><td></td></tr><tr><td>$\sigma$</td><td>\sigma</td><td>$\Sigma$</td><td>\Sigma</td></tr><tr><td>$\varsigma$</td><td>\varsigma</td><td></td><td></td></tr><tr><td>$\tau$</td><td>\tau</td><td></td><td></td></tr><tr><td>$\upsilon$</td><td>\upsilon</td><td></td><td></td></tr><tr><td>$\phi$</td><td>\phi</td><td>$\Phi$</td><td>\Phi</td></tr><tr><td>$\varphi$</td><td>\varphi</td><td></td><td></td></tr><tr><td>$\chi$</td><td>\chi</td><td></td><td></td></tr><tr><td>$\psi$</td><td>\psi</td><td>$\Psi$</td><td>\Psi</td></tr><tr><td>$\omega$</td><td>\omega</td><td>$\Omega$</td><td>\Omega</td></tr></tbody></table><h2 id="常用关系符">常用关系符</h2><p>关系符都可以前加<code>\not</code>表示否定形式</p><table><thead><tr><th>符号</th><th>代码</th></tr></thead><tbody><tr><td>$\neq$</td><td>\neq or \not=</td></tr><tr><td>$\leq$</td><td>\leq or \le</td></tr><tr><td>$\geq$</td><td>\geq or \ge</td></tr><tr><td>$\ll$</td><td>\ll</td></tr><tr><td>$\gg$</td><td>\gg</td></tr><tr><td>$\subset$</td><td>\subset</td></tr><tr><td>$\supset$</td><td>\supset</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td></tr><tr><td>$\supseteq$</td><td>\supseteq</td></tr><tr><td>$\in$</td><td>\in</td></tr><tr><td>$\ni$</td><td>\ni</td></tr><tr><td>$\bigcup$</td><td>\bigcup</td></tr><tr><td>$\bigcap$</td><td>\bigcap</td></tr><tr><td>$\propto$</td><td>\propto</td></tr><tr><td>$\infty$</td><td>\infty</td></tr></tbody></table><h2 id="特殊符号">特殊符号</h2><table><thead><tr><th>符号</th><th>代码</th></tr></thead><tbody><tr><td>$\leftarrow$</td><td>\leftarrow</td></tr><tr><td>$\Leftarrow$</td><td>\Leftarrow</td></tr><tr><td>$\rightarrow$</td><td>\rightarrow</td></tr><tr><td>$\Rightarrow$</td><td>\Rightarrow</td></tr><tr><td>$\leftrightarrow$</td><td>\leftrightarrow</td></tr><tr><td>$\Leftrightarrow$</td><td>\Leftrightarrow</td></tr><tr><td>$\leftharpoonup$</td><td>\leftharpoonup</td></tr><tr><td>$\leftharpoondown$</td><td>\leftharpoondown</td></tr><tr><td>$\rightharpoondown$</td><td>\rightharpoonup</td></tr><tr><td>$\rightharpoondown$</td><td>\rightharpoondown</td></tr><tr><td>$\leftrightharpoons$</td><td>\leftrightharpoons</td></tr></tbody></table><h2 id="特殊字体">特殊字体</h2><table><thead><tr><th>字体样式</th><th>代码</th></tr></thead><tbody><tr><td>$\mathrm{ABCdef}$</td><td>\mathrm{ABCdef}</td></tr><tr><td>$\mathit{ABCdef}$</td><td>\mathit{ABCdef}</td></tr><tr><td>$\mathnormal{ABCdef}$</td><td>\mathnormal{ABCdef}</td></tr><tr><td>$\mathcal{ABC}$</td><td>\mathcal{ABC}</td></tr><tr><td>$\mathscr{ABC}$</td><td>\mathscr{ABC}</td></tr><tr><td>$\mathfrak{ABCdef}$</td><td>\mathfrak{ABCdef}</td></tr><tr><td>$\mathbb{ABC}$</td><td>\mathbb{ABC}</td></tr></tbody></table><h1>5. 文字样式</h1><h2 id="文字颜色">文字颜色</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\color</span>&#123;blue&#125;&#123;文字&#125;<span class="built_in">$</span>             <span class="comment">%文字颜色</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\color</span>[rgb]&#123;0.9,0.1,0.2&#125;&#123;文字&#125;<span class="built_in">$</span><span class="comment">%rgb三个参数取值[0,1]</span></span><br></pre></td></tr></table></figure><p>$\color{blue}{文字}$<br>$\color[rgb]{0.9,0.1,0.2}{文字}$</p><h2 id="文字高亮">文字高亮</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\colorbox</span>&#123;green&#125;&#123;文字&#125;<span class="built_in">$</span>              <span class="comment">%文字颜色</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\colorbox</span>&#123;yellow&#125;&#123;<span class="keyword">\color</span>&#123;red&#125;&#123;文字&#125;&#125;<span class="built_in">$</span><span class="comment">%复合用法</span></span><br></pre></td></tr></table></figure><p>$\colorbox{green}{文字}$<br>$\colorbox{yellow}{\color{red}{文字}}$</p>]]></content>
    
    
    <summary type="html">由于在博客撰写中用到了许多公式的输入，每次遇到不会的Latex语法都要现查，很费劲，因此在这里总结一下。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="网站" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BD%91%E7%AB%99/"/>
    
    
    <category term="Latex" scheme="https://www.mahaofei.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>数据处理Numpy的基本使用方法</title>
    <link href="https://www.mahaofei.com/post/55ccd68.html"/>
    <id>https://www.mahaofei.com/post/55ccd68.html</id>
    <published>2022-04-24T01:47:13.000Z</published>
    <updated>2022-04-24T01:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Numpy的安装</strong></p><p>建议使用Anaconda管理这些包，Anaconda的具体教程参考上一篇笔记【Anaconda的基本使用与在Pycharm中调用】</p><p>安装好Anaconda后可以在Anaconda Prompt使用<code>activate 环境名</code>进入自己创建的环境。</p><p>使用下面指令安装Numpy和Pandas</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy</span><br><span class="line">conda install pandas</span><br></pre></td></tr></table></figure><p><strong>导入numpy</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h1>1. 数组创建</h1><h2 id="（1）从已有数据创建数组">（1）从已有数据创建数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># object  数组或嵌套的数列</span></span><br><span class="line"><span class="comment"># dtype   数组元素的数据类型，可选</span></span><br><span class="line"><span class="comment"># copy    对象是否需要复制，可选</span></span><br><span class="line"><span class="comment"># order   创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</span></span><br><span class="line"><span class="comment"># subok   默认返回一个与基类类型一致的数组</span></span><br><span class="line"><span class="comment"># ndmin   指定生成数组的最小维度</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.array([[1, 2], [3, 4]])<br>print (a)<br>[ [1  2]<br>[3  4] ]</p><p>a = np.array([1, 2, 3, 4, 5], ndmin = 2)<br>print (a)<br>[ [1 2 3 4 5] ]</p></blockquote><h2 id="（2）从数值范围创建数组">（2）从数值范围创建数组</h2><p>numpy.arange：使用 arange 函数创建数值范围并返回 ndarray 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure><p>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># num       要生成的等步长的样本数量，默认为50</span></span><br><span class="line"><span class="comment"># endpoint  该值为True时，数列中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment"># retstep   如果为True时，生成的数组中会显示间距，反之不显示，默认是False</span></span><br></pre></td></tr></table></figure><p>numpy.logspace 函数用于创建一个于等比数列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># base  对数 log 的底数</span></span><br></pre></td></tr></table></figure><h2 id="（3）创建全0数组">（3）创建全0数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="（4）创建全1数组">（4）创建全1数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="（5）创建指定形状、指定数据类型、但未初始化的数组">（5）创建指定形状、指定数据类型、但未初始化的数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>2. 数组的基本属性</h1><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ndarray.ndim</td><td style="text-align:left">秩，即轴的数量或维度的数量</td></tr><tr><td style="text-align:left">ndarray.shape</td><td style="text-align:left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td style="text-align:left">ndarray.reshape</td><td style="text-align:left">调整数组的大小</td></tr><tr><td style="text-align:left">ndarray.size</td><td style="text-align:left">数组元素的总个数，相当于 .shape 中 n·m 的值</td></tr><tr><td style="text-align:left">ndarray.dtype</td><td style="text-align:left">ndarray 对象的元素类型</td></tr><tr><td style="text-align:left">ndarray.itemsize</td><td style="text-align:left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td style="text-align:left">ndarray.flags</td><td style="text-align:left">ndarray 对象的内存信息</td></tr><tr><td style="text-align:left">ndarray.real</td><td style="text-align:left">ndarray元素的实部</td></tr><tr><td style="text-align:left">ndarray.imag</td><td style="text-align:left">ndarray 元素的虚部</td></tr><tr><td style="text-align:left">ndarray.data</td><td style="text-align:left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><blockquote><p>例如：<br>a = np.array([[1,2,3],[4,5,6]])   # (2, 3)</p><p>a = np.array([[1,2,3],[4,5,6]])<br>b = a.reshape(3,2)<br>print (b)<br>[[1, 2]<br>[3, 4]<br>[5, 6]]</p></blockquote><h1>3. 数组的切片与索引</h1><h2 id="（1）slice函数切片">（1）slice函数切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">slice</span>(start, stop[, step])</span><br><span class="line"><span class="comment"># start  起始位置</span></span><br><span class="line"><span class="comment"># stop   结束位置</span></span><br><span class="line"><span class="comment"># step   间距</span></span><br></pre></td></tr></table></figure><h2 id="（2）冒号-分割切片-start-stop-step">（2）冒号<code>:</code>分割切片[start:stop:step]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]</span><br><span class="line">b = a[2:7:2]</span><br><span class="line">b = a[5]</span><br><span class="line">b = a[2:]</span><br></pre></td></tr></table></figure><blockquote><p>冒号 : 的解释：如果只放置一个参数，如 <strong>[2]</strong>，将返回与该索引相对应的单个元素。如果为 <strong>[2:]</strong>，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 <strong>[2:7]</strong>，那么则提取两个索引(不包括停止索引)之间的项。</p></blockquote><h2 id="（3）split方法">（3）split方法</h2><p>numpy.split 函数沿特定的轴将数组分割为子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.split(ary, indices_or_sections, axis)</span><br><span class="line"><span class="comment"># ary：被分割的数组</span></span><br><span class="line"><span class="comment"># indices_or_sections：如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</span></span><br><span class="line"><span class="comment"># axis：设置沿着哪个方向进行切分，默认为 0，横向切分，即水平方向。为 1 时，纵向切分，即竖直方向</span></span><br></pre></td></tr></table></figure><h1>4. 数组基本操作</h1><h2 id="（1）数组展开">（1）数组展开</h2><p>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">a.flatten()             <span class="comment"># [0 1 2 3 4 5 6 7]</span></span><br><span class="line">a.flatten(order = <span class="string">&#x27;F&#x27;</span>)  <span class="comment"># [0 4 1 5 2 6 3 7]</span></span><br><span class="line"><span class="comment"># order：&#x27;C&#x27;按行，&#x27;F&#x27;按列，&#x27;A&#x27;原顺序，&#x27;K&#x27;元素在内存中的出现顺序</span></span><br></pre></td></tr></table></figure><p>numpy.ravel() 展平的数组元素，顺序通常是&quot;C风格&quot;，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">a.ravel()              <span class="comment"># [0 1 2 3 4 5 6 7]</span></span><br><span class="line">a.ravel(order = <span class="string">&#x27;F&#x27;</span>)  <span class="comment"># [0 4 1 5 2 6 3 7]</span></span><br></pre></td></tr></table></figure><h2 id="（2）数组转置">（2）数组转置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.transpose(arr, axes)</span><br><span class="line"><span class="comment"># arr ：要操作的数组</span></span><br><span class="line"><span class="comment"># axes：整数列表，对应维度，通常所有维度都会对换</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.T</span><br><span class="line"><span class="comment"># 数组全部转置</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.arange(12).reshape(3,4)<br>print (np.transpose(a))<br>print (a.T)</p></blockquote><h2 id="（3）数组轴的移动与交换">（3）数组轴的移动与交换</h2><p>numpy.rollaxis 函数移动特定的轴到一个特定位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.rollaxis(arr, axis, start)</span><br><span class="line"><span class="comment"># arr   ：数组</span></span><br><span class="line"><span class="comment"># axis  ：要移动的轴，其它轴的相对位置不会改变</span></span><br><span class="line"><span class="comment"># start ：默认为零，表示完整的滚动。会滚动到特定位置</span></span><br></pre></td></tr></table></figure><p>numpy.swapaxes 函数用于交换数组的两个轴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.swapaxes(arr, axis1, axis2)</span><br><span class="line"><span class="comment"># arr   ：数组</span></span><br><span class="line"><span class="comment"># axis1 ：对应第一个轴的整数</span></span><br><span class="line"><span class="comment"># axis2 ：对应第二个轴的整数</span></span><br></pre></td></tr></table></figure><h2 id="（4）连接数组">（4）连接数组</h2><p><strong>数组连接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.concatenate((a1, a2, ...), axis)</span><br><span class="line"><span class="comment"># a1, a2, ... ：相同类型的数组</span></span><br><span class="line"><span class="comment"># axis：沿着它连接数组的轴，默认为 0</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.array([[1,2],[3,4]])<br>b = np.array([[5,6],[7,8]])<br>print (np.concatenate((a,b)))<br>[[1 2]<br>[3 4]<br>[5 6]<br>[7 8]]<br>print (np.concatenate((a,b),axis = 1))<br>[[1 2 5 6]<br>[3 4 7 8]]</p></blockquote><p><strong>数组堆叠</strong></p><p>numpy.stack 函数用于沿新轴连接数组序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.stack(arrays, axis)</span><br><span class="line"><span class="comment"># arrays : 相同形状的数组序列</span></span><br><span class="line"><span class="comment"># axis   : 返回数组中的轴，输入数组沿着它来堆叠</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.array([[1,2],[3,4]])<br>b = np.array([[5,6],[7,8]])<br>print (np.stack((a,b),0))<br>[[[1 2]<br>[3 4]]<br>[[5 6]<br>[7 8]]]<br>print (np.stack((a,b),1))<br>[[[1 2]<br>[5 6]]<br>[[3 4]<br>[7 8]]]</p></blockquote><p>具体的数组堆叠方式，参考此文章：<a href="https://blog.csdn.net/weixin_44330492/article/details/100126774">【Python中numpy.stack()函数最形象易懂的理解】</a></p><h2 id="（5）数组形状改变">（5）数组形状改变</h2><p><strong>numpy.resize</strong></p><p>numpy.resize 函数返回指定大小的新数组。如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.resize(arr, shape)</span><br><span class="line"><span class="comment"># arr   : 要修改大小的数组</span></span><br><span class="line"><span class="comment"># shape : 返回数组的新形状</span></span><br></pre></td></tr></table></figure><h2 id="（6）数组元素的操作">（6）数组元素的操作</h2><p><strong>numpy.append</strong></p><p>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.append(arr, values, axis=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># arr   ：输入数组</span></span><br><span class="line"><span class="comment"># values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</span></span><br><span class="line"><span class="comment"># axis  ：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</span></span><br></pre></td></tr></table></figure><p><strong>numpy.insert</strong></p><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br><span class="line"><span class="comment"># arr   ：输入数组</span></span><br><span class="line"><span class="comment"># obj   ：在其之前插入值的索引</span></span><br><span class="line"><span class="comment"># values：要插入的值</span></span><br><span class="line"><span class="comment"># axis  ：沿着它插入的轴，如果未提供，则输入数组会被展开</span></span><br></pre></td></tr></table></figure><p><strong>numpy.delete</strong></p><p>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.delete(arr, obj, axis)</span><br><span class="line"><span class="comment"># arr ：输入数组</span></span><br><span class="line"><span class="comment"># obj ：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</span></span><br><span class="line"><span class="comment"># axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</span></span><br></pre></td></tr></table></figure><p><strong>numpy.unique</strong></p><p>numpy.unique 函数用于去除数组中的重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br><span class="line"><span class="comment"># arr：输入数组，如果不是一维数组则会展开</span></span><br><span class="line"><span class="comment"># return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</span></span><br></pre></td></tr></table></figure><h2 id="（7）数组排序">（7）数组排序</h2><table><thead><tr><th style="text-align:left">种类</th><th style="text-align:left">速度</th><th style="text-align:left">最坏情况</th><th style="text-align:left">工作空间</th><th style="text-align:left">稳定性</th></tr></thead><tbody><tr><td style="text-align:left"><code>'quicksort'</code>（快速排序）</td><td style="text-align:left">1</td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left">0</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><code>'mergesort'</code>（归并排序）</td><td style="text-align:left">2</td><td style="text-align:left"><code>O(n*log(n))</code></td><td style="text-align:left">~n/2</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><code>'heapsort'</code>（堆排序）</td><td style="text-align:left">3</td><td style="text-align:left"><code>O(n*log(n))</code></td><td style="text-align:left">0</td><td style="text-align:left">否</td></tr></tbody></table><p><strong>numpy.sort()</strong></p><p>numpy.sort() 函数返回输入数组的排序副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br><span class="line"><span class="comment"># a: 要排序的数组</span></span><br><span class="line"><span class="comment"># axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序</span></span><br><span class="line"><span class="comment"># kind: 默认为&#x27;quicksort&#x27;（快速排序）</span></span><br><span class="line"><span class="comment"># order: 如果数组包含字段，则是要排序的字段</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.sort(a))  <span class="comment"># [[3 7],[1 9]]</span></span><br><span class="line"><span class="built_in">print</span> (np.sort(a, axis = <span class="number">0</span>))  <span class="comment"># [[3 1],[9 7]]</span></span><br></pre></td></tr></table></figure><p><strong>numpy.argsort()</strong></p><p>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argsort([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># [1 2 0]</span></span><br></pre></td></tr></table></figure><h3 id="（8）数组乘法">（8）数组乘法</h3><p><strong>numpy.dot()</strong></p><p>numpy.dot(a, b, out=None)：对于二维数组，它相当于矩阵的乘法；对于一维数组，则是向量的内积；而对于n维，它是a的最后一个轴向和b的倒数第二个轴向的乘积和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot([<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(a, b)</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p><strong>numpy.outer()</strong></p><p>numpy.outer(a, b, out=None)：计算两个向量的外积。输入a,b如果不是一维数组，则先将其变成一维数组，即可得a(M,)和b(N,)这种形式，可得输出为(M,N)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[a0*b0 a0*b1 ... a0*bN ]</span><br><span class="line"> [a1*b0 .               ]</span><br><span class="line"> [ ... .                ]</span><br><span class="line"> [aM*b0           aM*bN ]]</span><br></pre></td></tr></table></figure><p><strong>numpy.multiply()</strong></p><p>numpy.multiply(a, b)：为对应元素的乘积。维度相等时才能使用，当<strong>数组</strong>或者<strong>矩阵</strong>的维度不相同时，会根据一定的广播规则将维数扩充到一致的形式</p><p><strong>*</strong></p><p>*：当是两个数组相乘时和np.multiply用法相同，为对应元素的乘积；但是如果相乘的元素是矩阵时，则和np.dot用处相同，表示矩阵相乘。</p><h1>5. Broadcast广播规则</h1><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p><strong>具体广播规则如下：</strong></p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p><strong>举例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt=""></p><h1>6. 数组基本运算</h1><h2 id="（1）算数函数">（1）算数函数</h2><p><strong>加减乘除</strong></p><p>NumPy 算术函数包含简单的加减乘除: <strong>add()</strong>，<strong>subtract()</strong>，<strong>multiply()</strong> 和 <strong>divide()</strong>。数组必须具有相同的形状或符合数组广播规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">9</span>, dtype = np.float_).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span> (np.add(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.subtract(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.multiply(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.divide(a,b))</span><br></pre></td></tr></table></figure><p><strong>倒数</strong></p><p>numpy.reciprocal() 函数返回参数逐元素的倒数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">0.25</span>, <span class="number">1.33</span>, <span class="number">1</span>, <span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span> (np.reciprocal(a))</span><br></pre></td></tr></table></figure><p><strong>指数</strong></p><p>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span> (np.power(a,b))</span><br></pre></td></tr></table></figure><p><strong>模与余数</strong></p><p>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line">b = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span> (np.mod(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.remainder(a,b))</span><br></pre></td></tr></table></figure><h2 id="（2）统计函数">（2）统计函数</h2><p><strong>最大值与最小值</strong></p><p>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。<br>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。<br>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.amin(a,<span class="number">1</span>))    <span class="comment"># [3 3 2]</span></span><br><span class="line"><span class="built_in">print</span> (np.amin(a,<span class="number">0</span>))    <span class="comment"># [2 4 3]</span></span><br><span class="line"><span class="built_in">print</span> (np.amax(a))      <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">print</span> (np.amax(a, axis = <span class="number">0</span>))   <span class="comment"># [8 7 9]</span></span><br><span class="line"><span class="built_in">print</span> (np.argmax(a))    <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span> (np.argmax(a, axis = <span class="number">0</span>)) <span class="comment"># [1 0 2]</span></span><br><span class="line"><span class="built_in">print</span> (np.argmin(a))    <span class="comment"># 6</span></span><br><span class="line"><span class="built_in">print</span> (np.argmin(a, axis = <span class="number">1</span>)) <span class="comment"># [0 2 0]</span></span><br></pre></td></tr></table></figure><p><strong>最值差（最大值-最小值）</strong></p><p>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.ptp(a))    <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span> (np.ptp(a, axis = <span class="number">1</span>))    <span class="comment"># [4 5 7]</span></span><br><span class="line"><span class="built_in">print</span> (np.ptp(a, axis = <span class="number">0</span>))    <span class="comment"># [6 3 6]</span></span><br></pre></td></tr></table></figure><p><strong>算数平均值</strong></p><p>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.mean(a))    <span class="comment"># 3.6666666666666665</span></span><br><span class="line"><span class="built_in">print</span> (np.mean(a, axis = <span class="number">0</span>))  <span class="comment"># [2.66666667 3.66666667 4.66666667]</span></span><br><span class="line"><span class="built_in">print</span> (np.mean(a, axis = <span class="number">1</span>))  <span class="comment"># [2. 4. 5.]</span></span><br></pre></td></tr></table></figure><p><strong>加权平均值</strong></p><p>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (np.average(a))  <span class="comment"># 2.5</span></span><br><span class="line">wts = np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span> (np.average(a,weights = wts))  <span class="comment"># 2.0</span></span><br></pre></td></tr></table></figure><p><strong>中位数</strong></p><p>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">65</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">95</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.median(a))  <span class="comment"># 65.0</span></span><br><span class="line"><span class="built_in">print</span> (np.median(a, axis = <span class="number">0</span>))  <span class="comment"># [50. 90. 60.]</span></span><br><span class="line"><span class="built_in">print</span> (np.median(a, axis = <span class="number">1</span>))  <span class="comment"># [65. 80. 60.]</span></span><br></pre></td></tr></table></figure><p><strong>方差</strong></p><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.var([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># 1.25</span></span><br></pre></td></tr></table></figure><p><strong>标准差</strong></p><p>标准差是一组数据平均值分散程度的一种度量，是方差的算术平方根。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.std([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># 1.1180339887498949</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于使用Numpy进行一些数组操作的函数方法记录与部分例程，包括数组的创建、切片索引、数组的基本操作（转置、连接、排序、展开等），以及数组运算的一些基本函数的使用方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda的基本使用与在Pycharm中调用</title>
    <link href="https://www.mahaofei.com/post/8543c9d.html"/>
    <id>https://www.mahaofei.com/post/8543c9d.html</id>
    <published>2022-04-22T09:00:27.000Z</published>
    <updated>2022-04-22T09:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1>关于Anaconda</h1><p>环境 = “好比一栋楼，在楼里面分配一间屋给各种‘包’放，每间房里面的‘包’互不影响”</p><p>激活环境 = “告诉电脑，我现在要用这个屋子里面的‘包’来做东西了所以要进这间屋子”</p><p>移除环境 = “现在这个屋子里面我原来要用的东西现在不需要了把它赶出去节省电脑空间”</p><p>Conda创建环境相当于创建一个虚拟的空间将这些包都装在这个位置，我不需要了可以直接打包放入垃圾箱，同时也可以针对不同程序的运行环境选择不同的conda虚拟环境进行运行。</p><p>例如：</p><p>我的某个程序需要使用python3.8以及一堆其他的包，另一个程序需要python2.7加其它的一些包，这就需要我为这两个程序分别创建虚拟环境。</p><p>这样就可以在一台电脑上实现<strong>多个版本的python程序编写</strong>，同时想<strong>打包程序为exe</strong>的时候，也不会打包进其它没用到的包。</p><h1>Anaconda的安装</h1><p>Anaconda官网链接：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p><p>各个系统版本的Anaconda安装程序都可以直接下载安装即可。</p><h1>Anaconda的使用</h1><h2 id="配置Anaconda源">配置Anaconda源</h2><p>通常anaconda的默认源在境外，下载速度会非常慢甚至导致网络错误下载包失败，打开<code>Anaconda Prompt</code>使用以下方法将清华镜像添加到<code>Anaconda</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ </span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>使用如下命令查看当前channel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure><h2 id="Anaconda-Prompt">Anaconda Prompt</h2><p><strong>conda版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><p><strong>列出所有虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p><strong>创建虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n 环境名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda create --name python39 python=3.9</span></span><br></pre></td></tr></table></figure><p><strong>删除已有的环境及其安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name 环境名 --all</span><br></pre></td></tr></table></figure><p><strong>克隆环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name 新环境名 --clone 原环境名</span><br></pre></td></tr></table></figure><p><strong>激活某个环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate 环境名</span><br></pre></td></tr></table></figure><p><strong>退出当前环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><strong>查看环境中现有的包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p><strong>用conda或者pip安装包到当前环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install 包名称</span><br></pre></td></tr></table></figure><p><strong>包更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update numpy</span><br></pre></td></tr></table></figure><h2 id="Anaconda-Navigtor">Anaconda Navigtor</h2><p>用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。</p><h1>Pycharm中使用</h1><p><strong>1. 新建工程后，选择使用现有的解释器</strong></p><p><img src="https://img.mahaofei.com/img/20220422191328.png" alt=""></p><p><strong>2. 选择自己新建的虚拟环境</strong></p><p><img src="https://img.mahaofei.com/img/20220422191623.png" alt=""></p>]]></content>
    
    
    <summary type="html">我们想要在电脑上安装许多不同版本的python，或者想要让python环境中只存在用到的包方便对程序打包发布，这些情况都需要我们创建python虚拟环境，Anaconda就是一个这样管理python环境的工具。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Python/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计论文写作格式规范</title>
    <link href="https://www.mahaofei.com/post/16785ea7.html"/>
    <id>https://www.mahaofei.com/post/16785ea7.html</id>
    <published>2022-04-20T07:13:46.000Z</published>
    <updated>2022-04-20T07:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://pan.baidu.com/s/1n-1xqn3rarwiLiwlTYCNLA?pwd=p5tg">河北工业大学毕业设计中期报告模板.docx</a></p></blockquote><h1>重要要求</h1><p><strong>文档内所有文字（标题、正文、图、表、参考文献等）都应该使用模板规定的样式</strong></p><h1>标题</h1><ol><li><p>每个一级标题（一、二、三……）前应空一行。</p></li><li><p>一级、二级、三级标题不应该作为某页的最后一行（即所谓孤行控制）</p></li><li><p>页面最后由于插图导致的空白行最多允许1~2行的宽度。</p></li><li><p>正文多级标题格式顺序</p></li></ol><blockquote><p><strong>（1）这个可以加粗</strong><br>1）再下级的都与正文同格式<br>a.</p></blockquote><h1>图、表</h1><h2 id="图片插图">图片插图</h2><ol><li><p>表格和插图不能直接出现在正文段落的首行，必须先有文字说明。</p></li><li><p>图题、表头的编制要简洁明了，具有自明性，不能太笼统：图的序号编制只允许到二级，例如图1.1，图1.2，图4.5这样的二级图号，禁止出现图2.1.1这样的三级图号。</p></li><li><p>图片与图题、表头与表格，必须保证在同一页上。</p></li><li><p>图片尺寸尽量调小，能表达清楚图片内容即可。</p></li><li><p>图片中的上下空白尽可能小，通过裁剪剪去图片中的上下空白部分。</p></li><li><p>图中所标注文字大小，要比正文字号小1号。</p></li><li><p>流程图、框图等尽量使用Visio绘制，Visio打开状态下，可直接将visio文件插入word中。</p></li><li><p>图片标注格式</p></li></ol><p><img src="https://img.mahaofei.com/img/20220412112135.png" alt=""></p><p align="center" >图1.1 Web of Science网站图标（图题在下）<p align="center" >Fig.1.1 Web of Science favicon</p>## 表格<ol><li><p>表格一律采用三线表：表的序号编制只允许到二级，例如表1.1，表1.2，表4.5这样的二级图号，禁止出现表2.1.1这样的三级表号</p></li><li><p>表格标注格式</p></li></ol><p align="center" >表1.1 表格的标题（表头在上）<p align="center" >Table.1.1 Title of the table</p><p><img src="https://img.mahaofei.com/img/20220412112135.png" alt=""></p><h1>公式编辑</h1><ol><li>公式使用word中的公式插件（alt =），符号使用斜体、单位使用正体</li></ol><h1>参考文献</h1><p>[1]     袁庆龙, 候文义. Ni-P合金镀层组织形貌及显微硬度研究[J]. 太原理工大学学报, 2001, (1): 51-53.（期刊类）</p><p>[2]     金显贺, 王昌长, 王忠东, 等. 一种用于在线检测局部放电的数字滤波技术[J]. 清华大学学报（自然科学版）, 1993, 33(4): 62–67.</p><p>[3]     Khorasani K. Adaptive control of flexible joint robot[J]. IEEE Trans on Robotics and Automation, 1992, 8(2): 250-267.</p><p>[4]     刘国钧, 陈绍业, 王凤翥. 图书馆目录[M]. 北京: 高等教育出版社, 1957.（专著-参考书）</p><p>[5]     辛希孟. 信息技术与信息服务国际研讨会论文集: A集[C]. 北京: 中国社会科学出版社, 1994.（专著-会议论文集）</p><p>[6]     张筑生. 微分半动力系统的不变集[D]. 北京: 北京大学数学系数学研究所, 1983. （专著-博硕士论文）</p><p>[7]     冯西桥. 核反应堆压力管道与压力容器的LBB分析[R]. 北京: 清华大学核能技术设计研究院, 1997. （报告）</p><p>[8]     GB/T 16159-1996, 汉语拼音正词法基本规则[S]. （标准类）</p><p>[9]     姜锡洲. 一种温热外敷药制备方案[P]. 中国: 881056073,1989-07-26. （专利）</p><p>[10]  王明亮. 关于中国学术期刊标准化数据库系统工程的进展[EB/OL]. http: <a href="//www.cajcd.edu.cn/pub/wml.txt/980810%E2%80%932.html">//www.cajcd.edu.cn/pub/wml.txt/980810–2.html</a>, 1998-08-16/1998-10-04.  （电子文献）</p><p>[11]  Aytekin Çaʇlar, Rezaeitabar Yousef, Dogru Sedat, et al. Railway fastener inspection by real-time machine vision[J]. IEEE Transactions on Systems Man and Cybernetics: Systems, 2015, 45(7): 1101-1107.</p><p>[12]  Stivanello Maurício Edgar, Marcellino Kleber Juan. A Machine Vision System for Online Metal Can-End Rivet Inspection[J]. Journal of Physics: Conference Series, 2019, 1335(1)</p><p>[13]  Zhang Hui, Li Xuanlun, Zhong Hang, et al. Automated machine vision system for liquid particle inspection of pharmaceutical injection[J]. IEEE Transactions on Instrumentation and Measurement, 2018, 67(6): 1278-1297.</p><h1>附录：各样式信息</h1><table><thead><tr><th>样式</th><th>中文字体</th><th>英文字体</th><th>字号</th><th>格式</th><th>行距</th><th>段距</th><th>缩进</th><th>换行与分页</th><th>示例</th></tr></thead><tbody><tr><td>报告标题</td><td>黑体</td><td>Times New Roman</td><td>丝毫</td><td>居中加粗</td><td>1.5倍行距</td><td>段前段后12磅</td><td>无</td><td>孤行控制</td><td>HalfA博客毕业设计论文写作规范</td></tr><tr><td>一级标题</td><td>黑体</td><td>Times New Roman</td><td>小四</td><td></td><td>1.5倍行距</td><td>段前段后6磅</td><td>无</td><td>孤行控制</td><td>一、标题</td></tr><tr><td>二级标题</td><td>黑体</td><td>Times New Roman</td><td>五号</td><td>无</td><td>1.5倍行距</td><td>段前段后3磅</td><td>无</td><td>孤行控制</td><td>1.1 标题</td></tr><tr><td>三级标题</td><td>黑体</td><td>Times New Roman</td><td>五号</td><td>无</td><td>1.5倍行距</td><td>段前段后3磅</td><td>无</td><td>孤行控制</td><td>1.1.1 标题</td></tr><tr><td>正文</td><td>宋体</td><td>Times New Roman</td><td>五号</td><td>无</td><td>1.5倍行距</td><td>无</td><td>首行缩进2字符</td><td>无</td><td>正文</td></tr><tr><td>图题</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中</td><td>1.5倍行距</td><td>无</td><td>无</td><td>无</td><td>图1.1 图题 Fig.1.1 Figure title</td></tr><tr><td>表头</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中</td><td>1.5倍行距</td><td>无</td><td>无</td><td>无</td><td>表1.1 表头 Table.1.1 Table title</td></tr><tr><td>表格标题</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中加粗</td><td>1.25倍行距</td><td>无</td><td>无</td><td>无</td><td>标题</td></tr><tr><td>表格内容</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中</td><td>1.5倍行距</td><td>无</td><td>无</td><td>无</td><td>表格内容</td></tr><tr><td>参考标题</td><td>黑体</td><td>Times New Roman</td><td>五号</td><td>居中</td><td>1.5倍行距</td><td>段前段后0.5行</td><td>无</td><td>无</td><td>参考文献</td></tr><tr><td>参考文献</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>无</td><td>1.5倍行距</td><td>无</td><td>悬挂缩进2字符、首行缩进-2字符</td><td>无</td><td>[1] 马浩飞. 毕业设计论文写作规范[J]. HalfA博客. 2022.</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">博主在写毕业设计过程中遇到过的格式问题汇总，仅供参考。</summary>
    
    
    
    <category term="随笔" scheme="https://www.mahaofei.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="经验" scheme="https://www.mahaofei.com/categories/%E9%9A%8F%E7%AC%94/%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
</feed>
