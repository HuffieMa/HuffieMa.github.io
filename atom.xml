<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALFA博客</title>
  
  <subtitle>无限进步！！！</subtitle>
  <link href="https://www.mahaofei.com/atom.xml" rel="self"/>
  
  <link href="https://www.mahaofei.com/"/>
  <updated>2023-04-05T05:59:35.000Z</updated>
  <id>https://www.mahaofei.com/</id>
  
  <author>
    <name>马浩飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用内网穿透SakuraFrp远程连接服务器</title>
    <link href="https://www.mahaofei.com/post/9ed2c32f.html"/>
    <id>https://www.mahaofei.com/post/9ed2c32f.html</id>
    <published>2023-04-05T05:59:35.000Z</published>
    <updated>2023-04-05T05:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux端配置</h1><p><strong>（1）ssh配置</strong></p><p>安装ssh服务器与客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install openssh-server</span><br><span class="line">sudo apt -y install openssh-client</span><br></pre></td></tr></table></figure><p>配置ssh客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>​将<code>PermitRootLogin prohibt-password</code> 修改为 <code>PermitRootLogin yes</code></li><li>将<code>PasswordAuthentication yes</code> 前的#删除，取消注释</li></ul><p>重启ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>查看ssh服务运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh status</span><br></pre></td></tr></table></figure><p><strong>（2）Sakura配置</strong></p><p><a href="https://www.natfrp.com/user/">SakuraFrp</a></p><p>进入隧道列表新建隧道</p><ul><li>尽量选择国内节点</li><li>隧道类型为TCP隧道</li><li>本机端口为SSH</li><li>主机ip默认127.0.0.1即可(代指内网穿透本机)</li></ul><p><img src="https://img.mahaofei.com/img/20230405140317.png" alt=""></p><p>在官网下载对应版本的frpc，复制下载链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O frpc &lt;下载地址&gt;</span><br><span class="line">chmod 755 frpc</span><br><span class="line">ls -ls frpc</span><br><span class="line">md5sum frpc</span><br><span class="line">frpc -v</span><br></pre></td></tr></table></figure><p>隧道配置文件中复制隧道密钥</p><p>Ubuntu中使用下面的命令开启隧道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc -f &lt;复制的密钥&gt;</span><br></pre></td></tr></table></figure><h1>Windows端配置</h1><p>打开【设置-应用-添加功能】，添加OpenSSH 服务器和OpenSSH 客户端。</p><p>打开服务，找到 OpenSSH SSH Server 和 OpenSSH Authentication Agent -&gt; 启动服务并设为自动。</p><p>打开 power shell，使用以下命令检查安装和运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Service sshd</span><br></pre></td></tr></table></figure><p>打开Sakura官网，打开隧道列表，点击要连接的隧道，点击一键认证，下载exe认证程序并运行。</p><p>然后使用<code>ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;地址&gt;</code>进行远程连接</p><h1>VSCode远程ssh开发环境</h1><p>安装插件 <code>Remote - SSH</code></p>]]></content>
    
    
    <summary type="html">不想使用向日葵和todesk等工具远程连接桌面，而且个人电脑和服务器也不在一个局域网下，想要远程连接服务器，因此考虑使用内网穿透。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TensorBoard的使用丨深度学习曲线生成</title>
    <link href="https://www.mahaofei.com/post/6db9da8f.html"/>
    <id>https://www.mahaofei.com/post/6db9da8f.html</id>
    <published>2023-03-23T14:14:20.000Z</published>
    <updated>2023-03-23T14:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1>TensorBoard的安装</h1><p>要求Pytorch版本必须在1.2.0以上。</p><p>使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from torch.utils.tensorboard import SummaryWriter</span><br></pre></td></tr></table></figure><h1>TensorBoard的代码调用</h1><p><strong>（1）导入包，并创建TensorBoard回调对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> TensorBoard</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs/learning_rate_scheduler&quot;</span>) <span class="comment">#指定TensorBoard日志目录</span></span><br></pre></td></tr></table></figure><p><strong>（2）在模型的训练过程中导入回调</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global_step = <span class="number">0</span> <span class="comment"># 初始化 global_step 为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 训练过程</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将学习率和训练损失添加到 TensorBoard</span></span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Train/Loss&#x27;</span>, loss, global_step=global_step)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Train/Learning_Rate&#x27;</span>, lr, global_step=global_step)</span><br><span class="line">global_step += <span class="number">1</span>  <span class="comment"># 为每个batch更新 global_step 计数器</span></span><br></pre></td></tr></table></figure><h1>查看曲线</h1><p>训练开始后，打开一个终端，输入下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir logs/learning_rate_scheduler</span><br></pre></td></tr></table></figure><p>然后打开浏览器的<a href="http://localhost:6006/">http://localhost:6006/</a>页面，就可以看到曲线。</p><p><img src="https://img.mahaofei.com/img/20230323221410.png" alt=""></p>]]></content>
    
    
    <summary type="html">在深度学习训练过程中，我们必定会需要观察系统的Loss、Learning_rate等参数的变化，因此实时绘制曲线图是十分有必要的。本文就介绍了如何利用Pytorch的TensorBoard绘制曲线图。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.mahaofei.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Windows设置共享文件夹给Ubuntu或其它设备</title>
    <link href="https://www.mahaofei.com/post/76e8a448.html"/>
    <id>https://www.mahaofei.com/post/76e8a448.html</id>
    <published>2023-03-11T04:11:46.000Z</published>
    <updated>2023-03-11T04:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Windows系统设置</h1><p>在需要的位置新建一个文件夹，然后【右键-共享】，将其设置为共享文件夹。</p><p><img src="https://img.mahaofei.com/img202303111048877.png" alt=""></p><p>然后打开【设置-网络和Internet-高级网络设置-高级共享设置】，设置为如下的形式。<strong>主要是公用网络的两个都要打开，所有网络的共享打开，密码保护关闭</strong></p><p><img src="https://img.mahaofei.com/img202303111048312.png" alt=""></p><h1>二、Ubuntu系统设置</h1><h2 id="2-1-临时挂载">2.1 临时挂载</h2><p>挂载方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.1.143/Share ~/share -o username=&#x27;827855942@qq.com&#x27;,password=&#x27;mahaofei20000119&#x27;,dir_mode=0777,file_mode=0777,vers=2.0</span><br></pre></td></tr></table></figure><h2 id="2-2-自动挂载">2.2 自动挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/fstab</span><br></pre></td></tr></table></figure><p>在最后面按照下面的格式添加</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//192.168.1.143/Share ~/share cifs defaults,username=admin,password=123456,dir_mode=0777,file_mode=0777,vers=2.0 0 2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">局域网内，共享win电脑上的某个文件夹，使局域网内其它系统可以直接访问</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Windows工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Windows%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu使用OneDrive</title>
    <link href="https://www.mahaofei.com/post/ba007624.html"/>
    <id>https://www.mahaofei.com/post/ba007624.html</id>
    <published>2023-03-10T07:31:33.000Z</published>
    <updated>2023-03-10T07:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1>安装</h1><p>打开<code>/etc/apt/sources.list</code>添加源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>在最下面一行添加</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.kernel.org/ubuntu focal main universe</span><br></pre></td></tr></table></figure><p>从[<a href="https://packages.ubuntu.com/focal/amd64/onedrive/download">https://packages.ubuntu.com/focal/amd64/onedrive/download</a>]下载deb安装包并安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i onedrive_2.3.13-1build2_amd64.deb</span><br></pre></td></tr></table></figure><h1>使用</h1><p>输入以下命令登录onedrive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive</span><br></pre></td></tr></table></figure><p>下载config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/onedrive</span><br><span class="line">wget https://raw.githubusercontent.com/abraunegg/onedrive/master/config -O ~/.config/onedrive/config</span><br><span class="line">nano ~/.config/onedrive/config</span><br></pre></td></tr></table></figure><p>打开config文件中的下面几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sync_dir = &quot;~/disk/ubuntu/onedrive&quot;</span><br><span class="line">monitor_interval = &quot;60&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>同步</h1><p>第一次同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --synchronize</span><br></pre></td></tr></table></figure><p>实时同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --monitor</span><br></pre></td></tr></table></figure><blockquote><p>参考链接</p><ol><li><a href="https://github.com/abraunegg/onedrive">abraunegg/onedrive</a></li><li><a href="https://www.moerats.com/archives/740/">Rat’s. 适用于Linux的OneDrive客户端，支持VPS和OneDrive之间实时同步/备份</a></li></ol></blockquote><h1>替代方法</h1><p>此方法不太推荐，同步速度较慢，而且一旦取消同步本地文件都会清空。</p><h2 id="1-安装OneDriver">1. 安装OneDriver</h2><p>参考项目：<a href="https://github.com/jstaf/onedriver">https://github.com/jstaf/onedriver</a></p><p>根据作者的说明，对于Ubuntu系统，可以直接下载deb文件安装，下载链接为：<a href="https://software.opensuse.org/download.html?project=home%3Ajstaf&amp;package=onedriver">https://software.opensuse.org/download.html?project=home%3Ajstaf&amp;package=onedriver</a></p><p>选择Ubuntu，找到自己的Ubuntu版本，以及amd64/arm64，下载deb安装包并安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i onedriver_0.13.0-1_amd64.deb</span><br></pre></td></tr></table></figure><h1>2. OneDriver使用</h1><p>点击左上角<code>+</code>，选择本地同步文件夹。</p><p>然后输入用户名密码登录自己的OneDrive网盘。</p><p>点击右面的√，勾选系统登录时启动OneDriver。</p>]]></content>
    
    
    <summary type="html">之前一直使用坚果云做多设备同步，但是坚果云每个月只有1G流量，不够用。因此改到OneDrive，本文记录在Ubuntu上进行OneDrive的配置过程。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【浏览器插件】iTab新建标签页</title>
    <link href="https://www.mahaofei.com/post/999804d5.html"/>
    <id>https://www.mahaofei.com/post/999804d5.html</id>
    <published>2023-03-10T00:28:23.000Z</published>
    <updated>2023-03-10T00:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1>介绍</h1><p>本人之前很长一段时间都是实用的默认主页，并且只保留一个搜索框使主页尽可能简洁。</p><p>但是后来随着要用的网页越来越多，很多网站记不住经常需要搜索才能找到。</p><p>收藏夹又因为网站太多，我的收藏夹都是文件夹套文件夹套网址。</p><p>正巧看到了这个新建标签页，感觉还不错，有兴趣的可以体验一下，有点像之前用的infinite和青柠，但个人觉得这个更好一些。</p><h1>主页</h1><p>主页侧面是不同的分区，每个分区内可以添加很多不同的图标。</p><p><img src="https://img.mahaofei.com/img/20230310082742.png" alt=""></p><p>有官方给的图标，也可以自定义添加。</p><p><img src="https://img.mahaofei.com/img/20230310082814.png" alt=""></p><h1>其它</h1><p>而且itab支持网页版主页，也就是说，手机edge等无法安装浏览器扩展的应用，可以在设置里将主页改成<a href="https://go.itab.link/">https://go.itab.link/</a>就可以实现手机电脑使用同样的主页了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;本人之前很长一段时间都是实用的默认主页，并且只保留一个搜索框使主页尽可能简洁。&lt;/p&gt;
&lt;p&gt;但是后来随着要用的网页越来越多，很多网站记不住经常需要搜索才能找到。&lt;/p&gt;
&lt;p&gt;收藏夹又因为网站太多，我的收藏夹都是文件夹套文件夹套网址。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="浏览器插件" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记04】朴素贝叶斯法</title>
    <link href="https://www.mahaofei.com/post/7bc6ebb.html"/>
    <id>https://www.mahaofei.com/post/7bc6ebb.html</id>
    <published>2023-03-04T11:14:19.000Z</published>
    <updated>2023-03-04T11:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、贝叶斯定理</h1><h2 id="1-1-条件概率">1.1 条件概率</h2><p>条件概率属于概率论的内容，指的是已知在情况A的条件下，求发生事件B的概率，即P(B|A)，计算方法如下。</p><p>$$P(B|A)=\frac{P(AB)}{P(A)}$$</p><h2 id="1-2-贝叶斯定理">1.2 贝叶斯定理</h2><p>相对于条件概率，贝叶斯定理是其逆过程。已知发生事件B，求事件发生的情况A的概率，即P(A|B)，计算方法如下，其中分母是全概率公式。</p><p>$$P(A|B)=\frac{P(AB)}{P(B)}=\frac{P(A|B)\cdot P(B)}{P(B|A)\cdot P(A)+P(B|\hat A)\cdot P(\hat A)}$$</p><p>同理推广到分类问题，已知存在K类$c_1,c_2\dots c_k$，给定一个新的实例$x=(x^{(1)},x^{(2)}\dots x^{(n)})$，求该实例点归属于$c_i$类的可能。</p><p>$$P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{P(X=x)}=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{\sum^K_{i=1}P(X=x|Y=c_i)\cdot P(Y=c_i)}$$</p><h2 id="1-3-朴素贝叶斯">1.3 朴素贝叶斯</h2><p>朴素贝叶斯相较于贝叶斯，多了<strong>实例特征之间相互独立</strong>这个条件，这样更便于计算</p><p>即$P(X=x|Y=c_i)=\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)$</p><p>因此</p><p>$$P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{\sum^K_{c_i}P(Y=c_i)\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}$$</p><p>$$P(Y=c_i|X=x)=\frac{P(Y=c_i)\cdot \prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}{\sum^K_{c_i}P(Y=c_i)\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}$$</p><p>可以看出$x$属于任何分类$c_i$的概率，其分母都是一样的，因此实际计算时只需要比较分子即可，即</p><p>$$argmax P(Y=c_i)\cdot \prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)$$</p><p>通过训练数据集，我们可以得到联合概率分布。</p><h1>二、后验概率最大化准则</h1><h1>三、极大似然估计</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、贝叶斯定理&lt;/h1&gt;
&lt;h2 id=&quot;1-1-条件概率&quot;&gt;1.1 条件概率&lt;/h2&gt;
&lt;p&gt;条件概率属于概率论的内容，指的是已知在情况A的条件下，求发生事件B的概率，即P(B|A)，计算方法如下。&lt;/p&gt;
&lt;p&gt;$$P(B|A)=\frac{P(AB)}{P(A)}$</summary>
      
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Terminator终端终结者常用快捷键</title>
    <link href="https://www.mahaofei.com/post/79fdfcf6.html"/>
    <id>https://www.mahaofei.com/post/79fdfcf6.html</id>
    <published>2023-03-04T00:52:28.000Z</published>
    <updated>2023-03-04T00:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20230304085853.png" alt=""></p><h1>快捷键</h1><p><strong>常用快捷键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端（有按键冲突）</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+Shift+W                    //关闭当前标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="（1）同一个窗口">（1）同一个窗口</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //★移动到上面的终端</span><br><span class="line">Alt+Down                        //★移动到下面的终端</span><br><span class="line">Alt+Left                        //★移动到左边的终端</span><br><span class="line">Alt+Right                       //★移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //★水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端（有按键冲突）</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //★复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //★粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //★关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //★最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br></pre></td></tr></table></figure><h2 id="（2）不同窗口之间">（2）不同窗口之间</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个比较好用的终端工具。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>多版本OpenCV共存安装</title>
    <link href="https://www.mahaofei.com/post/96a605ae.html"/>
    <id>https://www.mahaofei.com/post/96a605ae.html</id>
    <published>2023-03-03T13:28:49.000Z</published>
    <updated>2023-03-03T13:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设此电脑已经安装了opencv4.0，现在需要安装opencv3，（其它版本同理）</p><h1>下载OpenCV并构建库</h1><p>为了避免冲突，在<code>/usr/local/</code>目录中新建<code>opencv3</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/opencv3</span><br></pre></td></tr></table></figure><p>照常从<a href="https://opencv.org/releases/">opencv官网</a>中下载另一版本的opencv，使用以下命令build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=RELEASE -DWITH_TBB=ON  -DWITH_V4L=ON -DCMAKE_INSTALL_PREFIX=/usr/local/opencv3 ..  </span><br></pre></td></tr></table></figure><p>进入<code>build</code>文件夹后，你需要输入下面这种格式的cmake指令，<strong>需要根据你的实际情况，对下面的指令参数进行修改，不要复制过去就直接运行。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/opencv3 -D OPENCV_EXTRA_MODULES_PATH=~/ros/sitepackages/opencv-3.4.2/opencv_contrib/modules/ -DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython2.7 ..</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1>切换opencv版本</h1><p>打开~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾增加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Change OpenCV3</span></span><br><span class="line">export PKG_CONFIG_PATH=/usr/local/opencv3/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/opencv3/lib</span><br></pre></td></tr></table></figure><p>更新~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc </span><br></pre></td></tr></table></figure><p>查询OpenCV版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure><p>如果输出3.4.2，就表明配置成功。</p><p><strong>如果想使用之前的版本，在~/.bashrc中注释掉增加的内容，然后source ~/.bashrc即可。</strong></p><p>如果只有一个版本的OpenCV，在CMakeList.txt中使用以下语句即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_PACKAGE</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure><p>在OpenCV编译好后，所在目录中会生成OpenCVConfig.cmake文件，这个文件中指定了CMake要去哪里找OpenCV，其.h文件在哪里等。</p><p>存在多版本OpenCV时，需要找到所需版本对应的OpenCVConfig.cmake文件，并将其路径添加到工程的CMakeLists.txt中。<br>示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(OpenCV_INCLUDE_DIRS <span class="string">&quot;/usr/local/opencv3/include&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(OpenCV_LIB_DIR <span class="string">&quot;/usr/local/opencv3/lib&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(OpenCV_LIBS opencv_core opencv_highgui opencv_imgproc)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;OpenCV_LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target_name <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p><ol><li><a href="https://immortalqx.github.io/2021/07/06/opencv-notes-0/">刘权祥. Ubuntu配置OpenCV及多版本OpenCV共存</a></li><li><a href="https://blog.csdn.net/learning_tortosie/article/details/80594399">W_Tortoise. Ubuntu下多版本OpenCV共存和切换</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">由于跑一些项目的时候，由于时代问题，有些程序是使用opencv2写的，现在大家普遍都安装的opencv4，由于项目代码繁多，修改源码过于麻烦，因此考虑多版本opencv共存安装。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    <category term="OpenCV" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/OpenCV/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="OpenCV" scheme="https://www.mahaofei.com/tags/OpenCV/"/>
    
    <category term="C++" scheme="https://www.mahaofei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记03】k近邻法</title>
    <link href="https://www.mahaofei.com/post/72393bb6.html"/>
    <id>https://www.mahaofei.com/post/72393bb6.html</id>
    <published>2023-02-14T02:56:06.000Z</published>
    <updated>2023-02-14T02:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、k近邻算法</h1><h2 id="1-1-算法">1.1 算法</h2><p>k近邻算法，假设给定了一个训练数据集，其中实例类别已定。</p><p>分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。 因此，k近邻法不具有显式的学习过程。</p><h2 id="1-2-模型">1.2 模型</h2><p>三个基本要素：距离度量、k值、分类决策规则</p><p>一般将特征空间，按照每个训练实例点xi，距离该点比其它点更近的所有点组合成一个单元。每个训练实例点拥有一个单元，单元内所有点都标记上类yi。</p><p>这样特征空间中每个点的类别都是确定的。</p><p><strong>（1）距离</strong></p><p>特征空间中两个实例点的距离一般使用欧式距离，或者更一般的$L_p$距离</p><p>$$L_p(x_i,x_j)=(\sum^n_{l=1}|x^{(l)}_i-x^{(l)}_j|)^{\frac{1}{p}}$$</p><p>其中l=2时为欧式距离，l=1时为曼哈顿距离，l=∞时为各个坐标距离的最大值。</p><p><strong>（2）k值</strong></p><p>如果k值过小，虽然可能会预测的比较准，但预测结果受邻近点影响过大，如果邻近点恰好为噪声，则会预测错误。</p><p>如果k值过大，与输入距离较远的示例也会起到预测作用。</p><p>如果k=N，那么总是输出实例中最多的类。</p><p><strong>（3）分类决策规则</strong></p><p>通常为k个近邻的实例中的最多数类。</p><h1>二、kd-tree</h1><p>在进行预测时，需要在训练数据中进行k近邻搜索，如果使用线性扫描，则需要计算输入点与所有训练实例的距离，速度过慢。</p><h2 id="2-1-构造kd-tree">2.1 构造kd-tree</h2><p>kd-tree的构造相当于不断用垂直于坐标轴的超平面将k维空间切分，每个节点对应一个k维超矩形区域。</p><p>构造过程：</p><ul><li>构造根结点：根结点对应的k维空间包含所有实例点的超矩形区域</li><li>递归切分：在超矩形区域中选择一个坐标轴和此坐标轴上的切分点，确定一个超平面，用此超平面将当前超矩形区域切分为左右两个子区域（子结点）</li><li>重复此过程，直到子区域内没有实例时终止（叶结点）</li></ul><h2 id="2-2-搜索kd-tree">2.2 搜索kd-tree</h2><p>输入：己构造的kd-tree， 目标点x<br>输出：x的最近邻</p><ul><li>在kd树中找出包含目标点x的叶结点：从根结点出发，递归地向下访问kd-tree。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。 直到子结点为叶结点为止。（有点类似二分法）</li><li>以此叶结点为“当前最近点”</li><li>递归地向上回退，在每个结点进行以下操作：<ul><li>如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。</li><li>当前最近点一定存在于该结点一个子结点对应的区域。 检査该子结点的父结点的另一子结点对应的区域是否有更近的点。即检査另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点” 间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点， 移动到另一个子结点。接着，递归地进行最近邻搜索；如果不相交， 向上回退。</li></ul></li><li>当回退到根结点时，搜索结束。最后的“当前最近点” 即为x的最近邻点。</li></ul>]]></content>
    
    
    <summary type="html">近邻算法，假设给定了一个训练数据集，其中实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。 因此，k近邻法不具有显式的学习过程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记02】感知机</title>
    <link href="https://www.mahaofei.com/post/6d27098f.html"/>
    <id>https://www.mahaofei.com/post/6d27098f.html</id>
    <published>2022-12-07T06:35:06.000Z</published>
    <updated>2022-12-07T06:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、感知机模型</h1><p>感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</p><p>假设输入空间$X\subseteq R^n$，输出空间$Y={+1,-1}$。输入$x\in X$表示实例的特征向量，对应于输入空间的点。输出$y\in Y$表示实例的类别，则输入空间到输出空间的函数：</p><p>$$f(x)=sign(w\cdot x+b)$$</p><p>称为感知机。其中$w$称为权值向量，$b$称为偏置，sign时符号函数sign(x)= {+1(if x&gt;=0), -1(if x&lt;0)}。</p><h1>二、感知机学习策略</h1><h2 id="2-1-数据集的线性可分性">2.1 数据集的线性可分性</h2><p>给定一个数据集，如果存在某个超平面能够将数据集的正实例点和负实例点完全正确的划分到超平面的两侧，则数据集称为线性可分数据集，否则称线性不可分。</p><h2 id="2-2-学习策略">2.2 学习策略</h2><p>输入空间中任意一点$x_0$到超平面S的距离为：$\frac{1}{||w||}|w\cdot x_0+b|$</p><p>因此误分类点到超平面S的距离为：$-\frac{1}{||w||}y_i(w\cdot x_0+b)$</p><p>所有误分类点的总距离，即损失函数为：$L(w,b)=-\sum_{i=0}^M y_i(w\cdot x_0+b)$</p><p>显然损失函数是非负的，感知机的学习策略就是在假设空间中找到使损失函数最小的模型参数$w,b$</p><h2 id="2-3-学习算法">2.3 学习算法</h2><p>感知机的学习算法采用随机梯度下降法。每次随机选取一个误分类点使其梯度下降。</p><p>输入：线性可分数据集T，学习率$\eta$</p><p>输出：感知机模型$w,b$</p><p>（1）选取初值$w_0,b_0$<br>（2）在训练集中选取数据$(x_i,y_i)$<br>（3）如果$y_i(w\cdot x_i+b)\le0$，更新参数$w=w+\eta y_i x_i$，$b=b+\eta y_i$，其中$\eta$为学习率，后项为两个参数的梯度<br>（4）重复上述过程，直到训练集中没有误分类点</p><p>当训练数据集线性可分时，感知机学习算法是收敛的，即经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。</p><h1>三、习题</h1><h2 id="3-1-为什么感知机不能表示异或">3.1 为什么感知机不能表示异或</h2><p>画出训练集的分布情况，易知无法使用一个线性平面将±区域分开。</p><p><img src="https://img.mahaofei.com/img/20221208104808.png" alt=""></p>]]></content>
    
    
    <summary type="html">感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记01】统计学习概论</title>
    <link href="https://www.mahaofei.com/post/fba31b0c.html"/>
    <id>https://www.mahaofei.com/post/fba31b0c.html</id>
    <published>2022-12-03T03:21:21.000Z</published>
    <updated>2022-12-03T03:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、统计学习</h1><h2 id="1-1-统计学习的概念">1.1 统计学习的概念</h2><p><strong>（1）概念</strong></p><p>统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。</p><p>统计学习是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><p><strong>（2）对象</strong></p><p>数据，如数字、文字、图像、视频、音频等。</p><p><strong>（3）目的</strong></p><p>从数据出发，提取数据的特征，抽象数据的模型，发现数据的知识，最后回到数据的分析与预测中。</p><h2 id="1-2-统计学习的分类">1.2 统计学习的分类</h2><h3 id="1-2-1-基本分类">1.2.1 基本分类</h3><p><strong>（1）监督学习</strong></p><p>从标注数据中学习预测模型的机器学习问题。即学习从输入到输出的映射的统计规律。</p><ul><li>输入空间与输出空间：输入与输出的所有可能取值。<ul><li>输入变量与输出变量均为连续变量，回归问题</li><li>输出变量为离散变量，分类问题</li><li>输入变量与输出变量均为变量序列，标注问题</li></ul></li><li>特征空间：输入可以用特征向量表示，所有特征向量存在的空间。</li><li>联合概率分布：假设训练数据与测试数据是一句联合概率分布P(X,Y)独立同分布产生的。</li><li>假设空间：由输入到输出的映射的集合。</li></ul><p><strong>（2）无监督学习</strong></p><p>从无标注数据中学习预测模型的机器学习问题。即学习数据的统计规律或潜在结构。</p><ul><li>输入空间与输出空间：模型的输入与输出的所有可能取值的集合。<ul><li>输入是实例，由特征向量表示。</li><li>输出是对输入的分析结果，由输入的类别、转换或概率表示。</li></ul></li><li>假设空间：所有模型z=g(x)的集合，其中X是输入空间，Z是隐式结构空间。</li></ul><p><strong>（3）强化学习</strong></p><p>智能系统在于环境的连续互动中学习最优行为策略的机器学习问题。智能系统观测到与环境互动得到的数据序列，本质是学习最优的序贯决策。</p><p>智能系统与环境的互动过程：每一步$t$，智能系统从环境观测到一个状态$s_t$和奖励$r_t$，采取一个动作$a_t$。环境根据智能系统的动作，确定下一步$t+1$的状态$s_{t+1}$和$r_{t+1}$。使系统实现长期累计奖励的最大化。</p><p>强化学习的马尔可夫决策过程由五元组&lt;S, A, P, r, $\gamma$&gt;组成：</p><ul><li>S：有限状态的集合</li><li>A：有限动作的集合</li><li>P：状态转移概率函数</li><li>r：奖励函数</li><li>$\gamma$：衰减系数</li></ul><p>策略：给定状态下的动作的函数<br>价值函数：策略从某一个状态开始的长期累积奖励的数学期望<br>动作价值函数：策略从某一个状态和动作开始的长期累计奖励的数学期望</p><p><strong>（4）半监督学习与主动学习</strong></p><p>半监督学习：利用标注数据和未标注数据学习预测模型的机器学习问题。</p><p>主动学习：机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。</p><h3 id="1-2-2-按模型分类">1.2.2 按模型分类</h3><p><strong>（1）概率模型与非概率模型</strong></p><ul><li>概率模型：取条件分布形式P(y|x)</li><li>非概率模型：函数形式y=f(x)</li></ul><p><strong>（2）线性模型与非线性模型</strong></p><ul><li>线性模型：感知机、线性支持向量机、k近邻、潜在语义分析</li><li>非线性模型：支持向量机、神经网络</li></ul><p><strong>（3）参数化模型与非参数化模型</strong></p><ul><li>参数化模型：假设模型参数的维度固定，模型可以由有限维参数完全刻画</li><li>非参数化模型：假设模型参数的维度不固定或者无穷大，随着训练数据量的增加而不断增大</li></ul><h3 id="1-2-2-按算法分类">1.2.2 按算法分类</h3><p><strong>（1）在线学习</strong></p><p>每次接受一个样本，进行预测，之后学习模型，并不断重复。</p><p><strong>（2）批量学习</strong></p><p>一次接受所有数据，学习模型，之后进行预测。</p><h3 id="1-2-3-按技巧分类">1.2.3 按技巧分类</h3><p><strong>（1）按贝叶斯学习</strong></p><p>在概率模型的学习和推理中，利用贝叶斯定理，计算在给定数据条件下模型的条件概率，并应用这个原理进行模型的估计。</p><p><strong>（2）核方法</strong></p><p>使用核函数表示和学习非线性模型的一种机器学习方法。</p><h1>二、统计学习的三要素</h1><h2 id="2-1-模型">2.1 模型</h2><ul><li>概率模型：假设空间为条件概率的集合。{f|Y=f(X)}</li><li>非概率模型：假设空间为决策函数的集合。{P|P(Y|X)}</li></ul><h2 id="2-2-策略">2.2 策略</h2><p><strong>（1）损失函数</strong></p><ul><li>0-1损失函数：$L(Y,f(x))=0,1$</li><li>平方损失函数：$L(Y,f(x))=(Y-f(X))^2$</li><li>绝对损失函数：$L(Y,f(x))=|Y-f(X)|$</li><li>对数损失函数：$L(Y,f(x))=-logP(Y|X)$</li></ul><p><strong>（2）风险函数</strong></p><p>损失函数的平均值，或称为期望损失。</p><p>当样本容量足够大时，经验风险最小化有利于保证很好的学习效果。当样本容量较小时，学习效果未必好，可能会产生过拟合。</p><p><strong>（3）结构风险</strong></p><p>结构风险在经验风险上加上表示模型复杂度的正则化项。</p><p>$R(f)=\frac{1}{N}\sum^N_{i=1}L(y_i,f(x_i))+\lambda J(f)$</p><p>其中$J(f)$为模型复杂度，模型越复杂其值越大。常取L1范数$||\omega||_1$或L2范数$\frac{||\omega||^2}{2}$<br>$\lambda$为系数，用于权衡风险函数与模型复杂度。</p><p>结构风险的思想其实就是奥卡姆剃刀原理，即在所有可能的模型函数中，选择能够很好的解释已知数据，并且最简单的模型。</p><h2 id="2-3-算法">2.3 算法</h2><h1>三、泛化能力</h1><p>泛化能力是学习到的模型对未知数据的预测能力。</p><h1>五、生成模型与判别模型</h1><p>极大似然估计：已知一组数据输出，定义该组数据的概率函数，通过求概率函数的极大值点，确定数据输入。</p>]]></content>
    
    
    <summary type="html">统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。本文是对李航老师的《统计学习方法》一书学习笔记。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Qt学习笔记05】Qt中调用ROS库</title>
    <link href="https://www.mahaofei.com/post/55cbe115.html"/>
    <id>https://www.mahaofei.com/post/55cbe115.html</id>
    <published>2022-09-03T01:45:22.000Z</published>
    <updated>2022-09-03T01:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>前提</h1><ol><li>安装配置好QT</li><li>安装配置好ROS</li></ol><h1>方法</h1><p><strong>（1）在QT配置文件中添加ros库</strong></p><p>在写的QT工程中加入:即在.pro文件中添加ros头文件路径和动态链接库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /opt/ros/noetic/include</span><br><span class="line">DEPENDPATH += /opt/ros/noetic/include</span><br><span class="line">LIBS += -L/opt/ros/noetic/lib -lroscpp -lroslib -lrosconsole -lroscpp_serialization -lrostime</span><br></pre></td></tr></table></figure><p><strong>（2）修改QT执行程序</strong></p><p>修改执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.local/share/applications/DigiaQt-qtcreator-community.desktop</span><br></pre></td></tr></table></figure><p>修改<code>Exec</code>行为下面的格式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -i -c /home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p><strong>但是这样修改之后，每次开机只能启动一次QT，第二次点击QT快捷方式就启动不起来了。</strong></p><p>可以修改<code>~/.bashrc</code>，在最后一行添加下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias qt=/home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p>然后每次启动都在终端使用<code>qt</code>命令启动QT，这样就ok了。</p>]]></content>
    
    
    <summary type="html">对机器人的软件开发的离不开ROS，可操作界面离不开Qt，本文介绍在Qt中调用ROS库的方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记04】对话框</title>
    <link href="https://www.mahaofei.com/post/e0de5819.html"/>
    <id>https://www.mahaofei.com/post/e0de5819.html</id>
    <published>2022-09-02T11:45:22.000Z</published>
    <updated>2022-09-02T11:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、模态和非模态对话框</h1><p>上一节中，我们实现了搭建一个简单的窗口，并且添加了如菜单栏、工具栏等项目。</p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>但现在的窗口只是徒有其形，其内部的功能却一个都没有实现。</p><p>这节我们实现点击一个按钮，弹出一个对话框的功能。</p><h2 id="1-1-介绍">1.1 介绍</h2><p>对话框分为两种</p><ul><li>模态对话框：弹出后，可以对其他窗口进行操作</li><li>非模态对话框：弹出后，无法点击除了对话框以外的其他区域（代码阻塞）</li></ul><h2 id="1-2-代码创建">1.2 代码创建</h2><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span>`</span></span><br></pre></td></tr></table></figure><p>编写对话框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew,&amp;QAction::triggered,[=]()&#123;</span><br><span class="line"><span class="comment">//模态对话框 （不可以对其他窗口进行操作） 非模态对话框 （可以对其他窗口进行操作）</span></span><br><span class="line"><span class="comment">//模态创建 阻塞</span></span><br><span class="line">    QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">    dlg.<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;模态对话框弹出了&quot;</span>;   <span class="comment">//需要引入#include &lt;QDebug&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非模态对话框</span></span><br><span class="line">    QDialog * dlg2 = <span class="keyword">new</span> <span class="built_in">QDialog</span> (<span class="keyword">this</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    dlg2-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;非模态对话框弹出了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二、标准对话框</h1><p>Qt提供了很多内置对话框：</p><table><thead><tr><th>Qt内置对话框</th><th>功能</th></tr></thead><tbody><tr><td>QColorDialog</td><td>选择颜色</td></tr><tr><td>QFileDialog</td><td>选择文件或者目录</td></tr><tr><td>QFontDialog</td><td>选择字体</td></tr><tr><td>QInputDialog</td><td>允许用户输入一个值，并将其值返回</td></tr><tr><td>QMessageBox</td><td>模态对话框，用于显示信息、询问问题等</td></tr><tr><td>QPageSetupDialog</td><td>为打印机提供纸张相关的选项</td></tr><tr><td>QPrintDialog</td><td>打印机配置</td></tr><tr><td>QPrintPreviewDialog</td><td>打印预览</td></tr><tr><td>QProgressDialog</td><td>显示操作过程</td></tr></tbody></table><p>以下以消息对话框为例。</p>]]></content>
    
    
    <summary type="html">介绍了Qt中的模态/非模态对话框，以及标准对话框。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记03】UI设计</title>
    <link href="https://www.mahaofei.com/post/549bf258.html"/>
    <id>https://www.mahaofei.com/post/549bf258.html</id>
    <published>2022-09-01T07:36:06.000Z</published>
    <updated>2022-09-01T07:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、QMainWindow</h1><h2 id="1-1-QMainWindow结构概览">1.1 QMainWindow结构概览</h2><p>QMainWindow由一个菜单栏、多个工具栏、多个铆接部件、一个状态栏、一个中心部件组成。各部件的具体布局区域如图所示。</p><p><img src="https://img-blog.csdn.net/20180106132722303" alt=""></p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><blockquote><p>上面图片所用到的代码及注释附在本文的最后</p></blockquote><h2 id="1-2-菜单栏QMenuBar">1.2 菜单栏QMenuBar</h2><p>菜单栏是窗口最上方的区域，基本每个软件的标题栏下面都会有这么一行，这就是菜单栏。</p><p><img src="https://img.mahaofei.com/img/20220902161029.png" alt=""></p><p>注意：菜单栏只能创建一个</p><p><strong>代码示例</strong></p><p>引入菜单栏QMenuBar</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>菜单栏创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br></pre></td></tr></table></figure><p>将菜单栏放入到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br></pre></td></tr></table></figure><p>创建菜单栏的菜单（比如文件、编辑、工具、帮助等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建菜单项（比如文件菜单下的新建、打开项）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902161412.png" alt=""></p><h2 id="1-3-工具栏QToolBar">1.3 工具栏QToolBar</h2><p>工具栏一般位于菜单栏下方，或者左右两侧、或底部。</p><p><img src="https://img.mahaofei.com/img/20220902161816.png" alt=""></p><p>注意：工具栏可以创建多个。</p><p><strong>代码示例</strong></p><p>引入工具栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建工具栏（工具栏创建后可以随意拖动）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将工具栏放入窗口，Qt::TopToolBarArea是默认放上侧，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br></pre></td></tr></table></figure><p>设置只允许左右停靠</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br></pre></td></tr></table></figure><p>设置浮动（可以拖拽，但移动不了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>设置移动（总开关，设为False后无法拖拽）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在工具栏中添加内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将刚才创建的菜单项Action添加到工具栏中</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line"><span class="comment">//添加另一个菜单项</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line"><span class="comment">//工具栏中添加控件</span></span><br><span class="line">QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902162526.png" alt=""></p><h2 id="1-4-状态栏QStatusBar">1.4 状态栏QStatusBar</h2><p>状态栏是窗口最低不，显示软件状态的栏。（例如ppt、word最下面显示字数、幻灯片数量的那一行）</p><p><img src="https://img.mahaofei.com/img/20220902162734.png" alt=""></p><p>注意：状态栏最多有一个。</p><p><strong>代码示例</strong></p><p>引入状态栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建状态栏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br></pre></td></tr></table></figure><p>将状态栏设置到窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setStatusBar</span>(stBar);</span><br></pre></td></tr></table></figure><p>在菜单栏中放入标签控件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902163152.png" alt=""></p><h2 id="1-5-铆接部件QDockWidget">1.5 铆接部件QDockWidget</h2><p>铆接部件又称为浮动窗口，是窗口中，在中心窗口周围的部件，通常是可以修改位置，可以拖出来成为单独的窗口，也可以双击使其回到父窗口中。</p><p>常见的铆接部件包括（IDE左侧或右侧的项目栏、底部的编译输出栏等）</p><p><img src="https://img.mahaofei.com/img/Screenshot%20from%202022-09-02%2016-54-35.png" alt=""></p><p>铆接部件可以有多个</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建铆接部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将铆接部件添加到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br></pre></td></tr></table></figure><p>设置铆接部件的停靠区域，例如只允许上下（与工具栏设置参数一致）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902172602.png" alt=""></p><h2 id="1-6-中心部件QTextEdit">1.6 中心部件QTextEdit</h2><p>中心部件就是一个程序中心的部分，例如IDE的程序编写区域，WPS的文字编辑区域等。</p><p>中心部件只能设置一个。</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建中心部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>设置中心部件到父窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setCentralWidget</span>(edit);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>中间白色的区域就是中心部件。</p><h2 id="1-7-UI工具设计图形界面">1.7 UI工具设计图形界面</h2><p>在Qt中也提供了图形化的UI设计界面。</p><p>通过双击项目文件中的<code>xxx.ui</code>文件，就可以打开设计页面。</p><p><img src="https://img.mahaofei.com/img/20220902192942.png" alt=""></p><p>在这里，上文提到的所有项目（菜单栏、工具栏等），以及各自的属性，都可以直接拖拽放置，并在右下角修改其属性。</p><p>创建的控件，在代码中通过<code>ui-&gt;abcd</code>可以找到所有控件。</p><p>但是这种布局方式所产生的代码结构较差。</p><p>通常是在代码中编写大概，然后在设计中进行微调。</p><h1>二、资源文件</h1><p>很多时候，在窗口中我们不仅需要文字，还需要添加一些图标，图片等，让应用显得更人性化。这就需要我们在项目中导入资源文件。</p><h2 id="2-1-资源文件的导入">2.1 资源文件的导入</h2><ol><li><p>首先将图片复制到项目文件夹中（注意图片必须是png格式，直接更改用户名无效，必须通过图片编辑软件转换）</p></li><li><p>右键项目名 -&gt; 添加新文件 -&gt; Qt -&gt; QtResourceFile</p></li></ol><p><img src="https://img.mahaofei.com/img/20220902193453.png" alt=""></p><ol start="3"><li><p>得到一个<code>.qrc</code>文件，右键，<code>open in edit</code></p></li><li><p>添加 -&gt; 前缀，自己设置一个前缀</p></li><li><p>添加 -&gt; 文件 -&gt; 找到图片文件夹 -&gt; 选中所有图片 -&gt; 打开</p></li><li><p>可以看到<code>.qrc</code>文件下方多了一个“前缀”文件夹</p></li></ol><h2 id="2-2-代码中使用">2.2 代码中使用</h2><p>代码中使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ui-&gt;actionNew-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(``<span class="string">&quot;:/前缀/图片文件夹名/图片文件名.png&quot;</span>``));`</span><br></pre></td></tr></table></figure><h1>附</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏  只能最多有一个</span></span><br><span class="line">    <span class="comment">//菜单栏创建</span></span><br><span class="line">    QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br><span class="line">    <span class="comment">//将菜单栏放入到窗口中</span></span><br><span class="line">    <span class="built_in">setMenuBar</span>(bar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单</span></span><br><span class="line">    QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单项</span></span><br><span class="line">    QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏  可以有多个</span></span><br><span class="line">    QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后期设置 只允许 左右停靠</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置浮动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置移动 (总开关)</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏中可以设置内容</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    <span class="comment">//工具栏中添加控件</span></span><br><span class="line">    QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏 最多有一个</span></span><br><span class="line">    QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br><span class="line">    <span class="comment">//设置到窗口中</span></span><br><span class="line">    <span class="built_in">setStatusBar</span>(stBar);</span><br><span class="line">    <span class="comment">//放标签控件</span></span><br><span class="line">    QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//铆接部件 （浮动窗口） 可以有多个</span></span><br><span class="line">    QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br><span class="line">    <span class="comment">//设置后期停靠区域，只允许上下</span></span><br><span class="line">    dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置中心部件 只能一个</span></span><br><span class="line">    QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(edit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了QMainWindow相关的实现方法，包括菜单栏、工具栏、状态栏、铆接部件、中心部件等。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记02】自定义信号与槽函数</title>
    <link href="https://www.mahaofei.com/post/b61fb72.html"/>
    <id>https://www.mahaofei.com/post/b61fb72.html</id>
    <published>2022-08-27T12:43:15.000Z</published>
    <updated>2022-08-27T12:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自定义信号和槽</h1><p>实现功能：定义两个类，mysignal类，myslot类。mysignal类发出信号hello，myslot响应信号打印Hello World。</p><p><strong>（1）创建类</strong></p><p>首先右键项目-添加新文件-创建新的C++类，基类选择QObject。</p><p><img src="https://img.mahaofei.com/img/20220827210652.png" alt=""></p><p><strong>（2）自定义信号和槽函数</strong></p><p>自定义信号写到signals下。返回值是void，只需要声明，不需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysignal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSIGNAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSIGNAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySignal</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySignal</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;   <span class="comment">//添加了自定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSIGNAL_H</span></span></span><br></pre></td></tr></table></figure><p>自定义槽函数写在public slots下。返回值是void，需要声明，也需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSLOT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSLOT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySlot</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySlot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;    <span class="comment">//添加了自定义槽</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSLOT_H</span></span></span><br></pre></td></tr></table></figure><p>实现槽函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span>    <span class="comment">//QDebug可在底部打印输出字符串</span></span></span><br><span class="line"></span><br><span class="line">MySlot::<span class="built_in">MySlot</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义槽函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySlot::printhello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;Hello World!&quot;</span>);    <span class="comment">//输出HelloWorld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）创建两个类的对象并使用connect进行连接</strong></p><p>首先在widget.h中声明两个类的指针，然后在widget.cpp中new两个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span>  <span class="comment">//引入两个类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;    <span class="comment">//声明两个类的指针</span></span><br><span class="line">    MySlot * myslot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;    <span class="comment">//new两个对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）创建触发函数</strong></p><p>只有上面的代码，虽然创建了两个类，也定义了信号和槽函数，但是缺少触发条件，此时运行程序，程序无反应。</p><p>在widget.h的widget类的private中声明触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;</span><br><span class="line">    MySlot * myslot;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mytrigger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure><p>在widget.cpp下方定义触发函数，并在widget中添加触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;</span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">    <span class="built_in">mytrigger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">widget::mytrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit mysignal-&gt;<span class="built_in">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220827213040.png" alt=""></p><h1>二、信号的连接与断开</h1><h2 id="2-1-信号连接信号">2.1 信号连接信号</h2><p>connect不仅可以连接信号与槽，也可以连接信号与信号，实现当触发一个信号时，由该信号继续触发另一个信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello);</span><br></pre></td></tr></table></figure><h2 id="2-2-信号与槽断开">2.2 信号与槽断开</h2><p>断开信号使用disconnect关键字，其参数与connect完全相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">信号与槽是QT中最重要的概念之一，信号与槽可以实现发送端和接收端的信号传输，是qt各种操作的基础。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【QT学习笔记01】Qt基础、按钮、对象树以及信号和槽的基本使用</title>
    <link href="https://www.mahaofei.com/post/e1f7a4b6.html"/>
    <id>https://www.mahaofei.com/post/e1f7a4b6.html</id>
    <published>2022-08-27T02:50:59.000Z</published>
    <updated>2022-08-27T02:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Qt的介绍</h1><p><strong>Qt</strong>是一个<strong>跨平台</strong>的<strong>C++图形用户界面应用程序框架</strong>。为应用程序开发者提供建立艺术级图形界面所需的所有功能。Qt是完全面向对象的，很容易扩展，且允许真正的组件编程。</p><p>支持Windows、Linux、MacOS、嵌入式平台等全平台开发。</p><p>Qt的优点</p><ul><li>跨平台，几乎支持所有平台</li><li>接口简单，容易上手</li><li>简化了内存回收机制</li><li>开发效率高，可快速构建应用程序</li><li>社区氛围好</li><li>可进行嵌入式开发</li></ul><p>Qt的案例</p><ul><li>Linux桌面环境KDE</li><li>WPS Office</li><li>Skype</li><li>Google Earth</li><li>VirtualBox<br>以上都是使用Qt进行开发的。</li></ul><h1>二、第一个Qt程序</h1><h2 id="2-1-界面介绍">2.1 界面介绍</h2><p><img src="https://img.mahaofei.com/img/20220827133056.png" alt=""></p><ul><li>欢迎界面<ul><li>工程：创建、打开工程</li><li>示例：提供了各行各业一些现成的qt工程，可以直接打开学习其代码</li><li>教程：Qt官方提供的教程，感觉不如b站大学</li></ul></li><li>编辑<ul><li>进行应用程序代码编写，C++</li></ul></li><li>设计<ul><li>进行界面UI设计</li></ul></li><li>Debug<ul><li>如名</li></ul></li><li>项目<ul><li>进行一些项目配置</li></ul></li><li>帮助<ul><li>非常重要，很多想要实现的功能都可以通过查阅帮助文档实现</li></ul></li></ul><h2 id="2-2-第一个项目">2.2 第一个项目</h2><p>注意，项目名称和路径中都不要出现<strong>中文和空格</strong>。</p><p><strong>（1）创建项目</strong></p><p>基类：</p><ul><li>QWidget：是下面两种基类的父类，创建后什么都没有</li><li>QMainWindow：多了菜单栏和工具，以及底部状态栏</li><li>QDialog：多了对话框</li></ul><p>类名：</p><ul><li>创建自己的类</li></ul><p><img src="https://img.mahaofei.com/img/20220827135159.png" alt=""></p><p>创建完成后如图，注意这里没有勾选ui文件，因此工程目录如左面所示。</p><p><strong>（2）main文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span>  <span class="comment">//新建qt工程后的类.h文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>  <span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main程序入口，argc命令行变量的数量，argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//a是应用程序对象，在Qt中有且只有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//通过自定义的类，实例化一个对象（窗口对象）</span></span><br><span class="line">    <span class="comment">//其父类在创建项目时选择</span></span><br><span class="line">    learning01 w;</span><br><span class="line">    <span class="comment">//窗口对象默认不会显示，必须调用show方法显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让应用程序对象进入消息循环机制</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息循环机制：</p><p>在正常C++中，运行后窗口都会一闪而过，一般只有添加system(“pause”)才能看到输出窗口。而在qt中，应用程序会阻塞到return行，等待用户的鼠标键盘操作，或点击窗口右上角x才可以退出程序。</p><p><strong>（3）.pro文件</strong></p><p>注意：除非知道你在做什么，否则不要动.pro文件，里面的内容会根据项目自动更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt包含的模块</span></span><br><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于4版本以上，包含 wigdet 模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标，生成的.exe程序的名称</span></span><br><span class="line">TARGET = learning01</span><br><span class="line"><span class="comment"># 模板，应用程序模板</span></span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件，自动追加</span></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        learning01.cpp</span><br><span class="line"><span class="comment"># 头文件，自动追加</span></span><br><span class="line">HEADERS += \</span><br><span class="line">        learning01.h</span><br></pre></td></tr></table></figure><p><strong>（4）头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARNING01_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARNING01_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含头文件QWidget窗口类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">learning01</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">//Q_OBJECT宏，允许类中 使用信号和槽的机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">learning01</span>(QWidget *parent = <span class="number">0</span>);    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">learning01</span>();    <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LEARNING01_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（5）cpp文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;learning01.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;QApplication&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    learning01 w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（6）快捷键</strong></p><ul><li>注释：ctrl + /</li><li>运行：ctrl + r</li><li>编译：ctrl + b</li><li>查找：ctrl + f</li><li>整行移动：ctrl + shift +↑/↓</li><li>字体缩放：ctrl + 滚轮</li><li>自动对齐：ctrl + i</li><li>同名之间的.h和.cpp切换：F4</li></ul><h1>三、按钮控件</h1><p><strong>（1）创建按钮</strong></p><p>使用QPushButton创建按钮，需要指定父类（否则会新建窗口生成按钮），设置文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）其他操作</strong></p><p>见代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、对象树</h1><p>QObject是以对象树的形式组织的。</p><p>当创建一个QObject对象，并指定了父对象指针时，会自动将其添加到其父对象的children()列表。</p><p>当父对象析构时，children()列表的所有对象都会析构。</p><p><img src="https://img-blog.csdnimg.cn/2020121618000044.png" alt=""></p><h1>五、信号与槽</h1><p>实现点击按钮关闭窗口</p><p>具体过程如下：</p><ol><li>信号的发送者</li><li>发送具体信号</li><li>信号的接受者</li><li>对信号进行处理（槽函数）</li></ol><p>以上四个就是信号传递connect的四个参数。</p><p>信号槽的优点：松散耦合，信号发送端和接收端本身是没有关联的，通过connect函数进行连接。</p><p>connect()函数参数</p><ul><li>参数1：信号的发送者，按钮对象</li><li>参数2：发送的信号，clicked, pressed, released,toggled</li><li>参数3：信号的接受者，窗口，this</li><li>参数4：信号的处理，close</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/************* 创建按钮 ************/</span></span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************* 按钮关闭窗口 ************/</span></span><br><span class="line">    <span class="comment">//参数1：信号的发送者; 参数2：发送的信号;</span></span><br><span class="line">    <span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;QWidget::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了QT的基础，并给出了QT第一个程序的创建过程（空窗口与按钮）。介绍了信号和槽的概念与最简单的按下按钮关闭窗口功能的实现。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记08】经典神经网络</title>
    <link href="https://www.mahaofei.com/post/4a294477.html"/>
    <id>https://www.mahaofei.com/post/4a294477.html</id>
    <published>2022-08-21T10:57:11.000Z</published>
    <updated>2022-08-21T10:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、目标定位</h1><h2 id="1-1-基本思想">1.1 基本思想</h2><p>目标定位是在图像分类的基础上发展而来的，而目标检测又是建立在目标定位的基础之上。</p><p>对于一张图片来说，我们可以通过卷积神经网络以及softmax函数实现图像的分类，例如人、车、自行车等。</p><p><strong>如果我们想要定位目标在图像中的位置，我们可以让softmax函数多输出几个数字，例如多输出4个数字来描述边界框的位置(bx, by, w, h)</strong>。这样训练集就不仅是图像的分类数据了，还要包括图像中的边界框坐标。</p><h2 id="1-2-标签的定义">1.2 标签的定义</h2><p>根据上面的思想，我们可以将图像的标签定义为如下：</p><p>$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有物体（区分物体与背景）</li><li>$b_x, b_y, b_w, b_h$：边界框的中心坐标以及宽高</li><li>$c_1, c_2, c_3$：图像中物体属于三类的概率</li></ul><h2 id="1-3-损失函数的设计">1.3 损失函数的设计</h2><p>对于上面定义的标签，如果采用平方损失策略，则损失函数定义如下：</p><p>如果$y_1=1$，即图片中有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2+(\hat y_2-y_2)^2+\dots+(\hat y_8-y_8)^2$</p><p>（由于标签中共有8个元素，因此从$y_1$到$y_8$）</p><p>如果$y_1=0$，即图片中没有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2$</p><h1>二、特征点检测</h1><p>上面我们介绍了通过在标签中添加4个参数$b_x, b_y, b_w, b_h$来输出边界框的坐标。</p><p>特征点检测也是类似的原理。</p><p>加入我们出于某种原因，想要获取一个人的四个眼角在图像中的坐标，那么我们完全可以将其添加到标签中，事先标记好训练图像中每个人的眼角坐标，然后用神经网络进行训练。</p><p>$y = [P_c, l_{1x}, l_{1y}, l_{2x}, l_{2y}, \dots, l_{4x}, l_{4y}]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有人脸（图像分类）</li><li>$l_{1x}, l_{1y}, \dots, l_{4x}, l_{4y}$：四个眼角的xy坐标</li></ul><p>这与边界框的获取，图片的分类等等，都是同样的原理。</p><p>如果我们想更进一步，获取脸部表情，我们可以在人脸上设置多个特征点，然后再每一张图片上的人脸作标注，然后由神经网络来回归计算。</p><p>通过这种方式，就可以实现特征点的检测。</p><h1>三、目标检测</h1><p>目标检测的基础是图像分类。</p><h2 id="3-1-滑动窗口法">3.1 滑动窗口法</h2><p>以汽车检测为例：</p><p>首先在训练集来说，我们可以使用让汽车占满全部区域的图片来作为训练图片，可以通过在其他照片中裁减出来汽车所占据的区域。</p><p>对于一张给定图片，我们在图像上选取一个小窗口，将这个小窗口内的图像传入神经网络中，判断这个小窗口中的图像是不是一辆车，然后移动小窗口到下一个位置，继续检测。整幅图片遍历完成之后，再调整窗口的大小，重新遍历。</p><p><img src="https://img.mahaofei.com/img/20220910194902.png" alt=""></p><p>这种算法一般就被称为滑动窗口法。</p><p>这种算法的优点是算法设计简单，但也有很明显的缺点就是计算量太大，而且需要合理选择窗口大小和步幅，否则无法准确定位图像中的物体。</p><h2 id="3-2-获取更精准的边界框">3.2 获取更精准的边界框</h2><p>现有问题：使用滑动窗口法</p><ul><li>如果步长较大，所标出的窗口经常不能很好的完全覆盖目标物体，如果步长较小，计算量又过大。</li><li>目标物体有时不是规则的正方形，使用正方形的滑动窗口，获得的边界框精度不够</li></ul><p>解决思路</p><ol><li>利用图像定位算法，将图片分割成9个网格，对每一个网格进行图像定位，使用类似于$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$的标签进行训练。</li><li>这样每一个格子都会获得一个输出，例如$y = [1, b_x, b_y, b_w, b_h, 0, 1, 0]^T$，这样综合来看，输出的维度就是3x3x8。3x3是格子数量，8是输出参数个数。</li></ol><p>这样，相比于滑动窗口来说，滑动窗口是将覆盖范围最大的那个窗口，作为边界框输出。而这里则是将边界框作为四个参数作回归了。</p><p>优点：</p><ul><li>由于使用卷积处理不同格子时，很多计算步骤是共享的，因此大大提高了计算效率</li><li>并且由于是卷积实现，所以计算速度非常快，可以达到实时识别</li></ul><h2 id="3-3-非极大抑制NMS（Non-Max-Suppression）">3.3 非极大抑制NMS（Non-Max Suppression）</h2><p>问题：算法可能对同一个物体识别多次，我们需要采取某种措施使算法对每个对象只检测一次。</p><p><img src="https://img.mahaofei.com/img/20220911144627.png" alt=""></p><p>解决方法：</p><p>在输出结果中，找到识别结果概率最高的一个，例如图中的0.9，将与这个框交并比较大的其他框抑制掉，我们认为这个0.9的框就标出了一个对象。</p><p>然后找到剩余所有框中概率最高的一个，例如图中的0.8，将与这个框交并比较大的其他框抑制掉，得到预测结果。</p><blockquote><p>交并比$IOU=\frac{交集区域}{并集区域}$</p></blockquote><p>实现流程</p><ul><li>将图片分为nxn个格子，对每个格子进行预测，获得包括物体存在概率，边界框位置大小等参数</li><li>删除所有物体存在概率小于0.6的边界框</li><li>对剩余的边界框<ul><li>选取概率最高的边界框作为输出，认为其标出了某个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>在剩余的边界框中在找概率最高的边界框作为输出，认为其中也标出了另一个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>重复过程</li></ul></li></ul>]]></content>
    
    
    <summary type="html">目标检测的基本实现方法，从目标定位开始，总结了特征点检测、目标检测、滑动窗口法、NMS非极大抑制等目标检测的算法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记08】经典神经网络</title>
    <link href="https://www.mahaofei.com/post/4a294477.html"/>
    <id>https://www.mahaofei.com/post/4a294477.html</id>
    <published>2022-08-20T11:37:11.000Z</published>
    <updated>2022-08-20T11:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeNet-5</h1><p>该网络的作用可用于手写数字识别。</p><p><img src="https://img.mahaofei.com/img/20220820194640.png" alt=""></p><ul><li>输入：32x32x1的手写数字图片</li><li>卷积：f=5, s=1, filters=6，图像变为28x28x6</li><li>平均池化：f=2, s=2，图像变为14x14x6</li><li>卷积：f=5, s=2, filters=16，图像变为10x10x16</li><li>平均池化：f=2, s=2，图像变为5x5x16</li><li>全连接层：400 -&gt; 120</li><li>全连接层：120 -&gt; 84</li><li>分类：10类输出</li></ul><p>共计约6万个参数，使用sigmoid作为激活函数。</p><h1>AlexNet</h1><p><img src="https://img.mahaofei.com/img/20220821082332.png" alt=""></p><ul><li>输入：227x227x3的包含目标物体的图片</li><li>卷积：f=11, s=4, filters=96，图像变为55x55x96</li><li>最大池化：f=3, s=2，图像变为27x27x96</li><li>卷积same：f=5, padding=2,filters=256，图像变为27x27x256</li><li>最大池化：f=3, s=2，图像变为13x13x256</li><li>卷积same：f=3, padding=1, filters=384，图像变为13x13x384</li><li>卷积same：f=3, padding=1, filters=384，图像维度不变</li><li>卷积same：f=3, padding=1, filters=256，图像变为13x13x256</li><li>最大池化：f=3, s=2，图像变为6x6x256</li><li>全连接层：9216 -&gt; 4096</li><li>全连接层：4096 -&gt; 4096</li><li>分类输出：softmax分为1000类</li></ul><p>共计约6000万个参数，使用ReLU作为激活函数，</p><h1>VGG-16</h1><p><img src="https://img.mahaofei.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-08-21%20083422.png" alt=""></p><ul><li>输入：224x224x3的图片</li><li>卷积网络<ul><li>卷积：f=3, s=1, same</li><li>最大池化：f=2, s=2</li><li>重复16次</li></ul></li><li>全连接层</li><li>softmax</li></ul><p>共计约1.38亿参数，每一组卷积层后，图像缩小一倍，通道数量翻倍。</p><h1>ResNet</h1><p><img src="https://img.mahaofei.com/img/20220821092154.png" alt=""></p><h2 id="残差块">残差块</h2><p>ResNet网络是由残差块构成的。</p><p><img src="https://img.mahaofei.com/img/20220821084324.png" alt=""><br><img src="https://img.mahaofei.com/img/20220821084748.png" alt=""></p><p>这样$a^{[l+2]}=g(z^{[l+2]}+a^{[l]})$</p><h2 id="ResNet的意义">ResNet的意义</h2><p>对于没有残差连接的普通神经网络而言，网络越深，优化算法越难训练，并且随着网络深度的加深，训练错误会越来越多。</p><p>如果有了ResNet，即使网络深度很深，错误率也不会上升。</p><h2 id="为什么ResNet有效">为什么ResNet有效</h2><p>如果在很深的网络处，有某层网络出现了梯度消失的问题，即W=0。</p><p>根据$a^{[l+2]}=g(z^{[l+1]}+a^{[l]})=g(w^{[l+2]}a^{[l+1]}+b^{[l+2]}+a^{[l]})$</p><p>由于梯度消失，$w^{[l+2]}=0$，此时若$b^{[l+2]}=0$，则$a^{[l+2]}=g(0+0+a^{[l]})=g(a^{[l]})$，因为激活函数是ReLU函数，$a^{[l]}$已经激活过，因此$a^{[l+2]}=g(a^{[l]})=a^{[l]}$。</p><p>这样就相当于跳过了梯度消失的部分。</p><h1>Inception网络</h1><p><img src="https://img.mahaofei.com/img/20220821100948.png" alt=""></p><p>上图为Inception模块，原理就是将不同卷积核卷积出的结果，按通道叠加连接成一个具有所有卷积特征的大方块。</p><p>由于提供了各种不同的卷积核，因此网络训练时可以自动选择效果最好的一种或几种卷积核组合，避免了使用单一类型的卷积核的限制。</p><p><img src="https://img.mahaofei.com/img/20220821101431.png" alt=""></p><p>这是Inception网络的结构，其就是将传统的卷积层替换为了Inception模块。</p>]]></content>
    
    
    <summary type="html">本文介绍了一些经典的神经网络模型，包括实现LeNet-5，AlexNet，VGG-16，ResNet，Inception网络等的网络结构。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记07】卷积神经网络</title>
    <link href="https://www.mahaofei.com/post/c2525cf1.html"/>
    <id>https://www.mahaofei.com/post/c2525cf1.html</id>
    <published>2022-08-18T01:21:51.000Z</published>
    <updated>2022-08-18T01:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、卷积运算</h1><p>前面已经提到，对于一个神经网络来说，例如人脸识别，前面的层主要用来提取图像的边缘，中间的层主要用来检测部分如眼睛鼻子嘴等，后面的层主要用来检测整个人脸。</p><h2 id="1-1-如何检测边缘">1.1 如何检测边缘</h2><p>通常使用不同的卷积核或者称过滤器来实现各种边缘检测。</p><p><strong>（1）垂直边缘</strong></p><p>使用如下的卷积核进行检测：</p><p><img src="https://img.mahaofei.com/img/20220818095121.png" alt=""></p><p>例如，对于一张具有垂直边缘的图像，利用此卷积核进行卷积运算，输出结果在边缘处数值较大，在图像变化缓慢的区域数值较小。</p><p><img src="https://img.mahaofei.com/img/20220818095338.png" alt=""></p><p>上面的卷积运算可以很好的计算出图像中边缘在什么位置，并且，如果卷积的结果是正值，说明从左到右是从亮到暗的变化，如果是负值，说明从左到右是从暗到亮的变化。</p><p><strong>（2）水平边缘</strong></p><p><img src="https://img.mahaofei.com/img/20220818095712.png" alt=""></p><p>此卷积核可以计算图像的水平边缘，并且正值代表上方亮下方暗，数值越大边缘变化越明显。</p><p><strong>（3）其他滤波器</strong></p><p><img src="https://img.mahaofei.com/img/20220818100201.png" alt=""></p><p>通过定义卷积核中的值的分布，可以实现检测不同方向的，不仅是水平竖直，也可以是45°75°。</p><p>此外还可以改变各行的数值，例如1：2：1，来实现更有目标的检测。</p><h2 id="1-2-Padding">1.2 Padding</h2><p><strong>（1）普通卷积存在的问题</strong></p><ul><li>图像缩小：对于一个(n, n)的图像，使用(f, f)的卷积核做卷积，得到的图像大小是(n-f+1, n-f+1)，因此每做一次卷积，图像大小都会减小。</li><li>边缘信息丢失：图像角落的像素只会被一个卷积核处理，边缘像素相比于中间的像素，也会容易丢失很多信息。</li></ul><p><strong>（2）解决方法</strong></p><p>在进行卷积操作之前，先在图像边缘填充一层像素。</p><p>例如在图像边缘添加p层像素，那么卷积后图像大小是(n+2p-f+1, n+2p-f+1)。</p><p><strong>通常情况下，卷积核边长是奇数</strong></p><h2 id="1-3-卷积步长">1.3 卷积步长</h2><p>使用一个(f, f)的卷积核，卷积一个(n, n)的图像，padding为p，步长为s，输出的图像维度为$(\frac{n+2p-f}{s}+1, \frac{n+2p-f}{s}+1)$</p><h1>二、三维卷积</h1><h2 id="2-1-三维卷积基础">2.1 三维卷积基础</h2><p>例如对于一个RGB图像来说，其有(w, h, 3)的维度，对其进行卷积，必须是(f, f, 3)的维度。</p><p>即<strong>图像和卷积核的通道数要相同</strong>。</p><p><strong>卷积完成后的输出图像是(w-f+1, h-f+1, n)的n通道图像，其中n是卷积核的个数。</strong></p><p><img src="https://img.mahaofei.com/img/20220818205222.png" alt=""></p><h2 id="2-2-三维卷积在神经网络的应用">2.2 三维卷积在神经网络的应用</h2><p>三维卷积在神经网络的应用，与传统方法基本一致。</p><p>在传统方法中有，$z^{[1]}=w^{[1]}a^{[0]}+b^{[1]}$，其中$a^{[0]}$就是输入x，$a^{[1]}=g(z^{[1]})$</p><p>而若是卷积运算，则只需将输入图片替换x，卷积核替换w，然后同样添加偏差和非线性激活函数即可。</p><p><img src="https://img.mahaofei.com/img/20220818210442.png" alt=""></p><h1>三、池化层</h1><p>池化层可以缩小模型大小，提高运算速度，提高模型的鲁棒性。</p><h2 id="3-1-最大池化">3.1 最大池化</h2><p>例如对一个4x4的输入，最大池化选择2x2，那么输出就是将4x4的输入分成4部分，每部分取最大值填充到2x2中。最大池化输出维度的计算方法与卷积相同。</p><p><img src="https://img.mahaofei.com/img/20220818215833.png" alt=""></p><p>最大池化的作用是，如果卷积过滤提取到了某个特征，那么保留其最大值，如果没有提取到特征，那么最大值也还是很小。</p><h2 id="3-2-平均池化">3.2 平均池化</h2><p>平均池化与最大池化类似，是在不同区域内求平均值，主要用在很深的网络。</p><p>目前来说最大池化比平均池化更常用。</p><h2 id="3-3-池化总结">3.3 池化总结</h2><p>池化的参数主要有：</p><ul><li>f：池化过滤器大小</li><li>s：补偿</li><li>最大或平均池化</li></ul><p>由于池化层没有权重，只有上面一些超参数，因此一般来说会将卷积层和池化层合并称为一层。</p><h1>四、全连接层</h1><p>在神经网络的最后，经过多轮的卷积和池化处理，最后的输出往往是宽高较小，通道数较多。这是我们会将其展开成为一个向量，这个向量的长度就等于上一层输出的$w\times h\times c$，将向量中的所有参数作为同样数量单元的输入，进行常规神经网络计算，这就是全连接层。</p><h1>五、代码实现</h1><p><strong>（1）添加padding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero_pad</span>(<span class="params">X, pad</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对数据集X的所有图像添加pad，padding被应用再一张图片的宽和高方向上。</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- numpy数组，shape (m, n_H, n_W, n_C) 代表批量为m的图片</span></span><br><span class="line"><span class="string">    pad -- 整数，图片边缘填充的pad大小</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    X_pad -- 添加了以0填充的pad图片，shape (m, n_H + 2*pad, n_W + 2*pad, n_C)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    X_pad = np.pad(X, ((<span class="number">0</span>, <span class="number">0</span>), (pad, pad), (pad, pad), (<span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_pad</span><br></pre></td></tr></table></figure><p><strong>（2）单步卷积（numpy实现）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_single_step</span>(<span class="params">a_slice_prev, W, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在上一层的一个切片用卷积核W进行卷积, 并添加偏差b</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    a_slice_prev -- 输入数据的切片，shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- 权重参数，以卷积核的形式体现，shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    b -- 偏置参数，shape (1, 1, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    Z -- 标量，滑动窗口(W, b)与输入切片x的卷积计算的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># a_slice 和 W 按元素相乘并添加偏置.</span></span><br><span class="line">    S = np.multiply(W, a_slice_prev) + b</span><br><span class="line">    <span class="comment"># 求和</span></span><br><span class="line">    Z = np.<span class="built_in">sum</span>(S)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z</span><br></pre></td></tr></table></figure><p><strong>（3）三维卷积（numpy实现）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_forward</span>(<span class="params">A_prev, W, b, hparameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    卷积前向计算</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 上一层的激活输出，shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- 权重, shape (f, f, n_C_prev, n_C)</span></span><br><span class="line"><span class="string">    b -- 偏置, shape (1, 1, 1, n_C)</span></span><br><span class="line"><span class="string">    hparameters -- 包含 &quot;stride&quot; 和 &quot;pad&quot; 的字典</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    Z -- 卷积输出，shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- 缓存，用于conv_backward()函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 A_prev 的维度  </span></span><br><span class="line">    m, n_H_prev, n_W_prev, n_C_prev = A_prev.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取 W 的维度</span></span><br><span class="line">    f, _, n_C_prev, n_C = W.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 hparameters 中的参数</span></span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    pad = hparameters[<span class="string">&quot;pad&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算卷积输出的维度</span></span><br><span class="line">    n_H = (n_H_prev - f + <span class="number">2</span> * pad) // stride + <span class="number">1</span></span><br><span class="line">    n_W = (n_W_prev - f + <span class="number">2</span> * pad) // stride + <span class="number">1</span></span><br><span class="line">    n_C = W.shape[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 零初始化卷积输出变量Z</span></span><br><span class="line">    Z = np.zeros((m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用函数，填充0创建 A_prev_pad </span></span><br><span class="line">    A_prev_pad = zero_pad(A_prev, pad)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在训练样本的批量中循环</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 选择第e个填充样本</span></span><br><span class="line">        A_prev_pad_e = A_prev_pad[e]</span><br><span class="line">        <span class="comment"># 在输出Z的竖直方向遍历</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n_H):</span><br><span class="line">            <span class="comment"># 在输出Z的水平方向遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n_W):</span><br><span class="line">                <span class="comment"># 遍历所有通道，通道数为卷积核个数</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_C):</span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot; (≈4 lines)</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + pad</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 确定被卷积区域</span></span><br><span class="line">                    A_prev_pad_slice = A_prev_pad_e[vert_start:vert_end, horiz_start:horiz_end, :]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 使用卷积核W和偏置b进行卷积</span></span><br><span class="line">                    Z[e, h, w, c] = np.<span class="built_in">sum</span>(np.multiply(A_prev_pad_slice, W[:, :, :, c]) + b[:, :, :, c])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出维度正确</span></span><br><span class="line">    <span class="keyword">assert</span>(Z.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将信息保存在cache中，用于反向传播</span></span><br><span class="line">    cache = (A_prev, W, b, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z, cache</span><br></pre></td></tr></table></figure><p><strong>（4）池化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: pool_forward</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool_forward</span>(<span class="params">A_prev, hparameters, mode = <span class="string">&quot;max&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前向传播的池化层</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 输入数据，shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    hparameters -- 包含 &quot;f&quot; 和 &quot;stride&quot; 的python字典</span></span><br><span class="line"><span class="string">    mode -- 想要使用的池化模式, 定义为字符串 (&quot;max&quot; or &quot;average&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    A -- 池化层输出，shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- 保存池化层的数据，用于反向传播</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取输入数据的维度</span></span><br><span class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从 &quot;hparameters&quot; 中获取超参数</span></span><br><span class="line">    f = hparameters[<span class="string">&quot;f&quot;</span>]</span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义输出维度</span></span><br><span class="line">    n_H = <span class="built_in">int</span>(<span class="number">1</span> + (n_H_prev - f) / stride)</span><br><span class="line">    n_W = <span class="built_in">int</span>(<span class="number">1</span> + (n_W_prev - f) / stride)</span><br><span class="line">    n_C = n_C_prev</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化输出矩阵A</span></span><br><span class="line">    A = np.zeros((m, n_H, n_W, n_C))              </span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 在训练样本的批量中循环</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 在输出Z的竖直方向遍历</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n_H):</span><br><span class="line">            <span class="comment"># 在输出Z的水平方向遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n_W):</span><br><span class="line">                <span class="comment"># 遍历所有通道</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_C):</span><br><span class="line">                    <span class="comment"># 找到当前要进行池化的区域</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + f</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 使用上面的角坐标定义slice区域</span></span><br><span class="line">                    A_prev_slice = A_prev[e, vert_start:vert_end, horiz_start:horiz_end, c]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 根据池化模式在slice进行计算，求最大值或平均值</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">                        A[e, h, w, c] = np.<span class="built_in">max</span>(A_prev_slice)</span><br><span class="line">                    <span class="keyword">elif</span> mode == <span class="string">&quot;average&quot;</span>:</span><br><span class="line">                        A[e, h, w, c] = np.mean(A_prev_slice)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存输入和超参数，用于反向传播</span></span><br><span class="line">    cache = (A_prev, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保输出维度正确</span></span><br><span class="line">    <span class="keyword">assert</span>(A.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A, cache</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">为什么神经网络对图片进行分析时经常使用卷积，为什么会有padding和stride，池化层和全连接层的作用是什么？</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记06】参数调试处理</title>
    <link href="https://www.mahaofei.com/post/bd5d217b.html"/>
    <id>https://www.mahaofei.com/post/bd5d217b.html</id>
    <published>2022-08-14T09:09:52.000Z</published>
    <updated>2022-08-14T09:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、超参数的取值</h1><p><strong>需要处理的参数通常包括：</strong></p><table><thead><tr><th>参数</th><th>常用取值范围</th><th>调试重要度</th></tr></thead><tbody><tr><td>学习率$\alpha$</td><td>0.1</td><td>最重要</td></tr><tr><td>动量</td><td>0.9</td><td>重要</td></tr><tr><td>优化参数$\beta_1,\beta_2,\epsilon$</td><td>$\beta_1=0.9,\beta_2=0.999,\epsilon=10^{-8}$</td><td>一般不修改</td></tr><tr><td>层数layers</td><td></td><td>一般</td></tr><tr><td>隐藏单元数hidden units</td><td></td><td>重要</td></tr><tr><td>学习率衰减learning rate decay</td><td></td><td>一般</td></tr><tr><td>批量大小mini-batch size</td><td></td><td>重要</td></tr></tbody></table><p><strong>如何调试选择参数：</strong></p><ol><li>首先大范围随机选择参数，根据随机取点测试超参数的效果，确定影响最大的参数是哪个。因为对于实际问题而言，很难确定哪个超参数对结果的影响更大，在众多参数中如果一个一个测试往往找不到需要调试的参数。</li><li>采用由粗糙到精细的策略，找到随机测试中结果较好的参数范围，然后放大这一范围，在其中更密集的取值测试，搜索超参数的最优选择。</li></ol><p><strong>如何有效的随机取值</strong></p><p>例如在搜索学习率$\alpha$的取值，其取值可能范围是0.0001-1。如果使用常规的随机取值，那么取到的值将有90%在0.1-1，只有10%在0.0001-0.1，而实际情况是学习率在后者的可能性更大。</p><p>为了解决这个问题，可以采用对数轴。在对数轴上随机取值，这样就可以保证在0.0001-0.1的取值数量大幅增加。</p><p><img src="https://img.mahaofei.com/img/20220814172926.png" alt=""></p><p>又例如在搜索动量$\beta$的值，其取值范围可能是0.9-0.999，但是实际取值肯定会更接近0.9，因此也可以使用上面的方法，通过用上面的方法取$1-\beta$的值[0.001,0.1]，来间接取$\beta$的值。</p><blockquote><p>关于为什么要采用非线性轴取值？因为超参数在不同的范围，对结果的灵敏度不同，以动量$\beta$为例，其在0.9变化为0.9001，比从0.999变为0.9991，对结果的影响要大很多。因此需要更多的在灵敏度高的区间取值，故采用了非线性轴取值方法。</p></blockquote><h1>二、Batch-Normalization(BN)</h1><h2 id="2-1-BN的基本思路">2.1 BN的基本思路</h2><p>在logistic回归中，我们使用了归一化方法（计算平均值、方差），改善了训练样本，加快了梯度下降的速度。</p><p>但在深层网络中，下一层做梯度下降的数据是上一层网络的输出结果。实际中会将上一层的数据，在激活之前进行归一化，然后再激活，传递给下一层。</p><p>在神经网络中，假设有一些隐藏单元值$z^{(1)}\dots z^{(m)}$，计算：</p><p>$\mu=\frac{1}{m}\sum_i z^{(i)}$<br>$\sigma^2=\frac{1}{m}\sum_i(z_i-\mu)^2$<br>$Z^{(i)}_{norm}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\epsilon}}$</p><p>这样就实现了将每层网络的输出z进行了标准化，这时输出就是平均值0和方差1的数据，我们虽然想通过正则化规范数据，加快梯度下降，但我们不想让它们都服从同样均值和方差的分布，因此有了下面的变式：</p><p>$\widetilde z^{(i)}=\gamma z_{norm}^{(i)}+\beta$</p><p>这里的$\gamma,\beta$是新的超参数，作用是设置输出z的平均值和方差。</p><h2 id="2-2-BN为何有效">2.2 BN为何有效</h2><p>BN可以使权重比网络更滞后或更深层。</p><p>对于神经网络的某一层而言，其输入数据就是上一层的输出，由于随着参数的更新，上一层的输出是实时变化的，这就导致当前层的训练总是面对不同分布的输入。</p><p>使用BN后，可以将上一层的数据归一化到同一分布中，使上一层的输出数据更加稳定，进而保证之后的层有更好的基础。</p><p>总而言之，BN减弱了前层参数的作用与后层参数作用之间的联系，使网络每层都可以自己学习，稍微独立于整个网络，这样有助于加速整个网络的学习。</p><h1>三、Softmax</h1><h2 id="3-1-softmax数学表示">3.1 softmax数学表示</h2><p>前面提到的分类方法都是用于二分分类，而softmax回归则适用于多种分类。常用C表示输入类别个数，也等于输出层单元数。</p><p>使用时就是将最后一层的激活函数换成softmax。</p><p>例如设网络的最后一层为$l$，则该softmax层计算过程如下：</p><p>计算线性部分：<br>$z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$</p><p>计算临时变量：<br>$t=e^{z^{[L]}}$</p><p>计算输出，也就是各个分类的概率：<br>$a^{[l]}=\frac{t_i}{\sum t_i}$</p><p>假设$z^{[l]}$是一个(4,1)的向量，那么$t,a^{[l]}$的维度都是(4,1)，其中$a^{[l]}$内的四个值就是四种分类的概率。</p><h2 id="3-2-训练softmax网络">3.2 训练softmax网络</h2><p><strong>（1）损失函数</strong></p><p>由于softmax的输出与分类个数相同，因此需要新的损失函数。</p><p>$l(\hat y,y)=-\sum_{j=1}y_jlog\hat y_j$</p><p>要想让损失函数尽量小，就需要让$log\hat y_j$尽可能大，也就是对应的概率尽可能大。</p><p><strong>（2）梯度下降</strong></p><p>关键步骤是对softmax层求导：</p><p>$dz^{[l]}=\hat y-y$</p>]]></content>
    
    
    <summary type="html">介绍了神经网络中一些常用参数的选择原则和大概范围，以及BN和softmax的基本原理。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
