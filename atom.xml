<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马浩飞丨博客</title>
  
  <subtitle>进步无止境</subtitle>
  <link href="https://www.mahaofei.com/atom.xml" rel="self"/>
  
  <link href="https://www.mahaofei.com/"/>
  <updated>2024-11-09T08:46:15.000Z</updated>
  <id>https://www.mahaofei.com/</id>
  
  <author>
    <name>马浩飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu设置定时任务</title>
    <link href="https://www.mahaofei.com/post/ad1bc0e3.html"/>
    <id>https://www.mahaofei.com/post/ad1bc0e3.html</id>
    <published>2024-11-09T08:46:15.000Z</published>
    <updated>2024-11-09T08:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于某些需求（例如定时重启某个任务，定时推送更新博客，定时备份文件等），需要定时执行某些任务。</p></blockquote><h2 id="cron">cron</h2><p><code>cron</code> 是 Linux 系统中用于管理和执行周期性任务的工具。</p><h2 id="任务编辑规则">任务编辑规则</h2><p><strong>（1）打开 cron 任务编辑器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>如果是第一次使用 crontab，系统可能会让你选择一个文本编辑器，通常可以选择 nano 简单一些。</p><p><strong>（2）配置 cron 服务</strong></p><p>表达式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *  * *  *   command</span><br><span class="line">分 时 天 月 周   命令</span><br></pre></td></tr></table></figure><ul><li>分：0-59</li><li>时：0-23</li><li>天：1-31</li><li>月：1-12</li><li>周：1-6 周一至周六，0 周日</li></ul><p>此外：</p><ul><li><code>*</code>：表示任意值，比如在小时部分填写 <code>*</code> 代表任意小时（每小时）</li><li><code>,</code>：允许在一个部分中填写多个值，比如在分钟部分填写 <code>1,3</code> 表示一分钟或三分钟</li><li><code>\</code>：一般配合 * 使用，代表每隔多长时间，比如在小时部分填写 <code>*/2</code> 代表每隔两分钟。所以 <code>*/1</code> 和 <code>*</code> 没有区别</li></ul><p>例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. \* * * * *      # 每隔一分钟执行一次任务</span><br><span class="line">2. 0 * * * *       # 每小时的0点执行一次任务，比如6:00，10:00  </span><br><span class="line">3. 6,10 * 2 * *    # 每个月2号，每小时的6分和10分执行一次任务  </span><br><span class="line">4. \*/3,\*/5 * * * *   # 每隔3分钟或5分钟执行一次任务，比如10:03，10:05，10:06</span><br></pre></td></tr></table></figure><h2 id="配置一个定时任务">配置一个定时任务</h2><p><strong>（1）创建脚本</strong></p><p>例如我们需要每天在命令行执行 <code>hexo g</code>, <code>hexo d</code> 的命令。</p><p>首先创建脚本：<code>gedit hexo.sh</code>，写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">HEXO_DIR=&quot;/path/hexo_blog_dir&quot;</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$HEXO_DIR&quot; ]; then</span><br><span class="line">    cd &quot;$HEXO_DIR&quot; || exit</span><br><span class="line">    hexo g &amp;&amp; hexo d</span><br><span class="line">    echo &quot;已在 $HEXO_DIR 执行 hexo g 和 hexo d&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;未找到 $HEXO_DIR 目录&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>（2）赋予权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x hexo.sh</span><br></pre></td></tr></table></figure><p>可以验证一下 <code>hexo.sh</code> 是否能够成功执行。</p><p><strong>（3）添加定时任务</strong></p><p>打开 <code>crontab -e</code>，添加一行内 W容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 0 * * * /home/mahaofei/Software/everyweek.sh</span><br></pre></td></tr></table></figure><p><strong>（4）重启 cron 服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service cron restart</span><br></pre></td></tr></table></figure><p>这样就会每天 0 点定时执行 <a href="http://hexo.sh">hexo.sh</a>。</p>]]></content>
    
    
    <summary type="html">由于某些需求（例如定时重启某个任务，定时推送更新博客，定时备份文件等），需要定时执行某些任务。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Ubuntu工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Ubuntu%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Ubuntu" scheme="https://www.mahaofei.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>【设备使用】法奥意威 FR5 机械臂 Python 控制</title>
    <link href="https://www.mahaofei.com/post/77bb032e.html"/>
    <id>https://www.mahaofei.com/post/77bb032e.html</id>
    <published>2024-04-10T02:40:07.000Z</published>
    <updated>2024-04-10T02:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!abstract]<br>FR5 是与 UR5 构型相似的 6 自由度机械臂，本文介绍其 Python SDK 的基本运动控制方法。本文内容参考自<a href="https://fr-documentation.readthedocs.io/zh-cn/latest/index.html">官方文档</a>。</p></blockquote><h1>一、FR5 机器人使用方法</h1><h2 id="1-1-机器人安装与连接">1.1 机器人安装与连接</h2><p><strong>（1）机器人安装</strong></p><p>安装好机器人，并将夹爪安装连接在机械臂末端。</p><p><strong>（2）网络配置</strong></p><p>机器人默认 IP 地址为 <code>192.168.58.2</code>，需要修改电脑 IP 同一频段例如 <code>192.168.58.10</code>，然后才可连接。</p><p>配置好网络后，在浏览器输入 <code>192.168.58.2</code>，进入机械臂网页控制页面说明连接成功，默认用户名 admin，默认密码 123。（必须使用 Chrome 浏览器）</p><p><strong>（3）Python 环境</strong></p><p>该 SDK 程序基于 Python 3.10 实现，因此需要创建 3.10 的 Python 环境才能正常使用。</p><p><strong>（4）设置工具坐标系</strong></p><p>首先进入浏览器机器人后台，打开【初始设置-机器人设置-工具坐标】，选择坐标系名称为 toolcoord1（初始默认是 toolcoord0，尽量不修改它），此时成功设置机器人工具坐标系为 toolcoord1。</p><p>如果已知参数，例如夹爪坐标系和法兰盘坐标系，方向相同，仅 Z 轴移动了一定距离。可以直接设置为：<code>[0, 0, 185, 0, 0, 0]</code></p><p>或者通过六点法标定，依次选择六个点</p><ul><li>第 1 点：在世界中指定一个点，保持工具尖端在该位置处</li><li>第 2 点：保持工具尖端在该位置处（与上一点姿态差距尽量大）</li><li>第 3 点：保持工具尖端在该位置处（与前两点姿态差距尽量大）</li><li>第 4 点：保持工具尖端在该位置处，末端 Z 轴与工具坐标 Z 轴平行</li><li>第 5 点：移动工具末端至工具 X 轴正方向上的任一点</li><li>第 6 点：移动工具末端至工具 Y 轴正方向上的任一点</li></ul><h2 id="1-2-示例程序">1.2 示例程序</h2><p><strong>（1）机器人连接与基本运动</strong></p><p>该程序的功能为，连接机器人，移动机器人至初始位置（本文中机器人安装位置绕 Z 轴有夹角，设置初始位置为夹爪向下），激活夹爪并关闭夹爪。</p><figure class="highlight python"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># from libfairino.utils.sdk_error import *</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> R</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">###################### 机器人控制器连接测试 ######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">error = robot.SetRobotInstallAngle(<span class="number">0.0</span>,-<span class="number">20.0</span>) <span class="comment">#！！！安装角度设置应与实际一致 (错误安装角度设置会导致拖动模式下机器人失控）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置机器人安装角度错误码&quot;</span>,error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询机器人的SDK版本号</span></span><br><span class="line">ret,version  = robot.GetSDKVersion()    <span class="comment">#查询SDK版本号</span></span><br><span class="line"><span class="keyword">if</span> ret ==<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SDK版本号为&quot;</span>, version )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询失败，错误码为&quot;</span>,ret)</span><br><span class="line"></span><br><span class="line"><span class="comment">###################### 机器本体运动测试 ######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取机器人的关节位置</span></span><br><span class="line">error, joint_deg = robot.GetActualJointPosDegree()</span><br><span class="line"><span class="keyword">if</span> error == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取当前关节位置 (角度)&quot;</span>, joint_deg)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取当前关节位置(角度)失败，错误码为&quot;</span>, error)</span><br><span class="line">error, joint_rad = robot.GetActualJointPosRadian()</span><br><span class="line"><span class="keyword">if</span> error == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取当前关节位置 (弧度)&quot;</span>, joint_rad)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取当前关节位置(弧度)失败，错误码为&quot;</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 机器人关节空间运动</span></span><br><span class="line"><span class="comment"># joint_pos1 = [20., -90., 90., -90., -90., 0.]</span></span><br><span class="line"><span class="comment"># tool = 0 #工具坐标系编号</span></span><br><span class="line"><span class="comment"># user = 0 #工件坐标系编号</span></span><br><span class="line"><span class="comment"># error = robot.MoveJ(joint_pos1, tool, user, vel=10)   #关节空间运动</span></span><br><span class="line"><span class="comment"># if error != 0:</span></span><br><span class="line"><span class="comment">#     print(&quot;关节空间运动失败，错误码为&quot;, error)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取机器人的工具坐标 [-432, -265, 477, 180, 0, 110]</span></span><br><span class="line">error, tcp_pose = robot.GetActualTCPPose()</span><br><span class="line"><span class="keyword">if</span> error == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取当前工具坐标&quot;</span>, tcp_pose)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;获取当前工具坐标失败，错误码为&quot;</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 机器人直线运动</span></span><br><span class="line"><span class="comment"># pose1 = [-432, -265, 477, 180, 0, 110]</span></span><br><span class="line"><span class="comment"># tool = 0 #工具坐标系编号</span></span><br><span class="line"><span class="comment"># user = 0 #工件坐标系编号</span></span><br><span class="line"><span class="comment"># error = robot.MoveL(pose1, tool, user, vel=10)   #直线运动</span></span><br><span class="line"><span class="comment"># if error != 0:</span></span><br><span class="line"><span class="comment">#     print(&quot;直线运动失败，错误码为&quot;, error)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 机器人点到点运动</span></span><br><span class="line">pose2 = [-<span class="number">432</span>, -<span class="number">265</span>, <span class="number">477</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">110</span>]</span><br><span class="line">tool = <span class="number">0</span> <span class="comment">#工具坐标系编号</span></span><br><span class="line">user = <span class="number">0</span> <span class="comment">#工件坐标系编号</span></span><br><span class="line">error = robot.MoveCart(pose2, tool, user, vel=<span class="number">10</span>)   <span class="comment">#点到点运动</span></span><br><span class="line"><span class="keyword">if</span> error != <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点到点运动失败，错误码为&quot;</span>, error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询机器人运动状态</span></span><br><span class="line">error, status = robot.GetRobotMotionDone()</span><br><span class="line"><span class="keyword">if</span> error == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> status == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;机器人运动已完成&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;机器人正在运动&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询机器人运动状态失败，错误码为&quot;</span>, error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###################### 机器人夹爪测试 ######################</span></span><br><span class="line">ret = robot.SetGripperConfig(<span class="number">4</span>,<span class="number">0</span>)  <span class="comment"># 配置夹爪，大寰夹爪</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">error, config = robot.GetGripperConfig()     <span class="comment"># 获取夹爪配置</span></span><br><span class="line"></span><br><span class="line">error = robot.ActGripper(<span class="number">1</span>,<span class="number">0</span>)   <span class="comment"># 激活夹爪（复位）</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># error = robot.ActGripper(1,1)   # 激活夹爪（激活）</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># error = robot.MoveGripper(1,100,48,46,30000,0)  # 控制夹爪（夹爪编号，位置百分比，速度百分比，力矩百分比，最大等待时间，阻塞）</span></span><br><span class="line"><span class="comment"># time.sleep(3)</span></span><br><span class="line"></span><br><span class="line">error = robot.MoveGripper(<span class="number">1</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">30000</span>,<span class="number">0</span>)     <span class="comment"># 控制夹爪</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">error, state = robot.GetGripperMotionDone() <span class="comment">#获取夹爪运动状态</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>二、FR5 常用 Python 接口</h1><h2 id="2-1-机器人基础">2.1 机器人基础</h2><h3 id="2-1-1-实例化机器人">2.1.1 实例化机器人</h3><p><code>RPC(ip)</code>：实例化一个机器人对象</p><ul><li>参数：<ul><li><code>ip</code>：机器人的IP地址，默认出厂IP为“192.168.58.2”</li></ul></li><li>返回<ul><li>机器人对象</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-1-2-查询-SDK-版本号">2.1.2 查询 SDK 版本号</h3><p><code>GetSDKVersion()</code>：查询 SDK 版本号</p><ul><li>参数</li><li>返回<ul><li>[SDK_version, Controller_version]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret,version  = robot.GetSDKVersion()    <span class="comment">#查询SDK版本号</span></span><br><span class="line"><span class="keyword">if</span> ret ==<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SDK版本号为&quot;</span>, version )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询失败，错误码为&quot;</span>,ret)</span><br></pre></td></tr></table></figure><h3 id="2-1-3-机器人手动-自动模式切换">2.1.3 机器人手动/自动模式切换</h3><p><code>Mode(state)</code>：控制机器人手动/自动模式切换</p><ul><li>参数<ul><li><code>state</code>：0-自动模式，1-手动模式</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line"><span class="comment">#机器人手自动模式切换</span></span><br><span class="line">ret = robot.Mode(<span class="number">0</span>)   <span class="comment">#机器人切入自动运行模式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;机器人切入自动运行模式&quot;</span>, ret)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">ret = robot.Mode(<span class="number">1</span>)   <span class="comment">#机器人切入手动模式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;机器人切入手动模式&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-1-4-控制机器人上使能或下使能">2.1.4 控制机器人上使能或下使能</h3><p><code>RobotEnable(state)</code>：控制机器人上使能或下使能</p><ul><li>参数<ul><li><code>state</code>：1-上使能，0-下使能</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line"><span class="comment">#机器人上使能或下使能</span></span><br><span class="line">ret = robot.RobotEnable(<span class="number">0</span>)   <span class="comment">#机器人下使能</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;机器人下使能&quot;</span>, ret)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">ret = robot.RobotEnable(<span class="number">1</span>)   <span class="comment">#机器人上使能，机器人上电后默认自动上使能</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;机器人上使能&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h2 id="2-2-机器人运动控制">2.2 机器人运动控制</h2><h3 id="2-2-1-机器人点动">2.2.1 机器人点动</h3><p><strong>（1）Jog 点动</strong></p><p><code>StartJOG(ref,nb,dir,max_dis,vel=20.0,acc=100.0)</code>：jog 点动</p><ul><li>参数<ul><li><code>ref</code>：0-关节点动,2-基坐标系点动,4-工具坐标系点动,8-工件坐标系点动；</li><li><code>nb</code>：1-1关节(x 轴),2-2关节(y 轴),3-3关节(z 轴),4-4关节(rx),5-5关节(ry),6-6关节(rz);</li><li><code>dir</code>：0-负方向，1-正方向;</li><li><code>max_dis</code>：单次点动最大角度/距离，单位 ° 或 mm;</li><li><code>vel</code>：速度百分比，[0~100] 默认20;</li><li><code>acc</code>：加速度百分比，[0~100] 默认100;</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）Jog 点动减速停止</strong></p><p><code>StopJOG(ref)</code>：jog 点动减速停止</p><ul><li>参数<ul><li><code>ref</code>：1-关节点动停止,3-基坐标系点动停止,5-工具坐标系点动停止,9-工件坐标系点动停止</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（3）Jog 点动立即停止</strong></p><p><code>ImmStopJOG()</code>：jog 点动立即停止</p><ul><li>参数</li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line"><span class="comment"># 机器人单轴点动</span></span><br><span class="line">robot.StartJOG(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">20.0</span>,<span class="number">20.0</span>,<span class="number">30.0</span>)    <span class="comment"># 单关节运动,StartJOG为非阻塞指令，运动状态下接收其他运动指令（包含StartJOG）会被丢弃</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#机器人单轴点动减速停止</span></span><br><span class="line">ret = robot.StopJOG(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"><span class="comment">#机器人单轴点动立即停止</span></span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">20.0</span>,vel=<span class="number">40</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">20.0</span>,acc=<span class="number">50</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">20.0</span>,<span class="number">20.0</span>,<span class="number">30.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line"><span class="comment"># 基坐标</span></span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">20.0</span>)  <span class="comment">#基坐标系下点动</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># #机器人单轴点动立即停止</span></span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line"><span class="comment"># 工具坐标</span></span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">20.0</span>,<span class="number">20.0</span>,<span class="number">100.0</span>)  <span class="comment">#工具坐标系下点动</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># #机器人单轴点动立即停止</span></span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">20.0</span>,<span class="number">20.0</span>,<span class="number">100.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">20.0</span>,vel=<span class="number">10.0</span>,acc=<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">20.0</span>,acc=<span class="number">40.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line"><span class="comment"># 工件坐标</span></span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">20.0</span>,<span class="number">20.0</span>,<span class="number">100.0</span>)  <span class="comment">#工件坐标系下点动</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># #机器人单轴点动立即停止</span></span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">20.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">20.0</span>,vel=<span class="number">30.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br><span class="line">robot.StartJOG(<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">20.0</span>,<span class="number">20.0</span>,acc=<span class="number">90.0</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">robot.ImmStopJOG()</span><br></pre></td></tr></table></figure><h3 id="2-2-2-关节空间运动">2.2.2 关节空间运动</h3><p><code>MoveJ(joint_pos, tool, user, desc_pos = [0.0,0.0,0.0,0.0,0.0,0.0], vel = 20.0, acc = 0.0, ovl = 100.0, exaxis_pos = [0.0,0.0,0.0,0.0], blendT = -1.0, offset_flag = 0, offset_pos = [0.0,0.0,0.0,0.0,0.0,0.0])</code>：关节空间运动</p><ul><li>参数<ul><li><code>joint_pos</code>:目标关节位置，单位[°]；</li><li><code>tool</code>:工具号，[0~14]；</li><li><code>user</code>:工件号，[0~14]；</li><li><code>desc_pos</code>:目标笛卡尔位姿，单位 [mm][°] 默认初值为[0.0,0.0,0.0,0.0,0.0,0.0]，默认值调用正运动学求解返回值;</li><li><code>vel</code>:速度百分比，[0~100] 默认20.0;</li><li><code>acc</code>:加速度百分比，[0~100]，暂不开放；</li><li><code>ovl</code>:速度缩放因子，[0~100] 默认100.0;</li><li><code>exaxis_pos</code>:外部轴 1 位置 ~ 外部轴 4 位置 默认[0.0,0.0,0.0,0.0];</li><li><code>blendT</code>:[-1.0]-运动到位 (阻塞)，[0~500.0]-平滑时间 (非阻塞)，单位 [ms] 默认-1.0;</li><li><code>offset_flag</code>:[0]-不偏移，[1]-工件/基坐标系下偏移，[2]-工具坐标系下偏移 默认 0;</li><li><code>offset_pos</code>:位姿偏移量，单位 [mm][°] 默认[0.0,0.0,0.0,0.0,0.0,0.0];</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">joint_pos4 = [-<span class="number">83.24</span>, -<span class="number">96.476</span>, <span class="number">93.688</span>, -<span class="number">114.079</span>, -<span class="number">62</span>, -<span class="number">100</span>]</span><br><span class="line">joint_pos5 = [-<span class="number">43.24</span>, -<span class="number">70.476</span>, <span class="number">93.688</span>, -<span class="number">114.079</span>, -<span class="number">62</span>, -<span class="number">80</span>]</span><br><span class="line">joint_pos6 = [-<span class="number">83.24</span>, -<span class="number">96.416</span>, <span class="number">43.188</span>, -<span class="number">74.079</span>, -<span class="number">80</span>, -<span class="number">10</span>]</span><br><span class="line">tool = <span class="number">0</span> <span class="comment">#工具坐标系编号</span></span><br><span class="line">user = <span class="number">0</span> <span class="comment">#工件坐标系编号</span></span><br><span class="line">ret = robot.MoveJ(joint_pos4, tool, user, vel=<span class="number">30</span>)   <span class="comment">#关节空间运动</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;关节空间运动点4:错误码&quot;</span>, ret)</span><br><span class="line">ret = robot.MoveJ(joint_pos5, tool, user)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;关节空间运动点5:错误码&quot;</span>, ret)</span><br><span class="line">robot.MoveJ(joint_pos6, tool, user, offset_flag=<span class="number">1</span>, offset_pos=[<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;关节空间运动点6:错误码&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-2-3-笛卡尔空间直线运动">2.2.3 笛卡尔空间直线运动</h3><p><code>MoveL(desc_pos, tool, user, joint_pos = [0.0,0.0,0.0,0.0,0.0,0.0], vel = 20.0, acc = 0.0 , ovl = 100.0, blendR = -1.0, exaxis_pos = [0.0,0.0,0.0,0.0], search = 0, offset_flag = 0, offset_pos = [0.0,0.0,0.0,0.0,0.0,0.0] )</code>：笛卡尔空间直线运动</p><ul><li>参数<ul><li><code>desc_pos</code>:目标笛卡尔位姿，单位[mm][°]；</li><li><code>tool</code>:工具号，[0~14]；</li><li><code>user</code>:工件号，[0~14]；</li><li><code>joint_pos</code>:目标关节位置，单位 [°] 默认初值为[0.0,0.0,0.0,0.0,0.0,0.0]，默认值调用逆运动学求解返回值;</li><li><code>vel</code>:速度百分比，[0~100] 默认20.0；</li><li><code>acc</code>:加速度百分比，[0~100]，暂不开放 默认0.0；</li><li><code>ovl</code>:速度缩放因子，[0~100] 默认100.0；</li><li><code>blendR</code>:blendR:[-1.0]-运动到位 (阻塞)，[0~1000]-平滑半径 (非阻塞)，单位 [mm] 默认-1.0;</li><li><code>exaxis_pos</code>:外部轴 1 位置 ~ 外部轴 4 位置 默认[0.0,0.0,0.0,0.0];</li><li><code>search</code>:[0]-不焊丝寻位，[1]-焊丝寻位；</li><li><code>offset_flag</code>:offset_flag:[0]-不偏移，[1]-工件/基坐标系下偏移，[2]-工具坐标系下偏移 默认 0;</li><li><code>offset_pos</code>:位姿偏移量，单位 [mm][°] 默认[0.0,0.0,0.0,0.0,0.0,0.0]</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">desc_pos1 = [<span class="number">36.794</span>,-<span class="number">475.119</span>, <span class="number">65.379</span>, -<span class="number">176.938</span>, <span class="number">2.535</span>, -<span class="number">179.829</span>]</span><br><span class="line">desc_pos2 = [<span class="number">136.794</span>,-<span class="number">475.119</span>, <span class="number">65.379</span>, -<span class="number">176.938</span>, <span class="number">2.535</span>, -<span class="number">179.829</span>]</span><br><span class="line">desc_pos3 = [<span class="number">236.794</span>,-<span class="number">475.119</span>, <span class="number">65.379</span>, -<span class="number">176.938</span>, <span class="number">2.535</span>, -<span class="number">179.829</span>]</span><br><span class="line">tool = <span class="number">0</span> <span class="comment">#工具坐标系编号</span></span><br><span class="line">user = <span class="number">0</span> <span class="comment">#工件坐标系编号</span></span><br><span class="line">ret = robot.MoveL(desc_pos1, tool, user)   <span class="comment">#笛卡尔空间直线运动</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间直线运动点1:错误码&quot;</span>, ret)</span><br><span class="line">robot.MoveL(desc_pos2, tool, user, vel=<span class="number">20</span>, acc=<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间直线运动点2:错误码&quot;</span>, ret)</span><br><span class="line">robot.MoveL(desc_pos3, tool, user, offset_flag=<span class="number">1</span>, offset_pos=[<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间直线运动点3:错误码&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-2-4-笛卡尔空间点到点运动">2.2.4 笛卡尔空间点到点运动</h3><p><code>MoveCart(desc_pos, tool, user, vel = 20.0, acc = 0.0, ovl = 100.0, blendT = -1.0, config = -1)</code>：笛卡尔空间点到点运动</p><ul><li>参数<ul><li><code>desc_pos</code>:目标笛卡尔位置；</li><li><code>tool</code>:工具号，[0~14]；</li><li><code>user</code>:工件号，[0~14]；</li><li><code>vel</code>:速度，范围 [0~100]，默认为 20.0;</li><li><code>acc</code>:加速度，范围 [0~100]，暂不开放,默认为 0.0;</li><li><code>ovl</code>:速度缩放因子，[0~100]，默认为 100.0;</li><li><code>blendT</code>:[-1.0]-运动到位 (阻塞)，[0~500]-平滑时间 (非阻塞)，单位 [ms] 默认为 -1.0;</li><li><code>config</code>:关节配置，[-1]-参考当前关节位置求解，[0~7]-依据关节配置求解 默认为 -1</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">desc_pos7 = [<span class="number">236.794</span>,-<span class="number">475.119</span>, <span class="number">65.379</span>, -<span class="number">176.938</span>, <span class="number">2.535</span>, -<span class="number">179.829</span>]</span><br><span class="line">desc_pos8 = [<span class="number">236.794</span>,-<span class="number">575.119</span>, <span class="number">165.379</span>, -<span class="number">176.938</span>, <span class="number">2.535</span>, -<span class="number">179.829</span>]</span><br><span class="line">desc_pos9 = [<span class="number">236.794</span>,-<span class="number">475.119</span>, <span class="number">265.379</span>, -<span class="number">176.938</span>, <span class="number">2.535</span>, -<span class="number">179.829</span>]</span><br><span class="line">tool = <span class="number">0</span> <span class="comment">#工具坐标系编号</span></span><br><span class="line">user = <span class="number">0</span> <span class="comment">#工件坐标系编号</span></span><br><span class="line">robot.MoveCart(desc_pos7, tool, user)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间点到点运动点7:错误码&quot;</span>, ret)</span><br><span class="line">robot.MoveCart(desc_pos8, tool, user, vel=<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间点到点运动点8:错误码&quot;</span>, ret)</span><br><span class="line">robot.MoveCart(desc_pos9, tool, user,)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间点到点运动点9:错误码&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-2-5-伺服运动">2.2.5 伺服运动</h3><p><strong>（1）伺服运动开始</strong></p><p><code>ServoMoveStart()</code>：伺服运动开始，配合 ServoJ、ServoCart 指令使用</p><ul><li>参数</li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）伺服运动结束</strong></p><p><code>ServoMoveEnd()</code>：伺服运动开始，配合 ServoJ、ServoCart 指令使用</p><ul><li>参数</li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（3）关节空间伺服模式运动</strong></p><p><code>ServoJ(joint_pos, acc = 0.0, vel = 0.0, cmdT = 0.008, filterT = 0.0, gain = 0.0)</code>：关节空间伺服模式运动</p><ul><li>参数<ul><li><code>joint_pos</code>:目标关节位置，单位[°]；</li><li><code>acc</code>:加速度，范围 [0~100]，暂不开放，默认为 0.0;</li><li><code>vel</code>:速度，范围 [0~100]，暂不开放，默认为 0.0;</li><li><code>cmdT</code>:指令下发周期，单位s，建议范围[0.001~0.0016], 默认为0.008;</li><li><code>filterT</code>:滤波时间，单位 [s]，暂不开放， 默认为0.0;</li><li><code>gain</code>:目标位置的比例放大器，暂不开放， 默认为0.0;</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（4）笛卡尔空间伺服模式运动</strong></p><p><code>ServoCart(mode, desc_pos, pos_gain = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0] , acc = 0.0, vel = 0.0, cmdT = 0.008, filterT = 0.0, gain = 0.0)</code>：笛卡尔空间伺服模式运动</p><ul><li>参数<ul><li><code>mode</code>:[0]-绝对运动(基坐标系)，[1]-增量运动(基坐标系)，[2]-增量运动(工具坐标系)；</li><li><code>desc_pos</code>:目标笛卡尔位置/目标笛卡尔位置增量；</li><li><code>pos_gain</code>:位姿增量比例系数，仅在增量运动下生效，范围 [0~1], 默认为 [1.0, 1.0, 1.0, 1.0, 1.0, 1.0];</li><li><code>acc</code>:加速度，范围 [0~100]，暂不开放，默认为 0.0;</li><li><code>vel</code>:速度，范围 [0~100]，暂不开放，默认为 0.0;</li><li><code>cmdT</code>:指令下发周期，单位s，建议范围[0.001~0.0016], 默认为0.008;</li><li><code>filterT</code>:滤波时间，单位 [s]，暂不开放， 默认为0.0;</li><li><code>gain</code>:目标位置的比例放大器，暂不开放， 默认为0.0;</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">error,joint_pos = robot.GetActualJointPosDegree()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;机器人当前关节位置&quot;</span>,joint_pos)</span><br><span class="line">joint_pos = [joint_pos[<span class="number">0</span>],joint_pos[<span class="number">1</span>],joint_pos[<span class="number">2</span>],joint_pos[<span class="number">3</span>],joint_pos[<span class="number">4</span>],joint_pos[<span class="number">5</span>]]</span><br><span class="line">error_joint = <span class="number">0</span></span><br><span class="line">count =<span class="number">100</span></span><br><span class="line">error = robot.ServoMoveStart()  <span class="comment">#伺服运动开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;伺服运动开始错误码&quot;</span>,error)</span><br><span class="line"><span class="keyword">while</span>(count):</span><br><span class="line">    error = robot.ServoJ(joint_pos)   <span class="comment">#关节空间伺服模式运动</span></span><br><span class="line">    <span class="keyword">if</span> error!=<span class="number">0</span>:</span><br><span class="line">        error_joint =error</span><br><span class="line">    joint_pos[<span class="number">0</span>] = joint_pos[<span class="number">0</span>] + <span class="number">0.1</span>  <span class="comment">#每次1轴运动0.1度，运动100次</span></span><br><span class="line">    count = count - <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">0.008</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;关节空间伺服模式运动错误码&quot;</span>,error_joint)</span><br><span class="line">error = robot.ServoMoveEnd()  <span class="comment">#伺服运动结束</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;伺服运动结束错误码&quot;</span>,error)</span><br><span class="line">mode = <span class="number">2</span>  <span class="comment">#[0]-绝对运动(基坐标系)，[1]-增量运动(基坐标系)，[2]-增量运动(工具坐标系)</span></span><br><span class="line">n_pos = [<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.5</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>]   <span class="comment">#笛卡尔空间位姿增量</span></span><br><span class="line">error,desc_pos = robot.GetActualTCPPose()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;机器人当前笛卡尔位置&quot;</span>,desc_pos)</span><br><span class="line">count = <span class="number">100</span></span><br><span class="line">error_cart =<span class="number">0</span></span><br><span class="line">error = robot.ServoMoveStart()  <span class="comment">#伺服运动开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;伺服运动开始错误码&quot;</span>,error)</span><br><span class="line"><span class="keyword">while</span>(count):</span><br><span class="line">    error = robot.ServoCart(mode, n_pos, vel=<span class="number">40</span>)   <span class="comment">#笛卡尔空间伺服模式运动</span></span><br><span class="line">    <span class="keyword">if</span> error!=<span class="number">0</span>:</span><br><span class="line">        error_cart =error</span><br><span class="line">    count = count - <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">0.008</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;笛卡尔空间伺服模式运动错误码&quot;</span>, error_cart)</span><br><span class="line">error = robot.ServoMoveEnd()  <span class="comment">#伺服运动开始</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;伺服运动结束错误码&quot;</span>,error)</span><br></pre></td></tr></table></figure><h2 id="2-3-机器人参数设置">2.3 机器人参数设置</h2><h3 id="2-3-1-设置全局速度">2.3.1 设置全局速度</h3><p><code>SetSpeed(vel)</code>：设置全局速度</p><ul><li>参数<ul><li><code>vel</code>:速度百分比，范围[0~100]</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">error = robot.SetSpeed(<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置全局速度错误码:&quot;</span>,error)</span><br></pre></td></tr></table></figure><h3 id="2-3-2-设置系统变量值">2.3.2 设置系统变量值</h3><p><code>SetSysVarValue(id,value)</code>：设置系统变量</p><ul><li>参数<ul><li><code>id</code>：变量编号，范围[1~20];</li><li><code>value</code>：变量值</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    error = robot.SetSysVarValue(i,<span class="number">10</span>)</span><br><span class="line">robot.WaitMs(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">21</span>):</span><br><span class="line">    sys_var = robot.GetSysVarValue(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;系统变量编号:&quot;</span>,i,<span class="string">&quot;值&quot;</span>,sys_var)</span><br></pre></td></tr></table></figure><h3 id="2-3-3-设置工具坐标系">2.3.3 设置工具坐标系</h3><p><strong>（1）计算工具坐标系 - 六点法</strong></p><p><code>SetToolPoint(point_num)</code>：设置工具参考点-六点法</p><ul><li>参数<ul><li><code>point_num</code>：点编号,范围[1~6]</li></ul></li><li>返回错误码</li></ul><p><code>ComputeTool()</code>：计算工具坐标系-六点法（设置完六个工具参考点后再进行计算）</p><ul><li>参数</li><li>返回<ul><li>错误码</li><li><code>tcp_pose [x,y,z,rx,ry,rz]</code>：工具坐标系</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">t_coord = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">    robot.DragTeachSwitch(<span class="number">1</span>)<span class="comment">#切入拖动示教模式</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    error = robot.SetToolPoint(i) <span class="comment">#实际应当控制机器人按照要求移动到合适位置后再发送指令</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;六点法设置工具坐标系，记录点&quot;</span>,i,<span class="string">&quot;错误码&quot;</span>,error)</span><br><span class="line">    robot.DragTeachSwitch(<span class="number">0</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">error = robot.ComputeTool()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;六点法设置工具坐标系错误码&quot;</span>,error)</span><br></pre></td></tr></table></figure><p><strong>（2）计算工具坐标系 - 四点法</strong></p><p><code>SetTcp4RefPoint(point_num)</code>：设置工具参考点-四点法</p><ul><li>参数<ul><li><code>point_num</code>：点编号,范围[1~4]</li></ul></li><li>返回值<ul><li>错误码</li></ul></li></ul><p><code>ComputeTcp4()</code>：计算工具坐标系-四点法（设置完四个工具参考点后再进行计算）</p><ul><li>参数</li><li>返回<ul><li>错误码</li><li><code>tcp_pose [x,y,z,rx,ry,rz]</code>：工具坐标系</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">t_coord = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    robot.DragTeachSwitch(<span class="number">1</span>)<span class="comment">#切入拖动示教模式</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    error = robot.SetTcp4RefPoint(i) <span class="comment">#应当控制机器人按照要求移动到合适位置后再发送指令</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;四点法设置工具坐标系，记录点&quot;</span>,i,<span class="string">&quot;错误码&quot;</span>,error)</span><br><span class="line">    robot.DragTeachSwitch(<span class="number">0</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">error,t_coord= robot.ComputeTcp4()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;四点法设置工具坐标系错误码&quot;</span>,error,<span class="string">&quot;工具TCP&quot;</span>,t_coord)</span><br></pre></td></tr></table></figure><p><strong>（3）设置工具坐标系</strong></p><p><code>SetToolCoord(id,t_coord,type,install)</code>：设置工具坐标系</p><ul><li>参数<ul><li><code>id</code>:坐标系编号，范围[0~14]；</li><li><code>t_coord</code>:[x,y,z,rx,ry,rz] 工具中心点相对末端法兰中心位姿，单位[mm][°]；</li><li><code>type</code>:0-工具坐标系，1-传感器坐标系；</li><li><code>install</code>:安装位置，0-机器人末端，1-机器人外部</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">t_coord = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>]</span><br><span class="line">error = robot.SetToolCoord(<span class="number">10</span>,t_coord,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置工具坐标系错误码&quot;</span>,error)</span><br></pre></td></tr></table></figure><h3 id="2-3-4-设置外部工具坐标系">2.3.4 设置外部工具坐标系</h3><p><strong>（1）设置外部工具参考点</strong></p><p><code>SetExTCPPoint(point_num)</code>：设置外部工具参考点-三点法</p><ul><li>参数<ul><li><code>point_num</code>：点编号,范围[1~3]</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）计算外部工具坐标系</strong></p><p><code>ComputeExTCF(point_num)</code>：计算外部工具坐标系-三点法（设置完三个参考点后再进行计算）</p><ul><li>参数<ul><li><code>point_num</code>：点编号,范围[1~3]</li></ul></li><li>返回<ul><li>错误码</li><li><code>etcp [x,y,z,rx,ry,rz]</code>：外部工具坐标系</li></ul></li></ul><p><strong>（3）设置外部工具坐标系</strong></p><p><code>SetExToolCoord(id,etcp ,etool)</code>：设置外部工具坐标系</p><ul><li>参数<ul><li><code>id</code>:坐标系编号，范围[0~14]；</li><li><code>etcp</code>:外部工具坐标系，单位[mm][°]；</li><li><code>etool</code>:末端工具坐标系，单位[mm][°]；</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">etcp = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>]</span><br><span class="line">etool = [<span class="number">21.0</span>,<span class="number">22.0</span>,<span class="number">23.0</span>,<span class="number">24.0</span>,<span class="number">25.0</span>,<span class="number">26.0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    error = robot.SetExTCPPoint(i) <span class="comment">#应当控制机器人按照要求移动到合适位置后再发送指令</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;三点法设置外部工具坐标系，记录点&quot;</span>,i,<span class="string">&quot;错误码&quot;</span>,error)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">error,etcp = robot.ComputeExTCF()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三点法设置外部工具坐标系错误码&quot;</span>,error,<span class="string">&quot;外部工具TCP&quot;</span>,etcp)</span><br><span class="line">error = robot.SetExToolCoord(<span class="number">10</span>,etcp,etool)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置外部工具坐标系错误码&quot;</span>,error)</span><br><span class="line">error = robot.SetExToolList(<span class="number">10</span>,etcp,etool)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置外部工具坐标系列表错误码&quot;</span>,error)</span><br></pre></td></tr></table></figure><h3 id="2-3-5-设置工件坐标系">2.3.5 设置工件坐标系</h3><p><strong>（1）设置工件参考点</strong></p><p><code>SetWObjCoordPoint(point_num)</code>：设置工件参考点-三点法</p><ul><li>参数<ul><li><code>point_num</code>:点编号,范围[1~3]</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）计算工件坐标系</strong></p><p><code>ComputeWObjCoord()</code>：计算工件坐标系-三点法（三个参考点设置完后再进行计算;</p><ul><li>参数<ul><li><code>method</code>：计算方式：0（原点-x轴-z轴），1（原点-x轴-xy平面）</li></ul></li><li>返回<ul><li>错误码</li><li><code>wobj_pose [x,y,z,rx,ry,rz]</code>：工件坐标系</li></ul></li></ul><p><strong>（3）设置工件坐标系</strong></p><p><code>SetWObjCoord(id,w_coord)</code>：设置工件坐标系</p><ul><li>参数<ul><li><code>id</code>:坐标系编号，范围[0~14]；</li><li><code>w_coord</code>:坐标系相对位姿，单位[mm][°]；</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">w_coord = [<span class="number">11.0</span>,<span class="number">12.0</span>,<span class="number">13.0</span>,<span class="number">14.0</span>,<span class="number">15.0</span>,<span class="number">16.0</span>]</span><br><span class="line">robot.SetToolList(<span class="number">0</span>,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>)<span class="comment">#设置参考点前应当将工具和工件号坐标系切换至0</span></span><br><span class="line">robot.SetWObjList(<span class="number">0</span>,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">    error = robot.SetWObjCoordPoint(i) <span class="comment">#实际应当控制机器人按照要求移动到合适位置后再发送指令</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;三点法设置工件坐标系，记录点&quot;</span>,i,<span class="string">&quot;错误码&quot;</span>,error)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">error, w_coord = robot.ComputeWObjCoord(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;三点法计算工件坐标系错误码&quot;</span>,error,<span class="string">&quot;工件坐标系&quot;</span>, w_coord)</span><br></pre></td></tr></table></figure><h2 id="2-4-机器人安全设置">2.4 机器人安全设置</h2><h3 id="2-4-1-碰撞设置">2.4.1 碰撞设置</h3><p><strong>（1）设置碰撞等级</strong></p><p><code>SetAnticollision (mode,level,config)</code>：设置碰撞等级</p><ul><li>参数<ul><li><code>mode</code>:0-等级，1-百分比；</li><li><code>level=[j1,j2,j3,j4,j5,j6]</code>:碰撞阈值；</li><li><code>config</code>:0-不更新配置文件，1-更新配置文件</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）设置碰撞后策略</strong></p><p><code>SetCollisionStrategy (strategy)</code>：设置碰撞后策略</p><ul><li>参数<ul><li><code>strategy</code>：0-报错暂停，1-继续运行</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">level = [<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>]</span><br><span class="line">error = robot.SetAnticollision(<span class="number">0</span>,level,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置碰撞等级错误码:&quot;</span>,error)</span><br><span class="line">level = [<span class="number">50.0</span>,<span class="number">20.0</span>,<span class="number">30.0</span>,<span class="number">40.0</span>,<span class="number">50.0</span>,<span class="number">60.0</span>]</span><br><span class="line">error = robot.SetAnticollision(<span class="number">1</span>,level,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置碰撞等级错误码:&quot;</span>,error)</span><br><span class="line">error = robot.SetCollisionStrategy(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置碰撞后策略错误码:&quot;</span>,error)</span><br></pre></td></tr></table></figure><h3 id="2-4-2-设置关节限位">2.4.2 设置关节限位</h3><p><strong>（1）正限位</strong></p><p><code>SetLimitPositive(p_limit)</code>：设置正限位</p><ul><li>参数<ul><li><code>p_limit=[j1,j2,j3,j4,j5,j6]</code>：六个关节位置</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）负限位</strong></p><p><code>SetLimitNegative(p_limit)</code>：设置负限位</p><ul><li>参数<ul><li><code>n_limit=[j1,j2,j3,j4,j5,j6]</code>：六个关节位置</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">p_limit = [<span class="number">170.0</span>,<span class="number">80.0</span>,<span class="number">150.0</span>,<span class="number">80.0</span>,<span class="number">170.0</span>,<span class="number">160.0</span>]</span><br><span class="line">error = robot.SetLimitPositive(p_limit)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;设置正限位错误码:&quot;</span>,error)</span><br><span class="line">n_limit = [-<span class="number">170.0</span>,-<span class="number">260.0</span>,-<span class="number">150.0</span>,-<span class="number">260.0</span>,-<span class="number">170.0</span>,-<span class="number">160.0</span>]</span><br><span class="line">5error = robot.SetLimitNegative(n_limit)</span><br><span class="line">6<span class="built_in">print</span>(<span class="string">&quot;设置负限位错误码:&quot;</span>,error)</span><br></pre></td></tr></table></figure><h3 id="2-4-3-错误状态清除">2.4.3 错误状态清除</h3><p><code>ResetAllError()</code>：错误状态清除，只能清除可复位的错误</p><ul><li>参数</li><li>返回<ul><li>错误码</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">error = robot.ResetAllError()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;错误状态清除错误码:&quot;</span>,error)</span><br></pre></td></tr></table></figure><h2 id="2-5-机器人状态查询">2.5 机器人状态查询</h2><h3 id="2-5-1-获取关节位置">2.5.1 获取关节位置</h3><p><strong>（1）获取当前关节位置(角度)</strong></p><p><code>GetActualJointPosDegree(flag = 1)</code>：获取关节当前位置(角度)</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞</li></ul></li><li>返回<ul><li>错误码</li><li><code>joint_pos</code>=[j1,j2,j3,j4,j5,j6]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">error, joint_deg = robot.GetActualJointPosDegree()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取当前关节位置 (角度)&quot;</span>, joint_deg)</span><br></pre></td></tr></table></figure><p><strong>（2）获取当前关节位置(弧度)</strong></p><p><code>GetActualJointPosRadian(flag = 1)</code>：获取关节当前位置(弧度)</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>joint_pos</code> =[j1,j2,j3,j4,j5,j6]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">error, joint_rad = robot.GetActualJointPosRadian()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取当前关节位置 (角度)&quot;</span>, joint_rad)</span><br></pre></td></tr></table></figure><h3 id="2-5-2-获取关节反馈速度">2.5.2 获取关节反馈速度</h3><p><code>GetActualJointSpeedsDegree(flag = 1 )</code>：获取关节反馈速度（deg/s）（实际速度）</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>speed</code>=[j1,j2,j3,j4,j5,j6]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetActualJointSpeedsDegree()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取关节反馈速度-deg/s&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-3-获取工具坐标系速度">2.5.3 获取工具坐标系速度</h3><p><strong>（1）TCP 指令合速度</strong></p><p><code>GetTargetTCPCompositeSpeed(flag = 1)</code>：获取 TCP 指令合速度（期望速度）</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>[tcp_speed,ori_speed]</code>：tcp_speed 线性合速度，ori_speed 姿态合速度</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetTargetTCPCompositeSpeed()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取TCP指令合速度&quot;</span>, ret)</span><br></pre></td></tr></table></figure><p><strong>（2）TCP 反馈合速度</strong></p><p><code>GetActualTCPCompositeSpeed(flag = 1)</code>：获取TCP反馈合速度（实际速度）</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>[tcp_speed,ori_speed]</code>：tcp_speed 线性合速度，ori_speed 姿态合速度</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetActualTCPCompositeSpeed()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取TCP反馈合速度&quot;</span>, ret)</span><br></pre></td></tr></table></figure><p><strong>（3）TCP 指令速度</strong></p><p><code>GetTargetTCPSpeed(flag = 1)</code>：获取 TCP 指令速度（期望速度）</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>speed</code>：[x,y,z,rx,ry,rz]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetTargetTCPSpeed()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取TCP指令速度&quot;</span>, ret)</span><br></pre></td></tr></table></figure><p><strong>（4）TCP 反馈速度</strong></p><p><code>GetActualTCPSpeed(flag = 1)</code>：获取 TCP 反馈速度</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>speed</code>：[x,y,z,rx,ry,rz]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetActualTCPSpeed()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取TCP反馈速度&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-4-获取工具位姿">2.5.4 获取工具位姿</h3><p><code>GetActualTCPPose(flag = 1)</code>：获取当前工具位姿</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>tcp_pose</code>=[x,y,z,rx,ry,rz]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetActualTCPPose()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取当前工具位姿&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-5-获取末端法兰位姿">2.5.5 获取末端法兰位姿</h3><p><code>GetActualToolFlangePose(flag = 1)</code>：获取当前末端法兰位姿</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认1</li></ul></li><li>返回<ul><li>错误码</li><li><code>flange_pose</code>=[x,y,z,rx,ry,rz]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetActualToolFlangePose()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取当前末端法兰位姿&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-6-获取关节转矩">2.5.6 获取关节转矩</h3><p><code>GetJointTorques(flag = 1)</code>：获取当前关节转矩</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认 1</li></ul></li><li>返回<ul><li>错误码</li><li><code>torques</code>=[j1,j2,j3,j4,j5,j6]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetJointTorques()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取当前关节转矩&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-7-获取关节软限位">2.5.7 获取关节软限位</h3><p><code>GetJointSoftLimitDeg(flag = 1)</code>：获取关节软限位角度</p><ul><li>参数<ul><li><code>flag</code>：0-阻塞，1-非阻塞 默认 1</li></ul></li><li>返回<ul><li>错误码</li><li><code>[j1min,j1max,j2min,j2max,j3min,j3max, j4min,j4max,j5min, j5max, j6min,j6max]</code>: 轴 1~ 轴 6 关节负限位与正限位，单位 [mm]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetJointSoftLimitDeg()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取关节软限位角度&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-8-查询机器人运动是否完成">2.5.8 查询机器人运动是否完成</h3><p><code>GetRobotMotionDone()</code>：查询机器人运动是否完成</p><ul><li>参数</li><li>返回<ul><li>错误码</li><li><code>state</code>：0-未完成，1-完成</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">ret = robot.GetRobotMotionDone()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查询机器人运动是否完成&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-5-9-获取-DH-参数">2.5.9 获取 DH 参数</h3><p><code>GetDHCompensation()</code>：获取 DH 补偿参数</p><ul><li>参数</li><li>返回<ul><li>错误码</li><li><code>[cmpstD1,cmpstA2,cmpstA3,cmpstD4,cmpstD5,cmpstD6]</code>：dhCompensation 机器人 DH 参数补偿值(mm)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">error = robot.GetDHCompensation()</span><br><span class="line"><span class="built_in">print</span>(error)</span><br></pre></td></tr></table></figure><h2 id="2-6-机器人运动学">2.6 机器人运动学</h2><h3 id="2-6-1-正运动学求解">2.6.1 正运动学求解</h3><p><code>GetForwardKin(joint_pos)</code>：正运动学，关节位置求解工具位姿</p><ul><li>参数<ul><li><code>joint_pos</code>:[j1,j2,j3,j4,j5,j6]:关节位置，单位[°]</li></ul></li><li>返回<ul><li>错误码</li><li><code>desc_pos</code>=[x,y,z,rx,ry,rz]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">J1=[<span class="number">95.442</span>,-<span class="number">101.149</span>,-<span class="number">98.699</span>,-<span class="number">68.347</span>,<span class="number">90.580</span>,-<span class="number">47.174</span>]</span><br><span class="line">ret = robot.GetForwardKin(J1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正运动学，关节位置求解工具位姿&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h3 id="2-6-2-逆运动学">2.6.2 逆运动学</h3><p><strong>（1）逆运动学求解</strong></p><p><code>GetInverseKin(type,desc_pos,config)</code>：逆运动学，笛卡尔位姿求解关节位置</p><ul><li>参数<ul><li><code>type</code>:0-绝对位姿(基坐标系)，1-相对位姿（基坐标系），2-相对位姿（工具坐标系）</li><li><code>desc_pose</code>:[x,y,z,rx,ry,rz],工具位姿，单位[mm][°]</li></ul></li><li>返回<ul><li>错误码</li><li><code>joint_pos</code>=[j1,j2,j3,j4,j5,j6]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">J1=[<span class="number">95.442</span>,-<span class="number">101.149</span>,-<span class="number">98.699</span>,-<span class="number">68.347</span>,<span class="number">90.580</span>,-<span class="number">47.174</span>]</span><br><span class="line">P1=[<span class="number">75.414</span>,<span class="number">568.526</span>,<span class="number">338.135</span>,-<span class="number">178.348</span>,-<span class="number">0.930</span>,<span class="number">52.611</span>]</span><br><span class="line">ret = robot.GetInverseKin(<span class="number">0</span>,P1,config=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;逆运动学，笛卡尔位姿求解关节位置&quot;</span>, ret)</span><br></pre></td></tr></table></figure><p><strong>（2）逆运动学求解（指定参考位置）</strong></p><p><code>GetInverseKinRef(type,desc_pos,joint_pos_ref)</code>：逆运动学，工具位姿求解关节位置，参考指定关节位置求解</p><ul><li>参数<ul><li><code>type</code>:0-绝对位姿(基坐标系)，1-相对位姿（基坐标系），2-相对位姿（工具坐标系）</li><li><code>desc_pos</code>：[x,y,z,rx,ry,rz]工具位姿，单位[mm][°]</li><li><code>joint_pos_ref</code>：[j1,j2,j3,j4,j5,j6]，关节参考位置，单位[°]</li></ul></li><li>返回<ul><li>错误码</li><li><code>joint_pos</code> =[j1,j2,j3,j4,j5,j6]</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">J1=[<span class="number">95.442</span>,-<span class="number">101.149</span>,-<span class="number">98.699</span>,-<span class="number">68.347</span>,<span class="number">90.580</span>,-<span class="number">47.174</span>]</span><br><span class="line">P1=[<span class="number">75.414</span>,<span class="number">568.526</span>,<span class="number">338.135</span>,-<span class="number">178.348</span>,-<span class="number">0.930</span>,<span class="number">52.611</span>]</span><br><span class="line">ret = robot.GetInverseKinRef(<span class="number">0</span>,P1,J1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;逆运动学，工具位姿求解关节位置，参考指定关节位置求解&quot;</span>, ret)</span><br></pre></td></tr></table></figure><p><strong>（3）逆运动学求解（判断是否有解）</strong></p><p><code>GetInverseKinHasSolution(type,desc_pos,joint_pos_ref)</code>：逆运动学，工具位姿求解关节位置 是否有解</p><ul><li>参数<ul><li><code>type</code>:0-绝对位姿(基坐标系)，1-相对位姿（基坐标系），2-相对位姿（工具坐标系）</li><li><code>desc_pos</code>：[x,y,z,rx,ry,rz]工具位姿，单位[mm][°]</li><li><code>joint_pos_ref</code>：[j1,j2,j3,j4,j5,j6]，关节参考位置，单位[°]</li></ul></li><li>返回<ul><li>错误码</li><li><code>result</code>：“True”-有解，“False”-无解</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">J1=[<span class="number">95.442</span>,-<span class="number">101.149</span>,-<span class="number">98.699</span>,-<span class="number">68.347</span>,<span class="number">90.580</span>,-<span class="number">47.174</span>]</span><br><span class="line">P1=[<span class="number">75.414</span>,<span class="number">568.526</span>,<span class="number">338.135</span>,-<span class="number">178.348</span>,-<span class="number">0.930</span>,<span class="number">52.611</span>]</span><br><span class="line">ret = robot.GetInverseKinHasSolution(<span class="number">0</span>,P1,J1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;逆运动学，工具位姿求解关节位置是否有解&quot;</span>, ret)</span><br></pre></td></tr></table></figure><h2 id="2-7-夹爪配置">2.7 夹爪配置</h2><h3 id="2-7-1-夹爪配置">2.7.1 夹爪配置</h3><p><strong>（1）获取夹爪配置</strong></p><p><code>GetGripperConfig()</code>：获取夹爪配置</p><ul><li>参数</li><li>返回<ul><li>错误码</li><li><code>[number,company,device,softversion]</code>：number（夹爪编号，范围[1]）；company（夹爪厂商，1-Robotiq，2-慧灵，3-天机，4-大寰，5-知行）；device（设备号，Robotiq(0-2F-85系列)，慧灵(0-NK系列,1-Z-EFG-100)， 天机(0-TEG-110)，大寰(0-PGI-140)，知行(0-CTPM2F20)）; softvesion（软件版本号，暂不使用，默认为0）;</li></ul></li></ul><p><strong>（2）配置夹爪</strong></p><p><code>SetGripperConfig(company,device,softversion,bus)</code>：配置夹爪</p><ul><li>参数<ul><li><code>company</code>：夹爪厂商，1-Robotiq，2-慧灵，3-天机，4-大寰，5-知行；</li><li><code>device</code>：设备号，Robotiq(0-2F-85系列)，慧灵(0-NK系列,1-Z-EFG-100)，天机(0-TEG-110)，大寰(0-PGI-140)，知行(0-CTPM2F20)</li><li><code>softversion</code>：软件版本号，暂不使用，默认为0；</li><li><code>bus</code>：设备挂载末端总线位置，暂不使用，默认为0；</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><h3 id="2-7-2-夹爪控制">2.7.2 夹爪控制</h3><blockquote><p>测试发现若夹爪连接在机械臂上，控制盒集成的夹爪控制与机械臂本体伺服控制会存在程序阻塞，无法同时使用<br>考虑夹爪直接连接电脑，通过 RS485 控制机械臂。</p></blockquote><p><strong>（1）激活夹爪</strong></p><p><code>ActGripper(index,action)</code>：激活夹爪</p><ul><li>参数<ul><li><code>index</code>:夹爪编号；</li><li><code>action</code>:0-复位，1-激活</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（2）控制夹爪</strong></p><p><code>MoveGripper(index,pos,speed,force,maxtime,block)</code>：控制夹爪</p><ul><li>参数<ul><li><code>index</code>:夹爪编号；</li><li><code>pos</code>:位置百分比，范围[0~100]；</li><li><code>speed</code>:速度百分比，范围[0~100];</li><li><code>force</code>:力矩百分比，范围[0~100]；</li><li><code>maxtime</code>:最大等待时间，范围[0~30000]，单位[ms]；</li><li><code>block</code>:0-阻塞，1-非阻塞。</li></ul></li><li>返回<ul><li>错误码</li></ul></li></ul><p><strong>（3）获取夹爪运动状态</strong></p><p><code>GetGripperMotionDone()</code>：获取夹爪运动状态</p><ul><li>参数</li><li>返回<ul><li>错误码</li><li><code>[fault,status]</code>：fault（0-无错误，1-有错误），status（0-运动未完成，1-运动完成）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fairino <span class="keyword">import</span> Robot</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 与机器人控制器建立连接，连接成功返回一个机器人对象</span></span><br><span class="line">robot = Robot.RPC(<span class="string">&#x27;192.168.58.2&#x27;</span>)</span><br><span class="line">desc_pos1=[-<span class="number">333.683</span>,-<span class="number">228.968</span>,<span class="number">404.329</span>,-<span class="number">179.138</span>,-<span class="number">0.781</span>,<span class="number">91.261</span>]</span><br><span class="line">desc_pos2=[-<span class="number">333.683</span>,-<span class="number">100.8</span>,<span class="number">404.329</span>,-<span class="number">179.138</span>,-<span class="number">0.781</span>,<span class="number">91.261</span>]</span><br><span class="line">zlength1 =<span class="number">10</span></span><br><span class="line">zlength2 =<span class="number">15</span></span><br><span class="line">zangle1 =<span class="number">10</span></span><br><span class="line">zangle2 =<span class="number">15</span></span><br><span class="line"><span class="comment">#测试外设指令</span></span><br><span class="line">ret = robot.SetGripperConfig(<span class="number">4</span>,<span class="number">0</span>)  <span class="comment">#配置夹爪</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;配置夹爪错误码&quot;</span>, ret)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">config = robot.GetGripperConfig()     <span class="comment">#获取夹爪配置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取夹爪配置&quot;</span>,config)</span><br><span class="line">error = robot.ActGripper(<span class="number">1</span>,<span class="number">0</span>)  <span class="comment">#激活夹爪</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;激活夹爪错误码&quot;</span>,error)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">error = robot.ActGripper(<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#激活夹爪</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;激活夹爪错误码&quot;</span>,error)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">error = robot.MoveGripper(<span class="number">1</span>,<span class="number">100</span>,<span class="number">48</span>,<span class="number">46</span>,<span class="number">30000</span>,<span class="number">0</span>) <span class="comment">#控制夹爪</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;控制夹爪错误码&quot;</span>,error)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">error = robot.MoveGripper(<span class="number">1</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">30000</span>,<span class="number">0</span>) <span class="comment">#控制夹爪</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;控制夹爪错误码&quot;</span>,error)</span><br><span class="line">error = robot.GetGripperMotionDone() <span class="comment">#获取夹爪运动状态</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取夹爪运动状态错误码&quot;</span>,error)</span><br></pre></td></tr></table></figure><h1>三、大寰 AG95 夹爪使用</h1><h2 id="3-1-RS385-控制接口">3.1 RS385 控制接口</h2><h3 id="3-1-1-RS485-默认配置">3.1.1 RS485 默认配置</h3><table><thead><tr><th>参数</th><th>默认</th></tr></thead><tbody><tr><td>夹爪ID</td><td>1</td></tr><tr><td>波特率</td><td>115200</td></tr><tr><td>数据位</td><td>8</td></tr><tr><td>停止位</td><td>1</td></tr><tr><td>校验位</td><td>无</td></tr></tbody></table><h3 id="3-1-2-命令格式">3.1.2 命令格式</h3><p>以初始化指令 <code>01 06 01 00 00 01 49 F6</code> 为例：</p><table><thead><tr><th>地址码</th><th>功能码</th><th>寄存器地址</th><th>寄存器数据</th><th>CRC 校验码</th></tr></thead><tbody><tr><td>01</td><td>06</td><td>01 00</td><td>00 01</td><td>49 F6</td></tr></tbody></table><ul><li>地址码：表示夹爪的ID 号，默认是 1；</li><li>功能码：描述读写操作，03（读取寄存器），06（写入寄存器）；</li><li>寄存器地址：夹爪功能对应地址；</li><li>寄存器数据：写入数据到具体的寄存器地址；</li><li>CRC 校验码：根据前面的数据进行转换，参考 <a href="http://www.ip33.com/crc.html">http://www.ip33.com/crc.html</a></li></ul><h3 id="3-1-3-初始化夹爪">3.1.3 初始化夹爪</h3><p><strong>初始化</strong>：</p><p><code>01 06 01 00 00 01 49 F6</code>：回零位（运行到张开极限位置）<br><code>01 06 01 00 00 A5 48 4D</code>：重新标定+回零点（先关闭夹爪，再打开夹爪，记录总行程标定）</p><p><strong>含义</strong>：</p><ul><li><code>01</code>：夹爪编号</li><li><code>06</code>：写入寄存器</li><li><code>01 00</code>：夹爪初始化寄存器</li><li><code>00 01</code> / <code>00 A5</code>：初始化指令</li><li><code>49 F6</code> / <code>48 4D</code>：校验码</li></ul><p><strong>初始化状态反馈</strong>：获取是否进行了初始化</p><p>发送：<code>01 03 02 00 00 01 85 B2</code></p><ul><li><code>01</code>：夹爪编号</li><li><code>03</code>：读取寄存器</li><li><code>02 00</code>：初始化状态反馈寄存器</li><li><code>00 01</code>：初始化状态反馈指令</li><li><code>85 B2</code>：校验码</li></ul><p>返回：<code>01 03 02 00 00 B8 44</code></p><ul><li><code>00 00</code>：未初始化，如果是 1 则初始化成功，如果是 2 则初始化中。</li></ul><h3 id="3-1-3-夹爪位置控制">3.1.3 夹爪位置控制</h3><p><strong>设置位置</strong>：设置夹爪位置，可以写入 0-1000，代表开合程度百分比，对应 16 进制为 <code>00 00 - 03 E8</code></p><p><code>01 06 01 03 01 F4 78 21</code>：设置夹爪位置 500。</p><ul><li><code>01</code>：夹爪编号</li><li><code>06</code>：写入寄存器</li><li><code>01 03</code>：夹爪位置寄存器</li><li><code>01 F4</code>：设置夹爪位置为 500</li><li><code>78 21</code>：校验码</li></ul><p><strong>读取设定位置</strong>：读取设置的位置</p><p>发送：<code>01 03 01 03 00 01 75 F6</code></p><ul><li><code>01</code>：夹爪编号</li><li><code>03</code>：读取寄存器</li><li><code>01 03</code>：夹爪位置寄存器</li><li><code>00 01</code>：读取设定位置指令</li><li><code>75 F6</code>：校验码</li></ul><p>返回：<code>01 03 02 xx xx crc1 crc2</code></p><ul><li><code>xx xx</code>：16 进制夹爪位置，对应 0-1000 夹爪开合程度百分比</li></ul><p><strong>读取实时位置</strong>：读取夹爪实时位置</p><p>发送：<code>01 03 02 02 00 01 24 72</code></p><ul><li><code>01</code>：夹爪编号</li><li><code>03</code>：读取寄存器</li><li><code>02 02</code>：夹爪实时位置寄存器</li><li><code>00 01</code>：读取实时位置指令</li><li><code>24 72</code>：校验码</li></ul><p>返回：<code>01 03 02 xx xx crc1 crc2</code></p><ul><li><code>xx xx</code>：16 进制夹爪位置，对应 0-1000 夹爪开合程度百分比</li></ul><h3 id="3-1-4-夹爪状态反馈">3.1.4 夹爪状态反馈</h3><p><strong>获取夹爪运动状态</strong>：读取目前夹爪的状态</p><p>发送：<code>01 03 02 01 00 01 D4 72</code></p><ul><li><code>01</code>：夹爪编号</li><li><code>03</code>：读取寄存器</li><li><code>02 01</code>：夹爪状态寄存器</li><li><code>00 01</code>：读取夹爪状态指令</li><li><code>24 72</code>：校验码</li></ul><p>返回：<code>01 03 02 00 02 39 85</code></p><ul><li><code>00 02</code>：代表夹住物体</li></ul><blockquote><p>00：夹爪处于正在运动状态。<br>01：夹爪停止运动，且夹爪未检测到夹到物体。<br>02：夹爪停止运动，且夹爪检测到夹到物体。<br>03：夹爪检测到夹住物体后，发现物体掉落。</p></blockquote><h2 id="3-2-Ubuntu-控制夹爪">3.2 Ubuntu 控制夹爪</h2><h3 id="3-2-1-连接夹爪">3.2.1 连接夹爪</h3><p><strong>（1）查看夹爪串口</strong></p><p>命令行输入 <code>ls -l /dev/ttyUSB*</code>，此时如果没有插入其它 usb 设备，则看不到输出</p><p>将 RS485 转 USB 连接至电脑，重新执行 <code>ls -l /dev/ttyUSB*</code> 命令，可以看到多出了一个 <code>/dev/ttyUSB0</code>，该设备即为夹爪的串口。</p><p><strong>（2）固定 ttyUSB 编号</strong></p><p>首先命令行输入 <code>lsusb</code> 查看设备 ID，可以拔插一次观察多出来的那一行就是夹爪设备，例如我的设备 ID 是  <code>0403:6001</code>，分别代表 <code>idVendor:idProduct</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus 001 Device 005: ID 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC</span><br></pre></td></tr></table></figure><p>然后创建并编辑配置文件：<code>sudo vim /etc/udev/rules.d/usb.rules</code>，输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==&quot;ttyUSB*&quot;, ATTRS&#123;idVendor&#125;==&quot;0403&quot;, ATTRS&#123;idProduct&#125;==&quot;6001&quot;, MODE:=&quot;0777&quot;, SYMLINK+=&quot;dh_gripper&quot;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>KERNEL</code>：不修改</li><li><code>ATTRS&#123;idVendor&#125;</code>：填写 ID 冒号前的部分</li><li><code>ATTRS&#123;idProduct&#125;</code>：填写 ID 冒号后的部分</li><li><code>MODE</code>：默认设置为 0777 即可，可读可写可执行</li><li><code>SYMLINK</code>：自定义，也就是想要将 ttyUSB0 改成什么一个固定的名字</li></ul><p>重启 <code>udev</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service udev reload</span><br><span class="line">service udev restart</span><br></pre></td></tr></table></figure><p>重新插拔设备，然后 <code>ls /dev/</code>，就可以看到自己设置的端口名出现。</p><h3 id="3-2-2-Python-串口控制">3.2.2 Python 串口控制</h3><p><strong>（1）安装依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyserial</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">FR5 是与 UR5 构型相似的 6 自由度机械臂，本文介绍其 Python SDK  的基本运动控制方法。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="实验设备" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/%E5%AE%9E%E9%AA%8C%E8%AE%BE%E5%A4%87/"/>
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="设备使用" scheme="https://www.mahaofei.com/tags/%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python识别图片中文字和数字_easyocr</title>
    <link href="https://www.mahaofei.com/post/f607dca0.html"/>
    <id>https://www.mahaofei.com/post/f607dca0.html</id>
    <published>2024-04-09T08:43:19.000Z</published>
    <updated>2024-04-09T08:43:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!abstract]<br>项目需要实现一个识别图片中文字、数字的小功能，因此找了比较好用的开源库 easyocr，本文介绍其使用方法。</p></blockquote><h2 id="EasyOCR-介绍">EasyOCR 介绍</h2><p>EasyOCR 是一个可以直接使用的开源项目，目前在 Github 上已经有 20k+ 的 star，支持 80 多种语言的识别，精度非常高。</p><p>项目地址：<a href="https://github.com/JaidedAI/EasyOCR">https://github.com/JaidedAI/EasyOCR</a></p><h2 id="EasyOCR-安装">EasyOCR 安装</h2><p>注意：本实验默认在 Ubuntu 上进行测试，Windows 理论上可以同样操作。</p><p><strong>（1）环境搭建</strong></p><p>为了避免 python 包混乱冲突，一般先创建一个 conda 环境，参考<a href="https://www.mahaofei.com/post/8543c9d.html">此文章</a>配置 anaconda。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n easyocr python=3.9</span><br></pre></td></tr></table></figure><p><strong>（2）安装 PyTorch</strong></p><p>EasyOCR 依赖于 PyTorch，因此需要在环境中安装 PyTorch，此处以 1.12 版本为例，其他版本的安装命令可以从<a href="https://pytorch.org/get-started/previous-versions/">此处</a>查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate easyocr</span><br><span class="line">conda install pytorch==1.12.1 torchvision==0.13.1 torchaudio==0.12.1 cudatoolkit=11.6 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><p><strong>（3）安装 EasyOCR</strong></p><p>安装 EasyOCR 非常简单，执行以下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install easyocr</span><br></pre></td></tr></table></figure><h2 id="EasyOCR-基本使用">EasyOCR 基本使用</h2><p>Easy 使用示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> easyocr</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 获取图像，既可以是在线图像，也可以是本地图像</span></span><br><span class="line"><span class="comment"># IMAGE_PATH = &#x27;https://img.mahaofei.com/img/202401011439226.png&#x27;</span></span><br><span class="line">image_path = <span class="string">&#x27;./src/digital_recognition/image/digit/2000-1400-Trans.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 识别文字</span></span><br><span class="line"><span class="comment"># reader = easyocr.Reader([&#x27;ch_sim&#x27;,&#x27;en&#x27;]) # 要识别的语言，ch_sim是简体中文，en是英文</span></span><br><span class="line">reader = easyocr.Reader([<span class="string">&#x27;en&#x27;</span>])</span><br><span class="line">result = reader.readtext(image_path)     <span class="comment"># 也可以传入opencv的图像对象(numpy数组)，detail为0表示只返回识别的文字，为1表示返回识别的文字和位置</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 绘制文字矩形框和文字</span></span><br><span class="line">image = cv2.imread(image_path)</span><br><span class="line"><span class="keyword">for</span> detection <span class="keyword">in</span> result:</span><br><span class="line">    <span class="comment"># 提取文字框坐标和识别结果</span></span><br><span class="line">    (bbox, text, prob) = detection</span><br><span class="line">    <span class="comment"># 将浮点数坐标转换为整数</span></span><br><span class="line">    bbox = np.array(bbox).astype(<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 在图像上绘制矩形框</span></span><br><span class="line">    cv2.rectangle(image, (bbox[<span class="number">0</span>][<span class="number">0</span>], bbox[<span class="number">0</span>][<span class="number">1</span>]), (bbox[<span class="number">2</span>][<span class="number">0</span>], bbox[<span class="number">2</span>][<span class="number">1</span>]), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 在矩形框左上角绘制文字和置信度</span></span><br><span class="line">    text_position = (bbox[<span class="number">0</span>][<span class="number">0</span>], bbox[<span class="number">0</span>][<span class="number">1</span>] - <span class="number">20</span>)</span><br><span class="line">    confidence_position = (bbox[<span class="number">0</span>][<span class="number">0</span>], bbox[<span class="number">0</span>][<span class="number">1</span>] - <span class="number">5</span>)</span><br><span class="line">    cv2.putText(image, text, text_position, cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    cv2.putText(image, <span class="string">f&quot;Confidence: <span class="subst">&#123;prob:<span class="number">.2</span>f&#125;</span>&quot;</span>, confidence_position, cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;OCR Result&quot;</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202404101030620.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">项目需要实现一个识别图片中文字、数字的小功能，因此找了比较好用的开源库easyocr，本文介绍其使用方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="编程基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/Python/"/>
    
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
    <category term="文字识别" scheme="https://www.mahaofei.com/tags/%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>【设备使用】omega.7主手配置与使用方法</title>
    <link href="https://www.mahaofei.com/post/520063b9.html"/>
    <id>https://www.mahaofei.com/post/520063b9.html</id>
    <published>2024-03-20T10:06:21.000Z</published>
    <updated>2024-03-20T10:06:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实验环境：<br>Ubuntu 20.04<br>omega.7</p></blockquote><h2 id="🛠️-Linux-下主手配置">🛠️ Linux 下主手配置</h2><h3 id="1-SDK-下载">1. SDK 下载</h3><p>官网(<a href="https://forcedimension.com/software/sdk">https://forcedimension.com/software/sdk</a>)下载对应版本 sdk，并解压。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf sdk-3.17.0-linux-x86_64-gcc.tar.gz</span><br></pre></td></tr></table></figure><ul><li><code>\bin</code>：包含示例的可执行程序和运行 omega.x 所需的二进制文件</li><li><code>\examples</code>：包含了一些演示程序</li><li><code>\doc</code>：所有的说明文档和注意事项</li><li><code>\lib,\include</code>：编译使用 Force Dimension SDK 所需要的库</li></ul><h3 id="2-驱动安装">2. 驱动安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libusb-1.0</span><br></pre></td></tr></table></figure><h3 id="3-坐标系">3. 坐标系</h3><p>平移坐标系如图所示，实际的原点是整个设备的中心，是一个虚拟的点。</p><p><img src="https://img.mahaofei.com/img/202403201333916.png" alt="image.png"></p><p>手腕的旋转方向如图所示，能够实现绕三个轴的旋转。</p><p><img src="https://img.mahaofei.com/img/202403201333135.png" alt="image.png"></p><p>手指处可以返回夹爪角度，若是右手操作涉及的 omega.7 设备，如上图所示，则返回一个正角度。</p><p>下方圆盘上的三个孔位由左到右依次是</p><ul><li>力按钮</li><li>力 LED</li><li>状态 LED（灭代表系统关闭、亮代表系统准备就绪、快速闪烁代表系统需要标定、缓慢闪烁代表腕部需要手动标定）</li></ul><h3 id="4-标定">4. 标定</h3><p>设备每次开机都需要校准一次，来保证末端执行器的准确和重复定位。</p><p>位置校准：校准时需要将<strong>校准杆放在校准孔中</strong>（圆盘中心处的空位），设备检测到达校准位置后自行校准，状态 LED 会停止闪烁。</p><p>姿态校准：为了校准手腕关节，必须将手腕处的<strong>三个旋转轴</strong>和<strong>夹爪控制轴</strong>移动到各自的<strong>行程终点</strong>，设备检测到后会自行完成校准。</p><p>自动校准的过程中不要触摸设备，校准完成后 LED 停止闪烁时再移动设备。</p><h3 id="5-HapticDesk-可视化测试">5. HapticDesk 可视化测试</h3><p>打开 Omega.7 电源，并完成标定。</p><p>进入 <code>sdk-3.17.0\bin</code> 目录，使用 <code>sudo ./HapticDesk</code> 命令启动可视化窗口，操作 Omega.7 主手移动，可以看到界面上方的位置、转角、夹爪转角随之变化。</p><p><img src="https://img.mahaofei.com/img/202403201403201.png" alt="image.png"></p><h2 id="💻-相关程序">💻 相关程序</h2><h3 id="1-配置环境">1. 配置环境</h3><p><strong>创建 conda 环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n omega python=3.8</span><br><span class="line">conda activate omega</span><br><span class="line">python3 -m pip install forcedimension-core numpy</span><br></pre></td></tr></table></figure><p><strong>安装库</strong></p><p>下载最新版本的 SDK，进入 sdk 目录，并进行手动安装（注意版本号是否正确）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd sdk-3.17.0</span><br><span class="line"></span><br><span class="line">sudo cp include/* /usr/local/include</span><br><span class="line">sudo cp lib/release/*/* /usr/local/lib</span><br><span class="line">sudo chmod 755 /usr/local/lib/libdhd.so.3.17.0</span><br><span class="line">sudo chmod 755 /usr/local/lib/libdrd.so.3.17.0</span><br><span class="line">sudo chmod 755 /usr/local/lib/libdhd.a</span><br><span class="line">sudo chmod 755 /usr/local/lib/libdrd.a</span><br><span class="line">sudo ln -s /usr/local/lib/libdhd.so.3.17.0 /usr/local/lib/libdhd.so</span><br><span class="line">sudo ln -s /usr/local/lib/libdrd.so.3.17.0 /usr/local/lib/libdrd.so</span><br></pre></td></tr></table></figure><blockquote><p>如果需要卸载，使用类似的方法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/local/include/dhdc.h</span><br><span class="line">sudo rm /usr/local/include/drdc.h</span><br><span class="line">sudo rm /usr/local/lib/libdhd.a</span><br><span class="line">sudo rm /usr/local/lib/libdhd.so.3.17.0</span><br><span class="line">sudo rm /usr/local/lib/libdhd.so</span><br><span class="line">sudo rm /usr/local/lib/libdrd.a</span><br><span class="line">sudo rm /usr/local/lib/libdrd.so.3.17.0</span><br><span class="line">sudo rm /usr/local/lib/libdrd.so</span><br></pre></td></tr></table></figure><p><strong>配置权限，主要是为了让普通用户访问 usb 设备，用于 ros 和 python 控制</strong></p><p>在 <code>/etc/udev/rules.d/</code> 下为设备添加 udev 规则。创建一个名为 <code>40-haptic-device-udev.rules</code> 的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/udev/rules.d/40-haptic-device-udev.rules</span><br></pre></td></tr></table></figure><p>然后粘贴以下模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TTR&#123;idVendor&#125;==&quot;&quot;, ATTR&#123;idProduct&#125;==&quot;&quot;, MODE=&quot;0666&quot;, SYMLINK+=&quot;haptic_device_%k&quot;, GROUP=&quot;plugdev&quot;</span><br><span class="line">SUBSYSTEM==&quot;usb&quot;, ACTION==&quot;add&quot;, ENV&#123;DEVTYPE&#125;==&quot;usb_device&quot;, ATTR&#123;idVendor&#125;==&quot;&quot;, ATTR&#123;idProduct&#125;==&quot;&quot;, MODE=&quot;0664&quot;, GROUP=&quot;plugdev&quot;</span><br></pre></td></tr></table></figure><p>使用 <code>lsusb</code> 可以查看供应商 ID 和产品 ID，格式为 <code>idVendor:idProduct</code></p><ul><li>使用设备名称（不带空格）替换掉 <code>SYMLINK+=&quot;haptic_device_%k&quot;</code> 中的 <code>haptic_device</code></li><li>在 <code>ATTR&#123;idVendor&#125;</code> 和 <code>ATTR&#123;idProduct&#125;</code> 的双引号中填写自己的供应商 ID 和产品 ID</li></ul><p>修改完成后的示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ATTR&#123;idVendor&#125;==&quot;1451&quot;, ATTR&#123;idProduct&#125;==&quot;0301&quot;, MODE=&quot;0666&quot;, SYMLINK+=&quot;haptic_device_%k&quot;, GROUP=&quot;plugdev&quot;</span><br><span class="line">SUBSYSTEM==&quot;usb&quot;, ACTION==&quot;add&quot;, ENV&#123;DEVTYPE&#125;==&quot;usb_device&quot;, ATTR&#123;idVendor&#125;==&quot;1451&quot;, ATTR&#123;idProduct&#125;==&quot;0301&quot;, MODE=&quot;0664&quot;, GROUP=&quot;plugdev&quot;</span><br></pre></td></tr></table></figure><p>执行以下命令重新加载 udev 规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo udevadm control --reload-rules &amp;&amp; sudo udevadm trigger</span><br></pre></td></tr></table></figure><h3 id="2-基本程序">2. 基本程序</h3><p>使用下面程序打印主手的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import forcedimension_core.containers as containers</span><br><span class="line">import forcedimension_core.dhd as dhd</span><br><span class="line"></span><br><span class="line">dhd.open()</span><br><span class="line">pos = containers.Vec3()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Equivalent to: dhd.getPosition(out=pos)</span></span><br><span class="line">dhd.direct.getPosition(out=pos)</span><br><span class="line"></span><br><span class="line">print(pos)</span><br></pre></td></tr></table></figure><h3 id="3-主手控制-mujoco-机器人">3. 主手控制 mujoco 机器人</h3><figure class="highlight python"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> gym <span class="keyword">import</span> error, spaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> diffusion_policy.env.gym_envs</span><br><span class="line"><span class="keyword">from</span> diffusion_policy.env.gym_envs.utils <span class="keyword">import</span> ctrl_set_action, mocap_set_action</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> mujoco_py</span><br><span class="line"><span class="keyword">from</span> diffusion_policy.env.gym_envs <span class="keyword">import</span> rotations</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> R</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> forcedimension_core.containers <span class="keyword">as</span> containers</span><br><span class="line"><span class="keyword">import</span> forcedimension_core.dhd <span class="keyword">as</span> dhd</span><br><span class="line"><span class="keyword">import</span> forcedimension_core.drd <span class="keyword">as</span> drd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment">#################### 初始化设备 ####################</span></span><br><span class="line"><span class="comment"># 打开设备</span></span><br><span class="line">dhd.<span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量，位置、旋转矩阵、夹爪角度、线速度、角速度</span></span><br><span class="line">pos = np.zeros(<span class="number">3</span>)</span><br><span class="line">matrix = np.zeros((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">gripper_pointer = ctypes.pointer(ctypes.c_double(<span class="number">0.0</span>))</span><br><span class="line">linear_velocity = np.zeros(<span class="number">3</span>)</span><br><span class="line">angular_velocity = np.zeros(<span class="number">3</span>)</span><br><span class="line">euler = np.zeros(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 力控配置</span></span><br><span class="line">devicePosition = np.zeros(<span class="number">3</span>)</span><br><span class="line">deviceRotation = np.zeros((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">deviceLinearVelocity = np.zeros(<span class="number">3</span>)</span><br><span class="line">deviceAngularVelocity = np.zeros(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">flagHoldPosition = <span class="literal">True</span></span><br><span class="line">flagHoldPositionReady = <span class="literal">True</span></span><br><span class="line">holdPosition = np.zeros(<span class="number">3</span>)</span><br><span class="line">holdRotation = np.zeros((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">last_display_time = dhd.os_independent.getTime()</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 连续控制</span></span><br><span class="line"><span class="comment"># pos_continus = np.zeros(3)</span></span><br><span class="line"><span class="comment"># pos_result = np.zeros(3)</span></span><br><span class="line"><span class="comment"># flag_continus = False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Drd 初始化</span></span><br><span class="line"><span class="keyword">if</span> drd.<span class="built_in">open</span>() &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法打开设备: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> drd.isInitialized() <span class="keyword">and</span> drd.autoInit() &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法初始化设备: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> drd.start() &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法启动设备: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> drd.moveToPos(pos, block=<span class="literal">True</span>) &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法移动到位置: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> drd.moveToRot(euler, block=<span class="literal">True</span>) &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法移动到旋转矩阵: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> drd.stop(<span class="literal">True</span>) &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法停止设备: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录相邻动作</span></span><br><span class="line">last_action = np.array([<span class="number">1.17</span>, <span class="number">0.75</span>, <span class="number">0.70</span>, -np.pi, <span class="number">0.</span>, -np.pi/<span class="number">2</span>, <span class="number">0.</span>])</span><br><span class="line">action_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment">#################### 常用函数 ####################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quaternion2euler</span>(<span class="params">quaternion</span>):</span><br><span class="line">    r = R.from_quat(quaternion)</span><br><span class="line">    euler = r.as_euler(<span class="string">&#x27;xyz&#x27;</span>, degrees=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> euler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euler2quaternion</span>(<span class="params">euler</span>):</span><br><span class="line">    r = R.from_euler(<span class="string">&#x27;xyz&#x27;</span>, euler, degrees=<span class="literal">True</span>)</span><br><span class="line">    quaternion = r.as_quat()</span><br><span class="line">    <span class="keyword">return</span> quaternion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_env = gym.make(<span class="string">&#x27;PutInDrawer-v0&#x27;</span>)</span><br><span class="line">test_env.reset()</span><br><span class="line"><span class="comment"># obs = test_env.reset()</span></span><br><span class="line"><span class="comment"># episode_acs = []</span></span><br><span class="line"><span class="comment"># episode_obs = []</span></span><br><span class="line"><span class="comment"># episode_info = []</span></span><br><span class="line"><span class="comment"># episode_obs.append(obs)    # 存储初始观察值</span></span><br><span class="line"><span class="comment"># idx = 0</span></span><br><span class="line"><span class="comment"># time_step = 0   # 记录总的时间步数</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="comment"># viewer2 = mujoco_py.MjRenderContextOffscreen(test_env.sim, 0)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">######################### 读取设备状态 #########################</span></span><br><span class="line">    <span class="comment"># 获取位置、旋转矩阵</span></span><br><span class="line">    dhd.getPositionAndOrientationFrame(pos, matrix)</span><br><span class="line">    <span class="comment"># 获取夹爪角度</span></span><br><span class="line">    dhd.getGripperAngleDeg(gripper_pointer)</span><br><span class="line">    gripper = gripper_pointer.contents.value</span><br><span class="line">    <span class="comment"># 获取线速度</span></span><br><span class="line">    dhd.getLinearVelocity(linear_velocity)</span><br><span class="line">    <span class="comment"># 获取角速度</span></span><br><span class="line">    dhd.getAngularVelocityDeg(angular_velocity)</span><br><span class="line"></span><br><span class="line">    <span class="comment">######################### 控制设备位置 #########################</span></span><br><span class="line">    <span class="comment"># 设置设备状态</span></span><br><span class="line">    devicePosition = pos</span><br><span class="line">    deviceRotation = matrix</span><br><span class="line">    deviceLinearVelocity = linear_velocity</span><br><span class="line">    deviceAngularVelocity = angular_velocity</span><br><span class="line">    deviceForce = np.zeros(<span class="number">3</span>)</span><br><span class="line">    deviceTorque = np.zeros(<span class="number">3</span>)</span><br><span class="line">    deviceGripperForce = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置刚度和阻尼</span></span><br><span class="line">    Kp = <span class="number">2000.0</span></span><br><span class="line">    Kv = <span class="number">10.0</span></span><br><span class="line">    Kr = <span class="number">5.0</span></span><br><span class="line">    Kw = <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保持设备位置</span></span><br><span class="line">    <span class="keyword">if</span> flagHoldPosition:</span><br><span class="line">        <span class="keyword">if</span> flagHoldPositionReady:</span><br><span class="line">            <span class="comment"># 计算反作用力</span></span><br><span class="line">            force = -Kp * (devicePosition - holdPosition) - Kv * deviceLinearVelocity</span><br><span class="line">            <span class="comment"># 计算反作用力矩</span></span><br><span class="line">            deltaRotation = np.transpose(deviceRotation) @ holdRotation</span><br><span class="line">            axis, angle = np.zeros(<span class="number">3</span>), <span class="number">0.0</span></span><br><span class="line">            <span class="comment"># 计算旋转轴和角度</span></span><br><span class="line">            angle = np.arccos((np.trace(deltaRotation) - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> angle &gt; <span class="number">1e-6</span>:</span><br><span class="line">                axis = np.array([deltaRotation[<span class="number">2</span>, <span class="number">1</span>] - deltaRotation[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                                 deltaRotation[<span class="number">0</span>, <span class="number">2</span>] - deltaRotation[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">                                 deltaRotation[<span class="number">1</span>, <span class="number">0</span>] - deltaRotation[<span class="number">0</span>, <span class="number">1</span>]]) / (<span class="number">2</span> * np.sin(angle))</span><br><span class="line">            torque = deviceRotation @ ((Kr * angle) * axis) - Kw * deviceAngularVelocity</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 加上所有力</span></span><br><span class="line">            deviceForce = deviceForce + force</span><br><span class="line">            deviceTorque = deviceTorque + torque</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            holdPosition = devicePosition</span><br><span class="line">            holdRotation = deviceRotation</span><br><span class="line">            flagHoldPositionReady = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置设备力</span></span><br><span class="line">    MaxTorque = <span class="number">0.3</span></span><br><span class="line">    <span class="keyword">if</span> np.linalg.norm(deviceTorque) &gt; MaxTorque:</span><br><span class="line">        deviceTorque = MaxTorque * deviceTorque / np.linalg.norm(deviceTorque)</span><br><span class="line">    <span class="comment"># dhd.setForceAndTorqueAndGripperForce(deviceForce, deviceTorque, deviceGripperForce)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dhd.setForceAndTorqueAndGripperForce(np.zeros(<span class="number">3</span>), np.zeros(<span class="number">3</span>), <span class="number">0.0</span>) &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无法设置力和力矩: &quot;</span> + dhd.error())</span><br><span class="line">        dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">######################### 键盘控制 #########################</span></span><br><span class="line">    <span class="keyword">if</span> dhd.os_independent.kbHit():</span><br><span class="line">        keyboard = dhd.os_independent.kbGet()</span><br><span class="line">        <span class="keyword">if</span> keyboard == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> keyboard == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 周期打印设备状态，并刷新输出</span></span><br><span class="line">    device_time = dhd.os_independent.getTime()</span><br><span class="line">    <span class="keyword">if</span> device_time - last_display_time &gt; <span class="number">0.1</span>:</span><br><span class="line">        last_display_time = device_time</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Pos (%.3f %.3f %.3f) m | Gripper %.3f deg | Rot (%.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f %.3f) | Force (%.3f %.3f %.3f) N | Freq %.2f kHz \r&quot;</span> </span><br><span class="line">              % (pos[<span class="number">0</span>], pos[<span class="number">1</span>], pos[<span class="number">2</span>], gripper, matrix[<span class="number">0</span>, <span class="number">0</span>], matrix[<span class="number">0</span>, <span class="number">1</span>], matrix[<span class="number">0</span>, <span class="number">2</span>], matrix[<span class="number">1</span>, <span class="number">0</span>], matrix[<span class="number">1</span>, <span class="number">1</span>], matrix[<span class="number">1</span>, <span class="number">2</span>], matrix[<span class="number">2</span>, <span class="number">0</span>], matrix[<span class="number">2</span>, <span class="number">1</span>], matrix[<span class="number">2</span>, <span class="number">2</span>], deviceForce[<span class="number">0</span>], deviceForce[<span class="number">1</span>], deviceForce[<span class="number">2</span>], dhd.getComFreq()), end=<span class="string">&quot;\r&quot;</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># action = np.array([0, 0., 0, 0., 0., 0., 0.])</span></span><br><span class="line">    <span class="comment"># print(action)</span></span><br><span class="line">    action_pos = pos</span><br><span class="line">    action_matrix = matrix</span><br><span class="line">    action_gripper = gripper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将主手的运动范围映射到mujoco机器人工作空间</span></span><br><span class="line">    <span class="comment"># x从[-0.05,0.05]映射到[0.8,1.5]</span></span><br><span class="line">    action_pos[<span class="number">0</span>] = pos[<span class="number">0</span>]*<span class="number">7</span>    <span class="comment"># + 1.15</span></span><br><span class="line">    <span class="comment"># y从[-0.1,0.1]映射到[0,1.2]</span></span><br><span class="line">    action_pos[<span class="number">1</span>] = pos[<span class="number">1</span>]*<span class="number">6</span>    <span class="comment"># + 0.6</span></span><br><span class="line">    <span class="comment"># z从[-0.05,0.1]映射到[0.4,1.0]</span></span><br><span class="line">    action_pos[<span class="number">2</span>] = pos[<span class="number">2</span>]*<span class="number">4</span>    <span class="comment"># + 0.6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将旋转矩阵转换为四元数</span></span><br><span class="line">    action_matrix *= <span class="number">0.05</span></span><br><span class="line">    <span class="comment"># 绕x轴旋转180度的旋转矩阵</span></span><br><span class="line">    matrix_rotation_x_180 = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">    <span class="comment"># 绕z轴旋转-90度的旋转矩阵</span></span><br><span class="line">    matrix_rotation_z_n90 = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">    <span class="comment"># 旋转矩阵乘法</span></span><br><span class="line">    action_matrix = np.dot(action_matrix, matrix_rotation_x_180)</span><br><span class="line">    action_matrix = np.dot(action_matrix, matrix_rotation_z_n90)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    action_quat = rotations.mat2quat(action_matrix)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将夹爪角度从[0,30](0为夹爪关闭)，归一化到[0,1](0为夹爪打开)</span></span><br><span class="line">    action_gripper = <span class="built_in">abs</span>((action_gripper - <span class="number">30.0</span>) / <span class="number">30.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># test_env.sim.step()             # 执行一步仿真，模拟环境中物体的运动和交互</span></span><br><span class="line">    action = np.concatenate([action_pos, action_quat, [action_gripper]])</span><br><span class="line">    test_env.step(action)             <span class="comment"># 执行一步仿真，模拟环境中物体的运动和交互</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># gym 渲染</span></span><br><span class="line">    test_env.render(mode=<span class="string">&quot;human&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取action</span></span><br><span class="line">    action_list.append(action)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将动作列表转换为numpy数组并保存为文件</span></span><br><span class="line">action_list = np.array(action_list)</span><br><span class="line"><span class="comment"># np.save(&quot;data/put_in_drawer/habtic_actions.npy&quot;, action_list)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> drd.close() &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法关闭设备: &quot;</span> + drd.error())</span><br><span class="line">    dhd.os_independent.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n设备已关闭&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Omega.7虚拟触觉力反馈操作主手的配置和基本程序使用</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="实验设备" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/%E5%AE%9E%E9%AA%8C%E8%AE%BE%E5%A4%87/"/>
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="模仿" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF/"/>
    
    <category term="设备使用" scheme="https://www.mahaofei.com/tags/%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】ACT 使用低成本硬件的双手操作模仿学习</title>
    <link href="https://www.mahaofei.com/post/24d9497f.html"/>
    <id>https://www.mahaofei.com/post/24d9497f.html</id>
    <published>2024-01-05T02:24:38.000Z</published>
    <updated>2024-01-05T02:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware<br><strong>中文标题</strong>：使用低成本硬件学习细粒度双手操作<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/tonyzhaozh/act">https://github.com/tonyzhaozh/act</a></p></blockquote><h2 id="1-1-目标问题-9">1.1 目标问题</h2><p>对于机器人而言，学习实现一些精细操作是较为困难的，因为涉及精确的力控以及闭环视觉反馈，这有需要先进的机器人，精确的传感器和准确的标定。</p><p><strong>能否使用低成本、不精确的硬件来执行这些精细的操作任务？</strong></p><h2 id="1-2-方法-9">1.2 方法</h2><p>本文提出了一种简单的算法，ACT (Action Chunking with Transformers)。</p><p>首先使用 ALOHA 收集人类演示的引导机器人的关节位置，并将其作为动作，观测结果由机器人的当前关节位置和相机的输入图像组成。然后训练 ACT 根据当前观测预测未来的动作序列，也就是下一个时间步中双臂的目标关节位置。</p><p><img src="https://img.mahaofei.com/img/202401051026095.png" alt="image.png"></p><p><strong>（1）动作分块和时间集成</strong></p><p>为了利用像素到动作的策略，通过对抗模仿学习解决复合错误。本文使用了动作分块的思想，将多个动作分组在一起平作为一个单元执行，从而使他们更有效的存储和执行。</p><p>本文将动作块的大小固定为 k ，每 k 步，智能体接收一个观测结果，生成接下来的 k 个操作，并按顺序执行这些操作，因此任务的有效范围被减小了 k 倍。</p><p>但是这种方法得到的动作块可能不是最理想的动作，因此可能导致机器人的运动不稳定。为了提高平滑型，本文在每个时间步内执行策略，得到不同的动作块相互重叠，因此会有多个预测动作，本文对这些预测进行指数加权 $w_i=exp(-m*i)$，其中 $w_0$ 是最旧的动作的权重，$m$ 越小则合并的速度越快。</p><p><strong>（2）人类数据建模</strong></p><p>人类可以从不同个轨迹来解决同一个任务，尤其是在不要求精度的区域，人类的动作会非常随机，因此策略重点关注高精度区域也是非常重要的。</p><p>本文将策略训练为条件变分自动编码器 CVAE 来生成当前观测为条件的动作序列。</p><ul><li>CVAE 编码器：输入当前观测（机器人本体状态）和动作序列，编码后得到变量 z 分布，将其参数化为高斯分布，输出该分布的均值和方差</li><li>CVAE 解码器：以 z 和当前观测（图像+机器人本体状态）为条件，预测动作序列。</li></ul><h1>二、代码复现 (act)</h1><blockquote><p>该部分参考论文原仓库：<a href="https://github.com/tonyzhaozh/act">https://github.com/tonyzhaozh/act</a></p></blockquote><h2 id="2-1-环境准备">2.1 环境准备</h2><p>创建虚拟环境并安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conda create -n aloha python=3.8.10</span><br><span class="line">conda activate aloha</span><br><span class="line">pip install torchvision</span><br><span class="line">pip install torch</span><br><span class="line">pip install pyquaternion</span><br><span class="line">pip install pyyaml</span><br><span class="line">pip install rospkg</span><br><span class="line">pip install pexpect</span><br><span class="line">pip install mujoco</span><br><span class="line">pip install dm_control</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install matplotlib</span><br><span class="line">pip install einops</span><br><span class="line">pip install packaging</span><br><span class="line">pip install h5py</span><br><span class="line">pip install ipython</span><br><span class="line">cd act/detr &amp;&amp; pip install -e .</span><br></pre></td></tr></table></figure><h2 id="2-2-数据收集-2">2.2 数据收集</h2><p>首先激活虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate aloha</span><br></pre></td></tr></table></figure><p>进入到代码根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;path to act&gt;</span><br></pre></td></tr></table></figure><p>创建两个目录，分别用于保存数据集和训练好后的模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p datasets/sim_transfer_cube_scripted</span><br><span class="line">mkdir checkpoints</span><br></pre></td></tr></table></figure><p>以 <code>sim_transfer_cube_scripted</code> 任务为例，使用下面的脚本产生 50 个 episodes 的数据（可以添加 <code>--onscreen_render</code> 来实现实时渲染）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 record_sim_episodes.py --task_name sim_transfer_cube_scripted --dataset_dir datasets/sim_transfer_cube_scripted/ --num_episodes 50</span><br></pre></td></tr></table></figure><p>产生的 50 个数据会以 50 个 hdf5 文件的格式保存在文件夹中，要想可视化这些数据集，可以使用下面的命令，以可视化第一个数据为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 visualize_episodes.py --dataset_dir datasets/sim_transfer_cube_scripted/ --episode_idx 0</span><br></pre></td></tr></table></figure><h2 id="2-3-训练-3">2.3 训练</h2><p>首先需要修改 <code>constants.py</code> 中的 DATA_DIR 参数，将其改为自己的数据集文件夹名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_DIR = <span class="string">&#x27;/home/mahaofei/Programs/Imitation/act/datasets&#x27;</span></span><br></pre></td></tr></table></figure><p>开始训练：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 8 --dim_feedforward 3200 --num_epochs 2000  --lr 1e-5 --seed 0</span><br></pre></td></tr></table></figure><p>如果 ACT 策略在一个 episode 中是不稳定的或者是停止不变的，那么就训练更长时间，在平台期过后成功率和轨迹平滑性都会得到提高。</p><h2 id="2-4-评估">2.4 评估</h2><p>还是和训练使用同一个脚本，只不过需要加入 <code>--eval</code>，该程序会把评估过程中的视频保存到 <code>checkpoints</code> 文件夹中，也可以添加 <code>--onscreen_render</code> 在评估是实时渲染。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 8 --dim_feedforward 3200 --num_epochs 2000  --lr 1e-5 --seed 0 --eval</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202401051053987.png" alt="image.png"></p><p>经测试，实际成功率并不高，在抓取时总会出现错位，且传递过程很难成功。</p><p>~~暂未知原因，等待后续检查。~~已查明原因，需使用特定版本的 mujoco，参考 <a href="https://github.com/MarkFzp/act-plus-plus/issues/12">issue #12</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mojoco==2.3.7 dm_env==1.6 dm_control==1.0.14</span><br></pre></td></tr></table></figure><h1>三、代码复现 (act-plus-plus)</h1><p>最近发现作者在一篇新的论文中 Mobile ALOHA Learning Bimanual Mobile Manipulation with Low-Cost Whole-Body Teleoperation，对 ACT 算法进行了更新，基本复现流程一致，部分进行了修改。</p><blockquote><p>该部分参考论文原仓库：<a href="https://github.com/MarkFzp/act-plus-plus">https://github.com/MarkFzp/act-plus-plus</a></p></blockquote><h2 id="2-1-环境准备-2">2.1 环境准备</h2><p>下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/MarkFzp/act-plus-plus</span><br></pre></td></tr></table></figure><p>创建虚拟环境并安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">conda create -n act python=3.8.10</span><br><span class="line">conda activate act</span><br><span class="line">pip install torchvision</span><br><span class="line">pip install torch</span><br><span class="line">pip install pyquaternion</span><br><span class="line">pip install pyyaml</span><br><span class="line">pip install rospkg</span><br><span class="line">pip install pexpect</span><br><span class="line">pip install mujoco==2.3.7</span><br><span class="line">pip install dm_control==1.0.14</span><br><span class="line">pip install dm_env==1.6</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install matplotlib</span><br><span class="line">pip install einops</span><br><span class="line">pip install packaging</span><br><span class="line">pip install h5py</span><br><span class="line">pip install ipython</span><br><span class="line">cd act-plus-plus/detr &amp;&amp; pip install -e .</span><br></pre></td></tr></table></figure><p>实际上没有提到但却调用的库还有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install diffusers</span><br><span class="line">pip install wandb</span><br><span class="line"></span><br><span class="line">git clone git@github.com:ARISE-Initiative/robomimic.git</span><br><span class="line">cd robomimic</span><br><span class="line">git checkout diffusion-policy-mg</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p>修改 <code>constants.py</code> 中的 DATA_DIR 参数，将其改为自己的数据集文件夹名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_DIR = <span class="string">&#x27;/home/mahaofei/Programs/Imitation/act/datasets&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <a href="https://wandb.ai/">wandb 官网</a>创建账号，并创建一个项目，将 <code>imitate_episodes.py</code> 的第 148 行修改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wandb.init(project=<span class="string">&quot;项目名称&quot;</span>, reinit=<span class="literal">True</span>, entity=<span class="string">&quot;wandb用户名&quot;</span>, name=expr_name)</span><br></pre></td></tr></table></figure><p>截至 2023-01-05 开源的代码还存在一些问题，需要修改 <code>detr/models/detr_vae.py</code> 的第 285 行为 <code>encoder = build_encoder(args)</code>，参考 <a href="https://github.com/MarkFzp/act-plus-plus/issues/3#issuecomment-1876588075">issue</a></p><h2 id="2-2-数据收集-3">2.2 数据收集</h2><p>首先激活虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate act</span><br></pre></td></tr></table></figure><p>进入到代码根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;path to act&gt;</span><br></pre></td></tr></table></figure><p>创建两个目录，分别用于保存数据集和训练好后的模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p datasets/sim_transfer_cube_scripted</span><br><span class="line">mkdir checkpoints</span><br></pre></td></tr></table></figure><p><strong>收集数据</strong>：以 <code>sim_transfer_cube_scripted</code> 任务为例，使用下面的脚本产生 50 个 episodes 的数据（可以添加 <code>--onscreen_render</code> 来实现实时渲染）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 record_sim_episodes.py --task_name sim_transfer_cube_scripted --dataset_dir datasets/sim_transfer_cube_scripted/ --num_episodes 50</span><br></pre></td></tr></table></figure><p><strong>可视化收集的数据</strong>：产生的 50 个数据会以 50 个 hdf5 文件的格式保存在文件夹中，要想可视化这些数据集，可以使用下面的命令，以可视化第一个数据为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 visualize_episodes.py --dataset_dir datasets/sim_transfer_cube_scripted/ --episode_idx 0</span><br></pre></td></tr></table></figure><h2 id="2-3-训练-4">2.3 训练</h2><p><strong>开始训练</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 4 --dim_feedforward 3200 --num_steps 2000  --lr 1e-5 --seed 0</span><br></pre></td></tr></table></figure><p>如果爆显存了(CUDA out of memory)，可以减小 <code>batch_size</code>。</p><p>如果 ACT 策略在一个 episode 中是不稳定的或者是停止不变的，那么就训练更长时间，在平台期过后成功率和轨迹平滑性都会得到提高。</p><h2 id="2-4-评估-2">2.4 评估</h2><p>还是和训练使用同一个脚本，只不过需要加入 <code>--eval</code>，该程序会把评估过程中的视频保存到 <code>checkpoints</code> 文件夹中，也可以添加 <code>--onscreen_render</code> 在评估是实时渲染。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 8 --dim_feedforward 3200 --num_steps 10000  --lr 1e-5 --seed 0 --eval --onscreen_render</span><br></pre></td></tr></table></figure><h1>三、代码解析</h1><h2 id="3-1-训练数据格式">3.1 训练数据格式</h2><p>ACT 的训练数据生成为多个 hdf5 文件，每个文件对应一个演示数据，每个 hdf5 文件的结构如下：</p><ul><li>episode_1.hdf5<ul><li><strong>action</strong>: dateset 数据，存储机器人的动作，shape 为 (400, 14)，包括末端执行器的位置和四元数，归一化的夹爪位置（0 关闭，1 打开）<br>[left_arm_qpos (6), left_gripper_positions (1), right_arm_qpos (6), right_gripper_positions (1),]，</li><li><strong>observations</strong>: group 组，存储观测数据<ul><li><strong>images</strong>: gropu 组，存储图像数据<ul><li><strong>left_wrist</strong>：dataset 数据，存储左侧机器人末端相机图像数据，shape 为 (400, 480, 640, 3)，即长度 400，每个图像为 (480, 640, 3) 大小。</li><li><strong>right_wrist</strong>：dataset 数据，存储右侧机器人末端相机图像数据，shape 为 (400, 480, 640, 3)，即长度 400，每个图像为 (480, 640, 3) 大小。</li><li><strong>top</strong>：dataset 数据，存储顶部相机图像数据，shape 为 (400, 480, 640, 3)，即长度 400，每个图像为 (480, 640, 3) 大小。</li></ul></li><li><strong>qpos</strong>：dateset 数据，shape 为 (400, 14)，包括绝对关节位置，归一化的夹爪位置（0 关闭，1 打开）<br>[left_arm_qpos (6), left_gripper_position (1), right_arm_qpos (6), right_gripper_qpos (1)]</li><li><strong>qvel</strong>：dateset 数据，shape 为 (400, 14)，包括绝对关节速度（rad），归一化的夹爪速度（正数为正在打开，负数为正在关闭）<br>[left_arm_qvel (6), left_gripper_velocity (1), right_arm_qvel (6), right_gripper_qvel (1)]</li></ul></li></ul></li></ul><h2 id="3-2-替换-Gym-环境">3.2 替换 Gym 环境</h2><p><strong>（1）补充依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install gym==0.12.1</span><br><span class="line">pip install &quot;cython&lt;3&quot;</span><br><span class="line">pip install perlin_noise</span><br></pre></td></tr></table></figure><p><strong>（2）编写脚本生成与 ACT 训练数据格式相同的 HDF5 数据</strong></p><p><strong>（3）进行训练</strong></p>]]></content>
    
    
    <summary type="html">斯坦福大学开发的双手模仿学习系统，包括一整套软硬件系统，实现低成本不精确硬件完成精细操作任务。</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>HDF5数据文件格式</title>
    <link href="https://www.mahaofei.com/post/87290c9f.html"/>
    <id>https://www.mahaofei.com/post/87290c9f.html</id>
    <published>2024-01-01T06:02:57.000Z</published>
    <updated>2024-01-01T06:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!abstract]<br>HDF5数据文件格式的简单介绍与基本使用方法。</p></blockquote><h1>1 HDF5 格式简介</h1><h2 id="1-1-什么是-hdf5-文件">1.1 什么是 hdf5 文件</h2><p>HDF5是一种常见的跨平台数据储存文件，可以存储不同类型的图像和数据，并且可以在不同类型的机器上传输，同时还有统一处理这种文件格式的函数库。</p><p>可以把HDF5文件想象成一个容器，这个容器由多个不同类型的数据对象组成。数据对象可以是任意类型，例如：图片、表格、图像，甚至文档（PDF、Excel）。</p><h2 id="1-2-hdf5-文件结构">1.2 hdf5 文件结构</h2><p>HDF5 文件一般以 <code>.h5</code> 或 <code>.hdf5</code> 作为后缀名，其文件结构包括两部分：<code>Groups</code> 和 <code>Datasets</code>。</p><ul><li><strong>Group</strong>: 类似于文件夹，负责管理数据对象</li><li><strong>Datasets</strong>: 类似于 numpy 中的数组 array，一个数据集由元数据（metadata）和数据本身（data）组成<ul><li><strong>Metadata</strong>: 元数据<ul><li><strong>Datatype</strong>: 数据类型</li><li><strong>Dataspace</strong>: 原始数据的秩和维度</li><li><strong>Properties</strong>: 该数据集的分块存储以及压缩情况<ul><li><strong>Chunked</strong>:</li><li><strong>Chunked &amp; Compressed</strong>:</li></ul></li><li><strong>Attributes</strong>: 为该数据的其它自定义属性</li></ul></li><li><strong>Data Values</strong>:</li></ul></li></ul><p><strong>（1）Group 组</strong></p><p>组负责管理数据对象。每个HDF5文件含有一个根组，根组包含其他组或者链接到其他文件的对象。组和组的成员与文件和文件夹类似，HDF5中对象也可以使用路径来表示：</p><ul><li><code>/</code> 代表根组</li><li><code>/a</code> 代表根组下的 <code>a</code> 成员</li><li><code>/a/b</code> 代表组 <code>a</code> 下的一个成员，<code>a</code> 是根组 <code>/</code> 下的成员</li></ul><p><strong>（2）Datasets 数据集</strong></p><p>一个数据集由元数据（metadata）和数据本身（data）组成。</p><p><img src="https://img.mahaofei.com/img/202401011439226.png" alt="image.png"></p><p>其中的 <code>Metadata</code> 包括一下几个部分：数据类型（datatype）、数据空间（dataspace）、性质（property）、属性（attribute）。</p><p><strong>（3）Datatype 数据类型</strong></p><p>数据类型描述数据集中元素的数据类型，例如 <code>float</code>。</p><ul><li>内置数据类型：包括标准数据类型和原生数据类型</li><li>衍生数据类型：例如符合数据类型（16位整型、1个字符、一个2x3x2的浮点数组组合而成）</li></ul><p><img src="https://img.mahaofei.com/img/202401011453368.png" alt="image.png"></p><p><strong>（4）Dataspace数据空间</strong></p><p>描述数据集内部数据元素（data element）的分布情况：</p><ul><li>Rank：表示数据集维度的个数（例如下图中数据维度个数为2，即2维数组）</li><li>Dimensions：数据空间的维度（数据空间的维度为5x3）<ul><li>NULL：代表数据集内没有任何数据元素</li><li>标量：代表只有一个元素</li><li>向量：代表数据集是一个数组</li></ul></li></ul><p>数据空间的维度可以是固定的，也可以是不固定的。如果是不固定的，代表该数据集的大小是可变的（例如，可扩展的数据集）。</p><p><img src="https://img.mahaofei.com/img/202401011454062.png" alt="image.png"></p><p><strong>（5）Properties 性质</strong></p><p>HDF5包含很多默认的性质，可以是用<code>HDF5 Property List API</code>来修改这些性质。</p><p><strong>（6）Attribute 属性</strong></p><p>属性包含一个名称（name）和一个值（value），是对HDF5对象的一些额外描述。通常都是一些很小的、用户自定义的元数据。</p><h1>二、Python 操作HDF5文件</h1><p><strong>（1）使用 <code>h5py</code> 包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br></pre></td></tr></table></figure><p><strong>（2）创建 <code>hdf5</code> 文件：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 hdf5文件</span></span><br><span class="line">f = h5py.File(<span class="string">&quot;h5py_example.hdf5&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在根目录`/` 下创建两个组</span></span><br><span class="line">g1 = f.create_group(<span class="string">&quot;bar1&quot;</span>)</span><br><span class="line">g2 = f.create_group(<span class="string">&quot;bar2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在根目录 `/` 下创建一个数据集(4x4的数组)</span></span><br><span class="line">d = f.create_dataset(<span class="string">&quot;dset&quot;</span>, data=np.arange(<span class="number">16</span>).reshape([<span class="number">4</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据集添加两个属性</span></span><br><span class="line">d.attrs[<span class="string">&quot;myAttr1&quot;</span>] = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">d.attrs[<span class="string">&quot;myAttr2&quot;</span>] = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 `bar1` 组下创建一个组和一个数据集</span></span><br><span class="line">c1 = g1.create_group(<span class="string">&quot;car1&quot;</span>)</span><br><span class="line">d1 = g1.create_dataset(<span class="string">&quot;dset1&quot;</span>, data=np.arange(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 `bar2` 组下创建一个组和一个数据集</span></span><br><span class="line">c2 = g2.create_group(<span class="string">&quot;car2&quot;</span>)</span><br><span class="line">d2 = g2.create_dataset(<span class="string">&quot;dset2&quot;</span>, data=np.arange(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>最后得到的 <code>hdf5</code> 文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-- &#x27;/&#x27;</span><br><span class="line">|   +--group &quot;bar1&quot;</span><br><span class="line">|   |   +-- group &quot;car1&quot;</span><br><span class="line">|   |   |   +-- None</span><br><span class="line">|   |   |   </span><br><span class="line">|   |   +-- dataset &quot;dset1&quot;</span><br><span class="line">|   |</span><br><span class="line">|   +-- group &quot;bar2&quot;</span><br><span class="line">|   |   +-- group &quot;car2&quot;</span><br><span class="line">|   |   |   +-- None</span><br><span class="line">|   |   |</span><br><span class="line">|   |   +-- dataset &quot;dset2&quot;</span><br><span class="line">|   |   </span><br><span class="line">|   +-- dataset &quot;dset&quot;</span><br><span class="line">|   |   +-- attribute &quot;myAttr1&quot;</span><br><span class="line">|   |   +-- attribute &quot;myAttr2&quot;</span><br><span class="line">|   |   </span><br><span class="line">|   </span><br></pre></td></tr></table></figure><p><strong>（3）读取 <code>hdf5</code> 文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取 hdf5 文件</span></span><br><span class="line">f = h5py.File(<span class="string">&quot;h5py_example.hdf5&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 `/` 下所有的组和数据集的 keys</span></span><br><span class="line"><span class="built_in">print</span>(f.filename, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>([key <span class="keyword">for</span> key <span class="keyword">in</span> f.keys()], <span class="string">&quot;\n&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 `/` 下的数据集 `dset`</span></span><br><span class="line">d = f[<span class="string">&quot;dset&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(d.name, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d[:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 `dset` 数据集的属性</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.attrs.keys():</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, d.attrs[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取组`bar1`</span></span><br><span class="line">g = f[<span class="string">&quot;bar1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 `bar1` 下所有的组和数据集的 keys</span></span><br><span class="line"><span class="built_in">print</span>([key <span class="keyword">for</span> key <span class="keyword">in</span> g.keys()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三种方式打印 `dset1` 的数据</span></span><br><span class="line"><span class="built_in">print</span>(f[<span class="string">&quot;/bar1/dset1&quot;</span>][:])   <span class="comment"># 绝对路径</span></span><br><span class="line"><span class="built_in">print</span>(f[<span class="string">&quot;bar1&quot;</span>][<span class="string">&quot;dset1&quot;</span>][:]) <span class="comment"># 相对路径：file[][]</span></span><br><span class="line"><span class="built_in">print</span>(g[<span class="string">&#x27;dset1&#x27;</span>][:])         <span class="comment"># 相对路径：g[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><ol><li><a href="https://www.hdfgroup.org/solutions/hdf5/">HDF Group</a></li><li><a href="https://zhuanlan.zhihu.com/p/656178708">仙棠生信. HDF5简介. 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/104145585">NoNo721. HDF5 数据文件简介. 知乎</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">HDF5数据文件格式的简单介绍与基本使用方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="强化学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据" scheme="https://www.mahaofei.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【仿真实验】robomimic项目复现</title>
    <link href="https://www.mahaofei.com/post/8cdbc8de.html"/>
    <id>https://www.mahaofei.com/post/8cdbc8de.html</id>
    <published>2023-12-27T02:31:36.000Z</published>
    <updated>2023-12-27T02:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>robomimic 是一个用于机器人从演示学习的框架，该项目提供了一系列机器人操作的演示数据和离线学习算法，可以让人们对任务和算法进行标准化测试。</p><p>本文测试的版本为 robomimic v0.3</p><h1>一、安装与环境搭建</h1><p>在安装之前确保运行 Linux 系统，并安装有 conda。</p><h2 id="1-1-安装-robomimic">1.1 安装 robomimic</h2><p><strong>（1）创建并激活虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n robomimic python=3.8.0 -y</span><br><span class="line">conda activate robomimic</span><br></pre></td></tr></table></figure><p><strong>（2）安装Pytorch</strong></p><p>其中的 pytorch 版本和 torchvision 版本官方说可以修改，暂未测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==2.0.0 torchvision==0.15.1 -c pytorch</span><br></pre></td></tr></table></figure><p><strong>（3）安装 robomimic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;你想保存robomimic代码的位置&gt;</span><br><span class="line">git clone https://github.com/ARISE-Initiative/robomimic.git</span><br><span class="line">cd robomimic</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h2 id="1-2-安装模拟器">1.2 安装模拟器</h2><p><strong>（1）robosuite</strong></p><p>运行大多数 robomimic 示例和发布的数据集需要使用 robosuite 模拟器，安装方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;你想保存robosuite代码的位置&gt;</span><br><span class="line">git clone https://github.com/ARISE-Initiative/robosuite.git</span><br><span class="line">cd robosuite</span><br><span class="line">git checkout v1.4.1</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p><strong>（2）D4RL</strong></p><p>D4RL也提供了标准化的训练环境和数据集，安装方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Farama-Foundation/d4rl.git</span><br><span class="line">cd d4rl</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h2 id="1-3-安装测试">1.3 安装测试</h2><p><strong>简单测试：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;robomimic代码安装位置&gt;</span><br><span class="line">python examples/train_bc_rnn.py --debug</span><br></pre></td></tr></table></figure><blockquote><p>[!question]- 问题：<code>AttributeError: module 'mujoco_py' has no attribute 'builder'</code><br>目前我的解决方法如下：</p><ol><li>安装 mujoco-210，可参考<a href="https://github.com/HaofeiMa/E05_Robotiq-2f-85#quick-start">3(3) Prepare the mujoco environment</a></li><li>安装 mujoco-py：<code>pip install mujoco-py</code></li><li>安装 Cython：<code>pip install &quot;cython&lt;3&quot;</code></li></ol></blockquote><blockquote><p>[!question]- 问题：<code>Error compiling Cython file</code><br>解决方法如下：</p><ol><li><code>pip install &quot;cython&lt;3&quot;</code></li></ol></blockquote><blockquote><p>[!question]- 问题：<code>EGL_NOT_INITIALIZED</code><br>解决方法如下：</p><ol><li>替换<code>robosuite/robosuite/renderers/context/egl_context.py</code>的155行<code>self.free()</code>为<code>pass</code></li><li>注释掉<code>robosuite/robosuite/utils/binding_utils.py</code>的199行<code>self.gl_ctx.free()</code></li></ol></blockquote><p><strong>全面测试：</strong></p><p>运行一个调试环境，以确保robomimic安装正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;robomimic代码安装位置&gt;/test</span><br><span class="line">bash test.sh</span><br></pre></td></tr></table></figure><p>运行过程可能持续几分钟，命令行会出现很多passed，说明没有问题，中间如果出现和EGL有关的问题，可以先不用管，EGL是用于没有显示器的server版服务器进行渲染的时候使用的。</p><h1>二、实验复现</h1><h2 id="2-1-论文结果复现">2.1 论文结果复现</h2><p><strong>（1）数据集下载</strong></p><p>这里下载了 <code>tool_hang</code> 场景进行了测试，其它可用的场景参考<a href="https://robomimic.github.io/docs/datasets/robomimic_v0.1.html">官方文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;robomimic代码安装位置&gt;/robomimic/scripts</span><br><span class="line">python download_datasets.py --tasks tool_hang</span><br></pre></td></tr></table></figure><p><strong>（2）生成配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python generate_paper_configs.py --output_dir &lt;想要保存试验结果的绝对路径&gt;</span><br></pre></td></tr></table></figure><p>生成的配置文件默认在<code>robomimic/exps/paper</code>路径下，可以在<code>core.sh</code>文件中复制命令进行训练测试。</p><p><strong>（3）执行训练</strong></p><p>在<code>core.sh</code>中找到想要测试的命令，执行命令例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /home/mahaofei/Programs/Imitation/RoboMimic/robomimic/robomimic/scripts/train.py --config /home/mahaofei/Programs/Imitation/RoboMimic/robomimic/robomimic/exps/paper/core/tool_hang/ph/low_dim/bc.json</span><br></pre></td></tr></table></figure><p>训练生成的可视化视频默认在</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/experiment_results/core/bc/tool_hang/ph/low_dim/trained_models/core_bc_tool_hang_ph_low_dim/20231227161534/videos/ToolHang_epoch_100.mp4</span><br></pre></td></tr></table></figure><h2 id="2-2-数据集分析">2.2 数据集分析</h2><p><strong>（1）官方数据 hdf5 内容说明</strong></p><p>官方对每一项任务提供了两种类型的数据集：<code>image</code> 和 <code>low_dim</code>，但两种数据结构基本相同：</p><ul><li>data (group)<ul><li>total (attribute): 数据集中的 state-action 样本数量</li><li>env_args (attribute): 一个 json 字符串，包含环境的 metadata 和用于收集数据的相关参数，包含三个keys<ul><li>env_name: 要创建的环境或任务名称</li><li>env_type: robomimic 支持的环境类型之一</li><li>env_kwargs: 要传递到 env_name 的关键字参数的字典</li></ul></li><li>demo_0 (group): 第一个轨迹的组<ul><li>num_samples (attribute): 该轨迹中的 state-action 样本数</li><li>model_file (attribute): 对应 mujoco 模型的 xml 字符串，仅适用于 robosuite 数据集</li><li>states (dataset): 展开的 mujoco 状态，按时间排序，shape(N,D)，其中 N 是轨迹的长度，D 是状态向量的维度，对于非 robosuite 数据集，应该为空。</li><li>actions (dataset): 环境动作，按时间排序，shape(N,A)，其中 N 是轨迹的长度，A 是动作空间维度。</li><li>rewards (datasets): 完成信号，如果当前动作对应的状态代表 eposide 应该结束了，则为1</li><li>obs (group): 存储 observation 的键的组，每个键都是一个 dataset<ul><li>obs_key_1 (dataset): 第一个 observation key，该数据集名称和形状可能会不同</li><li>…</li></ul></li><li>next_obs (group): 下一个 observation 的组<ul><li>obs_key_1 (dataset): 第一个 observation key</li><li>…</li></ul></li></ul></li><li>demo_1 (group): 第二个轨迹的组</li><li>…</li></ul></li><li>mask (group): 存在于包含 filter keys 的数据集中<ul><li>filter_key_1: 第一个 filter key，例如列表[“demo_0”, “demo_19”, “demo_35”]</li></ul></li></ul><p><strong>（2）下载 raw、low_dim、image 三种格式的数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;你想保存数据集的位置&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载原始数据和 low_dim 数据</span></span><br><span class="line">wget http://downloads.cs.stanford.edu/downloads/rt_benchmark/tool_hang/ph/demo_v141.hdf5</span><br><span class="line">wget http://downloads.cs.stanford.edu/downloads/rt_benchmark/tool_hang/ph/low_dim_v141.hdf5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">cd robomimic/robomimic/scripts</span><br><span class="line">python download_datasets.py --tasks &lt;任务名称&gt; --dataset_types all --hdf5_types all --download_dir &lt;数据保存路径&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转换得到 image 数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意，如果训练image数据，需要修改对应json文件中crop_height和crop_width为76</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意，转换后数据文件可能在 10GB 左右，注意磁盘空间</span></span><br><span class="line">python dataset_states_to_obs.py --dataset=&lt;原始数据的路径&gt; --output_name=image_v141.hdf5  --done_mode 2 --camera_names agentview robot0_eye_in_hand sideview --camera_height 84 --camera_width 84</span><br></pre></td></tr></table></figure><p>下载 <code>image</code> 格式数据，使用 <code>download_datasets.py</code> 下载会提示无 url，从 raw 数据转换 image 在训练时会提示图片格式错误。经查找，在 <a href="https://robomimic.github.io/docs/v0.2/datasets/robomimic_v0.1.html">v2.0 文档</a>中提供了 image 格式数据，如有需要请从此处下载。</p><p>例如 robomimic 的 tool_hang 环境的 <code>image</code> 类型数据集的  <code>demo_0</code> 中内容如下：</p><ul><li><strong>actions</strong>: shape (n, 7)，n 为轨迹长度，7为动作维度</li><li><strong>dones</strong>: shape (n, )，n 为轨迹长度</li><li><strong>obs</strong><ul><li><strong>agentview_image</strong>: shape (n, 256, 256, 3)，agent 视角图像，分别对应(n, H, W, C)，n 为轨迹长度，H 为图像高，W 为宽，C 为图像通道数，所有图像需为 np.uint8 类型</li><li><strong>object</strong>: shape (n, 44)，n 为轨迹长度，三个物体 base, frame, tool 的位置，姿态，相对机械臂末端的位置姿态(pos3, quat4, to_eef_pos3, to_eef_quat4)，共计 3x14 个值，以及 frame_is_assembled 与 tool_on_frame 两个布尔值</li><li><strong>robot0_eef_pos</strong>: shape (n, 3)，机器人末端位置</li><li><strong>robot0_eef_quat</strong>: shape (n, 4)，机器人末端姿态四元数</li><li><strong>robot0_eef_vel_ang</strong>: shape (n, 3)，机器人末端角速度</li><li><strong>robot0_eef_vel_lin</strong>: shape (n, 3)，机器人末端线速度</li><li><strong>robot0_eye_in_hand_image</strong>: shape (n, 256, 256, 3)，机器人末端相机图像</li><li><strong>robot0_gripper_qpos</strong>: shape (n, 2)，末端夹爪动作状态，左右两侧</li><li><strong>robot0_gripper_qvel</strong>: shape (n, 2)，末端夹爪动作速度，左右两侧</li><li><strong>robot0_joint_pos</strong>: shape (n, 7)，机器人各关节转角</li><li><strong>robot0_joint_pos_cos</strong>: shape (n, 7)，机器人各关节转角 cos 值</li><li><strong>robot0_joint_pos_sin</strong>: shape (n, 7)，机器人各关节转角 sin 值</li><li><strong>robot0_joint_vel</strong>: shape (n, 7)，机器人各关节速度</li><li><strong>sideview_image</strong>: shape (n, 256, 256, 3)，侧方位相机图像</li></ul></li><li><strong>next_obs</strong><ul><li>同上</li></ul></li><li><strong>rewards</strong>: shape (n, )，n 为轨迹长度</li><li><strong>states</strong>: shape (n, 58)，n 为轨迹长度，58 是状态向量的维度，对于非 robosuite 数据集，应该为空</li></ul><p>而 <code>low_dim</code> 类型的数据集的中内容与 <code>image</code> 基本相同，只是 obs 中少了所有的 image。</p><p><strong>（3）数据集可视化</strong></p><p>使用 <code>playback_dataset.py</code> 脚本查看数据集轨迹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python playback_dataset.py --dataset &lt;path/to/.hdf5&gt; --video_path &lt;path/to/.mp4&gt; --n 5</span><br></pre></td></tr></table></figure><h1>三、自定义</h1><h2 id="3-1-生成自定义数据集">3.1 生成自定义数据集</h2><p>该项目中收集人类演示数据的脚本为 <code>robosuite/robosuite/scripts/collect_human_demonstrations.py</code>，其中可以指定环境，指定所使用的机器人，控制单臂还是双臂，用于收集演示数据的相机等等。</p><p>但是这些都是 robomimic 所提供的，如果我想要使用自己的机器人模型，在自定义环境中记录任务数据，则需要修改的较多，因此考虑在自己的 mujoco 环境中按照前文分析的 hdf5 数据格式直接生成数据。</p><blockquote><p>参考链接：</p><ol><li><a href="https://robomimic.github.io/docs/">Robotmimic 官方文档 (robomimic documentation)</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">robomimic 是一个用于机器人从演示学习的框架，该项目提供了一系列机器人操作的演示数据和离线学习算法，可以让人们对任务和算法进行标准化测试。</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>【课程笔记】Stanford CS25 V2 - Robotics and Imitation Learning</title>
    <link href="https://www.mahaofei.com/post/1aebe4e4.html"/>
    <id>https://www.mahaofei.com/post/1aebe4e4.html</id>
    <published>2023-12-24T05:54:05.000Z</published>
    <updated>2023-12-24T05:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Video Link: <a href="https://www.youtube.com/watch?v=ct4tdyyNDY4">https://www.youtube.com/watch?v=ct4tdyyNDY4</a></p></blockquote><p>过去两年，由于大语言模型、语音技术、视觉技术的发展，机器人技术的研究思路发生了180度的转变。</p><h1>机器人基础模型</h1><p>目前在大量数据上进行大规模模型训练时，通常由两个比较重要的属性：</p><ul><li>涌现：当非常简单地事情在小范围发挥作用时，当扩大范围，它的表现会更好，例如更多的数据、更大的模型。</li><li>均质化：模型可以组合许多下游任务来实现泛化能力</li></ul><p>当然我们可能会思考一个问题，为什么目前还没有机器人领域的基础模型。不像音频、语言、图像等领域，这些领域已经出现了较为通用的基础模型，机器人技术的基础模型还没有人研究出来。</p><p>那么如果想要实现机器人的基础模型，可以如何做：</p><p><strong>（1）设计强化学习算法</strong></p><ol><li>利用高性能的架构，例如self-attention</li><li>利用比例法则，不仅要扩大模型大小，还有扩展计算，还需要扩大数据集语料库以及标记数量</li><li>数据集大小比数据质量更重要</li></ol><p><strong>（2）互联网规模的模型扩散</strong></p><ol><li>生成式模型在语言、编程、视觉、音频等领域已经展现出了涌现的能力，并且一次次超出了我们的预期，这个趋势在可见的未来中还会一直保持下去。</li><li>涌现和加速意味着这些模型可以“自己”变的更好</li></ol><p><strong>（3）从在线机器人学习转移到离线学习</strong></p><ol><li>目前的大模型都是在巨大规模的离线数据集上训练完成的</li></ol><h1>Google Brain 相关工作</h1><h2 id="过去工作">过去工作</h2><p><strong>（1）2016 - 机器人工厂</strong></p><ol><li><strong>强化学习</strong>：Google建立了一个包含7个Kuka机械臂的机器人工厂，7x24小时执行抓取动作，进行强化学习训练。</li><li><strong>Qt-Opt</strong>：Q-学习算法，接受视觉输入的同时进行连续控制。</li><li><strong>RL-CycleGan</strong>：将房展环境的图像转换为真实的图像，让机器人在显示世界中更好地完成任务。</li></ol><p><strong>（2）2020 - 厨房环境</strong></p><ol><li><strong>BC-Z</strong>：多任务模仿学习</li><li><strong>AW-Opt</strong>：将强化学习与模仿学习引导相结合</li></ol><p><strong>（3）2022</strong></p><p>遇到了一些问题，例如在一些场景任务中，成功率已经稳定到了50~70%，一些方法需要非常特定的数据分布，如果策略没有训练过当前的数据，那么任务很可能失败。为了解决这个问题，Google 进行了以下工作</p><ol><li>多任务模仿学习</li><li>使用大规模数据集</li></ol><h2 id="近期工作">近期工作</h2><p><strong>（1）RT-1</strong></p><p>主要聚焦于如何扩展模仿学习。</p><ol><li>使用一年半时间从13个机器人中收集了100k的演示数据，包括700个任务</li><li>使用BC-Z进行训练</li><li>由于基于Transformer的算法在处理图像时，现在还不足以支撑机器人学习中的高频率、实时性要求，因此希望数据集能够理解语言模型。</li></ol><p>从较高的层面来看，RT-1是一个机器人Transformer，它接受机器人摄像头的视觉输入，以及自然语言指令，仅仅使用transformer进行解码，分离目标物体类别，使用预训练的EfficientNet主干网络得到离散化动作。</p><p><strong>（2）SayCan</strong></p><p>机器人的技能能够是有限的，大语言模型也是受限制的，他不知道机器人的状态，不知道周围环境。</p><p>因此这项工作主要实现让语言模型说机器人的语言。</p><p><strong>（3）Inner-Monologue</strong></p><p>将环境的动态环境反馈加入到闭环中，也使用语言的API来传达环境中有什么。</p>]]></content>
    
    
    <summary type="html">Stanford CS25 V2中的一节课，由Google Brain工程师主讲的机器人学习主题课程。</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="课程笔记" scheme="https://www.mahaofei.com/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu与Window双主机共用一套键鼠</title>
    <link href="https://www.mahaofei.com/post/2f664e2b.html"/>
    <id>https://www.mahaofei.com/post/2f664e2b.html</id>
    <published>2023-12-14T01:43:41.000Z</published>
    <updated>2023-12-14T01:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="〇、使用软件（Synergy）">〇、使用软件（Synergy）</h2><p>Synergy是一款能够让使用者仅用一套键盘鼠标，就同时操控多部计算机的免费工具软件。</p><p>我的需求是在一个局域网内的一台windows 11主机，一台Ubuntu 20.04主机之间共享键鼠、剪切板，并且键鼠接在windows作为server，linux作为client。</p><h2 id="一、软件安装">一、软件安装</h2><blockquote><p>Github: <a href="https://github.com/DEAKSoftware/Synergy-Binaries/releases">https://github.com/DEAKSoftware/Synergy-Binaries/releases</a></p></blockquote><h3 id="1-1-Windows">1.1 Windows</h3><blockquote><p>下载最新的和</p></blockquote><p>在上面的 Github 页面中下载最新的版本： <a href="https://github.com/DEAKSoftware/Synergy-Binaries/releases/download/1.14.6.19-stable/synergy-1.14.6.19-stable-windows-10-amd64.msi">synergy-1.14.6.19-stable-windows-10-amd64.msi</a> ，直接安装。</p><h3 id="1-2-Ubuntu">1.2 Ubuntu</h3><p>在上面的 Github 页面中下载最新的版本 <a href="https://github.com/DEAKSoftware/Synergy-Binaries/releases/download/1.14.6.19-stable/synergy-1.14.6.19-stable-ubuntu-22.04-jammy-jellyfish-x86_64.deb">synergy-1.14.6.19-stable-ubuntu-22.04-jammy-jellyfish-x86_64.deb</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i synergy-1.14.6.19-stable-ubuntu-22.04-jammy-jellyfish-x86_64.deb</span><br></pre></td></tr></table></figure><p>如果出现缺少依赖的问题，就根据缺少的依次安装，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libqt5core5a</span><br><span class="line">sudo apt install libqt5dbus5</span><br><span class="line">sudo apt install libqt5gui5 libqt5gui5-gles</span><br><span class="line">sudo apt install libqt5network5</span><br><span class="line">sudo apt install libqt5widgets5</span><br></pre></td></tr></table></figure><h2 id="二、软件配置">二、软件配置</h2><p><strong>确保两个电脑在同一个局域网下</strong></p><h3 id="2-1-打开软件">2.1 打开软件</h3><p>Ubuntu 在应用菜单内点击 Synergy，或者命令行输入 <code>synergy</code>，等待 5 秒左右，可能会弹出 <code>System tray is unavailable, don't close your window.</code>，不用管，直接点 ok 就行。</p><p>Ubuntu 打开软件后，<strong>勾选 Client</strong>，<strong>勾选Auto config</strong> 即可。</p><p>Windows 打开 Synergy 程序。打开软件后，<strong>勾选 Server</strong>。</p><h3 id="2-2-设置服务端">2.2 设置服务端</h3><p>在服务端电脑，点击设置服务端，然后把右上角的电脑，拖一个到你的电脑旁边。<strong>屏幕名填写 Ubuntu 中的 Client 下的屏幕名</strong>。</p><p><img src="https://img.mahaofei.com/img/202405052044212.png" alt="image.png"></p><h3 id="2-3-设置客户端">2.3 设置客户端</h3><p>本来其实没有什么设置的，直接两边点开始就可以了。但是由于 Ubuntu 的 版本较老，有一些问题。</p><p><strong>问题 1</strong>：<code>ERROR: failed to connect secure socket.</code></p><p><strong>解决 1：</strong> 参考 <a href="https://blog.csdn.net/guojingyue123/article/details/120013254">CSDN. aprilaaaaa</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.config/Synergy/Synergy.conf</span><br><span class="line"><span class="comment"># 把cryptoEnabled = ture这一行，ture改成false</span></span><br></pre></td></tr></table></figure><p><strong>问题 2</strong>：<code>ERROR: error:140AB18F:SSL routines:SSL_CTX_use_certificate:ee key too small</code></p><p><strong>解决 2</strong>：参考 [CSDN.橘圆亮](c <a href="https://blog.csdn.net/CyFio/article/details/121060881">https://blog.csdn.net/CyFio/article/details/121060881</a> )</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 退出 Synergy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 删除 SSL文件夹</span></span><br><span class="line">cd /home/&lt;username&gt;/.synergy/</span><br><span class="line">rm -rf SSL/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 修改 /usr/share/synergy/gen_ssl_pem.sh 中 rsa:后面的参数为4096</span></span><br><span class="line">sudo gedit /usr/share/synergy/gen_ssl_pem.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 重新生成SSL文件夹</span></span><br><span class="line">bash /usr/share/synergy/gen_ssl_pem.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 重新启动 Synergy</span></span><br></pre></td></tr></table></figure><p>解决完以上问题后，服务端和客户端都点击开始，就可以建立通信了。实现鼠标、键盘、剪切板的互联。</p><h2 id="三、其它问题">三、其它问题</h2><h3 id="3-1-服务端鼠标移至客户端，直接卡死在右下角">3.1 服务端鼠标移至客户端，直接卡死在右下角</h3><p>这个问题的原因在于两个屏幕的分辨率不一致，或缩放比例不一致。参考 <a href="https://tieba.baidu.com/p/5016381206">Synergy 贴吧</a>。</p><h3 id="3-2-某次重启后，Client-端一直显示-synergy-failed-to-connect-to-server，无法连接">3.2 某次重启后，Client 端一直显示 synergy failed to connect to server，无法连接</h3><p>经过排查，我的问题 server 端的 IP 再某次重启后被改为了其它 IP 地址。</p><p>可以检查 server 端<strong>加粗的 IP 地址</strong>，与 client 端的服务端 IP 设置是否一致。</p><p>一劳永逸的方法是手动设置电脑 IP，点击 windows 的【设置-网络-以太网】编辑 IP 地址，根据自己的情况固定 IP，可以直接固定为之前自己电脑一直的 IP 或者 synergy 界面显示的 IP。（Ubuntu 作为服务端也可以固定 IP）</p><blockquote><p>参考：</p><ol><li><a href="https://blog.csdn.net/guojingyue123/article/details/120013254">aprilaaaaa. Ubuntu20.04 安装 synergy（Windows 和 linux 共用一套键鼠）. CSDN. </a></li><li><a href="https://blog.csdn.net/CyFio/article/details/121060881">橘圆亮. synergy 早期免费版本在 Ubuntu20 报错 SSL Key too small 问题解决方法. CSDN</a></li><li><a href="https://tieba.baidu.com/p/5016381206">Synergy 贴吧</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">Synergy是一款能够让使用者仅用一套键盘鼠标，就同时操控多部计算机的免费工具软件。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Ubuntu工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Ubuntu%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Ubuntu" scheme="https://www.mahaofei.com/tags/Ubuntu/"/>
    
    <category term="Windows" scheme="https://www.mahaofei.com/tags/Windows/"/>
    
    <category term="多主机" scheme="https://www.mahaofei.com/tags/%E5%A4%9A%E4%B8%BB%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Windows与Ubuntu双系统绑定同一个蓝牙设备（无需重新配对）</title>
    <link href="https://www.mahaofei.com/post/e0777253.html"/>
    <id>https://www.mahaofei.com/post/e0777253.html</id>
    <published>2023-12-13T13:25:52.000Z</published>
    <updated>2023-12-13T13:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1、Ubuntu 下配对蓝牙设备</h1><p>会生成一个配置文件。</p><h1>2、Windows 下再配对蓝牙设备</h1><p>读取蓝牙配对信息，Windows下的蓝牙配对信息存储在注册表中，并且此信息需要使用特殊方法才能查看。</p><p>下载 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">PsTools</a>，将PSTools.zip 中的 PsExec.exe 或 PsExec64.exe 解压出来，并以管理员权限运行 cmd，<code>cd</code> 到<code>PsExec64.exe</code> 所在目录，使用下面的命令启动regedit.exe</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec64.exe -si regedit</span><br></pre></td></tr></table></figure><p>找到下面的蓝牙配对信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTHPORT\Parameters\Keys\【本机蓝牙 MAC】</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312132218479.png" alt="image.png"></p><p>可以看到其中有类型为<code>REG_BINARY</code>的值，每个值对应一个设备，将其名称和数据记下来，或者直接导出，我导出后用记事本打开如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTHPORT\Parameters\Keys\d4d853556b34]</span><br><span class="line">&quot;CentralIRK&quot;=hex:38,a5,32,96,6c,bf,c2,31,7b,e9,43,e0,b9,cc,9d,d6</span><br><span class="line">&quot;6468761a6934&quot;=hex:6b,bf,d8,14,d8,aa,2f,d8,f7,68,73,a7,83,64,6e,8f</span><br></pre></td></tr></table></figure><blockquote><p>此外如果是罗技设备，例如本人的罗技鼠标，则需要<strong>导出</strong> <code>【本机蓝牙 MAC】</code> 下的子项，项名称为罗技鼠标的 MAC 地址，项中的各个值则是需要填写到 Ubunut 中的内容<br><img src="https://img.mahaofei.com/img/202401261931186.png" alt="image.png"></p></blockquote><h1>3、修改Linux下的蓝牙配对信息</h1><h2 id="3-1-一般设备">3.1 一般设备</h2><p>Linux 下蓝牙设备的配对信息存储在 <code>/var/lib/bluetooth/【本机蓝牙 MAC】</code>目录下，例如 <code>/var/lib/bluetooth/D4:D8:53:55:6B:34</code>，MAC 地址中的字母全为大写，且含冒号分隔符。</p><p>进入该目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd /var/lib/bluetooth/D4\:D8\:53\:55\:6B\:34/</span><br></pre></td></tr></table></figure><p>可以看到系统已配对的蓝牙设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Victus-Ubuntu:/var/lib/bluetooth/D4:D8:53:55:6B:34# ll</span><br><span class="line">total 44</span><br><span class="line">drwx------ 7 root root  4096 12月 13 22:19 ./</span><br><span class="line">drwxr-xr-x 3 root root  4096 5月  13  2023 ../</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:19 64:68:76:1A:69:34/</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:19 A4:C1:38:AB:43:5C/</span><br><span class="line">drwx------ 2 root root 16384 12月 13 22:20 cache/</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:19 EC:B3:D5:3C:5F:92/</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:20 F9:E7:70:AD:8C:64/</span><br><span class="line">-rw------- 1 root root    50 12月 13 22:19 settings</span><br></pre></td></tr></table></figure><p>根据我们导出的reg文件，可以知道进入我们要配置的蓝牙鼠标的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 64\:68\:76\:1A\:69\:34/</span><br></pre></td></tr></table></figure><p>我们需要修改的就是这个目录下的 info 文件，以我的为例，文件如下（这里已经改好了，只需要将Key换成windows下导出的注册表里面的key，具体就是win下的逗号删除小写变大写）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">Name=EDIFIER W820NB 双金标版</span><br><span class="line">Class=0x240404</span><br><span class="line">SupportedTechnologies=BR/EDR;</span><br><span class="line">Trusted=true</span><br><span class="line">Blocked=false</span><br><span class="line">Services=00001101-0000-1000-8000-00805f9b34fb;0000110b-0000-1000-8000-00805f9b34fb;0000110c-0000-1000-8000-00805f9b34fb;0000110d-0000-1000-8000-00805f9b34fb;0000110e-0000-1000-8000-00805f9b34fb;0000111e-0000-1000-8000-00805f9b34fb;66666666-6666-6666-6666-666666666666;edf00000-edfe-dfed-fedf-edfedfedfedf;</span><br><span class="line"></span><br><span class="line">[LinkKey]</span><br><span class="line">Key=6BBFD814D8AA2FD8F76873A783646E8F</span><br><span class="line">Type=4</span><br><span class="line">PINLength=0</span><br></pre></td></tr></table></figure><h2 id="3-2-罗技设备">3.2 罗技设备</h2><p>将 Windows 下的 IRK 字符<strong>倒序大写删除逗号</strong>，即为 Ubuntu 下的 IdentityResolvingKey</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;IRK&quot;=hex:d3,1f,03,20,e5,be,13,64,33,8b,63,09,d3,01,bd,33</span><br><span class="line"></span><br><span class="line">[IdentityResolvingKey]</span><br><span class="line">Key=33BD01D309638B6413BEE520031FD3</span><br></pre></td></tr></table></figure><p>Windows 下的 <strong>LTK</strong> <strong>大写删除逗号</strong>，即为 Ubuntu 下的 <strong>LontermKey</strong><br><strong>EDIV</strong> 需要<strong>转换成 10 进制</strong>，为 Ubuntu 的 <strong>EDiv</strong><br><strong>ERand</strong> 需要<strong>删除逗号并转换成 10 进制</strong>，为 Ubuntu 的 <strong>Rand</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;LTK&quot;=hex:ae,4b,59,52,fa,32,7d,2b,aa,0a,a7,de,33,ac,2b,20</span><br><span class="line">&quot;ERand&quot;=hex(b):cd,d7,f7,f8,01,f9,49,f2</span><br><span class="line">&quot;EDIV&quot;=dword:00006f5f</span><br><span class="line"></span><br><span class="line">[LongTermKey]</span><br><span class="line">Key=AE4B5952FA327D2BAA0AA7DE33AC20</span><br><span class="line">Authenticated=0</span><br><span class="line">EncSize=16</span><br><span class="line">EDiv=28511</span><br><span class="line">Rand=14832596542325082602</span><br></pre></td></tr></table></figure><p>然后重启电脑，可以直接连接蓝牙。</p>]]></content>
    
    
    <summary type="html">本人安装了Ubuntu与Windows双系统，平时使用蓝牙鼠标与耳机，但是每次切换系统都需要重新配对设备，因此想要实现双系统配对。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Ubuntu工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Ubuntu%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Ubuntu" scheme="https://www.mahaofei.com/tags/Ubuntu/"/>
    
    <category term="双系统" scheme="https://www.mahaofei.com/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Windows" scheme="https://www.mahaofei.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】机器人动作、轨迹、过程模仿</title>
    <link href="https://www.mahaofei.com/post/5e168247.html"/>
    <id>https://www.mahaofei.com/post/5e168247.html</id>
    <published>2023-12-12T07:36:37.000Z</published>
    <updated>2024-01-04T08:05:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 AW-Opt: Learning Robotic Skills with Imitation and Reinforcement at Scale</h1><blockquote><p><strong>标题</strong>：AW-Opt：通过大规模模仿和强化学习机器人技能<br><strong>作者团队</strong>：Google<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://awopt.github.io/">https://awopt.github.io/</a></p></blockquote><h2 id="1-1-目标问题-8">1.1 目标问题</h2><p>强化学习可以实现目标任务，但是需要大量自主数据收集。模仿学习只能学习和演示一样程度的动作。</p><p>本文探索如何最好的结合两种方法，并进行扩展。实现大规模机器人学习。</p><h2 id="1-2-方法-8">1.2 方法</h2><p><strong>（1）任务场景与基础算法</strong></p><p>本文以基于视觉的垃圾分类任务为例，机器人从不同对象类型（可回收物、不可回收对象）等垃圾箱中拾取特定类型的对象。</p><p>本文的算法为了研究IL+RL的扩展性，在QT-Opt和AWAC两种IL+RL算法的基础上进行研究。</p><p><strong>（2）正样本过滤</strong></p><p>两种基础算法性能不够好的原因可能有以下两点：</p><ul><li>探索过程中增加了大量的失败事件、掩盖了最初的成功演示</li><li>算法在学习有效的Q函数，对actor进行更新之前，会删除预训练初始化。</li></ul><p>为了解决这个问题，本文进行了以下两个修改：</p><ul><li>为critic使用优先缓冲区，其中一半来自于成功事件奖励</li><li>对actor使用正向过滤，仅对通过过滤器的样本进行更新</li></ul><p><strong>（3）混合 actor-critic 探索</strong></p><p>QT-Opt方法没有明确的actor，由于任务使用交叉熵利用critic来优化动作，因此可以视为隐式策略。</p><p>AWAC是一种actor-critic算法，通过对actor的动作采样来实现，而这种方式在训练初期，主要是critic进行学习，来确定哪些动作是好的。这种方式对于复杂的任务学习存在限制。</p><p>本文为了解决以上问题，结合两种算法，并比较了四种策略：仅actor探索、隐式critic策略、episode级随机切换策略（80%critic策略、20%actor）、step级随机切换策略、</p><h1>2 DexMV: Imitation Learning for Dexterous Manipulation from Human Videos</h1><blockquote><p><strong>标题</strong>：DexMV：模仿学习，从人类视频中进行灵巧操作<br><strong>作者团队</strong>：University of California San Diego<br><strong>期刊会议</strong>：ECCV<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/yzqin/dexmv-sim">https://github.com/yzqin/dexmv-sim</a></p></blockquote><h2 id="2-1-目标问题-4">2.1 目标问题</h2><p>由于多指机器人拥有高自由度关节、非线性驱动，因此需要大量的强化学习训练数据，而机器人数据收集困难，且仅使用仿真数据训练机器人运动也很不自然，能否利用人类与真实世界的交互经验来引导机器人？</p><h2 id="2-2-方法-4">2.2 方法</h2><p>设计了一个基于模仿学习的平台</p><ul><li>多指机器人复杂灵巧操作的模拟系统</li><li>记录人手执行相同任务的大规模演示（从视频中提取手部3D位置和物体姿态）</li><li>演示翻译方法：将人体动作转换为机器人演示</li></ul><p><img src="https://img.mahaofei.com/img/202312131522496.png" alt="image.png"></p><h3 id="2-2-1-姿态估计">2.2.1 姿态估计</h3><p><strong>物体位姿估计</strong>：使用在YCB数据集上训练的PVN3D实现物体6D位姿的估计。</p><p><strong>人手姿态估计</strong>：使用MANO模型表示人手关节，进行手部检测和实例分割，利用现有的模型估计手部关节。</p><h3 id="2-2-2-演示数据转换">2.2.2 演示数据转换</h3><p>常见的模仿学习算法使用==机器人状态和动作==作为训练数据，而不是人手姿态。并且人手和灵巧手的运动学模型也不同。</p><p><strong>（1）手部运动重定向</strong></p><p>给定视频中估计的人手姿态序列，将其重定向为机器人关节角度序列。改过程可视为优化问题。</p><p>在大多数操作任务中，人类和机器人都是指尖接触物体，因此保留手掌根的指尖的空间向量。</p><p>但是这样可能会导致手指弯曲信息丢失，导致手指穿透物体，因此考虑同时优化手掌根到中指骨的向量。</p><p><strong>（2）机器人动作估计</strong></p><p>手部运动重定向提供了手部姿态到机器人关节角度的转换，但是关节扭矩是位置的，因此通过逆动力学函数，将关节角度拟合到连续的关节轨迹函数中，计算扭矩。在这个过程中，需要保证q’‘’(t)加加速度尽可能小。</p><p><strong>（3）时间对齐</strong></p><p>录制的视频帧率为30Hz，模拟运行的频率为120Hz，因此在训练之前，需要进行时间对齐，以模拟频率对机器人动作q(t)进行采样。</p><h3 id="2-2-3-模仿学习">2.2.3 模仿学习</h3><p>本文使用转换后的演示进行模仿学习，不使用行为克隆方法，而是使用模仿学习算法，并将演示合并到强化学习中。</p><p>本文考虑使用 $&lt;S, A, P, R, \gamma&gt;$ 的马尔科夫决策链，其中：</p><ul><li>$S$: 状态空间</li><li>$A$: 动作空间</li><li>$P(s_{t+1}|s_t, a_t)$: 是状态转移函数，在$t+1$步，给定动作$a_t$时，下一个状态$s_{t+1}$的概率密度</li><li>$R(S, a)$: 奖励函数</li><li>$\gamma$: 折扣因子</li></ul><p>强化学习的目的是最大化策略$\pi(a|s)$下的预期奖励。给定演示轨迹${(s_i, a_i)}^n_{i=1}$，使用该轨迹和奖励，优化策略$\pi$。</p><p>本文使用<strong>生成对抗模仿学习GAIL</strong>，这是一种使用state-action动作密度匹配来学习策列的SOTA IL方法。通过最大限度的减小演示和动作的距离函数，实现动作模仿。</p><p>本文使用<strong>演示增强策略梯度</strong>进行强化学习。</p><h2 id="2-3-总结">2.3 总结</h2><ol><li>将真实世界人手姿态转换为机器人动作，加上物体位姿估计，作为演示数据用于后续模仿学习与强化学习。</li><li>使用生成对抗模仿学习GAIL</li><li>使用演示增强策略梯度进行强化学习</li></ol><h1>3 Learning and Retrieval from Prior Data for Skill-based Imitation Learning</h1><blockquote><p><strong>标题</strong>：基于技能的模仿学习的先验数据的学习和检索<br><strong>作者团队</strong>：The University of Texas at Austin<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://ut-austin-rpl.github.io/sailor">https://ut-austin-rpl.github.io/sailor</a></p></blockquote><h2 id="3-1-目标问题-3">3.1 目标问题</h2><p>模仿学习由于需要进行监督学习和较弱的泛化能力，因此可扩展性有限。</p><p>本文研究如何使用其他任务的先验数据，来稳定高效地学习新任务。</p><h2 id="3-2-方法-3">3.2 方法</h2><p>本文提出了一种基于技能的模仿学习框架，从先前的数据中提取运动技能，并随后调用这些学到的技能的目标函数策略。</p><p><strong>（1）学习可预测的技能表示</strong></p><p>通过使用变分自动编码器VAE编码小段轨迹来学习技能表示。为了提高技能的可预测性，将小段轨迹使用LSTM编码器编码为潜在技能的高斯分布，解码器也是一个LSTM网络。</p><p>对于每个时间步，将潜在特征z和给定的观察o，解码为动作a。</p><p><strong>（2）基于检索的策略学习</strong></p><p>为了提高任务策略的学习效果，从先前的数据集中检索与目标任务相关的数据。</p><p>策略学习阶段，使用LSTM策略通过观察历史的潜在技能，预测输出接下来要执行的技能z，这种方式可以利用丰富多样的先验交互知识，将其融入到策略中，从而在新环境中更有效的执行任务。</p><h2 id="3-3-总结">3.3 总结</h2><p>使用变分自动编码器VAE处理子轨迹，形成一致的潜在技能表示。</p><p>使用LSTM编码解码技能表示，根据状态预测需要输出的技能。</p><h1>4 VIOLA: Imitation Learning for Vision-Based Manipulation with Object Proposal Priors</h1><blockquote><p><strong>标题</strong>：VIOLA：使用对象提议先验进行基于视觉的操作的模仿学习<br><strong>作者团队</strong>：The University of Texas at Austin<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://ut-austin-rpl.github.io/VIOLA">https://ut-austin-rpl.github.io/VIOLA</a></p></blockquote><h2 id="4-1-目标问题-2">4.1 目标问题</h2><p>一种先进的模仿学习算法。</p><h2 id="4-2-方法-3">4.2 方法</h2><p>本文实现了一种基于视觉的机器人操作任务模仿学习算法：</p><ul><li>使用预训练的视觉模型生成通用的对象表示；</li><li>采用基于Transformer的策略，来推理这些表示，根据视觉预测动作；</li></ul><p><strong>（1）构建面向对象的表示</strong></p><ol><li>对象识别：使用预训练的RPN区域建议网络在工作空间图像上生成对象建议，并选择执行度最高的前K个建议。</li><li>对象特征表示：包含区域特征和上下文特征<ol><li>区域特征：为每个建议区域设计视觉特征和位置特征，使用ROI Align从工作空间图像的ResNet18编码的特征途中提取特征；</li><li>上下文特征，包括全局特征、手眼相机图像特征和机器人状态的本体感知特征组成；</li></ol></li><li>时间组合，将过去H+1步的特征和时间编码组合，构成面向对象的表示，来获得对象状态的时间依赖性和动态变化。</li></ol><p><strong>（2）基于Transformer的策略</strong></p><p>使用多个Transformer编码器，处理一系列特征向量。</p><p>该策略网络将面向对象的区域特征和上下文特征作为输入token，并加入了一个动作token，通过动作监督学习，能够关注任务相关的区域。</p><p>最后利用两层全连接层和高斯混合模型输出动作。</p><h2 id="4-3-总结">4.3 总结</h2><ol><li>构建面向对象的特征（图像区域特征+机器人状态特征）</li><li>使用Transformer进行特征编码与预测</li><li>使用高斯混合模型输出动作。</li></ol><h1>5 SEIL: Simulation-augmented Equivariant Imitation Learning</h1><blockquote><p><strong>标题</strong>：SEIL: Simulation-augmented Equivariant Imitation Learning<br><strong>作者团队</strong>：Northeastern University<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://saulbatman.github.io/project/seil/">https://saulbatman.github.io/project/seil/</a></p></blockquote><h2 id="5-1-目标问题-3">5.1 目标问题</h2><p>机器人模仿学习中，样本获取非常困难，因为需要与现实世界进行交互。为了解决这个问题，本文在图像数据增强的基础上进行模仿学习。</p><h2 id="5-2-方法-2">5.2 方法</h2><p><strong>（1）数据增强</strong></p><p>本文实现了一种专家数据增强方法Transition Simulation。通过将观察到的点云投影到模拟的机械臂姿态中，生成新的观察图像，从而模拟专家的state-action来增加数据多样性。</p><p><strong>（2）等变行为克隆</strong></p><p>利用机器人操作过程中的O(2)对称性（所有平面旋转和反射对称性），利用Steerable CNNs将策略自动泛化到不同的O(2)状态中。</p><h2 id="5-3-总结-2">5.3 总结</h2><p>专家数据增强+等变行为克隆</p><h1>6 Waypoint-Based Imitation Learning for Robotic Manipulation</h1><blockquote><p><strong>标题</strong>：基于路标点的机器人操作模仿学习<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/lucys0/awe">https://github.com/lucys0/awe</a></p></blockquote><h2 id="6-1-目标问题-3">6.1 目标问题</h2><p>模仿学习容易出现错误，特别是在执行复杂操作时。</p><p>使用路标点可以减少模仿学习中的错误，但是一般路标点需要认为监督，本文则是提出了一种自动生成路标点的方法。提高了模仿学习的成功率。</p><h2 id="6-2-方法-3">6.2 方法</h2><p>本文设计了一种自动路标点提取方法，这是一个预处理模块，因此很容易添加到其它行为克隆算法中。本文举例了两种先进的模仿学习算法：扩散策略和基于Transformer的动作。</p><p><strong>（1）重建损失</strong></p><p>定义了一种损失：给定路标点后重建轨迹的质量，通过最小化原始轨迹与根据路标点重建的轨迹之间的偏差，来使得路标点能尽可能代替真实轨迹。</p><p><strong>（2）路径点选择动态规划</strong></p><p>使用一种简单而动态规划算法，用于选择最小数量的路径点，并保证重建的误差满足要求。</p><h2 id="6-3-总结">6.3 总结</h2><p>一种自动路标点提取算法，用于对行为克隆数据进行预处理。</p><h1>7 Mobile ALOHA: Learning Bimanual Mobile Manipulation with Low-Cost Whole-Body Teleoperation</h1><blockquote><p><strong>标题</strong>：Mobile ALOHA：通过低成本全身远程操作学习双手移动操作<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：无<br><strong>时间</strong>：2024<br><strong>代码</strong>：<a href="https://mobile-aloha.github.io/">https://mobile-aloha.github.io/</a></p></blockquote><h2 id="7-1-目标问题-3">7.1 目标问题</h2><p>目前的大多数从人类演示中模仿学习的机器人技术集中在桌面操作，缺乏一般有用的任务所需的机动性和灵活性，本文主要是开发了一个移动机器人，实现移动+双手的模仿学习。</p><h2 id="7-2-论文中提到的学习方法">7.2 论文中提到的学习方法</h2><p><strong>（0）基础模仿学习算法</strong></p><ol><li>ACT: Learning fine-grained bimanual manipulation with low-cost hardware</li><li>扩散策略: Diffusion policy: Visuomotor policy learning via action diffusion</li><li>VINN: The surprising effectiveness of representation learning for visual imitation</li></ol><p><strong>（1）BC 的改进</strong></p><p>行为克隆 BC 与各种架构相结合</p><ol><li>Rt-1: Robotics transformer for real-world control at scale</li><li>Bc-z: Zero-shot task generalization with robotic imitation learning</li><li>What matters in learning from offline human demonstrations for robot manipulation</li><li>Behavior transformers: Cloning k modes with one stone</li></ol><p>使用新的训练目标</p><ol><li>Roboagent: Towards sample efficient robot manipulation with semantic augmentations and action chunking</li><li>Diffusion policy: Visuomotor policy learning via action diffusion</li><li>Implicit behavioral cloning</li><li>The surprising effectiveness of representation learning for visual imitation</li><li>Learning fine-grained bimanual manipulation with low-cost hardware</li></ol><p>正则化</p><ol><li>Vision-based multi-task manipulation for inexpensive robots using end-to-end learning from demonstration</li></ol><p>Motor Primitives</p><ol><li>Hierarchical neural dynamic policies</li><li>Dynamical movement primitives: learning attractor models for motor behaviors</li><li>Learning motor primitives for robotics</li><li>Using probabilistic movement primitives in robotics</li><li>Learning and generalization of motor skills by learning from demonstration</li><li>Learning periodic tasks from human demonstrations</li></ol><p>数据预处理</p><ol><li>Waypoint-based imitation learning for robotic manipulation</li></ol><p><strong>（2）多任务或少镜头模仿学习</strong></p><ol><li>Transformers for one-shot visual imitation</li><li>One-shot imitation learning</li><li>Learning manipulation skills from a single demonstration</li><li>One-shot visual imitation learning via meta-learning</li><li>Task-embedded control networks for few-shot imitation learning</li><li>Coarse-to-fine imitation learning: Robot manipulation from a single demonstration</li><li>Demonstrate once, imitate immediately (dome): Learning visual servoing for one-shot imitation learning</li><li>One-shot imitation from observing humans via domain-adaptive metalearning</li></ol><p><strong>（3）语言条件的模仿学习</strong></p><ol><li>Rt-1: Robotics transformer for real-world control at scale</li><li>Bc-z: Zero-shot task generalization with robotic imitation learning</li><li>Cliport: What and where pathways for robotic manipulation</li><li>Perceiver-actor: A multi-task transformer for robotic manipulation</li></ol><p><strong>（4）从演示数据模仿</strong></p><ol><li>From play to policy: Conditional behavior generation from uncurated robot data</li><li>Learning latent plans from play</li><li>Latent plans for task-agnostic offline reinforcement learning</li><li>Mimicplay: Longhorizon imitation learning by watching human play</li></ol><p><strong>（5）使用人类视频模仿</strong></p><ol><li>Learning generalizable robotic reward functions from&quot; in-the-wild&quot; human videos</li><li>Model-based inverse reinforcement learning from visual demonstrations</li><li>Perceptual values from observation</li><li>R3m: A universal visual representation for robot manipulation</li><li>Real-world robot learning with masked visual pre-training</li><li>Concept2robot: Learning manipulation concepts from instructions and human demonstrations</li><li>Avid: Learning multi-stage tasks via pixel-level translation of human videos</li><li>Learning by watching: Physical imitation of manipulation skills from human videos</li></ol><p><strong>（6）针对特定任务的模仿学习</strong></p><ol><li>Coarse-to-fine imitation learning: Robot manipulation from a single demonstration</li><li>Perceiver-actor: A multi-task transformer for robotic manipulation</li><li>Transporter networks: Rearranging the visual world for robotic manipulation</li></ol><p><strong>（7）针对模仿学习的通用化用于新的场景或对象</strong></p><ol><li>Rt-1: Robotics transformer for real-world control at scale</li><li>Rt-2: Vision-language-action models transfer web knowledge to robotic control</li><li>Bridge data: Boosting generalization of robotic skills with cross-domain datasets</li><li>Bc-z: Zero-shot task generalization with robotic imitation learning</li><li>Robot peels banana with goalconditioned dual-action deep imitation learning</li></ol><p><strong>（8）从不同但类似的机器人上收集数据模仿</strong></p><ol><li>Robocat: A self-improving foundation agent for robotic manipulation</li><li>Open X-Embodiment: Robotic learning datasets and RT-X models</li><li>In Towards Generalist Robots: Learning Paradigms for Scalable Skill Acquisition</li><li>Octo: An open-source generalist robot policy</li></ol><h2 id="7-3-总结">7.3 总结</h2>]]></content>
    
    
    <summary type="html">基于传统的强化学习方法大多实现某项任务，而无法实现动作的模仿，调研相关论文实现机器人动作轨迹的模仿。</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人动作" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A8%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【实验准备】MuJoCo导入自定义机器人</title>
    <link href="https://www.mahaofei.com/post/f67206dd.html"/>
    <id>https://www.mahaofei.com/post/f67206dd.html</id>
    <published>2023-12-04T01:59:28.000Z</published>
    <updated>2023-12-04T01:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本实验所配置的模型已开源至 <a href="https://github.com/HaofeiMa/E05_Robotiq-2f-85">Github: HaofeiMa/E05_Robotiq-2f-85</a></p></blockquote><h1>1 模型准备</h1><h2 id="1-1-机器人Solidworks模型转URDF">1.1 机器人Solidworks模型转URDF</h2><p>本仿真实验使用<a href="https://www.hansrobot.com/service/download/3dmoxing?pagenum=3">大族E05机器人</a>和<a href="https://robotiq.com/products/2f85-140-adaptive-robot-gripper">Robotiq 2f-85夹爪</a></p><p>该部分参考<a href="https://www.bilibili.com/video/BV1Tx411o7rH">以下视频</a></p><iframe src="http://player.bilibili.com/player.html?aid=56651666&bvid=BV1Tx411o7rH&cid=98972250&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="height:100%;width:100%; aspect-ratio: 16 / 9;"> </iframe><p>首先下载机器人模型，并转换为URDF。</p><p><strong>（1）安装sw_urdf_exporter插件</strong></p><p>下载sw_urdf_exporter插件：<a href="http://wiki.ros.org/sw_urdf_exporter">http://wiki.ros.org/sw_urdf_exporter</a>，注意下载最新的就行，最新的也支持以前版本的Solidworks。</p><p>关闭 Solidworks。</p><p>运行 <a href="https://github.com/ros/solidworks_urdf_exporter/releases">sw2urdfSetup.exe</a>，自行安装即可。</p><p><strong>（2）为机器人添加基准轴（旋转轴）</strong></p><p><img src="https://img.mahaofei.com/img/202312041343070.png" alt="image.png"></p><p>以此选择六个圆柱面，确定六个旋转轴方向。</p><p><img src="https://img.mahaofei.com/img/202312041401387.png" alt="image.png"></p><p><strong>（3）导出URDF</strong></p><p>查看是否有【工具-最下面File-Export as URDF】，如果有的话，直接点击打开，如果没有，则打开【工具-插件】，在最下面打开Sw2URDF插件的两个√。</p><p>按照以下过程，创建base_link和link1-6</p><p><img src="https://img.mahaofei.com/img/202312041434677.png" alt="image.png"></p><p>然后点击Preview and Export</p><p><img src="https://img.mahaofei.com/img/202312041439265.png" alt="image.png"></p><p>然后点击Next和Export URDF and Mesh，它会将我们的URDF模型以功能包的形式保存到设置的位置。</p><p><strong>注意创建完成后，一定要检查最后一个坐标系是否是在机器人末端连接法兰的中心，因为后续添加夹爪需要这个坐标系，如果不是，需要自己手动调整坐标系的位置，重新生成URDF</strong></p><h2 id="1-2-ROS-中查看模型">1.2 ROS 中查看模型</h2><blockquote><p>不需要使用 Gazebo 的可直接跳到第 2 节（2 模型导入 Mujoco）</p></blockquote><p>创建一个工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p catkin_robot/src</span><br><span class="line">cd catkin_robot/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p>将功能包复制到<code>src</code>目录下</p><p>回到 <code>catkin_robot</code> 目录下，编译工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行测试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05 display.launch</span><br></pre></td></tr></table></figure><p>将 <code>Fixed Frame</code> 改为 <code>base_link</code>，点击左下角的 <code>Add</code>，添加一个 <code>Robot Model</code>，可以看到机器人正常显示在 Rviz 界面中，拖动进度条即可控制机械臂各关节运动。</p><p><img src="https://img.mahaofei.com/img/202312041606763.png" alt="image.png"></p><h2 id="1-3-添加-Robotiq-2f-85-夹爪">1.3 添加 Robotiq 2f-85 夹爪</h2><p><strong>（1）准备夹爪环境</strong></p><p>进入工作空间的src目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">git clone https://github.com/ros-industrial/robotiq.git</span><br></pre></td></tr></table></figure><p>在自己的机械臂的功能包的urdf文件夹中，新建一个<code>common.gazebo.xacro</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src/e05/urdf</span><br><span class="line">gedit common.gazebo.xacro</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;ros_control&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_control.so&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了方便表示，我在<code>e05.urdf</code>最后添加了一个<code>ee_link</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;ee_link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- You can use any simple geometry like a sphere for visualization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- Choose a color for visualization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;ee_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;ee_link&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再新建一个<code>xacro</code>文件，（例如我的机械臂功能包名字为e05）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit e05.xacro</span><br></pre></td></tr></table></figure><p>添加如下内容，注意修改<code>Gazebo支持</code>和<code>E05机械臂</code>部分自己的机械臂功能包名称，以及<code>夹爪与机械臂连接</code>部分的第一行的parent，我这里连接在了link6也就是末端上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;e05&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">&quot;transmission_hw_interface&quot;</span> <span class="attr">default</span>=<span class="string">&quot;hardware_interface/PositionJointInterface&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- E05机械臂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find e05)/urdf/e05.urdf&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Gazebo 支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find e05)/urdf/common.gazebo.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载gazebo中需要使用的模型 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- macros for transmission --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;transmission_block&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;motor1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Transmissions for ros control --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint6&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find e05)/urdf/e05.gazebo.xacro&quot; /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 机器人固定在世界坐标系下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;world_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;world&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span> = <span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Robotiq 2F-85夹爪 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find robotiq_2f_85_gripper_visualization)/urdf/robotiq_arg2f_85_macro.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find robotiq_85_description)/urdf/robotiq_85_gripper.urdf.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_grasp_fix&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_grasp_fix.so&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arm</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;arm_name&gt;应该是一个单独的名字，不能和别的任何关节同名 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arm_name</span>&gt;</span>ur5_gripper<span class="tag">&lt;/<span class="name">arm_name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;palm_link&gt;是和手指相连的关节 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">palm_link</span>&gt;</span>link6<span class="tag">&lt;/<span class="name">palm_link</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;gripper_link&gt;是会检测碰撞的关节 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_finger_tip_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_finger_tip_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_inner_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_inner_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">arm</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">forces_angle_tolerance</span>&gt;</span>150<span class="tag">&lt;/<span class="name">forces_angle_tolerance</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 检测频率 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>130<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 检测为抓取状态的接触次数阈值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">grip_count_threshold</span>&gt;</span>2<span class="tag">&lt;/<span class="name">grip_count_threshold</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_grip_count</span>&gt;</span>8<span class="tag">&lt;/<span class="name">max_grip_count</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 释放时的容忍度，超过这个就会把物体放下。数值越大，需要把夹爪打开更大才能释放物体 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">release_tolerance</span>&gt;</span>0.005<span class="tag">&lt;/<span class="name">release_tolerance</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">disable_collisions_on_attach</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disable_collisions_on_attach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contact_topic</span>&gt;</span>__default_topic__<span class="tag">&lt;/<span class="name">contact_topic</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将夹爪实例化，并设置夹爪和机械臂的关系（连接在tool0上） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:robotiq_85_gripper</span> <span class="attr">prefix</span>=<span class="string">&quot;&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;ee_link&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 $&#123;-pi/2&#125; 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:robotiq_85_gripper</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 相机实例化，然后设置仿真位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find realsense_ros_gazebo)/xacro/depthcam.xacro&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;xacro:realsense_d435 sensor_name=&quot;d435&quot; parent_link=&quot;tool0&quot; rate=&quot;10&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;origin rpy=&quot;0 $&#123;-pi/2&#125; 0 &quot; xyz=&quot;-0.1 0 0&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/xacro:realsense_d435&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改原来的launch文件，这里我为了后续方便，将原来的<code>display.launch</code>重命名了<code>display_e05_with_gripper.launch</code>，这里主要修改<code>&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro '$(find e05)/urdf/e05.xacro'&quot; /&gt;  </code>这一行，添加刚刚创建的xacro文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find e05)/urdf/e05.xacro&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro &#x27;$(find e05)/urdf/e05.xacro&#x27;&quot;</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find e05)/urdf.rviz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）Rviz中查看机器人</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_motion</span><br><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05 display_e05_with_gripper.launch</span><br></pre></td></tr></table></figure><p>左下角Add，添加机器人模型RobotModel。</p><p>左侧Fixed Frame选择base_link，即可看到机器人了。</p><p><img src="https://img.mahaofei.com/img/202312051357909.png" alt="image.png"></p><p><strong>（3）Gazebo中查看机器人</strong></p><p>创建一个<code>gazebo_e05_with_gripper.launch</code>文件，内容参考如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span> <span class="attr">doc</span>=<span class="string">&quot;Starts gazebo gui&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span> <span class="attr">doc</span>=<span class="string">&quot;Starts gazebo in paused mode&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 启动仿真环境 后续有环境修改，可以替换此处的worlds/empty.world，改为例如&quot;$(find ur_gazebo)/worlds/table_custom.world&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.world&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载TF --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;tf_footprint_base&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0 base_link base_footprint 40&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 启动机器人 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find e05)/launch/display_e05_with_gripper.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将 robot_description 发送到 gazebo 中生成机器人 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;node name=&quot;spawn_model&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; args=&quot;-file $(find e05)/urdf/e05.urdf -urdf -model e05&quot; output=&quot;screen&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;spawn_gazebo_model&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -param robot_description -model robot -z 0&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;fake_joint_calibration&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rostopic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rostopic&quot;</span> <span class="attr">args</span>=<span class="string">&quot;pub /calibrated std_msgs/Bool true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时启动<code>launch</code>文件，可以看到gazebo环境中机器人。</p><p><img src="https://img.mahaofei.com/img/202312051949512.png" alt="image.png"></p><hr><p><strong>下面的创建moveit驱动，在mujoco中不需要，请直接跳到 2 模型导入mujoco</strong></p><h2 id="1-4-创建MoveIt驱动">1.4 创建MoveIt驱动</h2><p>此部分参考<a href="https://blog.csdn.net/Tepmoe/article/details/119533792">该文章</a>。</p><p>启动moveit设置助手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun moveit_setup_assistant moveit_setup_assistant</span><br></pre></td></tr></table></figure><p>选择Create New Moveit Configuration Package，选择自己的<code>e05.xacro</code>文件，点击<code>Load Files</code></p><p><img src="https://img.mahaofei.com/img/202312051459862.png" alt="image.png"></p><p>左侧第二个的<code>Self-Collisions</code>是检查碰撞，一定将所有有可能发生碰撞的都勾选上，不然后续会出错。</p><p><img src="https://img.mahaofei.com/img/202312051948359.png" alt="image.png"></p><p>第三个<code>Virtual Joints</code>一般也不需要。</p><p>第四个<code>Planning Groups</code>是最重要的，我们需要设置，点击<code>Add Group</code>，分别配置机器人和末端夹爪。</p><p>机械臂：</p><ul><li>Group Name一般填manipulator就行</li><li>运动学求解器，选择kdl</li><li>路径规划算法，默认选择RRT Star就行</li><li>点击<code>Add Kin. Chain</code>，Baselink选择 base_link，Tiplink选择ee_link</li></ul><p><img src="https://img.mahaofei.com/img/202312051507765.png" alt="image.png"></p><p>末端夹爪的Group Name填上gripper，其它的都不用选。</p><p>第五个<code>Robot Poses</code>可以添加一些常用位置，便于我们快速使机器人运动到这些位置，例如</p><ul><li>up：机器人初始的竖直向上</li><li>pick：机器人准备夹取</li><li>open：夹爪打开</li><li>close：夹爪关闭</li></ul><p><img src="https://img.mahaofei.com/img/202312051513180.png" alt="image.png"></p><p>第六个<code>End Effectors</code>，按下图设置就行</p><p><img src="https://img.mahaofei.com/img/202312051533929.png" alt="image.png"></p><p>点击<code>Controllers</code>，点击左上角自动生成</p><p><img src="https://img.mahaofei.com/img/202312051534681.png" alt="image.png"></p><p>点击倒数第二个<code>Author Information</code>，填写名字和邮箱，不一定是真实的，但是不填无法生成功能包</p><p>最后<code>Generate Package</code>就可以了（在src目录下新建一个<code>e05_moveit</code>文件夹，选择此文件夹生成）</p><p>测试rviz是否能控制机器人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05_moveit demo.launch</span><br></pre></td></tr></table></figure><p>测试gazebo是否能联动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch e05_moveit demo_gazebo.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312052212812.png" alt="image.png"></p><p>测试时遇到了<strong>Rviz中的机械臂可以正常做规划和执行，但是Gazebo中机械臂没有反应</strong>的问题，解决方法参考<a href="https://blog.csdn.net/qq_50598558/article/details/114702163">此文章</a></p><h1>2 模型导入Mujoco</h1><h2 id="2-1-修改URDF">2.1 修改URDF</h2><p>在现有模型的xacro或urdf中的开头，添加下面的tag</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mujoco</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">compiler</span> </span></span><br><span class="line"><span class="tag"><span class="attr">meshdir</span>=<span class="string">&quot;../meshes_mujoco/&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">balanceinertia</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">discardvisual</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mujoco</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个文件夹<code>e05/meshes_mujoco</code>，将所有模型的stl文件放到这个文件夹下。</p><p>从xacro文件生成urdf文件的命令（如果有urdf文件则不需要此步）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro --inorder e05.xacro &gt; e05.urdf</span><br></pre></td></tr></table></figure><p>检查urdf文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf e05.urdf</span><br></pre></td></tr></table></figure><p>在RViz中可视化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch e05 display.launch model:=path/to/your/urdf/file</span><br></pre></td></tr></table></figure><h2 id="2-2-生成基本模型">2.2 生成基本模型</h2><p>在确认URDF模型没有问题后，进入MuJoCo的可执行文件夹内执行命令进行转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.mujoco/mujoco210/bin</span><br></pre></td></tr></table></figure><p>官方说明可以转换成三种模型<code>.mjb/.txt/.xml</code>，我们一般用xml的格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile /path/to/model.urdf /path/to/model.xml</span><br></pre></td></tr></table></figure><p>测试生成的基本模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./simulate /path/to/model.xml</span><br></pre></td></tr></table></figure><p>可以看到我们的机器人出现在了仿真环境中，虽然会发现我们的模型直接瘫倒，但是这是因为没有添加actuator等配置。</p><p><img src="https://img.mahaofei.com/img/202312060913373.png" alt="image.png"></p><p>由于夹爪出现问题，一直无法使用，因此替换了<a href="https://github.com/vikashplus/robotiq_sim">vikashplus/robotiq_sim</a>的夹爪。</p><p>添加完成后的<code>e05_mujoco.xml</code>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mujoco</span> <span class="attr">model</span>=<span class="string">&quot;e05&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">compiler</span> <span class="attr">angle</span>=<span class="string">&quot;radian&quot;</span> <span class="attr">meshdir</span>=<span class="string">&quot;../meshes_mujoco/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span> <span class="attr">njmax</span>=<span class="string">&quot;500&quot;</span> <span class="attr">nconmax</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载 E05 机械臂模型与基本配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/base_link.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link1.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link2&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link2.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link3&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link3.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link4&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link4.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link5&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link5.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link6&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link6.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">texture</span> <span class="attr">type</span>=<span class="string">&quot;skybox&quot;</span> <span class="attr">builtin</span>=<span class="string">&quot;gradient&quot;</span> <span class="attr">rgb1</span>=<span class="string">&quot;0.3 0.5 0.7&quot;</span> <span class="attr">rgb2</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;512&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3072&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;texture builtin=&quot;flat&quot; height=&quot;1278&quot; mark=&quot;cross&quot; markrgb=&quot;1 1 1&quot; name=&quot;texgeom&quot; random=&quot;0.01&quot; rgb1=&quot;0.8 0.6 0.4&quot; rgb2=&quot;0.8 0.6 0.4&quot; type=&quot;cube&quot; width=&quot;127&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;material name=&quot;geom&quot; texture=&quot;texgeom&quot; texuniform=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">texture</span> <span class="attr">type</span>=<span class="string">&quot;2d&quot;</span> <span class="attr">name</span>=<span class="string">&quot;groundplane&quot;</span> <span class="attr">builtin</span>=<span class="string">&quot;checker&quot;</span> <span class="attr">mark</span>=<span class="string">&quot;edge&quot;</span> <span class="attr">rgb1</span>=<span class="string">&quot;0.2 0.3 0.4&quot;</span> <span class="attr">rgb2</span>=<span class="string">&quot;0.1 0.2 0.3&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">markrgb</span>=<span class="string">&quot;0.8 0.8 0.8&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;groundplane&quot;</span> <span class="attr">texture</span>=<span class="string">&quot;groundplane&quot;</span> <span class="attr">texuniform</span>=<span class="string">&quot;true&quot;</span> <span class="attr">texrepeat</span>=<span class="string">&quot;5 5&quot;</span> <span class="attr">reflectance</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">asset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">damping</span>=<span class="string">&#x27;200&#x27;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">damping</span>=<span class="string">&#x27;100&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 加载 Robotiq-2f-85 夹爪与基本配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;robotiq-2f-85-assets.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 机器人本体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">worldbody</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 仿真环境设置定义 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;body pos=&quot;-0.16 0.90 0.02&quot; euler=&quot;4.71238898 0 3.14159265&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;body euler=&quot;0 -0.82 0&quot;&gt;</span></span><br><span class="line"><span class="comment">                &lt;camera name=&quot;workbench_camera&quot; euler=&quot;0 0 0&quot; fovy=&quot;60&quot; pos=&quot;0 0 0.5&quot; /&gt;</span></span><br><span class="line"><span class="comment">            &lt;/body&gt;</span></span><br><span class="line"><span class="comment">        &lt;/body&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">light</span> <span class="attr">diffuse</span>=<span class="string">&quot;0.6 0.6 0.6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">light</span> <span class="attr">diffuse</span>=<span class="string">&quot;0.6 0.6 0.6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 -0.3 3&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;0 0.2 -0.8&quot;</span> <span class="attr">directional</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;light cutoff=&quot;100&quot; diffuse=&quot;0.5 0.5 0.5&quot; dir=&quot;-0 0 -1.3&quot; directional=&quot;true&quot; exponent=&quot;1&quot; pos=&quot;0 0 1.3&quot; specular=&quot;.1 .1 .1&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">name</span>=<span class="string">&quot;floor&quot;</span> <span class="attr">size</span>=<span class="string">&quot;0 0 0.05&quot;</span> <span class="attr">type</span>=<span class="string">&quot;plane&quot;</span> <span class="attr">material</span>=<span class="string">&quot;groundplane&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 整个运动链 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.501961 0.501961 0.501961 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.501961 0.501961 0.501961 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0.0735&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;-0.0218175 -1.34618e-05 0.0953928&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.696024 -0.147787 -0.14991 0.686467&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;2.58559&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.0143616 0.0141793 0.00506835&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link2&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0.1465&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.5 -0.5 -0.5 0.5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;4.42659e-06 -0.15814 0.130501&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.491565 0.508215 -0.508335 0.491606&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;1.21311&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.0159807 0.0154676 0.00149746&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 -1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link3&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 -0.38 0&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.707107 0 0 0.707107&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;-0.0414786 1.14213e-05 0.0194164&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.601987 0.371892 0.373044 0.600122&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;1.53239&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00608826 0.00587729 0.00215529&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 -1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.866667 0.866667 0.890196 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link3&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.866667 0.866667 0.890196 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link3&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link4&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.5 -0.5 0.5 -0.5&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;3.8238e-05 -0.0589656 -0.257081&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.988248 -0.152858 -0.000415939 -0.000860755&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;0.475189&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00538322 0.0052745 0.000778119&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint4&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link4&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link4&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link5&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 -0.42&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.707105 -0.707108 0 0&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;1.42418e-06 0.0365906 -0.0159722&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.527641 0.849468 0.000113207 -7.90953e-05&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;0.811919&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00229898 0.00217056 0.000742684&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint5&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link5&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link5&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0.155 0&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.707105 -0.707108 0 0&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;-4.84703e-06 0.00109667 -0.0032406&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.999926 0.0120786 2.3554e-05 -0.00120144&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;0.75038&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00129697 0.00122959 0.00051245&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 -1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.776471 0.756863 0.737255 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.776471 0.756863 0.737255 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">size</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">&lt;!-- 导入 Robotiq 2f-85 运动链 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;robotiq-2f-85-chain.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">worldbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">actuator</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E05 机械臂驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;4000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-1.57 1.57&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint4&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint4&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint5&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint5&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint6&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint6&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mujoco</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完成后效果如下：</p><blockquote><p>注意，需要在每个 joint 标签中加入 damping 属性，例如 <code>damping='200'</code> ，否则会出现模型持续抖动闪烁，无法控制的问题。</p></blockquote><p><img src="https://img.mahaofei.com/img/202312061457266.png" alt="image.png"></p><p>整理文件结构，添加桌子、小方块，移动机器人位置和相机视角，最后得到下面的仿真环境。具体代码已开源至<a href="https://github.com/HaofeiMa/E05_Robotiq-2f-85">Github</a>:</p><p><img src="https://img.mahaofei.com/img/202312062141059.png" alt="image.png"></p><h1>3 Mujoco 常用命令</h1><h2 id="3-1-模型加载与初始化配置">3.1 模型加载与初始化配置</h2><p>模型加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = mujoco_py.load_model_from_path(<span class="string">&quot;path/to/.xml&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建mujoco仿真实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim = mujoco_py.MjSim(model)</span><br></pre></td></tr></table></figure><p>渲染设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建渲染器</span></span><br><span class="line">viewer = mujoco_py.MjViewer(sim)</span><br><span class="line"><span class="comment"># 设置模拟环境视角</span></span><br><span class="line">lookat = [<span class="number">1.27998563</span>, <span class="number">0.68635066</span>, <span class="number">0.55350562</span>]</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">viewer.cam.lookat[idx] = lookat[idx]</span><br><span class="line">viewer.cam.distance = <span class="number">1.4547035766991275</span></span><br><span class="line">viewer.cam.azimuth = <span class="number">134.95215311004816</span></span><br><span class="line">viewer.cam.elevation = -<span class="number">32.488038277512022</span></span><br></pre></td></tr></table></figure><p>初始姿态设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initial_qpos = &#123;</span><br><span class="line"><span class="string">&#x27;joint1&#x27;</span>: np.pi/<span class="number">2</span>,</span><br><span class="line"><span class="string">&#x27;joint2&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;joint3&#x27;</span>: np.pi/<span class="number">2</span>,</span><br><span class="line"><span class="string">&#x27;joint4&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;joint5&#x27;</span>: np.pi/<span class="number">2</span>,</span><br><span class="line"><span class="string">&#x27;joint6&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;robotiq_2f_85_right_driver_joint&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;object0:joint&#x27;</span>: [<span class="number">1</span>, <span class="number">0.45</span>, <span class="number">0.425</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, value <span class="keyword">in</span> initial_qpos.items():</span><br><span class="line">sim.data.set_joint_qpos(name, value)</span><br><span class="line">sim.forward()</span><br></pre></td></tr></table></figure><p>主函数调用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">sim.step()</span><br><span class="line">viewer.render()</span><br></pre></td></tr></table></figure><h2 id="3-2-基本信息查询与设置">3.2 基本信息查询与设置</h2><p><strong>（1）body</strong></p><p>打印<code>body</code>位置与姿态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body_idx = sim.model.body_name2id(<span class="string">&quot;link6&quot;</span>)</span><br><span class="line"><span class="comment"># 打印 body 坐标</span></span><br><span class="line"><span class="built_in">print</span>(sim.data.body_xpos[body_idx])</span><br><span class="line"><span class="comment"># 打印 body 四元数</span></span><br><span class="line"><span class="built_in">print</span>(sim.data.body_xquat[body_idx])</span><br></pre></td></tr></table></figure><p><strong>（2）site</strong></p><p>打印<code>site</code>位置与姿态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.get_site_xpos(<span class="string">&#x27;site_name&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(sim.data.get_site_xquat(<span class="string">&#x27;site_name&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>（3）joint</strong></p><p>打印<code>joint</code>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">joint_idx = model.joint_name2id(<span class="string">&quot;joint_name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sim.data.qpos[model.jnt_qposadr[joint_idx]])</span><br></pre></td></tr></table></figure><p>设置<code>joint</code>值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim.data.set_joint_qpos(<span class="string">&quot;joint_name&quot;</span>, value)</span><br></pre></td></tr></table></figure><p><strong>（4）actuator</strong></p><p>打印<code>actuator</code>状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.ctrl)</span><br></pre></td></tr></table></figure><p>设置<code>actuator</code>值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim.data.ctrl[actuator_index] = value</span><br></pre></td></tr></table></figure><p><strong>（5）mocap</strong></p><p>打印<code>mocap</code>位置和姿态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.mocap_pos)</span><br><span class="line"><span class="built_in">print</span>(sim.data.mocap_quat)</span><br></pre></td></tr></table></figure><p>设置<code>mocap</code>位置和姿态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">sim.data.mocap_pos[:] = np.array([x, y, z])</span><br><span class="line">sim.data.mocap_quat[:] = np.array([quat_1, quat_2, quat_3, quat_4])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">sim.data.set_mocap_pos(<span class="string">&#x27;mocap_name&#x27;</span>, np.array([x, y, z]))</span><br><span class="line">sim.data.set_mocap_quat(<span class="string">&#x27;mocap_name&#x27;</span>, np.array([quat_1, quat_2, quat_3, quat_4]))</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：</p><ol><li><a href="https://www.bilibili.com/video/BV1Tx411o7rH">SUES木鸢机甲工作室. SolidWorks模型导出urdf （古月居老师）. Bilibili</a></li><li><a href="https://zhuanlan.zhihu.com/p/99991106">Robot Learning. MuJoCo的机器人建模. 知乎</a></li><li><a href="https://roboti.us/forum/index.php?resources/">MuJoCo官方论坛</a></li><li><a href="http://www.mujoco.org/book/index.html">MoJoCo官方文档</a></li><li><a href="https://github.com/vikashplus/robotiq_sim">vikashplus/robotiq_sim.git</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">将自定义机器人模型导入进Mujoco中，为后续强化学习搭建仿真环境基础。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="实验设备" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/%E5%AE%9E%E9%AA%8C%E8%AE%BE%E5%A4%87/"/>
    
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="MuJoCo" scheme="https://www.mahaofei.com/tags/MuJoCo/"/>
    
  </entry>
  
  <entry>
    <title>【笔记工具】Markdown语法与Obsidian编辑器</title>
    <link href="https://www.mahaofei.com/post/37a3baf2.html"/>
    <id>https://www.mahaofei.com/post/37a3baf2.html</id>
    <published>2023-11-29T12:34:55.000Z</published>
    <updated>2023-11-29T12:34:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 Markdown</h1><h2 id="1-1-什么是-Markdown">1.1 什么是 Markdown</h2><p>Markdown 是一种是目前互联网上最流行的写作语言，它使用一些简单的符号来标记文本格式，其简洁的语法、优美的格式以及强大的软件支持深受广大网友的喜爱。</p><p>Markdown 使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。它的学习门槛很低，你可能只需花几分钟就可以入门了。</p><p>目前基本上所有的博客网站、在线文档等都支持 markdown 格式，尤其广泛应用于程序员领域，例如 Github 中的所有说明文档一般都是 <code>.md</code> 格式。</p><h2 id="1-2-为什么使用-Markdown">1.2 为什么使用 Markdown</h2><p>Markdown 的出现主要是为了解决以下通点：</p><ul><li><strong>软件不兼容</strong>：例如不同版本的word、或者不同软件如office与wps，打开同一文档，可能有的正常，有的格式错误，有的乱码。</li><li><strong>排版浪费时间</strong>：功能越多，我们就容易想得越多，遇到的问题也会越多。对于专注于写作的场景，有时可能并不需要那么多选项格式，例如行高行距字体颜色等等。而是要关注内容。同时word中每次写完一段文字，都要再手动为它选择格式，多的这一步操作可能就会打断思路。而markdown可以让你仅通过键盘，在写文档的同时完成格式的设置。</li><li><strong>格式不兼容</strong>：复制同一段文字到另一个文档中，很有可能格式全乱了，同理复制到网页或从其他地方复制过来，格式也都是很麻烦的问题。</li></ul><p>为了解决这些问题，Markdown 实现了以下功能：</p><ul><li><strong>语法简单</strong>：只需要一些简单地标记符号，例如<code># * &gt; - [] () =</code></li><li><strong>兼容性强</strong>：所有的编辑器都可以打开 <code>.md</code> 文件，甚至记事本和vim都可以编辑</li><li><strong>导出方便</strong>：可以导出PDF、也可以嵌入HTML、Latex等格式</li><li><strong>专注内容</strong>：写作时双手无需脱离键盘，再也不用纠结排版问题</li></ul><h2 id="1-3-Markdown-怎么用">1.3 Markdown 怎么用</h2><p>虽然所有的编辑器都可以编辑 Markdown 文件，但是为了更加直观，并且让我们有更好地写作体验，这里推荐两款所见即所得的 Markdown 编辑神器：<a href="https://obsidian.md/">Obsidian</a>和<a href="https://typora.io/">Typora</a>。前者是我现在一直在用的笔记软件，作为我的知识库管理工具，后者在我写作初期使用过，编辑体验也非常不错。</p><p>下图为 Obsidian：</p><p><img src="https://img.mahaofei.com/img/202311292058718.png" alt="image.png"></p><p>下图为 Typora：</p><p><img src="https://img.mahaofei.com/img/202311292059046.png" alt="image.png"></p><p>打开自己的 Markdown 编辑器，新建一个文件，就可以开始自己的创作了。</p><h2 id="1-4-Markdown-基本语法">1.4 Markdown 基本语法</h2><p>以下是一些比较常用的 Markdown 语法，按照我的常用顺序排列：</p><h3 id="1-标题">1. 标题</h3><p>使用方式为：<code>#</code> + <code>空格</code> + <code>标题文字</code>，注意<code>#</code>号与<code>标题文字</code>之间的<code>空格</code>：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h1>一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6><h3 id="2-倾斜">2. 倾斜</h3><p>使用方式：<code>*被倾斜的文字*</code> 或者 <code>_被倾斜的文字_</code>，快捷键 <code>Ctrl+I</code>， 例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字，<span class="emphasis">*这里是被倾斜的文字*</span>，这里又是正常文字</span><br><span class="line"></span><br><span class="line"><span class="emphasis">_下划线在Obsidian中好像只能倾斜整行_</span></span><br></pre></td></tr></table></figure><p>这里是正常文字，<em>这里是被倾斜的文字</em>，这里又是正常文字</p><p><em>下划线在 Obsidian 中好像只能倾斜整行</em></p><h3 id="3-加粗">3. 加粗</h3><p>使用方式：<code>**被加粗的文字**</code> 或 <code>__被加粗的文字__</code>，快捷键 <code>Ctrl+B</code>， 例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字，<span class="strong">**这里是被加粗的文字**</span>，这里又是正常文字</span><br><span class="line"></span><br><span class="line"><span class="strong">__下划线在Obsidian中好像只能加粗整行__</span></span><br></pre></td></tr></table></figure><p>这里是正常文字，<strong>这里是被加粗的文字</strong>，这里又是正常文字</p><p><strong>下划线在 Obsidian 中好像只能加粗整行</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*当然倾斜和加粗可以一起使用，那样就是三个星号*</span>**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__<span class="emphasis">_也可以是三个下划线_</span>__</span></span><br></pre></td></tr></table></figure><p><em><strong>当然倾斜和加粗可以一起使用，那样就是三个星号</strong></em></p><p><em><strong>也可以是三个下划线</strong></em></p><h3 id="4-高亮">4. 高亮</h3><p>使用方式如下</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字，==这里是被高亮的文字，但是不能换行，如果要对多段高亮，需要每一段使用高亮标记==，这里又是正常文字</span><br></pre></td></tr></table></figure><p>这里是正常文字，==这里是被加粗的文字，但是不能换行，如果要对多段加粗，需要每一段使用加粗标记==，这里又是正常文字</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*==当然倾斜和加粗可以一起使用，就像这样==*</span>**</span></span><br><span class="line"></span><br><span class="line">==<span class="strong">**<span class="emphasis">*也可以是这样*</span>**</span>==</span><br><span class="line"></span><br><span class="line">==<span class="strong">__<span class="emphasis">_也可以是下划线_</span>__</span>==</span><br></pre></td></tr></table></figure><p>==<em><strong>当然倾斜和加粗可以一起使用，那样就是三个星号</strong></em>==</p><p>==<em><strong>也可以是这样</strong></em>==</p><p>==<em><strong>也可以是下划线</strong></em>==</p><h3 id="5-列表">5. 列表</h3><p><strong>无序列表</strong></p><p>使用<code>+ -</code>标记无序列表，使用方式为<code>+/-</code>+<code>空格</code>+<code>文字</code>，注意<code>+/-</code>号与<code>文字</code>之间的<code>空格</code>。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 这是无序列表的第一项</span><br><span class="line"><span class="bullet">-</span> 这是第二项</span><br><span class="line"><span class="bullet">-</span> 这是第三项</span><br></pre></td></tr></table></figure><ul><li>这是无序列表的第一项</li><li>这是第二项</li><li>这是第三项</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+</span> 这是无序列表的第一项</span><br><span class="line"><span class="bullet">+</span> 这是第二项</span><br><span class="line"><span class="bullet">+</span> 这是第三项</span><br></pre></td></tr></table></figure><ul><li>这是无序列表的第一项</li><li>这是第二项</li><li>这是第三项</li></ul><p><strong>有序列表</strong></p><p>使用方式为<code>数字</code>+<code>.</code>+<code>空格</code>+<code>文字</code>。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="6-引用">6. 引用</h3><p>使用<code>&gt;</code>标记引用的内容，使用方式为<code>&gt;</code> + <code>空格</code> + <code>引用文字</code>，注意<code>&gt;</code>号与<code>文字</code>之间的<code>空格</code>。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是被引用的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>这是被引用的内容</p></blockquote><h3 id="7-代码">7. 代码</h3><p>代码分为行内代码和代码块。</p><p><strong>行内代码</strong>，使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字`code`文字继续</span><br></pre></td></tr></table></figure><p>这里是正常文字<code>code</code>文字继续</p><p><strong>代码块</strong>，使用方式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```代码格式（c, c++, python, html, java, css, yaml, shell ...)</span></span><br><span class="line"><span class="code">代码内容</span></span><br><span class="line"><span class="code">```</span>ㅤㅤ</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">import numpy as np</span></span><br><span class="line"><span class="code">np.array([1, 2, 3])</span></span><br><span class="line"><span class="code">```</span>ㅤㅤ</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="8-链接">8. 链接</h3><p>链接的使用格式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接显示文字</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">马浩飞丨博客</span>](<span class="link">https://www.mahaofei.com</span>)</span><br></pre></td></tr></table></figure><p><a href="https://www.mahaofei.com">马浩飞丨博客</a></p><h3 id="9-图片">9. 图片</h3><p>图片的使用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](图片地址)</span><br><span class="line">![](https://img.mahaofei.com/img/202311292058718.png)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202311292058718.png" alt=""></p><h3 id="10-分割线">10. 分割线</h3><p>分割线使用三个以上的<code>*</code>或<code>-</code>或<code>_</code>组成，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分割线之上</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">或者使用</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">再或者</span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br><span class="line">就这些</span><br></pre></td></tr></table></figure><p>分割线之上</p><hr><p>或者使用</p><hr><p>再或者</p><hr><p>就这些</p><h3 id="11-表格">11. 表格</h3><p>表格的使用可能稍微有些繁琐，如果是在Obsidian中，可以有些插件简化表格的创建方式。</p><p>常规使用方式如下，注意中间的<code>|-|-|-|</code>是不能删的，表格有几列就写几个<code>|-|</code>：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头1|表头2|表头3|</span><br><span class="line">|-|-|-|</span><br><span class="line">|表格内容1|表格内容2|表格内容3|</span><br><span class="line">|表格内容4|表格内容5|表格内容6|</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr><td>表格内容1</td><td>表格内容2</td><td>表格内容3</td></tr><tr><td>表格内容4</td><td>表格内容5</td><td>表格内容6</td></tr></tbody></table><blockquote><p>哦对，补充一下，为了表示直观，markdown使用空行分割两个段落</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一段</span><br><span class="line"></span><br><span class="line">第二段</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-callout">12.callout</h3><p>使用<code>&gt; [!note] </code>就可以创建一个callout模块，例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [!INFO]</span></span><br><span class="line"><span class="quote">&gt; 这里是callout模块</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202401031849885.png" alt="image.png"></p><p>默认有12种风格。每一种有不同的颜色和图标（标题中的单词可以替换 <code>&gt; ![替换]</code> 实现下面效果）。</p><p><img src="https://img.mahaofei.com/img/202401031850041.png" alt="image.png"></p><p>可以使用 <code>+</code> 默认展开或者 <code>-</code> 默认折叠正文部分。例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [!FAQ]- 点击就可以展开了</span></span><br><span class="line"><span class="quote">&gt; 这里是callout的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>[!FAQ]- 点击就可以展开了<br>这里是callout的内容</p></blockquote><h1>2 Obsidian</h1><h2 id="2-1-为什么使用-Obsidian">2.1 为什么使用 Obsidian</h2><p><strong>Obsidian 很适合用来管理多层级多文件，因此很适合用来构建知识库</strong></p><p>最初我使用 Obsidian 是因为我写的文章越来越多，当时使用 Typora 管理起来感觉不是很方便，而且那时正逢 Typora 更新至1.0后开始收费，而 Obsidian 开始展露头角，因此我尝试使用了 Obsidian，从此在我的所有设备的dock栏上，一定会有一个 Obsidian，只要我在使用电脑，Obsidian一定是处于打开状态的。</p><p>下图是我现在的 Obsidian 图</p><ul><li>左边是文件列表、历史打开文件</li><li>右边是任务列表和日历（也可以切换为文档目录）</li></ul><p><img src="https://img.mahaofei.com/img/202311292140615.png" alt="image.png"></p><p>我自己的博客内容全部使用Obsidian存储，同时记录我的一些笔记和平时遇到的各种Bug，这样遇到相似问题时，直接使用全局搜索，就可以快速找到解决办法，亲测已经帮我解决了好多次问题，节约了大把时间。</p><p><strong>个人不放心云笔记，Obsidian 是纯本地化文件编辑与管理</strong></p><p>由于各种原因，我不想将我自己记录的一些内容全部放到云笔记上，一旦宕机或跑路，会是一件非常麻烦的问题，例如有道云笔记、印象笔记等等，OneNote等我也用过，但是迁移性太差，如果想换别的笔记软件，之前记录的东西根本不能导出。</p><p>而Obsidian则是使用的本地化文件管理，左侧的文件列表就是本地中真实存在的一个个文件夹和<code>.md</code>文件。在多设备同步方面，推荐坚果云或者OneDrive实现多设备的实时同步。</p><p><strong>Obsidian 的功能非常丰富，是一个笔记软件，又不止是一个笔记软件</strong></p><p>对于我来说，我使用 Obsidian 完成了很多功能，当然最主要的还是记笔记，包括学习笔记、Bug 笔记、组会记录等等。</p><p>同时使用<code>custom frames</code>插件能够将网页嵌入到 Obsidian 中，我将滴答清单加入了进来，这样就实现了上图右侧的任务管理功能。</p><p>此外我还写了一个自动化脚本，根据我的笔记库的内容修改，每天定时更新博客内容。</p><p><strong>Obsidian 颜值非常高，有各种各样主题，而且几乎所有的样式格式都可以自定义修改</strong></p><p>在外观这方面，我也折腾了一段时间，最终还是使用 <code>Blue Topaz</code>主题，辅以<code>Style Settings</code> 插件中的一些个性化设置。总的来说没有修改太多。</p><p>网上也有一些开源的高度修改的库模板，下载下来就可以直接用，但是我找了一圈，发现自己还是更喜欢简约直接的，各位可以根据自己的审美找找看。</p><h2 id="2-2-Obsidian-的特色功能">2.2 Obsidian 的特色功能</h2><p>这里只介绍大致功能，具体使用方法，请参考 <a href="https://publish.obsidian.md/help-zh/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B">Obsidian 官方教程</a>，或者下载Obsidian软件后，第一次打开会有示例库，我当时就是阅读那个学习的。</p><p><strong>双向链接</strong></p><p>不确定 Obsidian 是不是第一个双链笔记软件，但它也是最早的一批了。</p><p>双向链接，顾名思义就是双向引用的链接，例如我在A文章中使用<code>[[B文章的标题或者小标题]]</code>，就可以实现文章和文章之间的链接，有点类似于网页链接，但是它是在笔记软件内跳转的。</p><p>在被引用的笔记中，你也可以看到这篇笔记被哪些其它笔记引用了。例如可能某篇<code>[[Ubuntu系统Buglist]]</code>中的内容就可能被我在写其它实验笔记的时候引用很多次。</p><p>这样所有的笔记相互链接，就会形成一个庞大的关系图谱，Obsidian中也可以查看这个关系图谱。</p><p>此外，双向链接还可以使用<code>![[文件名]]</code>或<code>![[文件名#小节标题]]</code>这样的格式，在引用的同时，将那篇笔记的全部或某一节插入到当前文章中，例如：</p><p><img src="https://img.mahaofei.com/img/202311292210694.png" alt="image.png"></p><p><strong>模板</strong></p><p>Obsidian 提供了模板的功能。</p><p>我创建了一个文件夹保存所有的模板。当我新建笔记后，可以直接插入现有的模板，例如我经常使用的论文笔记模板</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># X 论文名称</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; <span class="strong">**标题**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**作者团队**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**期刊会议**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**时间**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**代码**</span>：</span></span><br><span class="line"></span><br><span class="line"><span class="section">## X.1 目标问题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## X.2 方法</span></span><br><span class="line"></span><br><span class="line"><span class="section">## X.3 思考</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202311292215167.png" alt="image.png"></p><p><strong>工作区保存与快速恢复</strong></p><p>有的时候我可能会同时打开好几个笔记，比如实验笔记、论文笔记、Buglist等等，我会把他们分屏分开放在不同的位置，例如这样：</p><p><img src="https://img.mahaofei.com/img/202311292218056.png" alt="image.png"></p><p>但是此时如果我需要去做另一件事，比如开会，我就需要把当前的这些笔记都关掉，打开会议记录，但是下次想要在恢复这个布局又比较麻烦。</p><p>这时候就可以点击左侧的<code>管理工作空间布局按钮</code>，保存工作空间布局，然后就可以放心关闭了，下次使用点击加载工作空间布局就可以一键恢复之前的布局。</p><p><strong>丰富的插件系统</strong></p><p>Obsidian 提供了丰富的插件系统，有些可以增加 Obsidian 的功能，有些则是美化外观，有些可以提高编辑体验。</p><p>具体哪些插件我用过比较好用的，后续会持续在本文下面更新。</p><p><strong>录音</strong></p><p>写这篇文章，在查资料的时候突然发现Obsidian出了录音功能，在【设置-核心插件】里打开即可使用，打开后会在主页面最左侧添加一个图标，按下即可开始录音。</p><p>录音完成后，会保存在当前笔记文件中。</p><p><img src="https://img.mahaofei.com/img/202311292224701.png" alt="image.png"></p><h2 id="2-3-Obsidian-插件推荐">2.3 Obsidian 插件推荐</h2><p><strong>所有的插件都可以在插件市场中直接搜索下载</strong>，【设置-第三方插件-社区插件市场】</p><p>后续有时间再更新各个插件的介绍和使用详情</p><h3 id="1-提升编辑体验">1. 提升编辑体验</h3><p><a href="https://obsidian.md/plugins?id=media-extended"><strong>Media Extended</strong></a></p><p>Media Extended增强了媒体播放功能，包括链接到在线视频，速度控制，循环播放，字幕支持。</p><p>以及创建时间戳链接笔记，从在线视频、本地视频、录音中获取时间戳等等。</p><p>（目前测试似乎只能添加 Youtube 在线视频）</p><p><img src="https://www.youtube.com/watch?v=yBCD-Hfpd8U" alt=""></p><p><a href="https://obsidian.md/plugins?id=obsidian-outliner"><strong>Outliner</strong></a></p><p>增强列表样式</p><ul><li>可以上移下移缩进列表</li><li>增加列表垂直缩进线</li><li>增加折叠展开功能</li></ul><p><a href="https://obsidian.md/plugins?id=table-editor-obsidian"><strong>Advanced Tables</strong></a></p><p>优化创建表格的语法：输入一个<code>|</code>，然后输入第一个标题，接着按下<code>tab</code>，继续输入标题直到创建所有标题，然后按下<code>Enter</code>转到第一行输入内容，以此类推。</p><p>当光标位于表格中时：</p><table><thead><tr><th>快捷键</th><th>动作</th></tr></thead><tbody><tr><td><code>Tab</code></td><td>下一个单元格</td></tr><tr><td><code>Shift</code> + <code>Tab</code></td><td>上一个单元格</td></tr><tr><td><code>Enter</code></td><td>下一行</td></tr><tr><td><code>Ctrl</code> + <code>Shift</code> + <code>D</code></td><td>打开表格控件侧边栏</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/202311301613362.gif" alt=""></p><h3 id="2-增加功能">2. 增加功能</h3><p><a href="https://obsidian.md/plugins?id=calendar"><strong>Calendar</strong></a></p><p>日历插件，打开后会在右边侧栏出现日历。</p><p>点击日历上的日期，可以跳转到当天的每日笔记中（每日笔记也可以设置模板）</p><p><img src="https://img.mahaofei.com/img/202311301615320.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=obsidian-custom-frames"><strong>Custom Frames</strong></a></p><p>可以将任意的网页转换为obsidian窗格，非常不错。</p><p>例如我这里右侧的滴答清单：</p><p><img src="https://img.mahaofei.com/img/202311292140615.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=obsidian-image-auto-upload-plugin"><strong>Image auto upload Plugin</strong></a></p><p>image auto upload插件搭配PicGo使用，能自动将ob中插入的图片上传到图床中，优化图片插件体验。</p><p>在这里我使用的是阿里云OSS存储我的图片，具体可以参考：<a href="https://www.mahaofei.com/post/d05a7f72.html">阿里云图床搭建方法</a>或者[[01_阿里云图床搭建方法]]</p><p><a href="https://obsidian.md/plugins?id=recent-files-obsidian"><strong>Recent Files</strong></a></p><p>非常直观的功能，就是在左侧文件列表增加最近打开的文件列表。</p><p><img src="https://img.mahaofei.com/img/202311301701536.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=dataview"><strong>Dataview</strong></a></p><p>一个高效信息动态查询插件，当你拥有足够多的笔记后，可以用它来生成目录表格，并且支持各种查询限制条件。</p><p><a href="https://obsidian.md/plugins?id=templater-obsidian"><strong>Templater</strong></a></p><p>相比较与 obsidian 自带的模板工具，他能实现更复杂的模板，设置更多的变量和函数，生成一些功能强大的模板。</p><p><a href="https://obsidian.md/plugins?id=obsidian-admonition"><strong>Admonition</strong></a></p><p>能够在 Obsidian 中添加样式框的插件，能让笔记显得好看又有层次，可以配合着 Task、QuickAdd、Button 和 Dataview 等插件使用。</p><p><img src="https://img.mahaofei.com/img/202401071717704.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=quickadd"><strong>Quickadd</strong></a></p><p>可快速添加信息，捕捉想法，采用模板新建笔记和添加宏命令，快速执行多项操作的好用又强大的插件。</p><p><a href="https://obsidian.md/plugins?id=buttons"><strong>Buttons</strong></a></p><p>可以添加一些自定义按钮，用来执行一些特定人物，例如一些命令或者打开链接或者结合 quickadd 实现一些自动化流程。</p><p><a href="https://obsidian.md/plugins?id=obsidian-banners"><strong>Banners</strong></a></p><p>在笔记的开头添加和管理横幅图片，一般用于制作笔记主页时使用。</p><p><a href="https://obsidian.md/plugins?id=workspaces-plus"><strong>Workspaces plus</strong></a></p><p>快速切换管理工作区的布局。你可以按照你不同的习惯，规划工作区。</p><p><a href="https://obsidian.md/plugins?id=obsidian-hover-editor"><strong>Hover Editor</strong></a></p><p>通过将悬停弹窗变成一个功能齐全的编辑器，来增强核心的“页面预览”原有的功能。</p><h3 id="3-个性化设置">3. 个性化设置</h3><p><a href="https://obsidian.md/plugins?id=mysnippets-plugin"><strong>MySnippets</strong></a></p><p>css片段管理插件，在右下角生成css管理菜单，点击后可方便的开关css片段。</p><p><img src="https://img.mahaofei.com/img/202312010757678.gif" alt=""></p><p><a href="https://obsidian.md/plugins?id=obsidian42-brat"><strong>Obsidian42 - BRAT</strong></a></p><p>obsidian的插件下载大致可分为两种，第一种是从ob软件内的官方渠道下载，第二种则是通过Github等渠道下载后再手动安装。</p><p>Obsidian42 - BRAT 可以帮助你直接安装社区插件市场无法安装的插件。</p><p><a href="https://obsidian.md/plugins?id=obsidian-style-settings"><strong>Style Settings</strong></a></p><p>主题自定义设置插件，可以在现有主题的基础上，根据自己的需要进行魔改。</p><p><img src="https://img.mahaofei.com/img/202312010804210.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">介绍一种我自己一直在用的非常强大的笔记语法Markdown，以及基于markdown语法的编辑器Obsidian.</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="效率工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】人机协作</title>
    <link href="https://www.mahaofei.com/post/a9bacf05.html"/>
    <id>https://www.mahaofei.com/post/a9bacf05.html</id>
    <published>2023-11-27T10:56:59.000Z</published>
    <updated>2023-11-27T10:56:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 Transfer Learning-enabled Action Recognition for Human-robot Collaborative Assembly</h1><blockquote><p><strong>标题</strong>：用于人机协作装配的迁移学习动作识别<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CIRP<br><strong>时间</strong>：2021<br><strong>代码</strong>：</p></blockquote><h2 id="1-1-背景">1.1 背景</h2><p>随着现代制造业从大规模生产转向大量的个性化应用，工业机器人对自适应控制以及在共享工作空间中与人类无缝协作的需求不断增加。在柔性自动化的背景下，人机协作旨在将机器人的准确性和强度在人类的认知能力和灵活性相结合。</p><blockquote><p>With modern manufacturing shifting from mass production to mass personalization, industrial robots have been of rising demands for adaptive control and seamless cooperation with human operators in a shared workspace. In the context of flexible automation, human-robot collaboration (HRC) aims to integrate the accuracy and strength of robots with cognitive ability and flexibility of humans in the execution loop.</p></blockquote><p>实现这一目标的一个重要基础，就是机器人动态规划对人类活动和意图的安全的响应。因此人类的动作识别作为先决条件，在高效HRC中起着至关重要的作用。</p><blockquote><p>One major pillar to achieve this is that robots dynamically plan safe reactions responded to human activities and intentions.</p></blockquote><p>这可以在面向个性化定制的制造中带来更高的效率。</p><blockquote><p>which can result in higher overall productivity in customization-oriented manufacturing.</p></blockquote><h2 id="1-2-目标问题">1.2 目标问题</h2><p>人机协作(Human-robot collaboration, HRC)对于当今制造业的高柔性装配趋势至关重要。人类动作识别作为HRC的先决条件，使工业机器人能够理解人类意图并自适应的执行规划。</p><blockquote><p>Human-robot collaboration (HRC) is critical to today’s tendency towards high-flexible assembly in manufacturing. Human action recognition, as one of the core prerequisites for HRC, enables industrial robots to understand human intentions and to execute planning adaptively.</p></blockquote><p>目前的基于深度学习的动作识别方法严重依赖大量的注释数据，这在实际中并不有效且不现实。</p><p>因此本文提出了一种基于迁移学习的动作识别方法，帮助HRC装配。并引入了机器人规划决策机制。</p><h2 id="1-3-方法">1.3 方法</h2><p>本文提出了一种基于迁移学习的动作预测方法，以实现高效的HRC装配。系统包括三部分：（1）数据感知和预处理；（2）从采样视频中提取知识和动作识别；（3）机器人根据学到的语义知识做出决策和反应。</p><p><strong>（1）基于迁移学习的人类动作识别</strong></p><p>使用Kinect获取机器人的动作，通过Openpose工具箱获得人体姿态（该工具箱可以在连续视频中预测操作者的身体关节）。</p><p>本文提出的基于迁移学习的ST-GCN框架，包括三个模块：特征提取器、动作分类器和域自适应模块。</p><p><strong>（2）面向任务的自适应HRC装配</strong></p><p>预测的人类活动通过语义图转换为HRC装配中的机器人规划决策。通过将人体轨迹和深度相机的手眼标定，机器人可以获得真实的物理世界坐标，从而使机器人能够移动到精确的位置。因此机器人可以动态的协调人类并根据人类的子任务自适应的改变动作，最终实现面向任务的HRC装配。</p><h1>2 Vision-based holistic scene understanding towards proactive human–robot collaboration</h1><blockquote><p><strong>标题</strong>：基于视觉的整体场景理解，实现主动的人机协作<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：Robotics and Computer-Integrated Manufacturing<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><p>近年来，人机协作因其潜在的生产效率提高和大规模自定义能力而在制造领域引起了许多关注。 HRC将机器人的力量和准确性与人类的灵活性和创造力相结合，使人类操作员和机器人能够在共享工作空间中无缝工作并执行共享任务。</p><blockquote><p>Human–robot collaboration (HRC) has attracted many interests in recent years in the field of manufacturing because of the potential production efficiency improvement and mass personalization capability. The strength and accuracy of robots along with the flexibility and creativity of humans are combined in an HRC team, allowing human operators and robots to work seamlessly in a shared workspace with shared tasks.</p></blockquote><p>近年来，由于能够充分利用人类的灵活性和机器人精度的优势，人机协作已经成为制造业大规模个性化的一个有前途的方法。</p><blockquote><p>Recently human–robot collaboration (HRC) has emerged as a promising paradigm for mass personalization in manufacturing owing to the potential to fully exploit the strength of human flexibility and robot precision.</p></blockquote><p>为了实现更好的协作，机器人应该能够实现整体感知和解析工作场景的信息，从而主动规划并采取相应行动。目前HRC的相关工作虽然关注了人类的认知，但是缺乏对工作场景的其它关键要素的整体考虑。</p><p>为了解决这个问题，本文考虑物体、人类和环境的认识以及视觉推理，以收集视觉信息，并将其编译为语义，用于后续机器人的决策与协作。</p><h1>3 Dynamic Scene Graph for Mutual-Cognition Generation in Proactive Human-Robot Collaboration</h1><blockquote><p><strong>标题</strong>：主动人机协作中相互认知生成的动态场景图<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CIRP Conference on Manufacturing Systems<br><strong>时间</strong>：<br><strong>代码</strong>：</p></blockquote><h2 id="3-1-背景">3.1 背景</h2><p>在先进制造业向工业5.0转型和在工业化过程中，人类在生产过程中发挥着核心作用。一方面，大规模个性化生产趋势对现代工厂的柔性制造提出了越来越高的要求，而这些要求目前还无法实现，只能依靠人的手动敏捷操作。此外，为了实现工业5.0的可持续性和弹性原则，产品的再利用和回收过程需要高水平的灵活性和自适应性的自动化技术。基于这种情况，人机协作引起了人们对灵活自动化任务的兴趣，该任务结合了人类和机器人的互补能力以提高生产力。</p><blockquote><p>Among the advanced manufacturing transition to Industry 5.0 and reindustrialization, human operators play a central role in the production process. For one side, the mass personalized production tendency raises ever-increasing flexible manufacturing requirements for modern factories, which remain unattained and rely on human manually agile operations. Besides, to achieve sustainability and resilience principles of Industry 5.0, the re-use, re-purpose and recycle processes of products demand high-level flexible and adaptable automation technologies. Motivated by this situation, human-robot collaboration (HRC) has elicited particular interest in flexiable automation tasks, which combines human and robotic complementing competencies for improved productivity.</p></blockquote><p>针对HRC系统，人们进行了大量的研究，以期在工业环境中实现人类技能和机器人操作的相互作用。例如，对人类的动作识别、工件的6-DOF位姿估计等。以及基于这些感知结果的机器人控制、 人类安全机制等等。</p><p>但是除了以上研究，HRC对于上下文感知的能力仍然停留在对周围环境的非语义感知。</p><h2 id="3-2-目标问题">3.2 目标问题</h2><p>人机协作在敏捷、灵活和以人为中心的制造向大规模个性化的转型中发挥着至关重要的作用。</p><p>现存问题：</p><ul><li>在当今的HRC任务中，无论是人类还是机器人都需要遵循命令和指示来进行协作活动，而不是主动、相互参与。</li><li>HRC的非语义感知阻碍了HRC系统中的主动规划和认知能力</li></ul><p>解决方法：<br>提出了一种基于动态场景图的方法，用于主动HRC应用中的相互认知生成。</p><ul><li>利用空间注意金字塔网络，检测工业环境中的对象（工件、机器人手臂、人手）。</li><li>利用链接预测模块构建HRC场景图，利用注意力图卷积网络来捕获工业零件、人类操作员和机器人操作之间的关系，并将人机协作处理结构连接推理为图嵌入，链接到人类操作和机器人主动指令的相互规划器。</li><li>在电池拆卸任务中进行了评估。</li></ul><h1>4 A visual reasoning-based approach for mutual-cognitive human-robot collaboration</h1><blockquote><p><strong>标题</strong>：基于视觉推理的人机交互认知协作方法<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CIRP Annals-Manufacturing Technology<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><h2 id="4-1-背景">4.1 背景</h2><p>在现代工厂中，许多复杂的机械产品的个性化生产，既依赖于机器人的精确操控，又依赖于人类的敏捷操作。在此背景下，人机协作HRC利用了人类的高灵活性和机器人的高效率和可靠性，引起了工业界和学术界的极大兴趣。人类和机器人具有互补的操作目标和能力，并在共享工作空间中协作执行制造任务，迄今为止，已经出现了大量的HRC解决方案。</p><blockquote><p>In modern factories, personalized production of many complicated mechanical products relies on both robots’ precision manipulation and human operators’ agile operations. In this context, human-robot collaboration (HRC) has attracted much interest from the industry and academia, which leverages humans’ high flexibility and robots’ high efficiency and reliability. Human and robotic agents have complementary operation goals and capabilities, and collaboratively conduct manufacturing tasks in a shared workspace. To date, numerous research efforts on HRC solutions have emerged.</p></blockquote><h2 id="4-2-目标问题">4.2 目标问题</h2><p>人机协作允许人类和机器人之间的无缝通信和协作，以在共享工作空间中完成灵活的制造任务。</p><p>现有的HRC系统缺乏机器人和人类认知的有效整合。</p><ul><li>现有的HRC系统上下文感知能力侧重于对环境的感知，而不是对任务过程的类人理解</li><li>现有的HRC系统直接将结果传递到反应控制中，很少考虑知识学习来进行主动路径规划</li><li>机器人执行和人类操作的规划器通常是预定义的，缺乏任务完成过程中的动态调整能力。</li></ul><p>本文提出了一种基于视觉推理的相互认知HRC方法：</p><ul><li>建立HRC知识图谱</li><li>视觉传感器将整体制造场景感知为时间图，通过图嵌入推断出具有相似指令的协作模式。</li><li>将相互认知决策融入到增强现实执行中。</li></ul><h1>5 Towards Mutual-Cognitive Human-Robot Collaboration: A Zero-shot Visual Reasoning Method</h1><blockquote><p><strong>标题</strong>：迈向相互认知的人机协作：零样本视觉推理方法<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CASE<br><strong>时间</strong>：2023<br><strong>代码</strong>：</p></blockquote><h2 id="5-1-背景">5.1 背景</h2><p>工业5.0代表了制造业转型为以人为本、可持续和弹性的原则。迈向以人为本的智能制造，人机协作揭示了改善人类工作条件和确保一致质量的优势。HRC系统结合了人类灵活能力和机器人的自动化能力，对于制造任务，人类能够敏捷操作，而机器人同时执行重复且精确的操作，所有这些都朝着一个共同的目标努力。</p><blockquote><p>Industry 5.0 represents the principles of human-centricity, sustainability and resilience for manufacturing transformation. Towards human-centric smart manufacturing, Human-Robot Collaboration (HRC) sheds light on the benefits of improving human working conditions and ensuring consistent quality. HRC systems combine human’s flexible capabilities and robot automatic capabilities. For a manufacturing task, human operators take agile operations, while the robot concurrently executes repetitive and precise manipulation, all working towards a common goal.</p></blockquote><p>HRC的成功取决于多种因素，包括周围环境的感知、安全的机器人控制和双向通信。在此背景下，先进的计算机视觉技术促进了HRC系统在工业环境中的应用。例如，在HRC系统中跟踪人体运动以避免机器人碰撞并确保人体安全。与此同时，人们还探索了人类的行为、手势和声音，以实现无缝的人机通信。 HRC 场景中的感知信息在人类和机器人代理之间传输，以便在共享制造目标内进行有效协作。</p><blockquote><p>The success of HRC relies on various factors, including the perception of surrounding environments, safe robot control, and bidirectional communication. In this context, the advanced computer vision techniques facilitate applications of HRC systems in industrial settings. For example, human motions were tracked in HRC systems to avoid robot collision and ensure human safety. Meanwhile, human actions, gestures, and voices were explored to allow for seamless human-robot communication. The perceived information in HRC scenarios is transmitted among human and robotic agents for effective co-working within a shared manufacturing goal.</p></blockquote><p>然而，现有的HRC研究工作主要集中在感知层面，未能学习人机操作意图的语义知识并制定认知任务规划策略。在当前的 HRC 系统中，机器人可以跟随人类手势来反应性地规划运动并协助工人，而很少考虑 HRC 任务结构知识和随时间变化的团队合作目标。如果没有对任务的整体理解，HRC系统就无法减轻人类手动操作并增强机器人自适应辅助。此外，对于相似但不同的任务，HRC系统需要学习新的知识表示来规划合理的人类和机器人操作，这限制了HRC在实际情况中的应用。</p><blockquote><p>Nevertheless, existing research efforts on HRC focus on perception level, which fails to learn semantic knowledge of human-robot operation intentions and make cognitive task planning strategies. In current HRC systems, a robot can follow human gestures to reactively plan motions and assist the worker, while seldom considering HRC task structure knowledge and time-changing teamwork goals. Without a holistic understanding of tasks, the HRC system cannot relieve human manual operations and enhance robot adaptive assistance. Besides, for similar but different tasks, the HRC system needs to learn new knowledge representations to plan reasonable human and robotic operations, which limits the HRC applications in real cases.</p></blockquote><h2 id="5-2-目标问题">5.2 目标问题</h2><p>人机协作HRC在当今工业5.0所规定的以人为本的智能制造中显示出了广泛的应用潜力。</p><p>为了实现安全高效的协作，人们探索了多种视觉感知方法。使机器人能够感知周围环境并实现无碰撞的操作规划。</p><p>现存问题：</p><ul><li>目前的视觉感知方法只能传达机器人和人类之间的基本信息，缺乏语义知识（机器人遇到类似但未见过的情况，则无法顺利执行）</li></ul><p>解决方法：</p><ul><li>本文提出了一种基于相互认知的HRC架构，基于现场情况和任务结构的知识表示进行学习，规划人类和机器人的操作。</li><li>引入零样本视觉推理方法，从感知结果中得出机器人策略。</li><li>对老化电动汽车电池协同拆卸任务进行测试。</li></ul>]]></content>
    
    
    <summary type="html">阅读人机协作相关论文的笔记</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="人机协作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E4%BA%BA%E6%9C%BA%E5%8D%8F%E4%BD%9C/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="机器人" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="人机协作" scheme="https://www.mahaofei.com/tags/%E4%BA%BA%E6%9C%BA%E5%8D%8F%E4%BD%9C/"/>
    
    <category term="HRC" scheme="https://www.mahaofei.com/tags/HRC/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】Reskill基于技能的适应性动作空间学习</title>
    <link href="https://www.mahaofei.com/post/be8c51e1.html"/>
    <id>https://www.mahaofei.com/post/be8c51e1.html</id>
    <published>2023-11-25T08:00:39.000Z</published>
    <updated>2023-11-25T08:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：剩余技能策略：学习基于技能的适应性行动空间，用于机器人强化学习<br><strong>作者团队</strong>：昆士兰科技大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://krishanrana.github.io/reskill">https://krishanrana.github.io/reskill</a></p></blockquote><h2 id="1-1-目标问题-6">1.1 目标问题</h2><p>基于技能的学习已经成为加速机器人学习的方法，技能从专家演示中提取，是短序列的单步操作（平移、抓取、抬起等动作），这些技能嵌入到潜在空间中，构成上层 RL 策略的行动空间。但是这种方式存在一些问题：</p><ul><li>对所有技能进行随机抽样探索，效率极低，因为其中只有一小部分技能与当前执行的任务相关，并且这些相关的技能通常不会聚集在技能空间的同一邻域内。</li><li>该方法假设技能是最优的，并且下层的任务来自于技能空间的相同分布，因此学习的通用性和变化适应性有限，例如从移动方块中学习技能，则无法应对障碍物、物体变化、不同摩擦等情况。</li></ul><p>为解决上述问题，本文提出了以下创新方法，称为残差技能策略（Residual Skill Policies，ReSkill）：</p><ul><li>状态条件技能先验：对相关技能进行采样来引导探索</li><li>底层残差策略：通过对技能进行细粒度的技能适应，实现任务变化的适应</li></ul><h2 id="1-2-方法-6">1.2 方法</h2><p>总的来说，该方法将经典控制器产生的演示轨迹分解为与任务无关的技能，并将其嵌入到连续到技能空间中，利用技能空间实现真正的通用学习，上层智能体能够从技能空间中访问但不动作，降低了对数据集详细程度的要求。</p><ul><li>从现有控制器中提取技能</li><li>学习技能嵌入和先验技能</li><li>训练一个分层强化学习策略，在技能空间中使用底层残差适应性策略。</li></ul><p><img src="https://img.mahaofei.com/img/202311161019261.png" alt="image.png"></p><p><strong>（1）数据收集</strong></p><p>本文通过手动控制收集演示数据（基本操作任务，如推物体、抓物体），虽然任务简单，但轨迹包含复杂的技能，可以重新组合解决复杂的任务。</p><p>轨迹是由 state-action 成对组成的，本文从中随机切片 $H$ 长度的片段进行无监督技能提取，利用提取的动作 a 和状态 s 学习下一小节中的 state-action。</p><p>其中状态 s 包括关节角度、关节速度、夹具位置、物体位置，动作是连续的 4D 向量，包括末端位置和速度。</p><p><strong>（2）学习强化学习的状态条件技能空间</strong></p><ul><li>将提取的技能嵌入到潜在空间中：使用变分自动编码器 VAE 将技能 $a$ 嵌入到潜在空间中，VAE 包括编码器和解码器，编码器将完整的 state-action 序列编码为 $z$，解码器根据当前状态 $s_t$ 和技能编码 $z$ 重建动作。</li><li>在探索过程中采样的技能状态条件先验：学习潜在技能空间上的条件概率密度。传统的高斯密度不能处理多模态信息，本文使用 real NVP 方法，实值非体积保留变换。学习从 $Z\times S-&gt;G$ 的映射，该映射就可以从简单分布 G 变换到技能空间 Z，因此 f 就是技能先验。</li></ul><p><img src="https://img.mahaofei.com/img/202311251603089.png" alt=""></p><blockquote><p><strong>变分自编码器</strong>，是一种深度生成模型<br><strong>传统</strong>：传统的自编码器包括编码器和解码器两部分，经过反复训练，输入数据被编码成一个编码向量，编码向量的每一个维度表示学习到的数据的特征，解码器尝试从编码向量中解码原始输入<br><strong>缺陷</strong>：传统的方法，使用单个值表示输入在某个潜在特征的表现。但实际上，将潜在特征表示为可能的取值范围会更合理。<br><strong>改进</strong>：因此变分自编码器就是使用取值的概率分布，代替原来的单值表示特征。<br><strong>优势</strong>：每个潜在特征表示为概率分布，解码时从潜在状态分布中随机采样，生成一个编码向量作为解码器的输入。实现了连续且平滑的潜在空间表示（潜在空间中彼此相邻的值重构出的结果相似）<br>参考理解:<a href="https://zhuanlan.zhihu.com/p/64485020">https://zhuanlan.zhihu.com/p/64485020</a></p></blockquote><p><strong>（3）状态条件技能空间中的强化学习</strong></p><p>一旦训练完成，解码器和技能先验权重就会被冻结，并合并到 RL 框架中。高级强化学习策略 $\pi$ 是一个神经网络，将状态映射到技能先验变化中的向量 g，在转换为潜在技能 Z。</p><p>然后解码器根据技能范围 H 的当前状态顺序重构动作。同时有一个底层残差策略，调整解码后的技能。</p><h2 id="1-3-总结">1.3 总结</h2><p>该方法是一种基于技能的强化学习方法。</p><ol><li>数据收集：使用最基本的控制器生成一些基本任务轨迹（移动、抓取），然后将这些轨迹分割成固定长度的序列，每一小段包括动作和对应的状态。</li><li>学习技能空间，使用变分自编码器将技能编码到潜在空间中；使用realNVP将技能潜在空间+机器人状态空间映射到简单分布空间（高斯分布），这样可以直接根据状态采样技能，称为技能先验。</li><li>强化学习：使用一个高层策略网络，根据当前的状态生成一个向量，根据技能先验（与当前状态有关的技能）中选择一个技能，利用技能解码器解码成机器人动作。</li></ol><h1>二、代码复现</h1><h2 id="2-1-环境搭建-2">2.1 环境搭建</h2><p><strong>（1）安装<code>mujoco</code>：</strong></p><p>下载<code>mujoco</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mujoco.org/download/mujoco210-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>创建一个隐藏文件夹，尽量不要修改此路经</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.mujoco</span><br></pre></td></tr></table></figure><p>将<code>mujoco</code>库解压到上面的文件夹中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf mujoco210-linux-x86_64.tar.gz -C ~/.mujoco</span><br></pre></td></tr></table></figure><p>编辑环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件最后添加下面的语句，注意修改自己的用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mujoco environment</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/用户名/.mujoco/mujoco210/bin</span><br><span class="line">export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so</span><br></pre></td></tr></table></figure><p>刷新环境变量，重启terminal或执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>测试mujoco</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.mujoco/mujoco210/bin</span><br><span class="line">./simulate ../model/arm26.xml</span><br></pre></td></tr></table></figure><p>能看到一个mujoco界面启动，并看到一个二自由度机械臂，说明安装成功。<code>../model/</code>下也有很多其它的模型示例，感兴趣可以看看。</p><p><strong>（2）python环境构建</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/krishanrana/reskill.git</span><br><span class="line">cd reskill</span><br><span class="line">conda env create -f environment.yml</span><br><span class="line">conda activate reskill_new</span><br><span class="line">pip install -e .</span><br><span class="line">cd reskill</span><br></pre></td></tr></table></figure><h2 id="2-2-数据收集">2.2 数据收集</h2><p>使用下面的脚本收集数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python data/collect_demos.py --num_trajectories 40000 --subseq_len 10 --task block</span><br></pre></td></tr></table></figure><p>其中<code>task</code>可以设置为<code>block</code>或<code>hook</code>。</p><h2 id="2-3-训练-2">2.3 训练</h2><p>训练技能模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_skill_modules.py --config_file block/config.yaml --dataset_name fetch_block_40000</span><br></pre></td></tr></table></figure><p>可视化训练完成的技能模块的性能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python utils/test_skill_modules.py --dataset_name fetch_block_40000 --task block --use_skill_prior True</span><br></pre></td></tr></table></figure><p>训练reskill代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_reskill_agent.py --config_file block/config.yaml --dataset_name fetch_block_40000</span><br></pre></td></tr></table></figure><p>可视化训练完成的reskill代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python utils/test_reskill_agent.py --dataset_name fetch_block_40000 --env_name FetchSlipperyPush-v0</span><br></pre></td></tr></table></figure><h2 id="2-4-日志记录">2.4 日志记录</h2><p>使用<a href="https://wandb.ai/">W&amp;B</a>，第一次train时输入自己的api即可。</p><h1>三、代码理解</h1><h2 id="3-1-基本定义-2">3.1 基本定义</h2><p><strong>（1）机器人动作</strong></p><p>算法中机器人通过下面的方法进行定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_set_action</span>(<span class="params">self, action</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;设置动作，在模拟环境中执行动作&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 处理输入动作</span></span><br><span class="line"><span class="keyword">assert</span> action.shape == (<span class="number">4</span>,) <span class="comment"># 确保输入的动作形状是（4，）</span></span><br><span class="line">action = action.copy()      <span class="comment"># ensure that we don&#x27;t change the action outside of this scope</span></span><br><span class="line">pos_ctrl, gripper_ctrl = action[:<span class="number">3</span>], action[<span class="number">3</span>]  <span class="comment"># 将动作差分成位置控制[:3]和夹爪控制[3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输入动作值进行处理，末端位置进行缩放，旋转固定，夹爪根据条件是否设0</span></span><br><span class="line">pos_ctrl *= <span class="number">0.05</span>  <span class="comment"># 限制位置变化的最大值</span></span><br><span class="line">rot_ctrl = [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]  <span class="comment"># 固定末端执行器的旋转，使用四元数表示</span></span><br><span class="line"><span class="comment">#rot_ctrl = [ 0.5, -0.5, 0.5, 0.5 ]  # 90 deg rotation of the original end effector, expressed as a quaternion</span></span><br><span class="line">gripper_ctrl = np.array([gripper_ctrl, gripper_ctrl])   <span class="comment"># 夹爪复制成两个</span></span><br><span class="line"><span class="keyword">assert</span> gripper_ctrl.shape == (<span class="number">2</span>,)</span><br><span class="line"><span class="keyword">if</span> self.block_gripper:  <span class="comment"># 如果block_gripper，则将手指位置设置为0</span></span><br><span class="line">gripper_ctrl = np.zeros_like(gripper_ctrl)</span><br><span class="line"><span class="comment"># 将经过修改后的位置控制、固定的末端执行器旋转和处理后的夹爪控制连接成一个新的动作数组 action</span></span><br><span class="line">action = np.concatenate([pos_ctrl, rot_ctrl, gripper_ctrl])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply action to simulation. 将动作应用到仿真环境中</span></span><br><span class="line">utils.ctrl_set_action(self.sim, action)</span><br><span class="line">utils.mocap_set_action(self.sim, action)</span><br></pre></td></tr></table></figure><p>可以看出在本算法中，机器人的动作被定义为了长度为4的数组，四个值分别代表机器人末端的控制位置和夹爪开合大小。（这里旋转被忽略了，因为任务是抓取方块到指定位置，所以算法直接设置末端永远竖直向下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = [x, y, z, gripper]</span><br></pre></td></tr></table></figure><p>实际上gym中机器人的<code>action</code>使用长度为9的数组进行控制，分别代表末端的空间位置3个变量，末端的空间姿态四元数，夹爪两个平行板的动作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = [x, y, z, quat1, quat2, quat3, quat4, gripper_l, gripper_r]</span><br></pre></td></tr></table></figure><p><strong>（2）观测状态</strong></p><p>观测状态通过如下代码获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_obs</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;获得环境的观察&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 位置</span></span><br><span class="line">    grip_pos = self.sim.data.get_site_xpos(<span class="string">&#x27;robot0:grip&#x27;</span>)   <span class="comment"># 获取机器人手爪的位置</span></span><br><span class="line">    dt = self.sim.nsubsteps * self.sim.model.opt.timestep</span><br><span class="line">    grip_velp = self.sim.data.get_site_xvelp(<span class="string">&#x27;robot0:grip&#x27;</span>) * dt    <span class="comment"># 计算手爪的线速度</span></span><br><span class="line">    robot_qpos, robot_qvel = utils.robot_get_obs(self.sim)  <span class="comment"># 使用辅助函数获取机器人的位置和速度</span></span><br><span class="line"></span><br><span class="line">    gripper_state = robot_qpos[-<span class="number">2</span>:]     <span class="comment"># 提取了夹爪的状态和速度</span></span><br><span class="line">    gripper_vel = robot_qvel[-<span class="number">2</span>:] * dt  <span class="comment"># change to a scalar if the gripper is made symmetric</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将夹爪的位置、状态、夹爪线速度、速度连接起来，形成初始观察</span></span><br><span class="line">    obs = np.concatenate([</span><br><span class="line">        grip_pos,</span><br><span class="line">        gripper_state,</span><br><span class="line">        grip_velp,</span><br><span class="line">        gripper_vel,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储已经到达的目标</span></span><br><span class="line">    achieved_goal = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有的方块</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_blocks):</span><br><span class="line">    <span class="comment"># for i in range(1):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取方块们的位置、姿态、速度、相对位置、相对速度</span></span><br><span class="line">        object_i_pos = self.sim.data.get_site_xpos(self.object_names[i])</span><br><span class="line">        <span class="comment"># rotations</span></span><br><span class="line">        object_i_rot = rotations.mat2euler(self.sim.data.get_site_xmat(self.object_names[i]))</span><br><span class="line">        <span class="comment"># velocities</span></span><br><span class="line">        object_i_velp = self.sim.data.get_site_xvelp(self.object_names[i]) * dt</span><br><span class="line">        object_i_velr = self.sim.data.get_site_xvelr(self.object_names[i]) * dt</span><br><span class="line">        <span class="comment"># gripper state</span></span><br><span class="line">        object_i_rel_pos = object_i_pos - grip_pos</span><br><span class="line">        object_i_velp -= grip_velp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接到观察值中</span></span><br><span class="line">        obs = np.concatenate([</span><br><span class="line">            obs,</span><br><span class="line">            object_i_pos.ravel(),</span><br><span class="line">            object_i_rel_pos.ravel(),</span><br><span class="line">            <span class="comment">#object_i_rot.ravel(),</span></span><br><span class="line">            object_i_velp.ravel(),</span><br><span class="line">            <span class="comment">#object_i_velr.ravel()</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This is current location of the blocks</span></span><br><span class="line">        <span class="comment"># 方块们的当前位置</span></span><br><span class="line">        achieved_goal = np.concatenate([</span><br><span class="line">            achieved_goal, object_i_pos.copy()</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    achieved_goal = np.concatenate([achieved_goal, grip_pos.copy()])</span><br><span class="line"></span><br><span class="line">    achieved_goal = np.squeeze(achieved_goal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.use_force_sensor:</span><br><span class="line">        self.sim.data.get_sensor(<span class="string">&#x27;force_sensor&#x27;</span>) </span><br><span class="line">        force_reading = self.sim.data.sensordata <span class="comment"># Read force sensor reading from tray</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        force_reading = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;observation&#x27;</span>: obs.copy(),</span><br><span class="line">        <span class="string">&#x27;achieved_goal&#x27;</span>: achieved_goal.copy(),</span><br><span class="line">        <span class="string">&#x27;desired_goal&#x27;</span>: self.goal.copy(),</span><br><span class="line">        <span class="string">&#x27;force_sensor&#x27;</span>: force_reading.copy()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出观测状态是一个字典：</p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">observation</td><td style="text-align:left">[grip_x, grip_y, grip_z,</td><td style="text-align:left">grip_pos，末端位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_q1, grip_q2, grip_q3, grip_q4,</td><td style="text-align:left">grip_quat，末端姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">gripper_left, gripper_right,</td><td style="text-align:left">gripper_state，夹爪两侧状态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_vx, grip_vy, grip_vz,</td><td style="text-align:left">grip_vel，末端速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_wx, grip_wy, grip_wz</td><td style="text-align:left">grip_w，末端角速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">gripper_vl, gripper_vr,</td><td style="text-align:left">gripper_vel，夹爪两侧速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_x, obj1_y, obj1_z,</td><td style="text-align:left">obj_i_pos，方块 i 位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_q1, obj1_q2, obj1_q3, obj1_q4</td><td style="text-align:left">obj_i_quat，方块 i 姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_rx, obj1_ry, obj1_rz,</td><td style="text-align:left">obj_i_rel_pos，方块 i 相对末端位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_rq1, obj1_rq2, obj1_rq3, obj1_rq4</td><td style="text-align:left">obj_i_rel_quat，方块 i 相对末端姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_vx, obj1_vy, obj1_vz,</td><td style="text-align:left">obj_i_velp, 方块 i 相对末端速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_wx, obj1_wy, obj1_wz,</td><td style="text-align:left">obj_i_wp，方块 i 相对末端角速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj2…</td><td style="text-align:left">方块 2 位置、相对位置、相对速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obji…]</td><td style="text-align:left">方块 i 位置、相对位置、相对速度</td></tr><tr><td style="text-align:left">achieved_goal</td><td style="text-align:left">[obj1_x, obj1_y, obj1_z,<br>obj1_q1, obj1_q2, obj1_q3, obj1_q4,<br>…</td><td style="text-align:left">每调用一次_get_obs()方法<br>保存所有方块的位置姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_x, grip_y, grip_z,<br>grip_q1, grip_q2, grip_q3, grip_q4<br>…]</td><td style="text-align:left">将当前末端位置<br>添加到 achieved_goal 最后</td></tr><tr><td style="text-align:left">desired_goal</td><td style="text-align:left">[[x1, y1, z1], [x2, y2, z2], … ]</td><td style="text-align:left">多个目标位置</td></tr><tr><td style="text-align:left">force_sensor</td><td style="text-align:left">[f_x, f_y, f_z]</td><td style="text-align:left">force_reading，末端力，默认[0,0,0]</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><!--python data/collect_demos_reskill_6d.py --num_trajectories 40000 --subseq_len 10python train_skill_modules.py --config_file pickplace/config.yaml --dataset_name fetch_pickplace_40000python utils/test_skill_modules.py --dataset_name fetch_pickplace_40000 --use_skill_prior Truepython train_reskill_agent.py --config_file pickplace/config.yaml --dataset_name fetch_pickplace_40000python utils/test_reskill_agent.py --dataset_name fetch_pickplace_40000 --env_name FetchPourWater-v0--><p>💰</p>]]></content>
    
    
    <summary type="html">基于技能单元的强化学习方法，将任务分解为技能，建立技能与状态的映射关系，学习技能选择策略</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人动作" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A8%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】Dex 演示引导强化学习与手术机器人任务自动化的高效探索</title>
    <link href="https://www.mahaofei.com/post/90275938.html"/>
    <id>https://www.mahaofei.com/post/90275938.html</id>
    <published>2023-11-21T06:00:57.000Z</published>
    <updated>2023-11-21T06:00:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：Demonstration-Guided Reinforcement Learning with Efficient Exploration for Task Automation of Surgical Robot<br><strong>标题</strong>：演示引导强化学习与手术机器人任务自动化的高效探索<br><strong>作者团队</strong>：香港中文大学（刘云辉团队）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/med-air/DEX">https://github.com/med-air/DEX</a></p></blockquote><h2 id="1-1-目标问题-5">1.1 目标问题</h2><p>虽然基于强化学习的方法为手术自动化提供了可能的方案，但是通常需要大量收集数据才能进行学习。因此本文目的是提高从演示中探索学习的效率，有效地利用专家演示数据。</p><p>具体而言，目前的问题如下：</p><ul><li>使用强化学习，如果不给出演示数据而仅通过探索学习，需要收集大量的数据来解决任务；</li><li>使用演示数据的方法，例如赋予演示数据相对于机器人探索数据更高的优先级，效率仍然低下，设置额外奖励函数的方法不仅只能针对特定环境，且容易引起局部最优；</li><li>使用 actor-critic 框架，通过正则化 actor 损失来衡量机器人与专家之间的行为差异，但是这种方式效率较低（尤其在初期机器人与演示差距较大情况下），且没有考虑 critic 的正则化，容易导致高估问题。</li></ul><p>本文贡献：</p><ul><li>提出一种 actor-critic 框架，降低 critic 的高估问题，提高强化学习过程中类似专家的行动进行探索。</li><li>使用非参数引导传播，实现未观测状态的探索</li><li>在 SurRoL 手术机器人上实验验证，效果优秀，同时部署在 dVRK 上，同样表示出强大的潜力。</li></ul><blockquote><p>dVRK(da Vinci Research Kit，达芬奇手术机器人系统)</p></blockquote><h2 id="1-2-方法-5">1.2 方法</h2><p>DEX(Demonstration-guided EXploration)，演示引导探索。</p><p><strong>（0）问题定义</strong></p><p>将手术机器人动作学习考虑为一个 off-policy 的智能体，在由马尔可夫决策过程构建的环境中进行交互。</p><blockquote><p>off-policy，指智能体不使用当前的策略来决定行动，而是使用不同的策略来生成行为数据，从过去的经历中学到最优的行为决策方法。</p></blockquote><p>在 $t$ 时刻，机器人根据当前状态 $s_t$ 以及确定性策略 $\pi$ 执行行动，环境用 $r_t=r(s_t,a_t)$ 奖励智能体，然后状态转移 $s_{t+1}$。</p><p>循环此过程，每次智能体将经验 $(s+t,a_t,r_t,s_{t+1})$ 存入重放缓冲区 $D_A$。</p><p>同时设置一个演示缓冲区 $D_E$，用于存放专家策略 $\pi$ 经验。</p><p><img src="https://img.mahaofei.com/img/202311151037433.png" alt="image.png"></p><p>如图，该方法由两部分组成：</p><ul><li>基于 actor-critic 的策略学习模块（右下角），用于从演示数据中指导探索；</li><li>基于最近邻匹配和局部加权回归的非参数模块（左上角），用于将与当前状态相差过大的演示传播到为当前状态。</li></ul><p><strong>（1）专家引导的 actor-critic 框架</strong></p><p>现有的 actor-critic 方法通过最大化预期回报来学习最优策略，但是如果 Q 值估计不准确，会阻碍探索。本文通过利用智能体和专家策略之间的动作差距来增强环境奖励。</p><p>$$<br>\max_{\pi}\mathbb{E}<em>{\pi}\left[\sum</em>{t=0}^{\infty}\gamma^{t}(r_{t}-\alpha d(a_{t},a_{t}^{e}))\right],a_{t}^{e}:=\pi^{e}(s_{t}),<br>$$</p><p>其中 $\alpha$ 是探索系数，$d()$ 衡量智能体动作和专家动作之间的相似性距离度量。</p><p>基于此奖励，本文设计了正则化 Q 函数（critic），并最小化动作价值和状态价值的差距。</p><p><strong>（2）有限演示情况下的引导的传播</strong></p><p>智能体在初始学习阶段很容易探索演示未覆盖的区域，无法实现监督 actor 探索。</p><p>常规的解决思路有行为克隆，但是当状态相差较大时，策略与专家行动仍会有较大的不同。因此本文使用非参数回归模型，从有限的演示中将经验传播实现更稳定的引导。</p><p>首先从演示缓冲区采样一小批状态和动作，然后给定一个当前状态，在一小批状态中搜索，利用 k 近邻方法找到最接近的状态，然后使用指数和函数的局部加权回归方法近似专家策略。</p><p>$$<br>\hat{\pi}^e(s)=\frac{\sum_{i=1}^k\exp\left(-|s-s^{(i)}|<em>2\right)\cdot a^{(i)}}{\sum</em>{i=1}^k\exp\left(-|s-s^{(i)}|_2)\right)}.<br>$$</p><h1>二、算法复现</h1><h2 id="2-1-环境配置">2.1 环境配置</h2><p>clone代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/med-air/DEX.git</span><br><span class="line">cd DEX</span><br></pre></td></tr></table></figure><p>创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n dex python=3.8</span><br><span class="line">conda activate dex</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -e SurRoL/# install surrol environments</span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line">pip3 install -e .</span><br></pre></td></tr></table></figure><p>在虚拟环境的<code>gym/envs/__init__.py</code>的第一行注册SurRoL任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">directory: anaconda3/envs/dex/lib/python3.8/site-packages/gym/envs/__init__.py</span></span><br><span class="line">import surrol.gym</span><br></pre></td></tr></table></figure><h2 id="2-2-数据采集">2.2 数据采集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir SurRoL/surrol/data/demo</span><br><span class="line">python SurRoL/surrol/data/data_generation.py --env NeedlePick-v0 </span><br></pre></td></tr></table></figure><h2 id="2-3-训练">2.3 训练</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 train.py task=NeedlePick-v0 agent=dex use_wb=True</span><br></pre></td></tr></table></figure><p>作者提供的程序中也包括了其它强化学习与模仿学习算法，例如：</p><ul><li>DDPG：深度确定性策略梯度的强化学习</li><li>DDPGBC：深度确定性策略梯度的强化学习+行为克隆</li><li>SAC：最大熵无模型深度强化学习</li><li>SQIL：正则化行为克隆的模仿学习</li><li>COL：行为克隆与强化学习</li><li>AWAC：离线强化学习</li><li>AMP：对抗模仿学习</li></ul><h1>三、代码理解</h1><h2 id="3-1-基本定义">3.1 基本定义</h2><p><strong>（1）机器人状态</strong></p><p>通过以下函数获取机器人状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SurRoL.surrol.tasks.psm_env.PsmEnv._get_robot_state</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_robot_state</span>(<span class="params">self, idx: <span class="built_in">int</span></span>) -&gt; np.ndarray:</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;获取机器人的状态，返回机器人当前位姿、夹爪角度，两者拼接成一个数组（3位置+3欧拉角+1开合角度）&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># robot state: tip pose in the world coordinate</span></span><br><span class="line">psm = self.psm1 <span class="keyword">if</span> idx == <span class="number">0</span> <span class="keyword">else</span> self.psm2</span><br><span class="line">pose_world = psm.pose_rcm2world(psm.get_current_position(), <span class="string">&#x27;tuple&#x27;</span>)    <span class="comment"># 机器人在世界坐标系下的位姿</span></span><br><span class="line">jaw_angle = psm.get_current_jaw_position()  <span class="comment"># 夹爪角度</span></span><br><span class="line"><span class="keyword">return</span> np.concatenate([</span><br><span class="line">np.array(pose_world[<span class="number">0</span>]), np.array(p.getEulerFromQuaternion(pose_world[<span class="number">1</span>])), np.array(jaw_angle).ravel()</span><br><span class="line">])  <span class="comment"># 3 + 3 + 1 = 7</span></span><br></pre></td></tr></table></figure><p>因此机器人的状态为一个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot_state = [x, y, z, roll, pitch, yaw, gripper]</span><br></pre></td></tr></table></figure><p><strong>（2）观测状态</strong></p><p>观测状态通过以下方法进行获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SurRoL.surrol.tasks.psm_env.PsmEnv._get_obs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_obs</span>(<span class="params">self</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;获取当前环境状态信息（机器人当前位置、目标物体位置、机器人与目标物体的相对位置）&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 获取机器人当前状态</span></span><br><span class="line">robot_state = self._get_robot_state(idx=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> may need to modify</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境中是否有物体，如果有则获取目标物体的位置、姿态、相对于机器人的位置</span></span><br><span class="line"><span class="keyword">if</span> self.has_object:</span><br><span class="line">pos, _ = get_link_pose(self.obj_id, -<span class="number">1</span>)     <span class="comment"># 目标物体位置</span></span><br><span class="line">object_pos = np.array(pos)</span><br><span class="line">pos, orn = get_link_pose(self.obj_id, self.obj_link1)   <span class="comment"># 获取目标物体的特定link的位置和方向</span></span><br><span class="line">waypoint_pos = np.array(pos)    <span class="comment"># 路径点位置为目标物体link位置</span></span><br><span class="line"><span class="comment"># rotations</span></span><br><span class="line">waypoint_rot = np.array(p.getEulerFromQuaternion(orn))  <span class="comment">#路径点姿态为目标物体link姿态</span></span><br><span class="line"><span class="comment"># relative position state</span></span><br><span class="line">object_rel_pos = object_pos - robot_state[<span class="number">0</span>: <span class="number">3</span>] <span class="comment"># 相对位置为目标位置与机器人末端位置之差</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> can have a same-length state representation</span></span><br><span class="line">object_pos = waypoint_pos = waypoint_rot = object_rel_pos = np.zeros(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定使用哪个位置作为目标位置</span></span><br><span class="line"><span class="keyword">if</span> self.has_object:</span><br><span class="line"><span class="comment"># object/waypoint position，使用物体位置object_pos，或物体link位置waypoint_pos</span></span><br><span class="line">achieved_goal = object_pos.copy() <span class="keyword">if</span> <span class="keyword">not</span> self._waypoint_goal <span class="keyword">else</span> waypoint_pos.copy()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># tip position，如果没有目标物体，则将机器人末端的位置作为目标位置</span></span><br><span class="line">achieved_goal = np.array(get_link_pose(self.psm1.body, self.psm1.TIP_LINK_INDEX)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">observation = np.concatenate([</span><br><span class="line">robot_state, object_pos.ravel(), object_rel_pos.ravel(),</span><br><span class="line">waypoint_pos.ravel(), waypoint_rot.ravel()  <span class="comment"># achieved_goal.copy(),</span></span><br><span class="line">])</span><br><span class="line">obs = &#123;</span><br><span class="line"><span class="string">&#x27;observation&#x27;</span>: observation.copy(),</span><br><span class="line"><span class="string">&#x27;achieved_goal&#x27;</span>: achieved_goal.copy(),</span><br><span class="line"><span class="string">&#x27;desired_goal&#x27;</span>: self.goal.copy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obs</span><br></pre></td></tr></table></figure><p>可以看出观测状态是一个字典，包含三个键：<code>observation</code>, <code>achieved_goal</code>, <code>desired_goal</code>。</p><ul><li>observation: 由robot_state, object_pos.ravel(), object_rel_pos.ravel(), waypoint_pos.ravel(), waypoint_rot.ravel()组成，</li></ul><table><thead><tr><th style="text-align:left">obs</th><th style="text-align:left">键值（三个都是一维数组）</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">observation</td><td style="text-align:left">[robot_x, robot_y, robot_z, robot_roll, robot_pitch, robot_yaw, gripper,</td><td style="text-align:left">机器人末端位姿和夹爪状态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_x, obj_y, obj_z,</td><td style="text-align:left">目标物体位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_rel_x, obj_rel_y, obj_rel_z,</td><td style="text-align:left">目标物体与当前机械臂相对位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_link1_x, obj_link1_y, obj_link1_z</td><td style="text-align:left">目标物体的link1位置作为waypoint位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_link1_roll, obj_link1_pitch, obj_link1_yaw]</td><td style="text-align:left">目标物体的link1姿态作为waypoint姿态</td></tr><tr><td style="text-align:left">achieved_goal</td><td style="text-align:left">[x, y, z]</td><td style="text-align:left">waypoint作为实际位置，未设置link1则用目标物体位置作为实际位置，无物体则用机器人末端位置为实际位置</td></tr><tr><td style="text-align:left">desired_goal</td><td style="text-align:left">[x, y, z]</td><td style="text-align:left">机器人末端的目标位置</td></tr></tbody></table><p><strong>（3）机器人动作</strong></p><p>机器人动作通过以下方法进行执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SurRoL.surrol.tasks.psm_env.PsmEnv._set_action</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_set_action</span>(<span class="params">self, action: np.ndarray</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">delta_position (3), delta_theta (1) and open/close the gripper (1)</span></span><br><span class="line"><span class="string">in the world frame</span></span><br><span class="line"><span class="string">执行动作的过程（位置的变化，旋转变化，夹爪的开合）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(action) == self.ACTION_SIZE, <span class="string">&quot;The action should have the save dim with the ACTION_SIZE&quot;</span> <span class="comment"># ACTION_SIZE = 5</span></span><br><span class="line"><span class="comment"># time0 = time.time()</span></span><br><span class="line">action = action.copy()  <span class="comment"># ensure that we don&#x27;t change the action outside of this scope</span></span><br><span class="line">action[:<span class="number">3</span>] *= <span class="number">0.01</span> * self.SCALING  <span class="comment"># position, limit maximum change in position</span></span><br><span class="line">pose_world = self.psm1.pose_rcm2world(self.psm1.get_current_position())</span><br><span class="line">workspace_limits = self.workspace_limits1</span><br><span class="line">pose_world[:<span class="number">3</span>, <span class="number">3</span>] = np.clip(pose_world[:<span class="number">3</span>, <span class="number">3</span>] + action[:<span class="number">3</span>],</span><br><span class="line">workspace_limits[:, <span class="number">0</span>] - [<span class="number">0.02</span>, <span class="number">0.02</span>, <span class="number">0.</span>],</span><br><span class="line">workspace_limits[:, <span class="number">1</span>] + [<span class="number">0.02</span>, <span class="number">0.02</span>, <span class="number">0.08</span>])  <span class="comment"># clip to ensure convergence</span></span><br><span class="line">rot = get_euler_from_matrix(pose_world[:<span class="number">3</span>, :<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> self.ACTION_MODE == <span class="string">&#x27;yaw&#x27;</span>:</span><br><span class="line">action[<span class="number">3</span>] *= np.deg2rad(<span class="number">30</span>)  <span class="comment"># yaw, limit maximum change in rotation</span></span><br><span class="line">rot = (self.psm1_eul[<span class="number">0</span>], self.psm1_eul[<span class="number">1</span>], wrap_angle(rot[<span class="number">2</span>] + action[<span class="number">3</span>]))  <span class="comment"># only change yaw</span></span><br><span class="line"><span class="keyword">elif</span> self.ACTION_MODE == <span class="string">&#x27;pitch&#x27;</span>:</span><br><span class="line">action[<span class="number">3</span>] *= np.deg2rad(<span class="number">15</span>)  <span class="comment"># pitch, limit maximum change in rotation</span></span><br><span class="line">pitch = np.clip(wrap_angle(rot[<span class="number">1</span>] + action[<span class="number">3</span>]), np.deg2rad(-<span class="number">90</span>), np.deg2rad(<span class="number">90</span>))</span><br><span class="line">rot = (self.psm1_eul[<span class="number">0</span>], pitch, self.psm1_eul[<span class="number">2</span>])  <span class="comment"># only change pitch</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">raise</span> NotImplementedError</span><br><span class="line">pose_world[:<span class="number">3</span>, :<span class="number">3</span>] = get_matrix_from_euler(rot)</span><br><span class="line">action_rcm = self.psm1.pose_world2rcm(pose_world)</span><br><span class="line"><span class="comment"># time1 = time.time()</span></span><br><span class="line">self.psm1.move(action_rcm)</span><br><span class="line"><span class="comment"># time2 = time.time()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jaw</span></span><br><span class="line"><span class="keyword">if</span> self.block_gripper:</span><br><span class="line">action[<span class="number">4</span>] = -<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> action[<span class="number">4</span>] &lt; <span class="number">0</span>:</span><br><span class="line">self.psm1.close_jaw()</span><br><span class="line">self._activate(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.psm1.move_jaw(np.deg2rad(<span class="number">40</span>))  <span class="comment"># open jaw angle; can tune</span></span><br><span class="line">self._release(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中机器人动作是一个长度为5的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action[<span class="number">5</span>] = [delta_x, delta_y, delta_z, yaw/pitch, gripper]</span><br></pre></td></tr></table></figure><ul><li>其中<code>delta_xyz</code>代表机器人末端在xyz轴上的位移量；</li><li>yaw/pitch根据类变量ACTION_MODE定义使用哪种旋转；</li><li>夹爪为负数则关闭，如果为非负数则根据数值大小确定打开大小。</li></ul><h1>四、代码修改</h1><h2 id="4-1-环境补充">4.1 环境补充</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install hydra-core colorlog termcolor opencv-python perlin_noise</span><br><span class="line">pip install <span class="string">&quot;cython&lt;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-测试">4.2 测试</h2><ul><li>AWAC：离线强化学习</li></ul><p><strong>（1）DDPGBC：深度确定性策略梯度的强化学习+行为克隆</strong></p><table><thead><tr><th style="text-align:left">DDPGBC</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（2）SAC：最大熵无模型深度强化学习</strong></p><table><thead><tr><th style="text-align:left">SAC</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left">平移物体到达位置，成功率高</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（3）SQIL：正则化行为克隆的模仿学习</strong></p><table><thead><tr><th style="text-align:left">SQIL</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（4）COL：行为克隆与强化学习</strong></p><table><thead><tr><th style="text-align:left">CoL</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（5）AWAC：离线强化学习</strong></p><table><thead><tr><th style="text-align:left">AWAC</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">平移物体到达位置，成功率低</td><td style="text-align:left">平移物体到达位置，成功率高</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（6）AMP：对抗模仿学习</strong></p><table><thead><tr><th style="text-align:left">AMP</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left">平移物体到达位置，成功率高</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（7）DEX：演示引导的强化学习</strong></p><table><thead><tr><th style="text-align:left">DEX</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">香港中文大学刘云辉团队基于DDPG+BC改进的手术机器人强化学习方法</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="机器人动作" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A8%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>强化学习与模仿学习Buglist（不定时更新）</title>
    <link href="https://www.mahaofei.com/post/1494b0dc.html"/>
    <id>https://www.mahaofei.com/post/1494b0dc.html</id>
    <published>2023-11-14T02:15:37.000Z</published>
    <updated>2023-11-14T02:15:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 环境搭建问题</h1><h2 id="1-1-mujoco-相关">1.1 mujoco 相关</h2><h3 id="1-mujoco-py-安装后编译错误-Error-compiling-Cython-file">(1) mujoco-py 安装后编译错误 Error compiling Cython file</h3><p><strong>问题详情：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">performance hint: /home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/mujoco_py/cymj.pyx:67:5: Exception check on &#x27;c_warning_callback&#x27; will always require the GIL to be acquired.</span><br><span class="line">Possible solutions:</span><br><span class="line">1. Declare the function as &#x27;noexcept&#x27; if you control the definition and you&#x27;re sure you don&#x27;t want the function to raise exceptions.</span><br><span class="line">2. Use an &#x27;int&#x27; return type on the function to allow an error code to be returned.</span><br><span class="line">performance hint: /home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/mujoco_py/cymj.pyx:104:5: Exception check on &#x27;c_error_callback&#x27; will always require the GIL to be acquired.</span><br><span class="line">Possible solutions:</span><br><span class="line">1. Declare the function as &#x27;noexcept&#x27; if you control the definition and you&#x27;re sure you don&#x27;t want the function to raise exceptions.</span><br><span class="line">2. Use an &#x27;int&#x27; return type on the function to allow an error code to be returned.</span><br><span class="line"></span><br><span class="line">Error compiling Cython file:</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">...</span><br><span class="line">    See c_warning_callback, which is the C wrapper to the user defined function</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    global py_warning_callback</span><br><span class="line">    global mju_user_warning</span><br><span class="line">    py_warning_callback = warn</span><br><span class="line">    mju_user_warning = c_warning_callback</span><br><span class="line">                       ^</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">/home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/mujoco_py/cymj.pyx:92:23: Cannot assign type &#x27;void (const char *) except * nogil&#x27; to &#x27;void (*)(const char *) noexcept nogil&#x27;. Exception values are incompatible. Suggest adding &#x27;noexcept&#x27; to type &#x27;void (const char *) except * nogil&#x27;.</span><br><span class="line"></span><br><span class="line">Error compiling Cython file:</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">...</span><br><span class="line">    See c_warning_callback, which is the C wrapper to the user defined function</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    global py_error_callback</span><br><span class="line">    global mju_user_error</span><br><span class="line">    py_error_callback = err_callback</span><br><span class="line">    mju_user_error = c_error_callback</span><br><span class="line">                     ^</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/76985054/import-mujoco-py-is-giving-me-compiling-errors">stackoverflow</a> 与 <a href="https://github.com/openai/mujoco-py/issues/773#issuecomment-1639684035">github issue</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &quot;cython&lt;3&quot;</span><br></pre></td></tr></table></figure><h3 id="2-ERROR-GLEW-initalization-error-Missing-GL-version">(2) ERROR: GLEW initalization error: Missing GL version</h3><p><strong>问题详情：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/gym/envs/registration.py:64: UserWarning: register(timestep_limit=100) is deprecated. Use register(max_episode_steps=100) instead.</span><br><span class="line">  warnings.warn(&quot;register(timestep_limit=&#123;&#125;) is deprecated. Use register(max_episode_steps=&#123;&#125;) instead.&quot;.format(timestep_limit, timestep_limit))</span><br><span class="line">Creating window glfw</span><br><span class="line">ERROR: GLEW initalization error: Missing GL version</span><br><span class="line"></span><br><span class="line">Press Enter to exit ...Killed</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so</span><br></pre></td></tr></table></figure><blockquote><p>[!question] 配置好 gym 环境后再使用 opencv 出现 RuntimeError: Failed to initialize OpenGL<br>目前来看 gym 渲染和 opencv 显示不能同时使用。</p><ul><li>想要使用 opencv 则需要执行 <code>unset LD_PRELOAD</code>；</li><li>想要使用 gym 渲染需要执行 <code>export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so</code>。</li></ul></blockquote><h3 id="3-MujocoException-Got-MuJoCo-Warning-Nan-Inf-or-huge-value-in-QACC-at-DOF-X-The-simulation-is-unstable">(3) MujocoException: Got MuJoCo Warning: Nan, Inf or huge value in QACC at DOF X. The simulation is unstable.</h3><p><strong>问题原因：</strong></p><p>在使用<code>mujoco</code>进行强化学习训练的过程中，有可能会出先上面这种报错，从而导致训练提前终止。</p><p>这是因为在执行<code>env.step</code>过程中，环境中的模型（机器人自身或者机器人和其它物体）发生了模型穿透或者约束冲突，导致mujoco无法进行仿真。</p><p><strong>解决方法1：添加关节属性damping和armature（有效！）</strong></p><p>参考链接：<a href="https://github.com/google-deepmind/mujoco/issues/989">https://github.com/google-deepmind/mujoco/issues/989</a></p><p>在限制关节转角后，法线算法能训练的epoch数变多了，但是到后面还是会报错。</p><p>经过检查法线我的夹爪上的关节都没有设置阻尼，添加<code>damping</code>和<code>armature</code>，注意需要给所有的<code>joint</code>都添加这两个属性，包括机器人和各种物体。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;robotiq_2f_85_right_driver_joint&quot;</span> <span class="attr">range</span>=<span class="string">&quot;0 0.834&quot;</span> <span class="attr">damping</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">armature</span>=<span class="string">&#x27;0.01&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>之后再进行训练，再也没有出现过错误。</p><p>注意：<code>damping</code>和<code>armature</code>这两个参数可能需要调节，尤其是夹爪等比较小的部件，如果这里的阻尼设置的太大，会出现关节无法运动的情况。</p><p><strong>其它方法2：限制关节范围（有一定效果）</strong></p><p>对于我的机械臂模型而言，由于我的目标任务是抓取，机械臂原本的活动范围设置的很大，在调试过程中也能够发现在很多情况下机械臂会与自身碰撞、或与桌面碰撞。</p><p>我的方法是：手动控制机械臂在<code>mujoco</code>环境中运动，使其到达任务空间的极限位置，使用下面的命令，打印出各<code>joint</code>在极限位置的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.qpos[model.jnt_qposadr])</span><br></pre></td></tr></table></figure><p>根据所有极限位置，确定各个关节的取值范围。</p><p>然后在模型的<code>.xml</code>文件中，修改<code>&lt;wholebody&gt;</code>中各个<code>&lt;joint&gt;</code>的<code>range</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 初始 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;joint name=&quot;joint1&quot; pos=&quot;0 0 0&quot; axis=&quot;0 0 1&quot; armature=&quot;1.5708&quot; limited=&quot;true&quot; range=&quot;-3.14159 3.14159&quot; damping=&#x27;200&#x27; /&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 测试关节范围(抓取) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">armature</span>=<span class="string">&quot;1.5708&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-1.57079 1.57079&quot;</span> <span class="attr">damping</span>=<span class="string">&#x27;200&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>经过测试，只改变<code>joint</code>的<code>range</code>后，能迭代的次数变多了，但是还是没有解决问题。</p><p><strong>其它方法3：修改奖励函数（有一定效果）</strong></p><p>因为报错的原因是机器人的动作超出了工作空间或者发生了碰撞，那么说明学习算法没有学习到合适的动作，让机器人产生了错误的运动。</p><p>因此考虑修改奖励函数，加入超出工作空间的惩罚，例如对于抓取，如果夹爪末端位置xyz超出一定坐标，则给予惩罚，以及夹爪距离物体过远，也给予惩罚。</p><p>这种方式有一定效果。</p><p><strong>其它方法4：减小solrel（未尝试）</strong></p><p>参考链接：<a href="https://github.com/google-deepmind/mujoco/discussions/63">https://github.com/google-deepmind/mujoco/discussions/63</a></p><p><strong>其它方法5：改用RK4积分器（无效）</strong></p><p>参考链接：<a href="https://github.com/google-deepmind/mujoco/issues/168">https://github.com/google-deepmind/mujoco/issues/168</a></p><p><strong>其它方法6：检查环境设置（有效）</strong></p><p>检查环境的<code>reset</code>函数是否设置正确，经过检查，我发现我的代码问题在于重置了环境和机械臂的各个关节，但是没有重置<code>mocap</code>，导致如果上一次仿真最后机械臂末端漂了，这一次一开始机械臂就会漂的很远，随着仿真的进行就容易出现上面的错误。</p>]]></content>
    
    
    <summary type="html">强化学习环境搭建，项目运行过程中可能遇到的bug与解决方法记录</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="强化学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="bugs" scheme="https://www.mahaofei.com/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】基于强化学习的机器人动作模仿</title>
    <link href="https://www.mahaofei.com/post/6fa4482c.html"/>
    <id>https://www.mahaofei.com/post/6fa4482c.html</id>
    <published>2023-11-09T07:36:15.000Z</published>
    <updated>2023-11-09T07:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1 Reinforcement Learning with Videos: Combining Offline Observations with Interaction</h1><blockquote><p><strong>标题</strong>：视频强化学习：将离线观察与互动相结合<br><strong>作者团队</strong>：宾夕法尼亚大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/kschmeckpeper/rl_with_videos">https://github.com/kschmeckpeper/rl_with_videos</a></p></blockquote><h2 id="1-1-目标问题-7">1.1 目标问题</h2><p>应用强化学习使机器人学习技能，通常需要大量的机器人在线数据，但是机器人的数据收集非常麻烦困难，难以获得足够多的数据。</p><p>人类视频广泛且多样，因此考虑从人类经验中进行强化学习。但因为人类视频没有动作的标注，并且人类视频和机器人相机图像，具有巨大的图像差异和视角差异。具体问题如下：</p><ul><li>机器人必须能通过观察来更新策略，不需要任何的行动或者奖励；</li><li>人手与末端执行器视觉差异较大，自由度也不同，因此需要考虑动作空间、形态、视角、环境差异带来的变化；</li></ul><p>为了解决这些问题，本文提出了视频强化学习框架（Reinforcement Learning with Videos，RLV），使用人类数据经验和机器人数据学习策略和价值函数。</p><h2 id="1-2-方法-7">1.2 方法</h2><p><strong>（1）问题定义</strong></p><p>该论文将问题公式化为马尔可夫决策过程 MDP，定义成元组 $(S_{int},A_{int},P,R)$，其中 $S_{int}$ 是状态空间，$A_{int}$ 是动作空间，$P$ 是环境的动力学，$R$ 是奖励函数。</p><p>机器人首先被提供了人类的观测 ${(s_{obs},s_{int}')_{1:t}}$，这些观察被建模成另一组马尔可夫决策链，其具有不同的状态和动作空间，但是两者的动力学和奖励函数是相同的。</p><p><strong>（2）方法概述</strong></p><p>该论文所提出的方法如下图所示，包含两个重放池，一个是无动作的观测数据 $(s_{obs},s_{obs}‘)\in D_{obj}$，另一个是包含动作条件的交互数据 $(s_{int},a_{int},s_{int}’,r_{int})\in D_{int}$，交互数据在训练期间会更新，而观测数据仅仅是初始的观测数据集。</p><blockquote><p><strong>重放池 (reply pool)</strong>：存储了智能体过去经历过的（状态，动作，奖励，新状态）的数据结构，通过采样这个池中的数据进行训练，可以从过去的经验中学习更多的规律，提高决策能力。</p></blockquote><p><img src="https://img.mahaofei.com/img/202311091616113.png" alt="image.png"></p><ul><li>左图：从动作条件重放池中采样数据 $(s_{int},a_{int},s_{int}‘,r_{int})$，将观测状态分别编码成特征 $h_{int},h_{int}’$，训练一个可逆的模型，来从特征中预测动作 $a_{int}$。</li><li>中图：将这个可逆模型用于根据观测状态特征 $h_{obs},h_{obs}'$，预测离线视频中的缺失的机器人动作 $\hat a_{int}$，将轨迹中最后一步设置为很大的奖励，前面其它步骤都设置为很小的奖励。</li><li>右图：使用 adversarial domain confusion(ADS)来对齐特征，最后使用离线策略强化学习算法，对于数据 $((h_{int},h_{obs}),(a_{int},\hat a_{int}),(h_{int}‘,h_{obs}’),(r_{int},\hat r_{obs}))$ 进行训练。</li></ul><blockquote><p><strong>Adversarial Domain Confusion (ADC)</strong>：通过最小化源域和目标域之间的特征分布距离来实现跨域的迁移学习。</p></blockquote><p><strong>（3）动作预测</strong></p><p>本文通过监督学习训练了一个参数为 $\theta$ 的逆模型，根据一对不变的特征编码 $(h,h’)$ 计算机器人动作。由于机器人与人类视频环境相同，我们应该能够预测任一马尔可夫决策过程的数据的操作。</p><p>损失使用预测动作 $\hat a_{int}=f_{inv}(h_{int},h_{int}';\theta)$ 和真实动作的均方误差 $a_{int}$：</p><p>$$<br>L_a(a_{int},h_{int},h_{int}‘,\theta)=||a_{int}-f_{inv}(h_{int},h_{int}’;\theta)||^2<br>$$</p><p>本文使用逆模型预测人手视频中的动作数据，并用它们来训练强化学习算法。</p><p><strong>（4）奖励生成</strong></p><p>由于强化学习使用观测数据的一个障碍就是缺乏奖励，虽然可以通过上面训练的逆模型预测奖励和动作，但实际上效果可能不会很好。</p><p>本文使用了替代方案，将观测数据轨迹的最后一个时间步长分配一个大的恒定奖励，之前的每一个时间步长分配一个小的恒定奖励。</p><p>这种方式目的是保证观测数据在轨迹结束时达到目标状态。至于其中的不准确之处，可以通过机器人收集的交互数据训练来消除。</p><p><strong>（5）域自适应</strong></p><p>要使用观测数据 $(s_{obs},s_{obs})'$，需要将其映射到一个不变的量 $h$。</p><p>为了实现这个目的，本文训练了一种特征编码器 $f_{enc}$，来从观测状态 $s$ 中学习编码表示 $h=f_{enc}(s;\psi)$，这种编码器应该包含所有相关的信息，并对与观测的域来说是不变的。</p><p>本文还训练了一个鉴别器，用于区分观测数据中提取的特征 $h_{obs}$ 和机器人交互数据中提取的特征 $h_{int}$。</p><p>将特征编码器和鉴别器使用对抗性学习方法进行训练，过程中编码器试图最小化鉴别器对编码特征的域的正确分类能力，鉴别器试图最大化分类能力。</p><p>最终获得的编码器就是我们需要的，将观测数据和机器人交互数据映射到不变量 $h$ 的编码器。</p><p><strong>（6）联合优化</strong></p><p>将领域自适应损失和逆模型的损失进行联合优化。</p><h1>2 Learning Generalizable Robotic Reward Functions from “In-The-Wild” Human Videos</h1><blockquote><p><strong>标题</strong>：从“野外”人类视频中学习可推广的机器人奖励函数<br><strong>作者团队</strong>：斯坦福大学<br><strong>期刊会议</strong>：Robotics: Science and Systems (RSS)<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://sites.google.com/view/dvd-human-videos">https://sites.google.com/view/dvd-human-videos</a></p></blockquote><h2 id="2-1-目标问题-3">2.1 目标问题</h2><p>要实现通用型机器人完成各类任务，关键是机器人能够知道任务成功和奖励的能力，该奖励函数还必须能够在不同环境、任务、对象中推广。</p><p>由于收集大规模机器人交互数据是一件十分复杂困难的问题，而人类视频中则包含了大量的不同环境中的任务信息。</p><p>本文提出了一种不可知域视频鉴别器(Domain-agnostic Video Discriminator, DVD)，通过训练鉴别器来分类两个视频是否执行相同的任务学习多任务奖励函数。并通过少量的机器人训练数据学习人类视频的广泛数据集进行推广。</p><p>要解决的问题：</p><ul><li>人类的 wild data 和机器人的观测空间有着巨大的域变换，不管是 agent 的形态、还是场景的外观。</li><li>人类的动作空间和机器人的动作空间不同，可能不能很好的实现动作的映射</li><li>人类视频很多情况下是低质量的、有噪声的，还有着复杂的背景或视角</li></ul><p>解决思路：</p><ul><li>训练一个分类器预测两个视频是否完成的是同一个任务，也就是不可知域视频鉴别器（DVD）</li><li>训练完成后，DVD 能够将人类视频作为演示，机器人的行为作为另一个视频，输出一个分数，衡量任务成功的奖励。</li></ul><h2 id="2-2-方法-3">2.2 方法</h2><p><strong>（1）Domain-Agnostic Video Discriminators</strong></p><ul><li>一个预训练视频编码器将视频 $d_i$ 编码为特征 $h_i$</li><li>一个全连接神经网络，预测两个视频是否完成同样的任务<ul><li>损失函数设置见原文</li><li>奖励函数通过训练分类器来获得</li></ul></li></ul><p>本文的关键是训练一个分类器来学习 $R_\theta$，该分类器两个视频作为输入，判断两个视频是否属于同一个任务。视频可以来自于人类数据集或机器人数据集。</p><p>首先对视频进行采样，设两个视频为 $d_i$ 和 $d_j$，采样一批视频 $(d_i,d_i’,d_j)$ 其中 $d_i$ 和 $d_i’$ 是完成相同的任务，$d_j$ 是完成不同的个任务，最小化平均交叉熵损失训练 $R_\theta$，损失函数见原文，最终得到奖励函数如下：</p><p>$$<br>R_\theta(d_i,d_j)=f_{sin}(f_{enc}(d_i),f_{enc}(d_j);\theta)<br>$$</p><p>其中 $h=f_{enc}$ 是一个预训练的视频编码器，$f_{sin}(h_i,h_j;\theta)$ 是一个参数为 $\theta$ 的全连接神经网络，用来预测两个视频编码特征 $h_i,h_j$ 是否完成同样的任务。</p><p><strong>（2）使用 DVD 执行任务</strong></p><p>使用视觉模型预测控制(Visual Model Predictive Control, VMPC)实现。</p><p><img src="https://img.mahaofei.com/img/202311101115799.png" alt="image.png"></p><ol><li>使用 SV2P 模型训练动作条件视频预测模型 $\rho$</li><li>使用交叉熵和该动作模型 $\rho$ 选择与人类演示最相似的动作<ol><li>对输入图像，从动作分布中采样多个动作序列，并使用动作模型 $\rho$ 预测相应的未来轨迹</li><li>将每个预测轨迹和人类演示视频，输入DVD，得到任务相似性分数</li><li>执行与演示图象具有最高相似性的动作轨迹</li></ol></li></ol><h1>3 PLAS: Latent Action Space for Offline Reinforcement Learning</h1><blockquote><p><strong>标题</strong>：PLAS：离线强化学习的潜在行动空间<br><strong>作者团队</strong>：卡耐基梅隆大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2021<br><strong>代码</strong>： <a href="https://github.com/sfujim/BCQ">https://github.com/sfujim/BCQ</a></p></blockquote><h2 id="3-1-目标问题-2">3.1 目标问题</h2><p>离线强化学习可以从固定的数据集中学习策略。</p><p>在机器人中，数据收集十分麻烦且有一定的危险性，现有的方法从离线数据集中进行学习，性能十分受限。</p><p>本文提出了潜在动作空间中的策略(Policy in the Latent Action Space, PLAS)。</p><h2 id="3-2-方法-2">3.2 方法</h2><p><strong>（0）原理基础-离线 RL</strong></p><p>给定一个固定的离线数据集 $D={(s_t,a_t,r_t,s_{t+1})_i}$，难点在于该数据集没有覆盖马尔科夫决策过程 MDP 的整个状态空间和动作空间。</p><p>离线 RL 目的就是学习能使奖励最大化的策略，而策略受到我们对马尔可夫决策过程的了解，马尔可夫决策过程则是从有限的数据集中推理得到的。</p><p>但如果考虑离线 RL 的目标是最大化 MDP 在有限数据集下的累计回报，也能作为近似替代。并且在近似 Q 函数的时候会存在推理误差，</p><p><img src="https://img.mahaofei.com/img/202311122207187.png" alt="image.png"></p><p>给定一个状态，潜在策略输出一个潜在动作，使用解码器将其解码为动作空间输出。（可以添加扰动层来增加泛化能力）</p><p><strong>（1）潜在动作空间中的策略（Policy in Latent Action Space, PLAS）</strong></p><p>给定离线数据集，本文使用条件变分自动编码器（Conditional Variational Autoencoder, CVAE）对策略进行建模。为了使策略约束在数据集的范围内，考虑使用确定性策略，从状态映射到潜在动作，再用解码器得到实际动作。</p><p><strong>（2）泛化</strong></p><p>潜在策略再数据集范围内能够提供约束，但是在训练的时候，本文允许了从分布外的行为的发生，即添加了一个扰动层，设置了一个超参数限制扰动层的动作输出残差。</p><p>当然，如果数据集再状态-动作空间中有着非常高的覆盖率，那么这个扰动层就是不必要的。</p><h1>4 Demonstration-Guided Reinforcement Learning with Efficient Exploration for Task Automation of Surgical Robot</h1><blockquote><p><strong>标题</strong>：演示引导强化学习与手术机器人任务自动化的高效探索<br><strong>作者团队</strong>：香港中文大学（刘云辉团队）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/med-air/DEX">https://github.com/med-air/DEX</a></p></blockquote><h2 id="4-1-目标问题">4.1 目标问题</h2><p>虽然基于强化学习的方法为手术自动化提供了可能的方案，但是通常需要大量收集数据才能进行学习。因此本文目的是提高从演示中探索学习的效率，有效地利用专家演示数据。</p><p>具体而言，目前的问题如下：</p><ul><li>使用强化学习，如果不给出演示数据而仅通过探索学习，需要收集大量的数据来解决任务；</li><li>使用演示数据的方法，例如赋予演示数据相对于机器人探索数据更高的优先级，效率仍然低下，设置额外奖励函数的方法不仅只能针对特定环境，且容易引起局部最优；</li><li>使用 actor-critic 框架，通过正则化 actor 损失来衡量机器人与专家之间的行为差异，但是这种方式效率较低（尤其在初期机器人与演示差距较大情况下），且没有考虑 critic 的正则化，容易导致高估问题。</li></ul><p>本文贡献：</p><ul><li>提出一种 actor-critic 框架，降低 critic 的高估问题，提高强化学习过程中类似专家的行动进行探索。</li><li>使用非参数引导传播，实现未观测状态的探索</li><li>在 SurRoL 手术机器人上实验验证，效果优秀，同时部署在 dVRK 上，同样表示出强大的潜力。</li></ul><blockquote><p>dVRK(da Vinci Research Kit，达芬奇手术机器人系统)</p></blockquote><h2 id="4-2-方法-2">4.2 方法</h2><p>DEX(Demonstration-guided EXploration)，演示引导探索。</p><p><strong>（0）问题定义</strong></p><p>将手术机器人动作学习考虑为一个 off-policy 的智能体，在由马尔可夫决策过程构建的环境中进行交互。</p><blockquote><p>off-policy，指智能体不使用当前的策略来决定行动，而是使用不同的策略来生成行为数据，从过去的经历中学到最优的行为决策方法。</p></blockquote><p>在 $t$ 时刻，机器人根据当前状态 $s_t$ 以及确定性策略 $\pi$ 执行行动，环境用 $r_t=r(s_t,a_t)$ 奖励智能体，然后状态转移 $s_{t+1}$。</p><p>循环此过程，每次智能体将经验 $(s+t,a_t,r_t,s_{t+1})$ 存入重放缓冲区 $D_A$。</p><p>同时设置一个演示缓冲区 $D_E$，用于存放专家策略 $\pi$ 经验。</p><p><img src="https://img.mahaofei.com/img/202311151037433.png" alt="image.png"></p><p>如图，该方法由两部分组成：</p><ul><li>基于 actor-critic 的策略学习模块（右下角），用于从演示数据中指导探索；</li><li>基于最近邻匹配和局部加权回归的非参数模块（左上角），用于将与当前状态相差过大的演示传播到为当前状态。</li></ul><p><strong>（1）专家引导的 actor-critic 框架</strong></p><p>现有的 actor-critic 方法通过最大化预期回报来学习最优策略，但是如果 Q 值估计不准确，会阻碍探索。本文通过利用智能体和专家策略之间的动作差距来增强环境奖励。</p><p>$$<br>\max_{\pi}\mathbb{E}<em>{\pi}\left[\sum</em>{t=0}^{\infty}\gamma^{t}(r_{t}-\alpha d(a_{t},a_{t}^{e}))\right],a_{t}^{e}:=\pi^{e}(s_{t}),<br>$$</p><p>其中 $\alpha$ 是探索系数，$d()$ 衡量智能体动作和专家动作之间的相似性距离度量。</p><p>基于此奖励，本文设计了正则化 Q 函数（critic），并最小化动作价值和状态价值的差距。</p><p><strong>（2）有限演示情况下的引导的传播</strong></p><p>智能体在初始学习阶段很容易探索演示未覆盖的区域，无法实现监督 actor 探索。</p><p>常规的解决思路有行为克隆，但是当状态相差较大时，策略与专家行动仍会有较大的不同。因此本文使用非参数回归模型，从有限的演示中将经验传播实现更稳定的引导。</p><p>首先从演示缓冲区采样一小批状态和动作，然后给定一个当前状态，在一小批状态中搜索，利用 k 近邻方法找到最接近的状态，然后使用指数和函数的局部加权回归方法近似专家策略。</p><p>$$<br>\hat{\pi}^e(s)=\frac{\sum_{i=1}^k\exp\left(-|s-s^{(i)}|<em>2\right)\cdot a^{(i)}}{\sum</em>{i=1}^k\exp\left(-|s-s^{(i)}|_2)\right)}.<br>$$</p><h1>5 Residual Skill Policies: Learning an Adaptable Skill-based Action Space for Reinforcement Learning for Robotics</h1><blockquote><p><strong>标题</strong>：剩余技能策略：学习基于技能的适应性行动空间，用于机器人强化学习<br><strong>作者团队</strong>：昆士兰科技大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://krishanrana.github.io/reskill">https://krishanrana.github.io/reskill</a></p></blockquote><h2 id="5-1-目标问题-2">5.1 目标问题</h2><p>基于技能的学习已经成为加速机器人学习的方法，技能从专家演示中提取，是短序列的单步操作（平移、抓取、抬起等动作），这些技能嵌入到潜在空间中，构成上层 RL 策略的行动空间。但是这种方式存在一些问题：</p><ul><li>对所有技能进行随机抽样探索，效率极低，因为其中只有一小部分技能与当前执行的任务相关，并且这些相关的技能通常不会聚集在技能空间的同一邻域内。</li><li>该方法假设技能是最优的，并且下层的任务来自于技能空间的相同分布，因此学习的通用性和变化适应性有限，例如从移动方块中学习技能，则无法应对障碍物、物体变化、不同摩擦等情况。</li></ul><p>为解决上述问题，本文提出了以下创新方法，称为残差技能策略（Residual Skill Policies，ReSkill）：</p><ul><li>状态条件技能先验：对相关技能进行采样来引导探索</li><li>底层残差策略：通过对技能进行细粒度的技能适应，实现任务变化的适应</li></ul><h2 id="5-2-方法">5.2 方法</h2><p>总的来说，该方法将经典控制器产生的演示轨迹分解为与任务无关的技能，并将其嵌入到连续到技能空间中，利用技能空间实现真正的通用学习，上层智能体能够从技能空间中访问但不动作，降低了对数据集详细程度的要求。</p><ul><li>从现有控制器中提取技能</li><li>学习技能嵌入和先验技能</li><li>训练一个分层强化学习策略，在技能空间中使用底层残差适应性策略。</li></ul><p><img src="https://img.mahaofei.com/img/202311161019261.png" alt="image.png"></p><p><strong>（1）数据收集</strong></p><p>本文通过手动控制收集演示数据（基本操作任务，如推物体、抓物体），虽然任务简单，但轨迹包含复杂的技能，可以重新组合解决复杂的任务。</p><p>轨迹是由 state-action 成对组成的，本文从中随机切片 $H$ 长度的片段进行无监督技能提取，利用提取的动作 a 和状态 s 学习下一小节中的 state-action。</p><p>其中状态 s 包括关节角度、关节速度、夹具位置、物体位置，动作是连续的 4D 向量，包括末端位置和速度。</p><p><strong>（2）学习强化学习的状态条件技能空间</strong></p><ul><li>将提取的技能嵌入到潜在空间中：使用变分自动编码器 VAE 将技能 $a$ 嵌入到潜在空间中，VAE 包括编码器和解码器，编码器将完整的 state-action 序列编码为 $z$，解码器根据当前状态 $s_t$ 和技能编码 $z$ 重建动作。</li><li>在探索过程中采样的技能状态条件先验：学习潜在技能空间上的条件概率密度。传统的高斯密度不能处理多模态信息，本文使用 real NVP 方法，实值非体积保留变换。学习从 $Z\times S-&gt;G$ 的映射，该映射就可以从简单分布 G 变换到技能空间 Z，因此 f 就是技能先验。</li></ul><blockquote><p><strong>变分自编码器</strong>，是一种深度生成模型<br><strong>传统</strong>：传统的自编码器包括编码器和解码器两部分，经过反复训练，输入数据被编码成一个编码向量，编码向量的每一个维度表示学习到的数据的特征，解码器尝试从编码向量中解码原始输入<br><strong>缺陷</strong>：传统的方法，使用单个值表示输入在某个潜在特征的表现。但实际上，将潜在特征表示为可能的取值范围会更合理。<br><strong>改进</strong>：因此变分自编码器就是使用取值的概率分布，代替原来的单值表示特征。<br><strong>优势</strong>：每个潜在特征表示为概率分布，解码时从潜在状态分布中随机采样，生成一个编码向量作为解码器的输入。实现了连续且平滑的潜在空间表示（潜在空间中彼此相邻的值重构出的结果相似）<br>参考理解:<a href="https://zhuanlan.zhihu.com/p/64485020">https://zhuanlan.zhihu.com/p/64485020</a></p></blockquote><p><strong>（3）状态条件技能空间中的强化学习</strong></p><p>一旦训练完成，解码器和技能先验权重就会被冻结，并合并到 RL 框架中。高级强化学习策略 $\pi$ 是一个神经网络，将状态映射到技能先验变化中的向量 g，在转换为潜在技能 Z。</p><p>然后解码器根据技能范围 H 的当前状态顺序重构动作。同时有一个底层残差策略，调整解码后的技能。</p><h2 id="5-3-总结">5.3 总结</h2><p>该方法是一种基于技能的强化学习方法。</p><ol><li>数据收集：使用最基本的控制器生成一些基本任务轨迹（移动、抓取），然后将这些轨迹分割成固定长度的序列，每一小段包括动作和对应的状态。</li><li>学习技能空间，使用变分自编码器将技能编码到潜在空间中；使用realNVP将技能潜在空间+机器人状态空间映射到简单分布空间（高斯分布），这样可以直接根据状态采样技能，称为技能先验。</li><li>强化学习：使用一个高层策略网络，根据当前的状态生成一个向量，根据技能先验（与当前状态有关的技能）中选择一个技能，利用技能解码器解码成机器人动作。</li></ol><h1>6 Watch and Match: Supercharging Imitation with Regularized Optimal Transport</h1><blockquote><p><strong>标题</strong>：观看与匹配：通过正则化最优传输增强模仿<br><strong>作者团队</strong>：纽约大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://rot-robot.github.io/">https://rot-robot.github.io/</a></p></blockquote><h2 id="6-1-目标问题-2">6.1 目标问题</h2><p>目前模仿学习通常使用逆强化学习，给出演示的情况下，交替推理奖励函数和策略。但是这种方式需要大量的在线交互来解决复杂的控制问题。</p><p>本文提出了正则化最佳传输（Regularized Optimal Transport，ROT）方法，即使只有少量的演示，也能自适应的匹配轨迹奖励与行为克隆，加速模仿。</p><blockquote><p>基于最佳传输的模仿学习（Optimal Transport，OT）：模仿学习实在给定专家策略或轨迹的情况下学习行为行为策略 $\pi^b$，逆强化学习根据专家轨迹 $T^e$ 推断奖励函数 $r^e$，然后利用奖励优化策略来得到行为策略 $\pi^b$。为了计算 $r^e$，基于 OT 的逆学习方法就是一种思路。专家轨迹和行为轨迹的接近程度可以通过测量两个轨迹之间的最佳传输来计算。</p></blockquote><h2 id="6-2-方法-2">6.2 方法</h2><p><strong>（1）BC 预训练</strong></p><p>使用 BC 对专家演示的数据进行随机初始化策略的训练。</p><p>BC 对应求解公式中的最大似然问题，这里的专家轨迹 $T^e$ 指的是专家演示，训练后，它能够使 $\pi^{BC}$ 模仿与演示中想对应的动作，但是如果出现未见过的状态，那么很容易会导致推理失败。</p><p><strong>（2）在线 IRL 微调</strong></p><p>在 BC 训练的模型基础上，进行在线微调策略。由于本文操作没有明确的任务奖励，因此使用基于 OT 的轨迹匹配获得奖励。（本文使用了 n 步 DDPG 方法实现连续控制）</p><ol><li>正则化微调：由于在线部署期间很容易因为错误累计导致分布偏移，本文通过基于引导 RL 和离线 RL 将 $\pi^{ROT}$ 与 BC 损失相结合来规范 $\pi^{ROT}$ 的训练，此处设置了一个 $\lambda(\pi)$ 自适应权重来控制两个损失项的贡献。</li><li>柔性 Q 滤波的自适应正则化：自适应权重调整 $\lambda(\pi)$，通过比较当前策略 $\pi^{ROT}$ 和与训练策略 $\pi^{BC}$ 在一段重放缓冲区采样的一批数据的性能表现来完成。</li><li>基于图像观测的考虑：对视觉观测进行数据增强，将图像输入 CNN 编码器，获得 OT 奖励的计算，减少 ROT 模仿过程中的非平稳性。</li></ol><h2 id="6-3-实验">6.3 实验</h2><p>本文的模型包括三个神经网络：encoder、actor、critic，三者均使用均方误差进行训练。</p><p>使用 n 步 DDPG 作为 RL 主干，actor 使用确定性策略梯度进行训练。critic 使用 clipped double Q-learning 进行训练，主要时为了减少高估问题，因此使用两个 Q 函数实现 critic 的学习。</p>]]></content>
    
    
    <summary type="html">基于强化学习的机器人动作模仿方法论文调研与笔记。</summary>
    
    
    
    <category term="科研" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/"/>
    
    <category term="模仿动作" scheme="https://www.mahaofei.com/categories/%E7%A7%91%E7%A0%94/%E6%A8%A1%E4%BB%BF%E5%8A%A8%E4%BD%9C/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="模仿" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF/"/>
    
    <category term="机器人动作" scheme="https://www.mahaofei.com/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A8%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【模仿学习笔记】行为克隆 Behavior Cloning</title>
    <link href="https://www.mahaofei.com/post/1d3a3b82.html"/>
    <id>https://www.mahaofei.com/post/1d3a3b82.html</id>
    <published>2023-11-03T09:12:44.000Z</published>
    <updated>2023-11-03T09:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、行为克隆概念</h1><p>行为克隆属于模仿学习中的方法，不是强化学习。</p><blockquote><p>强化学习：从环境给出的奖励中进行监督；<br>模仿学习：从人类动作经验中监督<br>区分两者主要在于，模仿学习没有奖励回报，知识模仿专家动作。</p></blockquote><h1>二、行为克隆过程</h1><ol><li>观测当前状态 $s_t$</li><li>策略网络做出预测 $p_t$</li><li>专家的动作是 $a_t^*$，向量化从而得到 $y_t$</li><li>计算损失 CrossEntropy($y_t,p_t$)</li><li>使用梯度下降来更新策略网络</li></ol><h1>三、行为克隆的优势与不足</h1><p>如果当前的状态出现在训练数据中，则可以根据行为克隆训练得到的策略网络，执行类似于人类专家的动作。</p><p>但是如果当前状态没有出现在训练数据中，那么策略网络输出的动作可能不会很好，而且错误会累加。这种情况尤其出现在状态极为复杂的情况下。</p><h1>一、模仿学习简介</h1><p>模仿学习是让智能体从专家示例中学习，从而像人类专家一样能够智能决策。</p><ul><li>不同于传统的监督学习算法，监督学习需要考虑大量的约束条件，根据约束设计特定的监督方法来引导智能体；</li><li>而模仿学习旨在让人类为之恩能够提提供大量的示例行为，利用这些专家示例来教会智能体进行决策。</li></ul><p>目前模仿学习主要分为两类：</p><ul><li>行为克隆：尝试最小化智能体策略和专家策略的动作差异，把模仿学习作为回归或分类任务学习；</li><li>对抗式模仿学习：通过逆强化学习来构建对抗的奖励函数，最大化这个奖励函数来模仿专家行为。</li></ul><h1>二、数学基础（马尔可夫决策过程）</h1><p>考察一个有限状态的马尔可夫链，状态空间$S={1,2,3,\cdots,|S|}$，由于马尔可夫性，状态转移与历史状态无关，因此对于有限状态的马尔可夫链，状态转移矩阵 $P$ 如下：</p><p>$$<br>P=\begin{bmatrix}{}<br>p_{1,1} &amp; p_{1,2} &amp; \cdots &amp; p_{1,|S|}\<br>p_{2,1} &amp; p_{2,2} &amp; \cdots &amp; p_{2,|S|}\<br>\cdots &amp; \cdots &amp; \cdots &amp; \cdots\<br>p_{|S|,1} &amp; p_{|S|,2} &amp; \cdots &amp; p_{|S|,|S|}<br>\end{bmatrix}<br>$$</p><p>其中每一个元素 $p_{i,j}$ 表示由状态 $i$ 转移到 $j$ 的概率，满足：</p><p>$$<br>\sum^{|S|}<em>{i=1}P</em>{i,j}=1, \sum^{|S|}<em>{j=1}P</em>{i,j}=1<br>$$</p><p>为了完整表示状态转移过程，需要指定初始状态分布 $\rho$ ，便于递归计算某个状态 $i$ 在 $t$ 时刻出现的概率（上一时刻为 $j$ 状态的概率 $\times$ $j$ 状态到 $i$ 状态的状态转移概率）：</p><p>$$<br>\mathbb{P}(s_t=i)=\sum_{j\in S}\mathbb{P}(s_{t-1}=j)p_{j,i}<br>$$</p><p>对于一个马尔可夫决策过程，状态转移不仅受到上移时刻状态的影响，还取决于当前动作，因此不仅要考虑状态，还要额外考虑动作和奖励，即一个马尔可夫决策过程可以表示为 $M=(S,A,\rho,P,r)$ ，数学上表示为 $P(s_{t+1}|s_t, a_t)$。</p><p>为了表示动作产生的过程，引入了策略 $\pi(a|s)$ ，代表在状态 $s$ 处选择动作 $a$ 的概率，因为我们最多有 $|S|$ 个状态和 $|A|$ 个动作，$\pi$ 也可以用一个 $|S| \times |A|$ 的矩阵来表示。</p><p>据马尔可夫决策过程的交互规则以及累计回报计算，实际需要考虑回报折扣，定义一个折扣因子 $\gamma \in(0,1)$，则马尔可夫决策过程变成了由6元组表示 $M=(S, A, \rho, P, r, \gamma)$，在 $M$ 下的累计回报为：</p><p>$$<br>V(\pi)=\mathbb{E}\left[\sum^\infty_{t=0}\gamma^t r(s_t, a_t)\right]<br>$$</p><p>这里的 $V(\pi)$ 代表了策略 $\pi$ 所能获得的累计奖励的期望，每一步奖励都会被乘以系数 $\gamma^t$，以此来保证无限求和时正确的。</p><p>当策略 $\pi$ 确定时，我们可以对任意的起始状态 $s$ 来定义其状态价值函数</p><p>$$<br>V^{\pi}(s)=\mathbb{E}\left[\sum_{t=0}^{\infty}\gamma^{t}r(s_{t},a_{t})\bigg|s_{0}=s,a_{t}\sim\pi(\cdot|s_{t}),s_{t+1}\sim P(s_{t+1}|s_{t},a_{t})\right].<br>$$</p><p>同样可以定义状态-动作价值函数</p><p>$$<br>Q^{\pi}(s,a)=\mathbb{E}\left[\sum_{t=0}^{\infty}\gamma^{t}r(s_{t},a_{t})\bigg|s_{0}=s,a_0=a,a_{t}\sim\pi(\cdot|s_{t}),s_{t+1}\sim P(s_{t+1}|s_{t},a_{t})\right].<br>$$</p><h1>三、模仿学习算法</h1><h2 id="3-1-行为克隆算法">3.1 行为克隆算法</h2><p>行为克隆的想法就是从数据中估计专家测类 $\pi^E$，具体到一个状态 $s$ ，$\pi(\cdot|s)$ 就是动作空间 $A$ 上的概率分布。一个经典的估计方法就是最大似然估计。</p><p>$$<br>\max_{\theta}\sum_{(s,a)\in\mathcal{D}}\log(\hat \pi_{\theta}(a|s))<br>$$</p><p>可以证明该最大似然模型对应的问题是一个凸优化问题。</p><ul><li>如果动作空间是离散的，可以使用 $A$ 维的向量定义 softmax 函数，这时要解决的问题就变成了常见的分类问题中的交叉熵优化问题。</li><li>如果哦当作空间是连续的，可以使用高斯分布表示一个策略，$\hat \pi_\theta(\cdot|s)=N(\mu_\theta(s),\sigma^2_\theta(s))$，因此问题被转换为基于均方差的回归问题。</li></ul><p>行为克隆算法可以直接从专家数据中估计出策略 $\pi$ ，但也会带来问题，即训练数据集</p><blockquote><p>参考链接：</p><ol><li><a href="https://www.lamda.nju.edu.cn/xut/docs/Imitation_Learning.pdf">许天, 李子牛, 俞扬. 模仿学习简洁教程. 2021</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">学习模仿学习中的行为克隆部分的笔记</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础知识" scheme="https://www.mahaofei.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="模仿学习" scheme="https://www.mahaofei.com/tags/%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【强化学习笔记】强化学习基础</title>
    <link href="https://www.mahaofei.com/post/cfa8c737.html"/>
    <id>https://www.mahaofei.com/post/cfa8c737.html</id>
    <published>2023-11-02T02:01:55.000Z</published>
    <updated>2023-11-02T02:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、基本概念</h1><h2 id="1-1-专业术语">1.1 专业术语</h2><p><strong>（1）状态（State）</strong>：状态可以被理解为当前环境的情况。</p><p><strong>（2）动作（Action）</strong>：动作是智能体（agent）采取的行为。</p><p><strong>（3）策略（Policy）</strong>：策略是用于在给定观测状态下做出决策的函数，通常表示为 $\pi(a|s)$，其中 $a$ 是动作，$s$ 是状态。强化学习的目标是学习策略函数，通常以概率密度函数的形式表示。</p><p><strong>（4）奖励（Reward）</strong>：奖励定义了奖励的方式，对强化学习的结果产生重要影响。</p><p><strong>（5）状态转移（State Transition）</strong>：状态转移表示在当前状态下，当智能体执行一个动作后，环境可能随机转移到的下一个状态的概率，通常表示为 $P(S’|S, A)$。</p><p><strong>（6）回报（Return）</strong>：回报又被称为未来奖励的累积，通常表示为 $U_t = R_t + R_{t+1} + R_{t+2} + \ldots$。</p><p><strong>（7）折扣回报（Discounted Return）</strong>：折扣回报考虑未来奖励的折扣效应，用折扣率 $\gamma$ 表示，通常表示为 $U_t = R_t + \gamma R_{t+1} + \gamma^2 R_{t+2} + \ldots$。</p><p><strong>（8）动作价值函数（Action-Value Function）</strong>：动作价值函数表示在给定状态和动作下，智能体可以获得的期望回报，通常表示为 $Q_\pi(s_t, a_t) = E[U_t | S_t=s_t, A_t=a_t]$。最优策略下的动作价值函数被表示为 $Q^*(s_t, a_t) = \max_\pi Q_\pi(s_t, a_t)$，使用动作价值函数可以评估当前动作的质量。</p><p><strong>（9）状态价值函数（State-Value Function）</strong>：状态价值函数表示在给定状态下，按照策略函数的预期回报，通常表示为 $V_\pi(s_t) = E_A[Q_\pi(s_t, A)]$。状态价值函数可以告诉我们当前状态的好坏程度。</p><p><strong>（10）交叉熵（Cross Entropy）</strong>：交叉熵用于度量两个概率分布之间的差异，通常表示为 $H(\textbf p, \textbf q) = -\sum^m_{j=1}p_j\cdot \log(q_j)$。当两个概率分布相同时，交叉熵达到最小值。</p><h2 id="1-2-强化学习的随机性">1.2 强化学习的随机性</h2><p><strong>（1）Action动作的随机性</strong></p><p>因为动作是根据策略函数随机抽样得到的，因此agent有可能做策略中的任何一种动作，虽然这些动作的概率有大有小，但是动作本身是随机的。</p><p><strong>（2）State transitions状态转移的随机性</strong></p><p>假定agent作出了一个动作，环境会用概率随机抽样，给出下一个状态。</p><h2 id="1-3-强化学习如何控制agent">1.3 强化学习如何控制agent</h2><p><strong>（1）如果有策略函数 $\pi(a|s)$</strong></p><ol><li>给定一个观测状态 $s_t$</li><li>利用策略函数从所有可能的动作中随机采样 $a_t~\pi(\cdot|s_t)$</li></ol><p><strong>（2）如果有最优的动作价值函数 $Q^<em>(s,a)</em>$</strong></p><ol><li>给定一个观测状态 $s_t$</li><li>最大化 $a_t=argmax_a Q^*(s_t,a)$ 来选择动作</li></ol><h1>二、价值学习 Deep Q-Network(DQN)</h1><p>$U_t$ 反映未来奖励的总和，因此我们要知道 $U_t$ 的大小，由于其是一个随机变量，我们可以对 $U_t$ 求期望，只留下 $s_t$ 和 $a_t$ 两个变量。</p><p>$$Q_\pi(s_t,a_t)=E[U_t|S_t=s_t,A_t=a_t]$$</p><p>要想进一步消除策略函数 $\pi$，可以对 $Q_\pi$ 关于 $\pi$ 球最大化，记为 $Q^*$</p><p>$$Q^*(s_t,a_t)=max_\pi Q_\pi(s_t,a_t)$$</p><p>这个参数告诉我们不管在什么情况 $s_t$ 下做动作 $a_t$，那么期望顶多就是 $Q^*(s_t,a_t)$。</p><blockquote><p>目标：完成任务（最大化总回报）<br>问题：如果已知 $Q^<em>(s,a)$，那么最好的动作就是 $a^</em>=argmax_a Q^<em>(s,a)$，因为 $Q^</em>$ 指示了该agent在s状态下选择a动作的好坏程度<br>挑战：我们不知道 $Q^*(s,a)$</p></blockquote><p><strong>（1）什么是 DQN</strong></p><p>我们使用神经网络 $Q(s,a;w)$ 来近似 $Q^*(s,a)$，其中 w 是要近似的参数，s 是输入，a 是输出是对所有动作的打分。</p><p><img src="https://img.mahaofei.com/img/202311030917032.png" alt="image.png"></p><p>当前观测到状态 $s_t$，用DQN把 $s_t$ 作为输入，为所有动作打分，选出分数最高的动作作为 $a_t$。</p><p>agent 作出动作 $a_t$ 后，环境会改变，用状态转移函数 $p$ 随机抽取一个新的状态 $s_{t+1}$，环境还会告诉我们一个回报 $r_t$，这个 $r_t$ 就是训练DQN的关键。</p><p><strong>（2）如何训练 DQN</strong></p><p>常规的网络训练过程如下：</p><ol><li>首先对任务结果做一个预测 $q=Q(w)$</li><li>完成任务后获得目标 $y$</li><li>计算损失 $L=\frac{1}{2}(q-y)^2$</li><li>计算梯度 $\frac{\partial L}{\partial w}=\frac{\partial L}{\partial q}\cdot \frac{\partial q}{\partial w}$</li><li>更新参数 $w_{t+1}=w_t-\alpha \cdot\frac{\partial L}{\partial w}|_{w=w_t}$</li></ol><p>但这种方式需要完整完成一次任务后才能更新参数，而能否执行一部分任务后就开始更新参数，因此有了 Temporal Difference Learning （TD算法），过程如下：</p><ol><li>首先对任务结果做一个预测 $q=Q(w)$</li><li>执行一部分任务后，对任务结果再进行预测 $y$，此时的 $y$ 包括已经完成的部分和对剩下部分的预测，因此比 $q$ 更可靠</li><li>计算损失 $L=\frac{1}{2}(q-y)^2$</li><li>计算梯度 $\frac{\partial L}{\partial w}=\frac{\partial L}{\partial q}\cdot \frac{\partial q}{\partial w}$</li><li>更新参数 $w_{t+1}=w_t-\alpha \cdot\frac{\partial L}{\partial w}|_{w=w_t}$</li></ol><p>在深度强化学习中，也就是下面这个公式</p><p>$$Q(s_t,a_t;w)\approx r_t+\gamma\cdot Q(s_{t+1},a_{t+1};w)$$</p><p>对未来奖励总和的期望，就是真实已经观测到的奖励，加在t+1时刻对未来奖励的期望。</p><ol><li>首先进行预测 $Q(s_t,a_t;w_t)$</li><li>获得TD目标 $y_t=r_t+\gamma\cdot Q(s_{t+1},a_{t+1};w_t)=r_t+\gamma\cdot max_a Q(s_{t+1},a;w_t)$</li><li>计算损失 $L_t=\frac{1}{2}[Q(s_t,a_t;w)-y_t]^2$</li><li>进行剃度下降 $w_{t+q}=w_t-\alpha\cdot\frac{\partial L_t}{\partial w}|_{w=w_t}$</li></ol><p><img src="https://img.mahaofei.com/img/202311031636429.png" alt="image.png"></p><p><strong>（3）经验回放</strong></p><p>之前我们使用在线梯度下降来更新 $w$，以此来减小TD errer $\delta_t=q_t-t_t$。</p><p>我们定义一个经验transition为$(s_t,a_t,r_t,s_{t+1})$，传统的方法再每使用一个transition后就会丢弃它，这回造成经验的浪费。此外传统的方法还忽略了不同经验之间的相关性。</p><p>将最近的n个transition存储进一个replay buffer，当有新的经验进来后，就删除老的transition。</p><ol><li>每次从buffer中随机抽取一个transition</li><li>计算TD error</li><li>极端梯度</li><li>进行随机梯度下降（实际一般使用minibatch SGD，一次取多个transition）</li></ol><p><strong>优先经验回放</strong>：为了解决数据的不均匀性，可以使用重要性抽样代替平均采样。可以根据TD error抽样，误差越大的，transition被抽样的概率越大。</p><p><strong>学习率比例设置</strong>：如果一个transition有较大的抽样概率，那么其学习率应该设置的比较小。</p><p><strong>更新TD error</strong>：如果一个transition没有被用过，那么就设置它的TD error为最大值，在训练DQN的同时，对TD error进行更新。</p><h1>三、策略学习</h1><p>策略函数 $\pi(a|s)$是一个概率密度函数，对每一个给定的状态 $s$，策略函数会抽取一个最优的动作 $a$ 作为将要执行的动作。</p><p>理想情况下，列出所有的状态和动作，计算所有状态和动作之间的概率即可。</p><p>但是实际情况下有无数个状态，不可能记录所有的状态对应的动作，因此需要函数近似。一般使用神经网络进行近似，即policy network $\pi(a|s;\theta)$</p><p>状态价值函数$V_\pi(s_t)=E_A[Q_\pi(s_t,A)]$，状态价值函数可以告诉我们当前的局势好不好。在状态已知时，还可以判断策略好不好，策略越好，$V_\pi$ 越大，任务完成成功率越高，$V_\pi$ 可以表示为：</p><p>$$V_\pi(s_t)=E_A[Q_\pi(s_t,A)]=\sum_a\pi(a|s_t)\cdot Q_\pi(s_t,a)$$</p><p>使用神经网络替换策略函数，因此得到：</p><p>$$V_\pi(s_t;\theta)=\sum_a\pi(a|s_t;\theta)\cdot Q_\pi(s_t,a)$$</p><p>给定状态 $s$，策略函数函数越好，价值函数越大。因此可以考虑通过改变神经网络参数 $\theta$，让 $V(s;\theta)$ 变大，基于这个思想，可以求期望：</p><p>$$J(\theta)=E_s[V(S;\theta)]$$</p><p>策略网络越好，$J(\theta)$ 就越大，为了改变 $\theta$，我们使用策略梯度算法。</p><ol><li>观测状态 $s$</li><li>更新策略 $\theta=\theta+\beta\cdot\frac{\partial V(s;\theta)}{\partial \theta}$，做梯度上升，因为我们希望价值函数越大越好。</li></ol><p>对于离散的动作，使用$\frac{\partial V(s;\theta)}{\partial \theta}=\sum_a \frac{\partial \pi(a|s;\theta)}{\partial \theta}\cdot Q_\pi(s,a)$</p><p>对于连续的动作，使用$\frac{\partial V(s;\theta)}{\partial \theta}=E_{A~\pi(\cdot|s;\theta)} [\frac{\partial \pi(a|s;\theta)}{\partial \theta}\cdot Q_\pi(s,a)]$</p><p><img src="https://img.mahaofei.com/img/202311031636316.png" alt="image.png"></p><h1>四、Actor-Crictic</h1><p>状态价值函数的定义如下：</p><p>$$V_\pi(s_t)=\sum_a\pi(a|s_t)\cdot Q_\pi(s_t,a)$$</p><p>策略网络（产生动作）：</p><ul><li>使用神经网络 $\pi(a|s;\theta)$ 来近似策略函数 $\pi(a|s)$</li><li>其中 $\theta$ 是训练的参数</li></ul><p>价值网络（产生评判标准）：</p><ul><li>使用神经网络 $q(s,a;w)$ 来近似价值函数 $Q_\pi(s,a)$</li><li>其中 $w$ 是训练的参数</li></ul><p>因此状态价值函数可以写成</p><p>$$V_\pi(s_t)=\sum_a\pi(a|s_t;\theta)\cdot Q_\pi(s_t,a;w)$$</p><p>同时训练策略网络和价值网络，就称为 Actor-Critic Method，大致步骤如下：</p><ol><li>观测当前状态 $s_t$</li><li>根据策略函数 $\pi(\cdot|s_t;\theta_t)$ 随机采样获得动作 $a_t$</li><li>执行动作 $a_t$，并观测新的状态 $s_{t+1}$ 和回报 $r_t$</li><li>更新价值网络的参数 $w$，使用TD算法</li><li>更新策略网络的参数 $\theta$，使用策略梯度算法</li></ol><p>训练过程中需要同时训练策略网络和价值网络，利用价值网络对策略网络进行评分。训练完成后就不需要价值网络了，只需要策略网络生成动作。</p><h1>五、蒙特卡洛树搜索（Monte Carlo Tree Search）</h1><h2 id="5-1-基本思想">5.1 基本思想</h2><p>蒙特卡洛树搜索的思想是人们必须要向前看很多步，看到未来时间内所有可能的情况，挑选最优的执行动作。</p><ol><li>如果我在此时选择执行动作 $a_t$</li><li>那么未来一段时间环境的反馈是怎么变化的 $s_{t+1}$</li><li>基于这种环境变化，我又会执行动作 $a_{t+1}$</li><li>此时环境又会如何变化</li></ol><p>如果一个agent能够穷举所有的可能性直到任务完成，那么这个任务一定有很高的成功率。</p><h2 id="5-2-过程">5.2 过程</h2><p><strong>（1）选择</strong></p><p>根据分数选择一个动作（假想的动作，实际上并不会执行）；</p><p>首先对所有可能的动作 $a$，计算得分：</p><p>$$score(a)=Q(a)+\eta\cdot\frac{\pi(a|s_t;\theta)}{1+N(a)}$$</p><p>其中 $Q(a)$ 是蒙特卡洛树搜索计算的动作价值<br>$\pi(a|s_t;\theta)$ 是学习好的策略网络，动作越好，策略分数越高<br>$N(a)$ 是给定环境状态 $s_t$ 情况下，目前为止选择动作 $a$ 的次数，如果同一个动作被探索太多次，该项分母就会变大。</p><p><strong>（2）扩展</strong></p><p>假想环境更新；</p><p><strong>（3）评估</strong></p><p>评价状态价值得分 $v$ 和回报 $r$，将动作的分数设为 $\frac{v+r}{22}$；</p><p><strong>（4）备份</strong></p><p>用动作的分数 $\frac{v+r}{2}$ 更新动作价值：</p><p>$$Q(a_t)=mean(the recorded V’s)$$</p><p>将以后所有步的状态价值进行平均。</p><h1>六、连续控制</h1><p>在实际进行强化学习时，可能有离散动作空间（例如上下左右控制游戏人物），也可能是连续动作（机械臂关节控制）。</p><p>在进行离散控制时，可以直接使用分类的思想，得到一个onehot向量，每个向量元素代表执行该动作的得分，以此来获得应该执行那种动作。而连续控制中动作空间是有无穷维的，因此不能直接使用这种思想实现连续控制。</p><p>比较常规的一种解决思路是将动作空间离散化，但这种方式也有问题，例如机械臂的6个自由度，就算每个自由度离散为360个点，那么整个动作空间也有 $360^6$ 个点，这会造成维度灾难，在训练时非常困难。</p><p>因此有两种方式实现连续控制：</p><ul><li>确定性策略网络</li><li>随机策略网络</li></ul><h2 id="6-1-确定策略梯度（Deterministic-Policy-Gradient-DPG）">6.1 确定策略梯度（Deterministic Policy Gradient DPG）</h2><p>考虑一个只有2自由度的机械臂，基座运动范围为(0,180)，机械臂运动范围为(0,360)，因此机械臂的动作空间是 $A=[0,180]\times[0,360]$ 的连续集合，动作就是一个二维向量。</p><p>DPG 是一种 Actor-Critic 方法</p><ul><li>有一个<strong>策略网络</strong>，控制 agent 运动，它根据状态 s 做出决策 a；<br>使用策略网络 $a=\pi(s;\theta)$ 根据输入状态 s，输出一个<strong>确定</strong>的动作 a，这里的动作 a 就是机器人的二维动作向量。</li><li>有一个<strong>价值网络</strong>，不控制 agent，它根据状态 s，给动作 a 打分，从而指导策略网络做出改进。<br>使用价值网络 $q(s,a;w)$，输入状态 s 和动作 a，输出一个实数 value 是对动作的评价，动作越好，value 越大。</li></ul><p>因此 DPG 的原理就是训练这两个网络。</p><p><img src="https://img.mahaofei.com/img/202311041607515.png" alt="image.png"></p><p><strong>（1）价值网络训练</strong></p><ol><li>每次得到一个训练数据 transition $(s_t,a_t,r_t,s_{t+1})$</li><li>用价值网络预测当前时刻 t 下的动作价值 $q_t=q(s_t,a_t;w)$</li><li>用价值网络预测下一时刻 t+1 的动作价值 $q_{t+1}=q(s_{t+1},a_{t+1}‘;w)$ ，其中 $a_{t+1}’=\pi(s_{t+1};\theta)$，这个动作并不是 agent 真正执行的动作，$a_{t+1}'$ 只用于更新价值网络。</li><li>计算 TD error：$\delta_t=q_t-(r_t+\gamma\cdot q_{t+1})$，其中第二项是 TD Target，它一部分是真实观测到的奖励，另一部分是价值网络自己做出的预测。因为我们认为第二项中由于包含本步真实奖励，比单纯的 $q_t$ 更接近真实情况，因此要让 $q_t$ 与 TD Target 接近，也就是让 TD error 尽可能小。</li><li>进行梯度下降更新 w：$w=w-\alpha\cdot\gamma_t\cdot\frac{\partial q(s_t,a_t;w)}{\partial w}$</li></ol><p>但这其中有一个问题，就是计算 TD error $\delta_t=q_t-(r_t+\gamma\cdot q_{t+1})$ 这一步时，会出现 bootstrapping 问题，也就是如果初始值高估或者低估，那么 TD target 就会有高估或低估，并传播回价值网络自身，导致高估或低估一直存在，解决方案就是用不同的神经网络计算 TD Target，也就是用 Target Networks。</p><ol><li>每次得到一个训练数据 transition $(s_t,a_t,r_t,s_{t+1})$</li><li>用价值网络预测当前时刻 t 下的动作价值 $q_t=q(s_t,a_t;w)$</li><li>用价值网络预测下一时刻 t+1 的动作价值 $q_{t+1}=q(s_{t+1},a_{t+1}‘;w^-)$ ，其中 $a_{t+1}’=\pi(s_{t+1};\theta^-)$<br>$\pi(s_{t+1};\theta^-)$ 是 Target policy network 用来代替策略网络，它的网络结构和策略网络一模一样，但是参数不一样。<br>$q(s_{t+1},a_{t+1}';w^-)$ 是 Target value network，它与价值网络结构一样，参数不同。</li></ol><p><strong>（2）策略网络训练</strong></p><p>训练策略网络，需要靠价值网络评价动作的好坏，从而指导策略网络进行改进。</p><p>也就是更新策略网络的参数 $\theta$ 让价值网络认为动作 $a=\pi(s;\theta)$ 更好，也就是改进 $\theta$ 让价值 $q(s,a;w)=q(s,\pi(s;\theta);w)$ 尽可能大。</p><p>由于给定状态 s，策略网络会输出一个确定的动作 a，而如果价值网络也是确定的，那么输出的价值就是确定的。</p><p>因此问题中只需要改变 $\theta$，使得价值 q 变大，也就是计算 $q(s,a;w)$ 对 $\theta$ 的梯度，然后用梯度上升更新 $\theta$，就可以让 $q$ 变大，这个梯度就叫<strong>确定策略梯度 DPG</strong>。</p><p>$$<br>g=\frac{\partial q(s,\pi(s;\theta);w)}{\partial\theta}=\frac{\partial a}{\partial \theta}\cdot\frac{\partial q(s,a;w)}{\partial a}<br>$$</p><p>其中 $a=\pi(s;\theta)$，然后进行梯度上升 $\theta=\theta+\beta\cdot g$</p><p><strong>策略网络和价值网络联合具体步骤如下：</strong></p><ol><li>策略网络做一个决策：$a=\pi(s;\theta)$</li><li>计算价值网络的输出：$q_t=q(s,a;w)$</li><li>用 DPG 更新策略网络： $\theta=\theta+\beta\cdot \frac{\partial a}{\partial \theta}\cdot\frac{\partial q(s,a;w)}{\partial a}$</li><li>利用 Target networks $\pi(s;\theta^-)$ 和 $q(s,a;w^-)$ 计算 $q_{t+1}$</li><li>计算 TD error：$\delta_t=q_t-(r_t+\gamma\cdot q_{t+1})$</li><li>更新价值网络：$w=w-\alpha\cdot\gamma_t\cdot\frac{\partial q(s_t,a_t;w)}{\partial w}$</li><li>更新 Target networks 的参数：$w^-=\tau\cdot w+(1-\tau)\cdot w^-$，$\theta^-=\tau\cdot \theta+(1-\tau)\cdot \theta^-$，其中 $\tau$ 是超参数</li></ol><h2 id="6-2-随机策略用于连续控制">6.2 随机策略用于连续控制</h2><p>首先考虑自由度等于 1 的随机策略连续控制，也就是动作都是实数。</p><p>设 $\mu$ 代表均值，和 $\sigma$ 代表标准差，都是状态 s 的函数。</p><p>用正态分布的概率密度函数作为策略函数：</p><p>$$<br>\pi(a|s)=\frac{1}{\sqrt{6.28}\sigma}\cdot exp(-\frac{(a-\mu)^2}{2\sigma^2})<br>$$</p><p>对于 d 维情况一样，动作是 d 维向量。</p><p>设向量 $\mu$ 代表均值，和向量 $\sigma$ 代表标准差，都是状态 s 的函数。</p><p>使用特殊正态分布作为策略函数：</p><p>$$<br>\pi(a|s)=\prod_{i=1}^d\frac{1}{\sqrt{6.28}\sigma_i}\cdot exp(-\frac{(a_i-\mu_i)^2}{2\sigma^2_i})<br>$$</p><p>但这里我们不知道 $\mu$ 和 $\sigma$，也就不知道策略函数。</p><p>因此可以用神经网络来近似 $\mu(s;\theta^{\mu})$ 和 $\rho(s;\theta{\rho})$，其中 $\rho_i=ln\sigma_i^2$</p><p>将策略函数进行取对数，将连乘变成连加，得到辅助神经网络 $f(s,a;\theta)=\sum^d_{i=1}[-\frac{\rho_i}{2}-\frac{(a_i-\mu_i)^2}{2\cdot exp(\rho_i)}]$，计算 f 关于其中卷积层和全连接层的参数的梯度，进而实现反向传播更新参数。</p><p><img src="https://img.mahaofei.com/img/202311041725827.png" alt="image.png"></p><blockquote><p>参考：</p><ol><li>王树森.  <a href="https://www.youtube.com/channel/UC9qKcEgXHPFP2-ywYoA-E0Q/playlists?view=50&amp;sort=dd&amp;shelf_id=2">强化学习课程(Youtube)</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">强化学习基础部分笔记</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="强化学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="强化学习" scheme="https://www.mahaofei.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.mahaofei.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Python" scheme="https://www.mahaofei.com/tags/Python/"/>
    
  </entry>
  
</feed>
