<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALFA博客</title>
  
  <subtitle>无限进步！！！</subtitle>
  <link href="https://www.mahaofei.com/atom.xml" rel="self"/>
  
  <link href="https://www.mahaofei.com/"/>
  <updated>2023-02-14T02:56:06.000Z</updated>
  <id>https://www.mahaofei.com/</id>
  
  <author>
    <name>马浩飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【统计学习方法笔记03】k近邻法</title>
    <link href="https://www.mahaofei.com/post/72393bb6.html"/>
    <id>https://www.mahaofei.com/post/72393bb6.html</id>
    <published>2023-02-14T02:56:06.000Z</published>
    <updated>2023-02-14T02:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、k近邻算法</h1><h2 id="1-1-算法">1.1 算法</h2><p>k近邻算法，假设给定了一个训练数据集，其中实例类别已定。</p><p>分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。 因此，k近邻法不具有显式的学习过程。</p><h2 id="1-2-模型">1.2 模型</h2><p>三个基本要素：距离度量、k值、分类决策规则</p><p>一般将特征空间，按照每个训练实例点xi，距离该点比其它点更近的所有点组合成一个单元。每个训练实例点拥有一个单元，单元内所有点都标记上类yi。</p><p>这样特征空间中每个点的类别都是确定的。</p><p><strong>（1）距离</strong></p><p>特征空间中两个实例点的距离一般使用欧式距离，或者更一般的$L_p$距离</p><p>$$L_p(x_i,x_j)=(\sum^n_{l=1}|x^{(l)}_i-x^{(l)}_j|)^{\frac{1}{p}}$$</p><p>其中l=2时为欧式距离，l=1时为曼哈顿距离，l=∞时为各个坐标距离的最大值。</p><p><strong>（2）k值</strong></p><p>如果k值过小，虽然可能会预测的比较准，但预测结果受邻近点影响过大，如果邻近点恰好为噪声，则会预测错误。</p><p>如果k值过大，与输入距离较远的示例也会起到预测作用。</p><p>如果k=N，那么总是输出实例中最多的类。</p><p><strong>（3）分类决策规则</strong></p><p>通常为k个近邻的实例中的最多数类。</p><h1>二、kd-tree</h1><p>在进行预测时，需要在训练数据中进行k近邻搜索，如果使用线性扫描，则需要计算输入点与所有训练实例的距离，速度过慢。</p><h2 id="2-1-构造kd-tree">2.1 构造kd-tree</h2><p>kd-tree的构造相当于不断用垂直于坐标轴的超平面将k维空间切分，每个节点对应一个k维超矩形区域。</p><p>构造过程：</p><ul><li>构造根结点：根结点对应的k维空间包含所有实例点的超矩形区域</li><li>递归切分：在超矩形区域中选择一个坐标轴和此坐标轴上的切分点，确定一个超平面，用此超平面将当前超矩形区域切分为左右两个子区域（子结点）</li><li>重复此过程，直到子区域内没有实例时终止（叶结点）</li></ul><h2 id="2-2-搜索kd-tree">2.2 搜索kd-tree</h2><p>输入：己构造的kd-tree， 目标点x<br>输出：x的最近邻</p><ul><li>在kd树中找出包含目标点x的叶结点：从根结点出发，递归地向下访问kd-tree。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。 直到子结点为叶结点为止。（有点类似二分法）</li><li>以此叶结点为“当前最近点”</li><li>递归地向上回退，在每个结点进行以下操作：<ul><li>如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。</li><li>当前最近点一定存在于该结点一个子结点对应的区域。 检査该子结点的父结点的另一子结点对应的区域是否有更近的点。即检査另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点” 间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点， 移动到另一个子结点。接着，递归地进行最近邻搜索；如果不相交， 向上回退。</li></ul></li><li>当回退到根结点时，搜索结束。最后的“当前最近点” 即为x的最近邻点。</li></ul>]]></content>
    
    
    <summary type="html">近邻算法，假设给定了一个训练数据集，其中实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。 因此，k近邻法不具有显式的学习过程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记02】感知机</title>
    <link href="https://www.mahaofei.com/post/6d27098f.html"/>
    <id>https://www.mahaofei.com/post/6d27098f.html</id>
    <published>2022-12-07T06:35:06.000Z</published>
    <updated>2022-12-07T06:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、感知机模型</h1><p>感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</p><p>假设输入空间$X\subseteq R^n$，输出空间$Y={+1,-1}$。输入$x\in X$表示实例的特征向量，对应于输入空间的点。输出$y\in Y$表示实例的类别，则输入空间到输出空间的函数：</p><p>$$f(x)=sign(w\cdot x+b)$$</p><p>称为感知机。其中$w$称为权值向量，$b$称为偏置，sign时符号函数sign(x)= {+1(if x&gt;=0), -1(if x&lt;0)}。</p><h1>二、感知机学习策略</h1><h2 id="2-1-数据集的线性可分性">2.1 数据集的线性可分性</h2><p>给定一个数据集，如果存在某个超平面能够将数据集的正实例点和负实例点完全正确的划分到超平面的两侧，则数据集称为线性可分数据集，否则称线性不可分。</p><h2 id="2-2-学习策略">2.2 学习策略</h2><p>输入空间中任意一点$x_0$到超平面S的距离为：$\frac{1}{||w||}|w\cdot x_0+b|$</p><p>因此误分类点到超平面S的距离为：$-\frac{1}{||w||}y_i(w\cdot x_0+b)$</p><p>所有误分类点的总距离，即损失函数为：$L(w,b)=-\sum_{i=0}^M y_i(w\cdot x_0+b)$</p><p>显然损失函数是非负的，感知机的学习策略就是在假设空间中找到使损失函数最小的模型参数$w,b$</p><h2 id="2-3-学习算法">2.3 学习算法</h2><p>感知机的学习算法采用随机梯度下降法。每次随机选取一个误分类点使其梯度下降。</p><p>输入：线性可分数据集T，学习率$\eta$</p><p>输出：感知机模型$w,b$</p><p>（1）选取初值$w_0,b_0$<br>（2）在训练集中选取数据$(x_i,y_i)$<br>（3）如果$y_i(w\cdot x_i+b)\le0$，更新参数$w=w+\eta y_i x_i$，$b=b+\eta y_i$，其中$\eta$为学习率，后项为两个参数的梯度<br>（4）重复上述过程，直到训练集中没有误分类点</p><p>当训练数据集线性可分时，感知机学习算法是收敛的，即经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。</p><h1>三、习题</h1><h2 id="3-1-为什么感知机不能表示异或">3.1 为什么感知机不能表示异或</h2><p>画出训练集的分布情况，易知无法使用一个线性平面将±区域分开。</p><p><img src="https://img.mahaofei.com/img/20221208104808.png" alt=""></p>]]></content>
    
    
    <summary type="html">感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记01】统计学习概论</title>
    <link href="https://www.mahaofei.com/post/fba31b0c.html"/>
    <id>https://www.mahaofei.com/post/fba31b0c.html</id>
    <published>2022-12-03T03:21:21.000Z</published>
    <updated>2022-12-03T03:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、统计学习</h1><h2 id="1-1-统计学习的概念">1.1 统计学习的概念</h2><p><strong>（1）概念</strong></p><p>统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。</p><p>统计学习是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><p><strong>（2）对象</strong></p><p>数据，如数字、文字、图像、视频、音频等。</p><p><strong>（3）目的</strong></p><p>从数据出发，提取数据的特征，抽象数据的模型，发现数据的知识，最后回到数据的分析与预测中。</p><h2 id="1-2-统计学习的分类">1.2 统计学习的分类</h2><h3 id="1-2-1-基本分类">1.2.1 基本分类</h3><p><strong>（1）监督学习</strong></p><p>从标注数据中学习预测模型的机器学习问题。即学习从输入到输出的映射的统计规律。</p><ul><li>输入空间与输出空间：输入与输出的所有可能取值。<ul><li>输入变量与输出变量均为连续变量，回归问题</li><li>输出变量为离散变量，分类问题</li><li>输入变量与输出变量均为变量序列，标注问题</li></ul></li><li>特征空间：输入可以用特征向量表示，所有特征向量存在的空间。</li><li>联合概率分布：假设训练数据与测试数据是一句联合概率分布P(X,Y)独立同分布产生的。</li><li>假设空间：由输入到输出的映射的集合。</li></ul><p><strong>（2）无监督学习</strong></p><p>从无标注数据中学习预测模型的机器学习问题。即学习数据的统计规律或潜在结构。</p><ul><li>输入空间与输出空间：模型的输入与输出的所有可能取值的集合。<ul><li>输入是实例，由特征向量表示。</li><li>输出是对输入的分析结果，由输入的类别、转换或概率表示。</li></ul></li><li>假设空间：所有模型z=g(x)的集合，其中X是输入空间，Z是隐式结构空间。</li></ul><p><strong>（3）强化学习</strong></p><p>智能系统在于环境的连续互动中学习最优行为策略的机器学习问题。智能系统观测到与环境互动得到的数据序列，本质是学习最优的序贯决策。</p><p>智能系统与环境的互动过程：每一步$t$，智能系统从环境观测到一个状态$s_t$和奖励$r_t$，采取一个动作$a_t$。环境根据智能系统的动作，确定下一步$t+1$的状态$s_{t+1}$和$r_{t+1}$。使系统实现长期累计奖励的最大化。</p><p>强化学习的马尔可夫决策过程由五元组&lt;S, A, P, r, $\gamma$&gt;组成：</p><ul><li>S：有限状态的集合</li><li>A：有限动作的集合</li><li>P：状态转移概率函数</li><li>r：奖励函数</li><li>$\gamma$：衰减系数</li></ul><p>策略：给定状态下的动作的函数<br>价值函数：策略从某一个状态开始的长期累积奖励的数学期望<br>动作价值函数：策略从某一个状态和动作开始的长期累计奖励的数学期望</p><p><strong>（4）半监督学习与主动学习</strong></p><p>半监督学习：利用标注数据和未标注数据学习预测模型的机器学习问题。</p><p>主动学习：机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。</p><h3 id="1-2-2-按模型分类">1.2.2 按模型分类</h3><p><strong>（1）概率模型与非概率模型</strong></p><ul><li>概率模型：取条件分布形式P(y|x)</li><li>非概率模型：函数形式y=f(x)</li></ul><p><strong>（2）线性模型与非线性模型</strong></p><ul><li>线性模型：感知机、线性支持向量机、k近邻、潜在语义分析</li><li>非线性模型：支持向量机、神经网络</li></ul><p><strong>（3）参数化模型与非参数化模型</strong></p><ul><li>参数化模型：假设模型参数的维度固定，模型可以由有限维参数完全刻画</li><li>非参数化模型：假设模型参数的维度不固定或者无穷大，随着训练数据量的增加而不断增大</li></ul><h3 id="1-2-2-按算法分类">1.2.2 按算法分类</h3><p><strong>（1）在线学习</strong></p><p>每次接受一个样本，进行预测，之后学习模型，并不断重复。</p><p><strong>（2）批量学习</strong></p><p>一次接受所有数据，学习模型，之后进行预测。</p><h3 id="1-2-3-按技巧分类">1.2.3 按技巧分类</h3><p><strong>（1）按贝叶斯学习</strong></p><p>在概率模型的学习和推理中，利用贝叶斯定理，计算在给定数据条件下模型的条件概率，并应用这个原理进行模型的估计。</p><p><strong>（2）核方法</strong></p><p>使用核函数表示和学习非线性模型的一种机器学习方法。</p><h1>二、统计学习的三要素</h1><h2 id="2-1-模型">2.1 模型</h2><ul><li>概率模型：假设空间为条件概率的集合。{f|Y=f(X)}</li><li>非概率模型：假设空间为决策函数的集合。{P|P(Y|X)}</li></ul><h2 id="2-2-策略">2.2 策略</h2><p><strong>（1）损失函数</strong></p><ul><li>0-1损失函数：$L(Y,f(x))=0,1$</li><li>平方损失函数：$L(Y,f(x))=(Y-f(X))^2$</li><li>绝对损失函数：$L(Y,f(x))=|Y-f(X)|$</li><li>对数损失函数：$L(Y,f(x))=-logP(Y|X)$</li></ul><p><strong>（2）风险函数</strong></p><p>损失函数的平均值，或称为期望损失。</p><p>当样本容量足够大时，经验风险最小化有利于保证很好的学习效果。当样本容量较小时，学习效果未必好，可能会产生过拟合。</p><p><strong>（3）结构风险</strong></p><p>结构风险在经验风险上加上表示模型复杂度的正则化项。</p><p>$R(f)=\frac{1}{N}\sum^N_{i=1}L(y_i,f(x_i))+\lambda J(f)$</p><p>其中$J(f)$为模型复杂度，模型越复杂其值越大。常取L1范数$||\omega||_1$或L2范数$\frac{||\omega||^2}{2}$<br>$\lambda$为系数，用于权衡风险函数与模型复杂度。</p><p>结构风险的思想其实就是奥卡姆剃刀原理，即在所有可能的模型函数中，选择能够很好的解释已知数据，并且最简单的模型。</p><h2 id="2-3-算法">2.3 算法</h2><h1>三、泛化能力</h1><p>泛化能力是学习到的模型对未知数据的预测能力。</p><h1>五、生成模型与判别模型</h1><p>极大似然估计：已知一组数据输出，定义该组数据的概率函数，通过求概率函数的极大值点，确定数据输入。</p>]]></content>
    
    
    <summary type="html">统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。本文是对李航老师的《统计学习方法》一书学习笔记。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>制作自己的Linemod数据集（ObjectDatasetTools）</title>
    <link href="https://www.mahaofei.com/post/82de970.html"/>
    <id>https://www.mahaofei.com/post/82de970.html</id>
    <published>2022-09-18T01:29:28.000Z</published>
    <updated>2022-09-18T01:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1>ObjectDatasetTools项目地址</h1><p><a href="https://github.com/F2Wang/ObjectDatasetTools">https://github.com/F2Wang/ObjectDatasetTools</a></p><p>本文过程参考该项目</p><h1>介绍</h1><p>这个工具是一个纯python脚本，用来从RGBD相机中创建物体的掩码，边界框标签，3D物体mesh文件。</p><p>该工具可以为各种深度学习项目准备训练和测试数据，例如6D位姿估计、对象检测、实例分割等等。</p><h1>准备工作</h1><p>彩色打印arucomarkers文件夹下的aruco markers标记版，ID1-13，一共三页A4纸。</p><p>将标记一个一个剪下来，贴在物体周围。</p><p><img src="https://img.mahaofei.com/img/20220918100104.png" alt=""></p><p>使用conda新建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n objectdatasettools python=2.7</span><br><span class="line">conda activate objectdatasettools</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake git pkg-config libssl-dev libgl1-mesa-glx</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy Cython==0.19 pypng==0.0.18 scipy scikit-learn open3d==0.9.0 scikit-image tqdm pykdtree opencv-python==3.3.0.10 opencv-contrib-python==3.3.0.10  trimesh==2.38.24</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyrealsense2</span><br><span class="line"><span class="comment"># 如果过慢，可以使用pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyrealsense2</span></span><br></pre></td></tr></table></figure><h1>录制视频</h1><p><strong>（1）如果有Realsense相机</strong></p><p>使用Realsense相机录制一段物体的视频，<a href="http://xn--record-og8ii8dy87a7nk7p1a8hlv28a.py">对于旧模型使用record.py</a>，对librealsense SDK <a href="http://2.xn--0recordf2-bd9n9724a.py">2.0使用recordf2.py</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python record2.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>默认情况下，脚本在倒计时5后录制40秒，录制时间长度可以在record.py中的第20行进行修改。可以通过按“q”退出录制。</p><p>请稳定移动相机以获得物体的不同视图，同时始终保持 2-3 个标记在相机的视野范围内。</p><p>请注意，该项目假设所有序列都保存在名为“LINEMOD”的文件夹下，使用其他文件夹名称会导致错误发生。</p><p>如果使用record.py创建序列，彩色图像、深度图以及相机参数会自动保存在序列目录下。</p><p><img src="https://img.mahaofei.com/img/20220918154609.png" alt=""></p><p><strong>（2）如果有现有的图像</strong></p><p>如果已有彩色图像或者深度图像，则应将彩色图像（.jpg）放在名为“JPEGImages”的文件夹中，并将对其的深度图像放在“depth”文件夹中。</p><p>注意：该算法假定深度图与彩图对齐。将彩图按顺序从0.jpg、1.jpg、…、600.jpg和相应的深度图命名为：0.png,…,600.png，同时应在序列目录下创建一个名为“intrinsics.json”的文件，并按照如下形式手动输入相机参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;fx&quot;</span><span class="punctuation">:</span> <span class="number">614.4744262695312</span><span class="punctuation">,</span> <span class="attr">&quot;fy&quot;</span><span class="punctuation">:</span> <span class="number">614.4745483398438</span><span class="punctuation">,</span> <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">480</span><span class="punctuation">,</span> <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">640</span><span class="punctuation">,</span> <span class="attr">&quot;ppy&quot;</span><span class="punctuation">:</span> <span class="number">233.29214477539062</span><span class="punctuation">,</span> <span class="attr">&quot;ppx&quot;</span><span class="punctuation">:</span> <span class="number">308.8282470703125</span><span class="punctuation">,</span> <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;620201000292&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1>获取帧之间的变换</h1><p>计算第一帧的变换，以制定的间隔（可在config/registrationParameters修改间隔），将变换（4x4矩阵）保存为numpy数组。计算结果保存在<code>LINEMOD/OBJECTNAME/transforms.npy</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python compute_gt_poses.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python compute_gt_poses.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><h1>目标物体三维重建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python register_scene.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>上面代码会原始的registeredScene.ply将保存在指定的目录下（例如，LINEMOD/OBJECTNAME/registeredScene.ply）。registerScene.ply是整个场景的点云，包括桌面、标记纸，物体等等相机中的对象。</p><p><img src="https://img.mahaofei.com/img/20220918154806.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python register_segmented.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>使用上面的代码可跳过手动工作，来删除不需要的背景，并实现物体的三维重建</p><p>register_segmented.py会将物体点云转换为mesh网络。FILLBOTTOM设置为true，算法会自动使用平坦表面填充物体底部。</p><p>但是register_segmented.py可能会失败，这时候需要调整一些参数来使算法可以正常运行。最重要的参数是MAX_RADIUS，如果物体较大，需要增加此值以保证对象不会被截断。</p><p><strong>调整MAX_RADIUS参数，使模型尽可能精准。生成后使用MeshLAB手动删除孤立的点和区域，然后手动保存一次。</strong></p><h1>手动处理点云</h1><p>如果上面的register_segmented.py处理结果比较满意，可以跳过该步骤。</p><p>将生成的点云数据registeredScene.ply使用meshlab打开：</p><ol><li>删除背景</li><li>进行表面重建补全缺失的底部</li><li>处理重建后的网络</li><li>确保处理后的网格没有孤立地噪声</li></ol><p>最终生成mesh网格文件。</p><h1>生成图像掩码和标签文件</h1><p>当完成了物体mesh网格文件的生成后，使用以下程序创建图像掩码和标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_label_files.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_label_files.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>这一步骤会生成一个名为OBJECTNAME.ply的文件，用meshlab打开此文件，另存为mesh并取消勾选binary，保存的文件就是数据集的<strong>模型文件</strong>。其AABB以原点为圆心，并与OBB的尺寸相同，同时在mask文件夹下会生成图像的掩码，transforms文件夹下会保存新mesh的变换矩阵，labels文件夹内保存标签文件。</p><p>同时将打印出的min_xyz和size_xyz复制到<strong>models_info.yml</strong>文件中。</p><p>使用下面的命令可以检查创建的边界框和掩码的正确性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python inspectMasks.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><h1>获得物体比例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getmeshscale.py</span><br></pre></td></tr></table></figure><p>将物体直径复制到<strong>models_info.yml</strong>文件中。</p><h1>创建边界框标签</h1><p>在获取了物体的mask后，使用下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get_BBs.py</span><br></pre></td></tr></table></figure><p>会在根目录创建annotations.csv文件，包含所有图片的物体类别的标签和边界框信息。</p><h1>匹配数据集格式</h1><p>下面4个程序是自己写的，主要用来将生成的linemod数据集进行处理，整理成linemod_processed数据集的格式。</p><p>（等有时间了把这几个程序上传上来）</p><p>从<code>annotations.csv</code>中生成<code>gt.yml</code>与<code>info.yml</code>。需要修改每个物体对应的<code>obj_id</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python generate_yml.py LINEMOD/timer</span><br></pre></td></tr></table></figure><p>将图片重命名为如<code>0000.png</code>格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rename.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>根据每个物体的图片数量划分数据集，生成<code>train.txt</code>与<code>test.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python data_divide.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>（将ply文件中的坐标单位由m转为mm），使用meshlab打开<code>objectname.ply</code>文件，删除无效点后保存为<code>objectname_aligned.ply</code>，勾选<code>normal</code>和<code>color</code>，取消勾选<code>binary encoding</code>。</p><p>然后运行下面的指令，将点云文件的单位由m转换为mm：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python plym2mm.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">目前正在学习6D位姿估计算法，该领域最常用的数据集就是LineMod数据集，但是只在数据集上测试还是不够，想要实际应用还需要搭建自己的数据集。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="位姿估计" scheme="https://www.mahaofei.com/tags/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/"/>
    
    <category term="Linemod" scheme="https://www.mahaofei.com/tags/Linemod/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】FFB6D</title>
    <link href="https://www.mahaofei.com/post/d027527.html"/>
    <id>https://www.mahaofei.com/post/d027527.html</id>
    <published>2022-09-15T12:25:09.000Z</published>
    <updated>2022-09-15T12:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><p>该方法认为RGB图像和深度信息是两个数据源，关键在于如何使两者有机结合。</p><blockquote><p>Our key insight is that appearance information in the RGB image and geometry information from the depth image are two complementary data sources, and it still remains unknown how to fully leverage them.</p></blockquote><p>通过在RGB和深度信息的特征提取网络的每一层中建立<strong>双向融合通道</strong>，这样两个网络可以使用另一个网络的局部和全局特征。</p><blockquote><p>Specifically, at the representation learning stage, we build bidirectional fusion modules in the full flow of the two networks, where fusion is applied to each encoding and decoding layer . In this way, the two networks can leverage local and global complementary information from the other one to obtain better representations.</p></blockquote><p>在网络输出层，设计了考虑纹理和几何信息的<strong>关键点选取算法</strong>，简化了关键点定位，实现了精确的位姿估计。</p><blockquote><p>Moreover , at the output representation stage, we designed a simple but effective 3D keypoints selection algorithm considering the texture and geometry information of objects, which simplifies keypoint localization for precise pose estimation.</p></blockquote><h1>二、FFB6D的流程框图</h1><p><strong>整体流程</strong></p><p><img src="https://img.mahaofei.com/img/20221108111424.png" alt=""></p><p>利用CNN和点云网络分别对RGB和点云进行表示，两个网络的每一层之间通过双向融合模块搭建桥梁。最终提取的逐点特征被送入实例分割模块和3D关键点投票模块，最终回归出物体的6D位姿。</p><p><strong>像素-&gt;点云融合模块</strong></p><p><img src="https://img.mahaofei.com/img/20221108210334.png" alt=""></p><p>RGB特征图部分：对于每一个点云，找到它的空间最近邻点，搜索这些点对应的RGB特征图，通过池化和共享多层感知机将这些特征图生成为一个RGB特征图。</p><p>点云特征部分：直接提取点云特征。</p><p>两者组合成为一组新的RGB-点云特征，交给下一层进行处理。</p><p><strong>点云-&gt;像素融合模块</strong></p><p><img src="https://img.mahaofei.com/img/20221108210504.png" alt=""></p><p>与像素-&gt;点云为对偶处理方式。</p><h1>三、具体实现</h1><h2 id="3-1-总体流程">3.1 总体流程</h2><ul><li>逐点提取RGBD特征，用于每个物体的3D关键点定位<ul><li>CNN网络提取RGB特征</li><li>Point Cloud Net提取点云特征</li><li>两者双向融合</li></ul></li><li>将逐点特征输入到实例分割网络和3D关键点检测模块，提取每个物体的3D关键点</li><li>用最小二乘法拟合姿态参数</li></ul><h2 id="3-2-双向融合网络">3.2 双向融合网络</h2><blockquote><p>Full Flow Bidirectional Fusion Network</p></blockquote><p>在特征提取前首先用相机标定矩阵将深度图转换为点云图。</p><p>网络基本框架是分别用CNN和PCN网络对RGB和点云进行特征提取，并在两个网络之间添加双向通信模块。</p><p><strong>（1）像素-&gt;点云融合 Pixel-to-point fusion</strong></p><p>常规方法是从RGB图中生成图像的全局特征，添加到每一个，但这种方法会引入背景和其他物体的特征，对结果反而造成干扰。</p><p>本文所使用的方法为：</p><ul><li>接受<em>RGBD特征图</em>，对于点云特征图中每一个点云</li><li>找到其在XYZ空间对应的点，以及周围的最近邻点</li><li>找到这些点对应的RGB特征</li><li>将这些RGB特征通过最大池化和多层感知机压缩到一个通道中</li><li>把<em>一个点云特征</em>和<em>一个压缩好的图像特征</em>串联组合成<em>一组RGBD特征向量</em></li><li>同样方法计算所有点的RGBD特征向量，组成传递<em>RGBD特征图</em>给下一层</li></ul><p>注意：由于随深度的增加，特征图的尺寸将会减小，需要采取方法使每一个特征图像素能找到它对应的3D点云坐标。本文采取的方式是<em>在最近邻搜索算法中也使用同样步长的卷积核进行卷积</em>，这样图像特征图和点云特征图就可以对应了。（不将整个点云特征进行同样的卷积是为了避免前景背景深度大幅度变化导致的卷积噪声）</p><p><strong>（2）点云-&gt;像素融合 Point-to-pixel fusion</strong></p><p>与像素-&gt;点云融合类似</p><ul><li>接受<em>RGBD特征图</em>，对于RGB特征图中每一个像素</li><li>找到其在XYZ空间对应的点，以及周围的最近邻点</li><li>找到这些点对应的点云特征</li><li>将这些点云特征通过最大池化和多层感知机压缩到一个通道中</li><li>把<em>一个RGB特征</em>和<em>一个压缩好的点云特征</em>串联组合成<em>一组RGBD特征向量</em></li><li>同样方法计算所有点的RGBD特征向量，组成传递<em>RGBD特征图</em>给下一层</li></ul><h2 id="3-3-基于3D关键点的6D位姿估计">3.3 基于3D关键点的6D位姿估计</h2><p>该部分延续了PVN3D的3D关键点算法，进行了优化使算法能够充分利用图像和纹理信息。</p><p><strong>（1）逐对象的3D关键点检测</strong></p><p>通过实例语义分割模块来区分不同的对象，包括语义分割和中心点投票两个子模块。</p><ul><li>前者用于预测每个点的语义标签</li><li>后者计算每个点到对象中心的距离。</li></ul><p>通过添加关键点投票模块来恢复每个对象的3D关键点。学习选定的关键点（利用MeanShift聚类方式）的逐点偏移来实现。</p><p><strong>（2）关键点选择</strong></p><p>以前的方法是在物体表面通过最远点采样算法FPS，首<em>先确定一组随机点</em>，然后再物体表面逐个找到FPS最远点并加入到序列中，直到点数量到达N。<br>这种方法有时会随机到没有特征的平坦表面，得到的关键点反而没有特征。</p><p>本文提出了SIFT-FPS方法，通过<em>在二维平面中用SIFT算法找到特征点，作为初始序列</em>，然后使用FPS找到N个关键点。</p><p><strong>（3）最小二乘拟合</strong></p><p>上面计算的是物体坐标系的3D关键点，即每个关键点相对于物体中心的偏移量。</p><p>我们又有相机中每个点的3D关键点对应的点云坐标。</p><p>通过最小二乘拟合我们就可以计算物体的位姿了。</p><h2 id="3-4-网络体系">3.4 网络体系</h2><p><strong>RGB</strong>：使用ImageNet预训练的ResNet34作为RGB的编码器，使用PSPNet作为解码器</p><p><strong>PointCloud</strong>：从深度图中抽取了12288个点，使用RandLA-Net进行学习。</p><p>上述两个网络的编解码层，利用最大池化和共享MLP构建双向融合模块。</p><p><strong>常规优化</strong>：语义分割分支使用Focal Loss，中心点投票和3D关键点投票使用L1 Loss。</p><p><strong>SIFT-FPS</strong>：将目标物体放在球体的中心，并等距采样摄像机的视点，通过渲染引擎获得带有相机姿态的RGBD图像，然后使用SIFT检测2D关键点，并转换到3D，在转换为相机坐标系。<br>（应该是使用mesh模型获取RGBD图像和关键点）</p><h1>总结</h1><p>相比于DenseFusion，我认为FFB6D通过一些rgb工作做了很有用的改进。</p><p>首先DenseFusion是利用CNN和PCN单独提取RGB和点云的特征，再加上全局特征，三者合并组合成一个点的特征，然后进行姿态预测。</p><p>而FFB6D相当于在特征提取阶段就将RGB和点云信息进行了融合，然后进行实例分割和关键点检测。</p><p>用不恰当的比喻，类比到2D图像识别中：<br>DenseFusion是从用一个网络提取每个点的X方向特征，再用一个网络提取每个点的Y方向特征，在提取整张图的全局特征，三者串在一起就是一个点的特征向量，用这个特征向量再进行回归计算。<br>FFB6D是在每一个点上，在一个网络中每层都同时看X方向和Y方向的特征，得到的也是两者组合的特征。</p><p>特征的含义：同样类比与二维图像识别，例如人脸识别，前几层每个特征图提取的是局部特征，例如边界线，角点，中间几层特征图得到的是部分特征，例如嘴角，眼睛，鼻子等，最后几层特征图得到的是整体特征，每个特征图中基本都包含一个人脸。此处也类似，使用点特征也就对应二维的像素，前几层提取的是局部特征，就是物体的边、角等，最后几层特征图就会代表物体整体。</p><h1>问题</h1><p>既然有RGB卷积网络，为什么不能有4通道卷积，类比于图像处理，直接将RGBD通过一个卷积核得到一个数字，将D也作为一个通道，这样是否有效？</p><hr><hr><h1>代码复现</h1><h2 id="1-安装">1 安装</h2><h2 id="1-1-准备工作">1.1 准备工作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethnhe/FFB6D.git</span><br></pre></td></tr></table></figure><h2 id="1-2-环境搭建">1.2 环境搭建</h2><p><strong>创建虚拟环境</strong>（据说3.6可以正常使用，3.8无法成功）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n ffb6d python=3.6</span><br><span class="line">conda activate ffb6d</span><br></pre></td></tr></table></figure><p>修改<code>requirement.txt</code>，将<code>yaml</code>改为<code>pyyaml</code>，删除<code>pprint</code>和<code>glumpy</code>，并在最后添加下面这些包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tqdm  </span><br><span class="line">tensorboardX  </span><br><span class="line">pandas  </span><br><span class="line">scikit-learn  </span><br><span class="line">termcolor</span><br><span class="line">packaging</span><br></pre></td></tr></table></figure><p>然后<strong>安装依赖</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirement.txt</span><br><span class="line">pip3 install glumpy</span><br></pre></td></tr></table></figure><p><strong>安装apex</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NVIDIA/apex</span><br><span class="line"><span class="built_in">cd</span> apex</span><br><span class="line"><span class="built_in">export</span> TORCH_CUDA_ARCH_LIST=<span class="string">&quot;6.0;6.1;6.2;7.0;7.5&quot;</span>  <span class="comment"># set the target architecture manually, suggested in issue https://github.com/NVIDIA/apex/issues/605#issuecomment-554453001</span></span><br><span class="line">pip3 install -v --disable-pip-version-check --no-cache-dir --global-option=<span class="string">&quot;--cpp_ext&quot;</span> --global-option=<span class="string">&quot;--cuda_ext&quot;</span> ./</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>python setup.py egg_info Check the logs for full command output</code>的错误<br>使用<code>python setup.py install -v</code>安装</p></blockquote><p><strong>安装normalSpeed</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hfutcgncas/normalSpeed.git</span><br><span class="line"><span class="built_in">cd</span> normalSpeed/normalSpeed</span><br><span class="line">python3 setup.py install --user</span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure><p><strong>安装tkinter</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-tk</span><br></pre></td></tr></table></figure><p><strong>编译RandLA-Net</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffb6d/models/RandLA/</span><br><span class="line">sh compile_op.sh</span><br></pre></td></tr></table></figure><h2 id="2-数据准备">2 数据准备</h2><ul><li><a href="https://hkustconnect-my.sharepoint.com/:u:/g/personal/yhebk_connect_ust_hk/ETW6iYHDbo1OsIbNJbyNBkABF7uJsuerB6c0pAiiIv6AHw?e=eXM1UE">LineMOD数据集</a></li><li><a href="https://rse-lab.cs.washington.edu/projects/posecnn/">YCB-Video数据集</a></li></ul><h2 id="3-训练、评估与可视化">3 训练、评估与可视化</h2><h2 id="4-自己的数据集">4 自己的数据集</h2><h3 id="4-1-生成mesh信息">4.1 生成mesh信息</h3><p><strong>（1）安装raster_triangle进行RGBD图像渲染</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethnhe/raster_triangle.git</span><br><span class="line"><span class="built_in">cd</span> raster_triangle</span><br><span class="line">sh rastertriangle_so.sh</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>fatal error: opencv2/highgui/highgui.hpp: No such file or directory</code><br>修改<code>rastertriangle_so.sh</code>文件中<code>-I</code>部分为<code>-I /usr/include/opencv4</code></p><p>修改后如下:<br><code>g++ rastertriangle_so.cpp -o rastertriangle_so.so -shared -fPIC -Wall -I /usr/include/opencv4 -L/usr/lib/x86_64-linux-gnu -lopencv_stitching -lopencv_objdetect -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_video -lopencv_photo -lopencv_ml -lopencv_imgproc -lopencv_flann -lopencv_core</code></p></blockquote><p><strong>（2）编译FPS脚本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffb6d/utils/dataset_tools/fps/</span><br><span class="line">python3 setup.py build_ext --inplace</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p><strong>（3）安装python依赖</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirement.txt</span><br></pre></td></tr></table></figure><p><strong>（4）生成物体的信息，如半径、3D关键点等</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gen_obj_info.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>如果使用ply模型，并且角点颜色信息包含在ply模型中，可以使用默认raster triangle来渲染。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以ape物体为例</span></span><br><span class="line"><span class="comment"># 需要根据情况设置单位参数scale2m，使生成的信息都以m为单位</span></span><br><span class="line">python3 gen_obj_info.py --obj_name=<span class="string">&#x27;ape&#x27;</span> --obj_pth=<span class="string">&#x27;example_mesh/ape.ply&#x27;</span> --scale2m=1000. --sv_fd=<span class="string">&#x27;ape_info&#x27;</span></span><br></pre></td></tr></table></figure><p>如果使用obj模型，可以将每一个角点转换为米为单位，然后使用pyrender。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以cracker box物体为例</span></span><br><span class="line">python3 gen_obj_info.py --obj_name=<span class="string">&#x27;cracker_box&#x27;</span> --obj_pth=<span class="string">&#x27;example_mesh/003_cracker_box/textured.obj&#x27;</span> --scale2m=1. --sv_fd=<span class="string">&#x27;cracker_box_info&#x27;</span> --use_pyrender</span><br></pre></td></tr></table></figure><blockquote><p><strong>bug：需要python3.8</strong></p></blockquote><h3 id="4-2-修改数据集信息">4.2 修改数据集信息</h3><p>先将<code>FFB6D/ffb6d/common.py</code>文件复制备份一个。</p><p>然后修改<code>FFB6D/ffb6d/common.py</code>文件内容。</p><h3 id="4-3-编写数据集预处理脚本">4.3 编写数据集预处理脚本</h3><p>参考<code>FFB6D/ffb6d/datasets/ycb/ycb_dataset.py</code>，注意要正确修改调用模型信息的函数，例如3D关键点、中心点、半径等。</p><h3 id="4-4-检查数据集预处理情况（非常重要）">4.4 检查数据集预处理情况（非常重要）</h3><p>通过可视化检查是否正确处理了数据，例如投影的关键点、中心点、每个点的语义标签等是否正确。</p><p>例如可以运行<code>python3 -m datasets.ycb.ycb_dataset</code>来可视化投影的中心点和所选的关键点。</p><h3 id="4-5-确保数据能被正确加载">4.5 确保数据能被正确加载</h3><p>检查<code>FFB6D/ffb6d/utils/pvn3d_eval_utils.py</code>中能否正确在物体坐标系中加载关键点、中心点、半径等信息。</p><h3 id="4-6-检查所有设置是否正确">4.6 检查所有设置是否正确</h3><p>利用ground_truth数据进行评估，检查所有设置是否正确，如果正确，结果应该接近100。</p><p>例如将<code>-test_gt</code>参数传给<code>train_ycb.py</code>，就可以获得YCB数据集的ground_truth结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tst_mdl=train_log/ycb/checkpoints/FFB6D_best.pth.tar</span><br><span class="line">python3 -m torch.distributed.launch --nproc_per_node=1 train_ycb.py --gpu <span class="string">&#x27;0&#x27;</span> -eval_net -checkpoint <span class="variable">$tst_mdl</span> -<span class="built_in">test</span> -test_pose -test_gt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">FFB6D相当于在特征提取阶段就将RGB和点云信息进行了融合，然后进行实例分割和关键点检测。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="位姿估计" scheme="https://www.mahaofei.com/tags/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】DenseFusion</title>
    <link href="https://www.mahaofei.com/post/362c6c6a.html"/>
    <id>https://www.mahaofei.com/post/362c6c6a.html</id>
    <published>2022-09-12T08:03:28.000Z</published>
    <updated>2022-09-12T08:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1>介绍</h1><p>以前的位姿估计工作，要么单独提取RGB和深度图，要么使用了昂贵的后处理过程，例如posecnn，这使得算法在聚集场景的应用与实时性受到了很大的限制。</p><p>本文提出了一种异形架构，对两个数据源（RGB和深度图）进行分别处理，并用一种新型的dense fusion network提取像素级稠密特征，从中估计姿态。</p><p>此外本文还提出了一种端到端的姿态优化步骤，进一步改善了估计过程，可以实现接近实时的判断。</p><h1>模型</h1><p>本文的模型是为了从一系列RGBD图像中估计物体的6D位姿。为了不丧失一般性，6D位姿使用齐次变换矩阵表示，即旋转矩阵$R\in SO(3)$和平移矩阵$T\in \mathbb R^3$。并且，由于物体的6D位姿来自相机，因此结果都是相对相机参考系。</p><p>本文的关键是如何从不同的两种数据（RGB和深度图）中提取特征，并进行适当的融合。</p><h2 id="总体架构">总体架构</h2><p>总体架构主要分为两个阶段：</p><ol><li>第一阶段：对RGB图进行语义分割，分割出所有已知的目标物体。然后将掩码对应的图像，以及深度像素送入第二阶段。</li><li>第二阶段：加工分割的结果，并估计物体的6D位姿。该阶段包含以下组件<ul><li>一个全卷积网络，处理颜色信息，并将裁减的图像中每个像素映射到一个颜色特征向量</li><li>一个基于PointNet的点云处理网络，将掩码对应的点云处理为一个几何特征向量</li><li>一个融合上面两个特征向量的像素级融合网络，并基于无监督置信度评分输出物体的6D位姿估计</li><li>一种迭代自优化方法，以学习的方式训练网络并迭代优化估计结果</li></ul></li></ol><p><img src="https://img.mahaofei.com/img/20220912191133.png" alt="网络结构"></p><p><img src="https://img.mahaofei.com/img/20220912194924.png" alt="迭代自优化方法"></p><h2 id="语义分割">语义分割</h2><p>语义分割网络，将图像作为输入，生成一个N+1通道的语义分割图（背景+N个物体分类），每个通道都是二维掩码。</p><p>本文使用的是现有的语义分割架构，由PoseCNN所提出的语义分割分支。</p><h2 id="稠密特征提取">稠密特征提取</h2><p>对于颜色信息和深度信息，本文分别单独处理它们，从特征向量中获得颜色和几何特征。</p><p><strong>(1)稠密3D点云特征</strong></p><p>以往方法通常将深度信息作为图像的额外通道进行处理，但这样会忽视隐含在深度通道的3D结构信息。因此本文将掩码分割出的深度像素转换为点云，然后使用类PointNet结构提取几何特征。</p><p>PointNet将原始点云作为输入，然后学习将每个点附近的信息和点云作为整体进行编码。本文提出了一个几何特征网络，通过映射每个分割点云的点到一个特征图中，来生成一个密集的逐点特征。</p><p><strong>(2)稠密颜色特征</strong></p><p>图像特征生成网络是一个基于CNN的编码解码架构，将图像$(H, W, 3)$映射为$(H, W, d_{rgb})$，每个像素点的特征向量代表了输入图像中该点的外观信息。</p><h2 id="像素级特征融合">像素级特征融合</h2><p>关键思想是进行局部的主像素融合，而不是全局融合，这样我们可以基于每个融合后的特征进行预测。这样我们就可以选择物体的可见部分进行预测，从而减少了遮挡和语义分割的噪声的影响。</p><p>首先，利用相机固有参数投影到图像平面，将每个点的几何特征与图像特征关联起来。将配对的特征送入另一个网络，利用对陈下降函数来产生固定大小的全局特征，用来丰富每个像素级特征。</p><p>然后将每个像素特征输入到一个最终的网络来预测物体的6D位姿。这个网络用来从每个密集的融合特征预测一个姿态，最终获得P个姿态。</p><p>同时网络还输出每个预测姿态的置信度，用来评价那个姿态估计的结果最好。</p><h2 id="损失函数">损失函数</h2><p>损失函数的设计与PoseCNN类似。</p><p>本文将损失函数定义为真实位姿的模型的采样点与预测位姿的模型的对应点之间的距离。</p><p><img src="https://img.mahaofei.com/img/20220912210553.png" alt=""></p><p>对于对称物体，损失函数定义为预测模型上每个点与真实位姿上最近的点之间的距离。</p><p><img src="https://img.mahaofei.com/img/20220912210610.png" alt=""></p><p>此外，由于每个像素的预测结果也同时输出了置信度，因此利用此置信度，对每个像素的损失进行加权。</p><p><img src="https://img.mahaofei.com/img/20220912210624.png" alt=""></p><h2 id="迭代优化">迭代优化</h2><p>以往的位姿估计算法，通常采用ICP来优化。但ICP的实时性不足够满足实际应用。</p><p>本文提出了一种基于神经网络的迭代优化方法，利用稠密融合的特征，可以改善最终的姿态估计结果，使其具有鲁棒性和快速性。</p><p>由于这个网络的作用是优化位姿估计的结果以减小误差，因此需要将上一个迭代的预测结果作为下一个迭代的输入的一部分。</p><p>该方法将先前的预测的姿态作为目标对象坐标系的估计，并将输入的点云转换为估计的坐标系中，通过这种方式转换的点云，就隐含了上一步估计的位姿。然后将转换后的点云输入到网络中，根据之前估计的位姿预测余项，通过不点迭代获得更精确的姿态估计。</p><h1>问题</h1><ol><li><p>new_target和new_points是当前点云经过逆变换的点，这个点代表了什么</p></li><li><p>PoseNet输入的img是实例分割后的mask区域img，测试时实例分割部分如何实现</p></li></ol><hr><h1>代码实现</h1><blockquote><p>参考：<a href="https://blog.csdn.net/weixin_44564705/article/details/125149491">https://blog.csdn.net/weixin_44564705/article/details/125149491</a></p></blockquote><h2 id="下载代码">下载代码</h2><p>原作者：</p><ul><li>原版：<a href="https://github.com/j96w/DenseFusion">https://github.com/j96w/DenseFusion</a></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/j96w/DenseFusion</span><br></pre></td></tr></table></figure><ul><li>Pytorch-1.0：<a href="https://github.com/j96w/DenseFusion/tree/Pytorch-1.0">https://github.com/j96w/DenseFusion/tree/Pytorch-1.0</a></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b Pytorch-1.0 https://github.com/j96w/DenseFusion</span><br></pre></td></tr></table></figure><p>RTX30系显卡适配：</p><ul><li>darpado构建的代码：<a href="https://github.com/drapado/DenseFusion-1/tree/Pytorch-1.6">https://github.com/drapado/DenseFusion-1/tree/Pytorch-1.6</a></li><li>并按照<a href="https://github.com/j96w/DenseFusion/pull/170#issuecomment-920496824">此评论修改loss_refiner.py</a></li></ul><h2 id="环境搭建">环境搭建</h2><p><strong>（1）创建conda环境</strong></p><p>使用anaconda创建一个虚拟环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name densefusion python=3.6</span><br></pre></td></tr></table></figure><p>激活虚拟环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate densefusion</span><br></pre></td></tr></table></figure><p><strong>（2）配置CUDA和Pytorch</strong></p><p>按照Github博主的Pytorch1.0分支，下载对应的版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原版</span></span><br><span class="line">conda install pytorch==1.0.0 torchvision==0.2.1 cuda100 -c pytorch</span><br><span class="line"><span class="comment"># 30系</span></span><br><span class="line">conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><p>cuda和pytorch安装后，可以命令行输入<code>python</code>，进入后使用以下代码确认cuda是否可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available)</span><br></pre></td></tr></table></figure><p><strong>（3）安装依赖</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install trimesh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install scipy pyyaml matplotlib -y</span><br></pre></td></tr></table></figure><h2 id="数据集准备">数据集准备</h2><p>参考：[[06_制作自己的Linemod数据集（ObjectDatasetTools）]]</p><h2 id="依赖库KNN">依赖库KNN</h2><p>knn需要在自己的环境中进行编译，RTX30系显卡在这一步是会出现各种错误，推荐使用<a href="https://github.com/drapado/DenseFusion-1/tree/Pytorch-1.6">darpado修改的源码</a>，并<a href="https://github.com/j96w/DenseFusion/pull/170#issuecomment-920496824">修改loss_refiner</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lib/knn</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>执行后会在lib/knn路径下出现一个dist文件夹，里面是编译好的.egg文件，将此文件解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line"><span class="comment">#输入你自己的编译文件名</span></span><br><span class="line">unzip knn_pytorch-0.1-py3.6-linux-x86_64.egg</span><br></pre></td></tr></table></figure><p>解压后会在dist文件夹里面生成两个文件夹，进入knn_pytorch文件夹里面，将下面两个文件移动到lib/knn里面：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> knn_pytorch</span><br><span class="line"><span class="built_in">cp</span> knn_pytorch.cpython-36m-x86_64-linux-gnu.so ../../</span><br><span class="line"><span class="built_in">cp</span> knn_pytorch.py ../../</span><br></pre></td></tr></table></figure><h2 id="开始训练">开始训练</h2><p>回到DenseFusion根目录，为sh文件添加可执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./experiments/scripts/train_linemode.sh</span><br></pre></td></tr></table></figure><h2 id="可能遇到的错误">可能遇到的错误</h2><ol><li>libgio-2.0.so.0: undefined symbol: g_uri_join while importing cv2 in conda environmnent</li></ol><p>参考：<a href="https://github.com/opencv/opencv/issues/20212">https://github.com/opencv/opencv/issues/20212</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv ~/anaconda3/envs/&lt;anaconda_env&gt;/lib/libgio-2.0.so.0 ~/anaconda3/envs/&lt;anaconda_env&gt;/lib/libgio-2.0.so.0.backup</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文提出了一种异形架构，对两个数据源（RGB和深度图）进行分别处理，并用一种新型的dense fusion network提取像素级稠密特征，从中估计姿态。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="位姿估计" scheme="https://www.mahaofei.com/tags/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/"/>
    
    <category term="DenseFusion" scheme="https://www.mahaofei.com/tags/DenseFusion/"/>
    
  </entry>
  
  <entry>
    <title>【论文复现】PVNet</title>
    <link href="https://www.mahaofei.com/post/fa97b07e.html"/>
    <id>https://www.mahaofei.com/post/fa97b07e.html</id>
    <published>2022-09-12T02:51:48.000Z</published>
    <updated>2022-09-12T02:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PVNet尚未跑通，暂时放弃。</p></blockquote><h1>环境搭建</h1><p><strong>（1）创建虚拟环境</strong></p><p>创建conda环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pvnet python=3.7</span><br><span class="line">conda activate pvnet</span><br><span class="line"></span><br><span class="line">conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge</span><br><span class="line"></span><br><span class="line">pip install Cython==0.28.2</span><br><span class="line">sudo apt-get install libglfw3-dev libglfw3</span><br></pre></td></tr></table></figure><p>注释掉<code>requirement.txt</code>中<code>numpy</code>和<code>ipdb</code>的版本限制，然后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><strong>（2）编译扩展程序</strong></p><p>创建环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CUDA_HOME=<span class="string">&quot;/usr/local/cuda-11.6&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd lib/cscr</span><br></pre></td></tr></table></figure><p>编译ransac_voting</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ransac_voting</span><br><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>编译nn</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../nn</span><br><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>编译fps</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../fps</span><br><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><h1>准备数据集</h1><p>使用Objectdatasettools创建数据集，并按照下面的格式整理：</p><p>整理好后的文件参考：<a href="https://zjueducn-my.sharepoint.com/:u:/g/personal/pengsida_zju_edu_cn/Ec6Hd9j7z4lCiwDhqIwDcScBGPw2rsbn6FJh1C2FwbPJTw?e=xcKGAw">此文件</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── /path/to/dataset</span><br><span class="line">│   ├── model.ply</span><br><span class="line">│   ├── camera.txt</span><br><span class="line">│   ├── diameter.txt  // the object diameter, whose unit is meter</span><br><span class="line">│   ├── rgb/</span><br><span class="line">│   │   ├── 0.jpg</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── 1234.jpg</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   ├── mask/</span><br><span class="line">│   │   ├── 0.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── 1234.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   ├── pose/</span><br><span class="line">│   │   ├── pose0.npy</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── pose1234.npy</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   └──</span><br></pre></td></tr></table></figure><p>创建软连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/custom_dataset data/custom</span><br></pre></td></tr></table></figure><p>处理数据集</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run.py --<span class="built_in">type</span> custom</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>ValueError: shapes (8,4) and (3,3) not aligned: 4 (dim 1) != 3 (dim 0)</code>的问题<br>修改<code>lib/utils/base_utils</code>第23行如下<br><code>xyz = np.dot(xyz, RT[:3, :3].T) + RT[:3, 3:].T</code></p></blockquote>]]></content>
    
    
    <summary type="html">尝试测试PVNet，中途放弃。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="实验" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="位姿估计" scheme="https://www.mahaofei.com/tags/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【论文笔记】PoseCNN</title>
    <link href="https://www.mahaofei.com/post/20f6fcc2.html"/>
    <id>https://www.mahaofei.com/post/20f6fcc2.html</id>
    <published>2022-09-07T12:25:09.000Z</published>
    <updated>2022-09-07T12:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、介绍</h1><h2 id="1-1-问题提出">1.1 问题提出</h2><p>物体之间的遮挡和聚集增加了6D位姿估计的难度。</p><p>现有方法</p><ul><li>传统基于RGB图像，依赖纹理，无法处理弱纹理物体</li><li>基于RGBD模板，受遮挡影响较大</li><li>2D-&gt;3D的方法无法处理对称物体</li></ul><h2 id="1-2-方法介绍">1.2 方法介绍</h2><p><strong>（1）概述</strong></p><p>PoseCNN（利用RGB图像进行位姿估计，使用RGBD图像进行位姿优化）</p><ul><li>物体的3D位置和到相机的距离通过计算图像中物体的中心来估计。</li><li>物体的3D旋转通过回归到四元数来估计。</li></ul><p>提出了一种损失函数解决对称物体的估计。</p><p><strong>（2）思路</strong></p><p>PoseCNN的关键想法：将位姿估计解耦为位置和姿态两个不同的部分，使网络可以对两个系统的独立性和依赖性建模。</p><ul><li>预测每个像素的语义标签</li><li>估计2D图像坐标系下的物体中心</li><li>估计物体中心与相机的距离（利用每个像素语义标签和物体中心位置）</li><li>估计3D位置</li><li>估计3D姿态（通过边界框内物体的四元数）</li></ul><p><strong>（3）对称物体的处理</strong></p><p>由于对称物体在不同角度观测时可能得到同样的结果，无法估计它们的姿态。</p><p>提出ShapeMatch-Loss。</p><h1>二、PoseCNN</h1><p>物体的位姿估计，就是估计物体坐标系与相机坐标系之间的刚性变换SE3，包含旋转R和平移T。T决定了图像中物体的位置和大小，R决定了物体在图像中的形状和纹理。</p><h2 id="2-1-网络简述">2.1 网络简述</h2><p>PoseCNN主要分为两个阶段：</p><ol><li>主干网络：由13个卷积层和4个最大池化层组成，提取特征图。</li><li>将主干网络生成的高为特征图映射到低维。</li><li>进行三个不同的任务估计</li></ol><p><img src="https://img.mahaofei.com/img/20220906220501.png" alt=""></p><h2 id="2-2-语义标签">2.2 语义标签</h2><p>语义标签分支使用了两张特征图，通道数均为512，分辨率分别从原始图像降低了1/8和1/16。</p><p>该分支首先将特征图维度降为64，然后使用反卷积层将1/16图像的分辨率翻倍，获得两个64通道，1/8分辨率的特征图。</p><p>然后将两个特征图相加，在进行反卷积，将分辨率提高8倍，获得与原始图象大小相同的特征图。</p><p>最后对特征图进行卷积层运算，生成像素的语义标签分数。该层的输出有n个通道（n为语义分类数）。训练时使用Softmax交叉商损失函数训练语义标签分支，测试是使用softmax函数计算像素的类概率。</p><h2 id="2-3-3D位置估计">2.3 3D位置估计</h2><p><strong>（1）原理</strong></p><p>通过定位物体在图像中的中心和与相机的距离，估计3D平移。</p><p>原理是，只要获得T在图像上的投影$c=(c_x, c_y)^T$，以及距离$T_z$，就可以计算出$T_x$和$T_y$。</p><p><img src="https://img.mahaofei.com/img/20220907190136.png" alt=""></p><p>其中$f_x$和$f_y$是焦距，$p_x$和$p_y$是像主点。</p><p><strong>（2）确定物体中心</strong></p><p>常规的方法是直接检测中心点，但这样的问题是无法处理物体被遮挡的情况。</p><p>本文利用隐式形状模型的思想，将图像上的每一个像素，回归为3个变量：</p><p><img src="https://img.mahaofei.com/img/20220907191438.png" alt=""></p><p>其中$P=(x, y)$是图像中的一个像素点，$(c_x, c_y)$是物体中心座标点。$n_x$表示$x$方向上，像素点与中心点之间的偏移，并进行归一化处理。$n_y$表示y方向上的偏移，$T_z$表示像素点的预测深度。</p><p>因此需要预测的变量包括$(n_x, n_y, T_z)$。</p><p>由于需要回归三个变量，因此使用了128通道的特征图，最后一个卷积层有3xn通道，n为物体类别数。</p><p><strong>得到了每个像素预测的3个变量后，需要确定物体中心坐标</strong></p><p>引入了霍夫投票机制，将像素级 语义标签结果 和 中心回归结果 作为输入。</p><p>每个像素沿网络预测的射线方向对图像中心位置进行投票。当所有物体类中的像素完成投票后，可以获得所有的投票分数，选取分数最高的位置即为物体中心位置。</p><p><img src="https://img.mahaofei.com/img/20220907193804.png" alt=""></p><p>对于同一图像中有多个同类物体的情况，使用非极大抑制，通过设定阈值来实现分数选择。</p><p>通过以上操作，就可以确定物体中心的三维坐标，其中预测的$T_z$认为是物体内部中心点的距离。</p><h2 id="2-4-3D姿态估计">2.4 3D姿态估计</h2><p><strong>（1）网络结构</strong></p><p>3D旋转估计分支利用了主干网络得到的特征图的ROI区域部分，通过两个池化层，来实现3D回归。</p><p>将所有特征图加在一起，送入三个全连接层中，前两个全连接层维度为4096，最后一个全连接层维度为4xn，其中n为对象类别数，每个对象输出以四元数表示的3D旋转。</p><p><strong>（2）损失函数的设计</strong></p><p>为了回归四元数，设计了两个损失函数。</p><p><strong>PoseLoss（PLoss）</strong></p><p>在3维空间中计算，计算正确模型位姿的点与测量的位姿的点的平均平方距离。</p><p><img src="https://img.mahaofei.com/img/20220907194859.png" alt=""></p><p>其中$M$代表一系列三维模型的点，m为点的个数，$R(\overline q)$和$R(q)$分别代表计算的旋转矩阵和真实的旋转矩阵。</p><p><strong>ShapeMatch-Loss（SLOSS）</strong></p><p>由于PLoss损失函数无法处理对称物体的情况，对于对陈物体来说，会有很多个正确的三维旋转矩阵。</p><p>因此设计了损失函数如下：</p><p><img src="https://img.mahaofei.com/img/20220907195511.png" alt=""></p><p>该损失函数测量的是预测模型上的点与真实模型的最近的点的偏移量。通过这种方式，SLoss不会惩罚对称物体绕对称轴的等效旋转。</p><p>注意：是计算法中不需要在三维空间中计算距离，而是将变换后的点投影到图像上，计算图像空间中的距离（重投影误差）。</p><h1>三、实验</h1><h2 id="3-1-数据集">3.1 数据集</h2><p>在YCB数据集和Occluded-LINEMOD数据集（在LINEMOD数据集中挑选一段物体严重遮挡的视频）进行测试。</p><h2 id="3-2-对比基准">3.2 对比基准</h2><p>由于文章发布时主流的位姿估计方法是将图像像素回归到3D物体坐标。因此作者实现了一个根据PoseCNN网络修改的变体，在网络中直接回归每个像素在物体坐标系的三维坐标，移除了3D旋转预测分支，而是利用语义标签结果和三维物体坐标结果，通过RANSAC恢复6D位姿。</p><h2 id="3-3-改进">3.3 改进</h2><p>当深度可用时，使用ICP算法来优化6D姿态。</p><p><img src="https://img.mahaofei.com/img/20220907202451.png" alt=""></p><h1>四、PoseCNN可视化</h1><blockquote><p>以下内容原作者为<a href="https://blog.csdn.net/weixin_44564705" title="Panpanpan！">Panpanpan！</a><br>分类专栏： <a href="https://blog.csdn.net/weixin_44564705/category_11853299.html">【DenseFusion进阶】</a> 文章标签： <a href="https://so.csdn.net/so/search/s.do?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;t=blog&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=">深度学习</a> <a href="https://so.csdn.net/so/search/s.do?q=pytorch&amp;t=blog&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=">pytorch</a> <a href="https://so.csdn.net/so/search/s.do?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89&amp;t=blog&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=">计算机视觉</a><br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/weixin_44564705/article/details/125129844">https://blog.csdn.net/weixin_44564705/article/details/125129844</a><br>DenseFusion系列代码全讲解目录：<a href="https://blog.csdn.net/weixin_44564705/article/details/125149491" title="【DenseFusion系列目录】代码全讲解+可视化+计算评估指标_Panpanpan！的博客-CSDN博客">【DenseFusion系列目录】代码全讲解+可视化+计算评估指标_Panpanpan！的博客-CSDN博客</a><br>这些内容均为个人学习记录，欢迎大家提出错误一起讨论一起学习！</p></blockquote><hr><h2 id="可视化的效果展示">可视化的效果展示</h2><p>选择要可视化的图片，输入路径，然后对其进行eval，估计姿态pred，输出target点云和pred点云在二维图像上的投影，如下：</p><p><img src="https://img-blog.csdnimg.cn/3e041aa30266491d9e42953b7863f314.png" alt=""><img src="https://img-blog.csdnimg.cn/062d962ea0174495860db8fe0a1b56d1.png" alt=""></p><p>左边的图为pred，右边的图为target。</p><h2 id="具体操作">具体操作</h2><p>代码放在了tools/draw_linemod.py</p><p>脚本放在了experiments/scripts/draw_linemod.sh</p><p>先看脚本文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">export PYTHONUNBUFFERED=&quot;True&quot;</span><br><span class="line">export CUDA_VISIBLE_DEVICES=0</span><br><span class="line"></span><br><span class="line">python3 ./tools/draw_linemod.py --data_root ./datasets/linemod/Linemod_preprocessed/data/08\</span><br><span class="line">  --item 0707\</span><br><span class="line">  --seg_root ./datasets/linemod/Linemod_preprocessed/segnet_results/08_label\</span><br><span class="line">  --obj 8\</span><br><span class="line">  --model_root ./datasets/linemod/Linemod_preprocessed/models\</span><br><span class="line">  --model trained_models/linemod/original/pose_model_current.pth\</span><br><span class="line">  --refine_model trained_models/linemod/original/pose_refine_model_current.pth\</span><br><span class="line">  --output ./</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数分别为：</p><blockquote><p>–data_root：要选择的图像类别文件夹路径<br>  --item：选择的图像编号<br>  --seg_root：因为是eval模式，需要用到标准分割的标签，这里输入选择的图像类别的语义分割路径<br>  --obj：图像类别编号<br>  --model_root：图像类别元数据模型路径<br>  --model：训练好的PoseNet路径<br>  --refine_model：训练好的PoseRefineNet路径</p><p>–output：可视化保存路径</p></blockquote><p>输入这些参数，然后在DenseFusion文件夹下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./experiments/scripts/draw_linemod.sh</span><br></pre></td></tr></table></figure><p>如果是最开始执行，可能会提示.sh文件没有权限，就要执行以下命令打开权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./experiments/scripts/draw_linemod.sh</span><br></pre></td></tr></table></figure><p>然后就能在保存路径里查看这两个图片。</p><p><img src="https://img-blog.csdnimg.cn/58319e90949d434293c276afc9310a8b.png" alt=""></p><h2 id="完整代码">完整代码</h2><p>draw_linemod.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> _init_paths</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.ma <span class="keyword">as</span> ma</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> lib.network <span class="keyword">import</span> PoseNet, PoseRefineNet</span><br><span class="line"><span class="keyword">from</span> lib.loss <span class="keyword">import</span> Loss</span><br><span class="line"><span class="keyword">from</span> lib.loss_refiner <span class="keyword">import</span> Loss_refine</span><br><span class="line"><span class="keyword">from</span> lib.knn.__init__ <span class="keyword">import</span> KNearestNeighbor</span><br><span class="line"><span class="keyword">from</span> lib.transformations <span class="keyword">import</span> euler_matrix, quaternion_matrix, quaternion_from_matrix</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">border_list = [-<span class="number">1</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">200</span>, <span class="number">240</span>, <span class="number">280</span>, <span class="number">320</span>, <span class="number">360</span>, <span class="number">400</span>, <span class="number">440</span>, <span class="number">480</span>, <span class="number">520</span>, <span class="number">560</span>, <span class="number">600</span>, <span class="number">640</span>, <span class="number">680</span>]</span><br><span class="line">img_width = <span class="number">480</span></span><br><span class="line">img_length = <span class="number">640</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mask_to_bbox</span>(<span class="params">mask</span>):</span><br><span class="line">    mask = mask.astype(np.uint8)</span><br><span class="line">    _, contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    </span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    w = <span class="number">0</span></span><br><span class="line">    h = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">        tmp_x, tmp_y, tmp_w, tmp_h = cv2.boundingRect(contour)</span><br><span class="line">        <span class="keyword">if</span> tmp_w * tmp_h &gt; w * h:</span><br><span class="line">            x = tmp_x</span><br><span class="line">            y = tmp_y</span><br><span class="line">            w = tmp_w</span><br><span class="line">            h = tmp_h</span><br><span class="line">    <span class="keyword">return</span> [x, y, w, h]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bbox</span>(<span class="params">bbox</span>):</span><br><span class="line">    bbx = [bbox[<span class="number">1</span>], bbox[<span class="number">1</span>] + bbox[<span class="number">3</span>], bbox[<span class="number">0</span>], bbox[<span class="number">0</span>] + bbox[<span class="number">2</span>]]</span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        bbx[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">1</span>] &gt;= <span class="number">480</span>:</span><br><span class="line">        bbx[<span class="number">1</span>] = <span class="number">479</span></span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">2</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        bbx[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">3</span>] &gt;= <span class="number">640</span>:</span><br><span class="line">        bbx[<span class="number">3</span>] = <span class="number">639</span>                </span><br><span class="line">    rmin, rmax, cmin, cmax = bbx[<span class="number">0</span>], bbx[<span class="number">1</span>], bbx[<span class="number">2</span>], bbx[<span class="number">3</span>]</span><br><span class="line">    r_b = rmax - rmin</span><br><span class="line">    <span class="keyword">for</span> tt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(border_list)):</span><br><span class="line">        <span class="keyword">if</span> r_b &gt; border_list[tt] <span class="keyword">and</span> r_b &lt; border_list[tt + <span class="number">1</span>]:</span><br><span class="line">            r_b = border_list[tt + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    c_b = cmax - cmin</span><br><span class="line">    <span class="keyword">for</span> tt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(border_list)):</span><br><span class="line">        <span class="keyword">if</span> c_b &gt; border_list[tt] <span class="keyword">and</span> c_b &lt; border_list[tt + <span class="number">1</span>]:</span><br><span class="line">            c_b = border_list[tt + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    center = [<span class="built_in">int</span>((rmin + rmax) / <span class="number">2</span>), <span class="built_in">int</span>((cmin + cmax) / <span class="number">2</span>)]</span><br><span class="line">    rmin = center[<span class="number">0</span>] - <span class="built_in">int</span>(r_b / <span class="number">2</span>)</span><br><span class="line">    rmax = center[<span class="number">0</span>] + <span class="built_in">int</span>(r_b / <span class="number">2</span>)</span><br><span class="line">    cmin = center[<span class="number">1</span>] - <span class="built_in">int</span>(c_b / <span class="number">2</span>)</span><br><span class="line">    cmax = center[<span class="number">1</span>] + <span class="built_in">int</span>(c_b / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> rmin &lt; <span class="number">0</span>:</span><br><span class="line">        delt = -rmin</span><br><span class="line">        rmin = <span class="number">0</span></span><br><span class="line">        rmax += delt</span><br><span class="line">    <span class="keyword">if</span> cmin &lt; <span class="number">0</span>:</span><br><span class="line">        delt = -cmin</span><br><span class="line">        cmin = <span class="number">0</span></span><br><span class="line">        cmax += delt</span><br><span class="line">    <span class="keyword">if</span> rmax &gt; <span class="number">480</span>:</span><br><span class="line">        delt = rmax - <span class="number">480</span></span><br><span class="line">        rmax = <span class="number">480</span></span><br><span class="line">        rmin -= delt</span><br><span class="line">    <span class="keyword">if</span> cmax &gt; <span class="number">640</span>:</span><br><span class="line">        delt = cmax - <span class="number">640</span></span><br><span class="line">        cmax = <span class="number">640</span></span><br><span class="line">        cmin -= delt</span><br><span class="line">    <span class="keyword">return</span> rmin, rmax, cmin, cmax</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ply_vtx</span>(<span class="params">path</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(path)</span><br><span class="line">    <span class="keyword">assert</span> f.readline().strip() == <span class="string">&quot;ply&quot;</span></span><br><span class="line">    f.readline()</span><br><span class="line">    f.readline()</span><br><span class="line">    N = <span class="built_in">int</span>(f.readline().split()[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">while</span> f.readline().strip() != <span class="string">&quot;end_header&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    pts = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        pts.append(np.float32(f.readline().split()[:<span class="number">3</span>]))</span><br><span class="line">    <span class="keyword">return</span> np.array(pts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">data_root, item, seg_root, obj, model_root, add_noise, noise_trans</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/rgb/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(data_root, item))</span><br><span class="line">    ori_img = np.array(img)</span><br><span class="line">    depth = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/depth/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(data_root, item)))</span><br><span class="line">    label = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/&#123;1&#125;_label.png&#x27;</span>.<span class="built_in">format</span>(seg_root, item)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/depth/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(data_root, item))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/&#123;1&#125;_label.png&#x27;</span>.<span class="built_in">format</span>(seg_root, item))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/gt.yml&#x27;</span>.<span class="built_in">format</span>(data_root))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/obj_&#123;1&#125;.ply&#x27;</span>.<span class="built_in">format</span>(model_root, <span class="string">&#x27;%02d&#x27;</span> % obj))</span><br><span class="line">    </span><br><span class="line">    meta_file = <span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/gt.yml&#x27;</span>.<span class="built_in">format</span>(data_root), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    meta = yaml.load(meta_file, Loader=yaml.FullLoader)</span><br><span class="line">    pt = ply_vtx(<span class="string">&#x27;&#123;0&#125;/obj_&#123;1&#125;.ply&#x27;</span>.<span class="built_in">format</span>(model_root, <span class="string">&#x27;%02d&#x27;</span> % obj))</span><br><span class="line">    </span><br><span class="line">    trancolor = transforms.ColorJitter(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.05</span>)</span><br><span class="line">    norm = transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    num = <span class="number">500</span></span><br><span class="line">    xmap = np.array([[j <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">640</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">480</span>)])</span><br><span class="line">    ymap = np.array([[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">640</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">480</span>)])</span><br><span class="line">    cam_cx = <span class="number">325.26110</span></span><br><span class="line">    cam_cy = <span class="number">242.04899</span></span><br><span class="line">    cam_fx = <span class="number">572.41140</span></span><br><span class="line">    cam_fy = <span class="number">573.57043</span></span><br><span class="line">    num_pt_mesh_large = <span class="number">500</span></span><br><span class="line">    num_pt_mesh_small = <span class="number">500</span></span><br><span class="line">    rank = <span class="built_in">int</span>(item)</span><br><span class="line">    <span class="keyword">if</span> obj == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(meta[obj])):</span><br><span class="line">            <span class="keyword">if</span> meta[rank][i][<span class="string">&#x27;obj_id&#x27;</span>] == <span class="number">2</span>:</span><br><span class="line">                meta = meta[rank][i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        meta = meta[rank][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    mask_depth = ma.getmaskarray(ma.masked_not_equal(depth, <span class="number">0</span>))</span><br><span class="line">    mask_label = ma.getmaskarray(ma.masked_equal(label, np.array(<span class="number">255</span>)))</span><br><span class="line">    mask = mask_label * mask_depth</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> add_noise:</span><br><span class="line">        img = trancolor(img)</span><br><span class="line"></span><br><span class="line">    img = np.array(img)[:, :, :<span class="number">3</span>]</span><br><span class="line">    img = np.transpose(img, (<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    img_masked = img</span><br><span class="line"></span><br><span class="line">    rmin, rmax, cmin, cmax = get_bbox(mask_to_bbox(mask_label))</span><br><span class="line">    img_masked = img_masked[:, rmin:rmax, cmin:cmax]</span><br><span class="line">    <span class="comment">#p_img = np.transpose(img_masked, (1, 2, 0))</span></span><br><span class="line">    <span class="comment">#scipy.misc.imsave(&#x27;evaluation_result/&#123;0&#125;_input.png&#x27;.format(index), p_img)</span></span><br><span class="line"></span><br><span class="line">    target_r = np.resize(np.array(meta[<span class="string">&#x27;cam_R_m2c&#x27;</span>]), (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    target_t = np.array(meta[<span class="string">&#x27;cam_t_m2c&#x27;</span>])</span><br><span class="line">    add_t = np.array([random.uniform(-noise_trans, noise_trans) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">    choose = mask[rmin:rmax, cmin:cmax].flatten().nonzero()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(choose) == <span class="number">0</span>:</span><br><span class="line">        cc = torch.LongTensor([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span>(cc, cc, cc, cc, cc, cc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(choose) &gt; num:</span><br><span class="line">        c_mask = np.zeros(<span class="built_in">len</span>(choose), dtype=<span class="built_in">int</span>)</span><br><span class="line">        c_mask[:num] = <span class="number">1</span></span><br><span class="line">        np.random.shuffle(c_mask)</span><br><span class="line">        choose = choose[c_mask.nonzero()]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        choose = np.pad(choose, (<span class="number">0</span>, num - <span class="built_in">len</span>(choose)), <span class="string">&#x27;wrap&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    depth_masked = depth[rmin:rmax, cmin:cmax].flatten()[choose][:, np.newaxis].astype(np.float32)</span><br><span class="line">    xmap_masked = xmap[rmin:rmax, cmin:cmax].flatten()[choose][:, np.newaxis].astype(np.float32)</span><br><span class="line">    ymap_masked = ymap[rmin:rmax, cmin:cmax].flatten()[choose][:, np.newaxis].astype(np.float32)</span><br><span class="line">    choose = np.array([choose])</span><br><span class="line"></span><br><span class="line">    cam_scale = <span class="number">1.0</span></span><br><span class="line">    pt2 = depth_masked / cam_scale</span><br><span class="line">    pt0 = (ymap_masked - cam_cx) * pt2 / cam_fx</span><br><span class="line">    pt1 = (xmap_masked - cam_cy) * pt2 / cam_fy</span><br><span class="line">    cloud = np.concatenate((pt0, pt1, pt2), axis=<span class="number">1</span>)</span><br><span class="line">    cloud = cloud / <span class="number">1000.0</span></span><br><span class="line">    <span class="built_in">print</span>(cloud.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> add_noise:</span><br><span class="line">        cloud = np.add(cloud, add_t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fw = open(&#x27;evaluation_result/&#123;0&#125;_cld.xyz&#x27;.format(index), &#x27;w&#x27;)</span></span><br><span class="line">    <span class="comment">#for it in cloud:</span></span><br><span class="line">    <span class="comment">#    fw.write(&#x27;&#123;0&#125; &#123;1&#125; &#123;2&#125;\n&#x27;.format(it[0], it[1], it[2]))</span></span><br><span class="line">    <span class="comment">#fw.close()</span></span><br><span class="line">    model_points = pt/ <span class="number">1000.0</span></span><br><span class="line">    dellist = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(model_points))]</span><br><span class="line">    dellist = random.sample(dellist, <span class="built_in">len</span>(model_points) - num_pt_mesh_small)</span><br><span class="line">    model_points = np.delete(model_points, dellist, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fw = open(&#x27;evaluation_result/&#123;0&#125;_model_points.xyz&#x27;.format(index), &#x27;w&#x27;)</span></span><br><span class="line">    <span class="comment">#for it in model_points:</span></span><br><span class="line">    <span class="comment">#    fw.write(&#x27;&#123;0&#125; &#123;1&#125; &#123;2&#125;\n&#x27;.format(it[0], it[1], it[2]))</span></span><br><span class="line">    <span class="comment">#fw.close()</span></span><br><span class="line"></span><br><span class="line">    target = np.dot(model_points, target_r.T)</span><br><span class="line">    <span class="keyword">if</span> add_noise:</span><br><span class="line">        target = np.add(target, target_t / <span class="number">1000.0</span> + add_t)</span><br><span class="line">        out_t = target_t / <span class="number">1000.0</span> + add_t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        target = np.add(target, target_t / <span class="number">1000.0</span>)</span><br><span class="line">        out_t = target_t / <span class="number">1000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#fw = open(&#x27;evaluation_result/&#123;0&#125;_tar.xyz&#x27;.format(index), &#x27;w&#x27;)</span></span><br><span class="line">    <span class="comment">#for it in target:</span></span><br><span class="line">    <span class="comment">#    fw.write(&#x27;&#123;0&#125; &#123;1&#125; &#123;2&#125;\n&#x27;.format(it[0], it[1], it[2]))</span></span><br><span class="line">    <span class="comment">#fw.close()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.from_numpy(cloud.astype(np.float32)), \</span><br><span class="line">           torch.LongTensor(choose.astype(np.int32)), \</span><br><span class="line">           norm(torch.from_numpy(img_masked.astype(np.float32))), \</span><br><span class="line">           torch.from_numpy(target.astype(np.float32)), \</span><br><span class="line">           torch.from_numpy(model_points.astype(np.float32)), \</span><br><span class="line">           torch.LongTensor([obj])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data_root&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;ycb or linemod&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seg_root&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;ycb or linemod&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--model_root&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;ycb or linemod&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--item&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--obj&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--model&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;resume PoseNet model&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--refine_model&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;resume PoseRefineNet model&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--output&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;resume PoseRefineNet model&#x27;</span>)</span><br><span class="line">opt = parser.parse_args() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">estimator = PoseNet(num_points = <span class="number">500</span>, num_obj = <span class="number">13</span>)</span><br><span class="line">estimator.cuda()</span><br><span class="line">refiner = PoseRefineNet(num_points = <span class="number">500</span>, num_obj = <span class="number">13</span>)</span><br><span class="line">refiner.cuda()</span><br><span class="line">estimator.load_state_dict(torch.load(opt.model))</span><br><span class="line">refiner.load_state_dict(torch.load(opt.refine_model))</span><br><span class="line"></span><br><span class="line">bs = <span class="number">1</span></span><br><span class="line">num_points = <span class="number">500</span></span><br><span class="line">iteration = <span class="number">4</span></span><br><span class="line">knn = KNearestNeighbor(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    points, choose, img, target, model_points, idx = get_data(opt.data_root, opt.item, opt.seg_root, opt.obj, opt.model_root, <span class="literal">True</span>, <span class="number">0.0</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points.size()) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No.&#123;0&#125; NOT Pass! Lost detection!&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    points, choose, img, target, model_points, idx = Variable(points.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(choose.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(img.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(target.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(model_points.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(idx.unsqueeze(<span class="number">0</span>)).cuda()</span><br><span class="line">    pred_r, pred_t, pred_c, emb = estimator(img, points, choose, idx)</span><br><span class="line">    pred_r = pred_r / torch.norm(pred_r, dim=<span class="number">2</span>).view(<span class="number">1</span>, num_points, <span class="number">1</span>)</span><br><span class="line">    pred_c = pred_c.view(bs, num_points)</span><br><span class="line">    how_max, which_max = torch.<span class="built_in">max</span>(pred_c, <span class="number">1</span>)</span><br><span class="line">    pred_t = pred_t.view(bs * num_points, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    my_r = pred_r[<span class="number">0</span>][which_max[<span class="number">0</span>]].view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">    my_t = (points.view(bs * num_points, <span class="number">1</span>, <span class="number">3</span>) + pred_t)[which_max[<span class="number">0</span>]].view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">    my_pred = np.append(my_r, my_t)</span><br><span class="line">    <span class="keyword">for</span> ite <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iteration):</span><br><span class="line">        Tt = Variable(torch.from_numpy(my_t.astype(np.float32))).cuda().view(<span class="number">1</span>, <span class="number">3</span>).repeat(num_points, <span class="number">1</span>).contiguous().view(<span class="number">1</span>, num_points, <span class="number">3</span>)</span><br><span class="line">        my_mat = quaternion_matrix(my_r)</span><br><span class="line">        R = Variable(torch.from_numpy(my_mat[:<span class="number">3</span>, :<span class="number">3</span>].astype(np.float32))).cuda().view(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">        my_mat[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = my_t</span><br><span class="line">        </span><br><span class="line">        new_points = torch.bmm((points - Tt), R).contiguous()</span><br><span class="line">        pred_r, pred_t = refiner(new_points, emb, idx)</span><br><span class="line">        pred_r = pred_r.view(<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        pred_r = pred_r / (torch.norm(pred_r, dim=<span class="number">2</span>).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        my_r_2 = pred_r.view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">        my_t_2 = pred_t.view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">        my_mat_2 = quaternion_matrix(my_r_2)</span><br><span class="line">        my_mat_2[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = my_t_2</span><br><span class="line"></span><br><span class="line">        my_mat_final = np.dot(my_mat, my_mat_2)</span><br><span class="line">        my_r_final = copy.deepcopy(my_mat_final)</span><br><span class="line">        my_r_final[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">        my_r_final = quaternion_from_matrix(my_r_final, <span class="literal">True</span>)</span><br><span class="line">        my_t_final = np.array([my_mat_final[<span class="number">0</span>][<span class="number">3</span>], my_mat_final[<span class="number">1</span>][<span class="number">3</span>], my_mat_final[<span class="number">2</span>][<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">        my_pred = np.append(my_r_final, my_t_final)</span><br><span class="line">        my_r = my_r_final</span><br><span class="line">        my_t = my_t_final</span><br><span class="line">    model_points = model_points[<span class="number">0</span>].cpu().detach().numpy()</span><br><span class="line">    my_r = quaternion_matrix(my_r)[:<span class="number">3</span>, :<span class="number">3</span>]</span><br><span class="line">    pred = np.dot(model_points, my_r.T) + my_t  </span><br><span class="line">    target = target[<span class="number">0</span>].cpu().detach().numpy()</span><br><span class="line"></span><br><span class="line">    pred = pred*<span class="number">1000.0</span></span><br><span class="line">    target = target*<span class="number">1000.0</span></span><br><span class="line">    cam_scale = <span class="number">1.0</span></span><br><span class="line">    cam_cx = <span class="number">325.26110</span></span><br><span class="line">    cam_cy = <span class="number">242.04899</span></span><br><span class="line">    cam_fx = <span class="number">572.41140</span></span><br><span class="line">    cam_fy = <span class="number">573.57043</span></span><br><span class="line"></span><br><span class="line">    depth_masked =  pred[:,<span class="number">2</span>] * cam_scale</span><br><span class="line">    ymap_masked_pred =  pred[:,<span class="number">0</span>] * cam_fx / pred[:,<span class="number">2</span>] + cam_cx</span><br><span class="line">    xmap_masked_pred = pred[:,<span class="number">1</span>] * cam_fy / pred[:,<span class="number">2</span>] + cam_cy</span><br><span class="line"></span><br><span class="line">    depth_masked =  target[:,<span class="number">2</span>] * cam_scale</span><br><span class="line">    ymap_masked_target =  target[:,<span class="number">0</span>] * cam_fx / target[:,<span class="number">2</span>] + cam_cx</span><br><span class="line">    xmap_masked_target = target[:,<span class="number">1</span>] * cam_fy / target[:,<span class="number">2</span>] + cam_cy</span><br><span class="line"></span><br><span class="line">    image = Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/rgb/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(opt.data_root, opt.item))</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">12</span>)) <span class="comment"># 图像窗口名称</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.scatter(ymap_masked_pred,xmap_masked_pred,marker=<span class="string">&#x27;.&#x27;</span>,c=<span class="string">&#x27;r&#x27;</span>,alpha=<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;on&#x27;</span>) <span class="comment"># 关掉坐标轴为 off</span></span><br><span class="line">    plt.title(<span class="string">&#x27;image&#x27;</span>) <span class="comment"># 图像题目</span></span><br><span class="line">    plt.show()  </span><br><span class="line">    plt.savefig(<span class="string">&#x27;&#123;0&#125;/test_pred.png&#x27;</span>.<span class="built_in">format</span>(opt.output))</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">12</span>)) <span class="comment"># 图像窗口名称</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.scatter(ymap_masked_target,xmap_masked_target,marker=<span class="string">&#x27;.&#x27;</span>,c=<span class="string">&#x27;r&#x27;</span>,alpha=<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;on&#x27;</span>) <span class="comment"># 关掉坐标轴为 off</span></span><br><span class="line">    plt.title(<span class="string">&#x27;image&#x27;</span>) <span class="comment"># 图像题目</span></span><br><span class="line">    plt.show() </span><br><span class="line">    plt.savefig(<span class="string">&#x27;&#123;0&#125;/test_target.png&#x27;</span>.<span class="built_in">format</span>(opt.output))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">解决物体之间的遮挡和聚集增加的6D位姿估计的难度，通过主干网络加ICP点配对的方式实现位姿估计。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="位姿估计" scheme="https://www.mahaofei.com/tags/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Qt学习笔记05】Qt中调用ROS库</title>
    <link href="https://www.mahaofei.com/post/55cbe115.html"/>
    <id>https://www.mahaofei.com/post/55cbe115.html</id>
    <published>2022-09-03T01:45:22.000Z</published>
    <updated>2022-09-03T01:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>前提</h1><ol><li>安装配置好QT</li><li>安装配置好ROS</li></ol><h1>方法</h1><p>在写的QT工程中加入:即在.pro文件中添加ros头文件路径和动态链接库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /opt/ros/noetic/includeDEPENDPATH += /opt/ros/kinetic/includeLIBS += -L/opt/ros/kinetic/lib -lroscpp -lroslib -lrosconsole -lroscpp_serialization -lrostime</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">对机器人的软件开发的离不开ROS，可操作界面离不开Qt，本文介绍在Qt中调用ROS库的方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记04】对话框</title>
    <link href="https://www.mahaofei.com/post/e0de5819.html"/>
    <id>https://www.mahaofei.com/post/e0de5819.html</id>
    <published>2022-09-02T11:45:22.000Z</published>
    <updated>2022-09-02T11:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、模态和非模态对话框</h1><p>上一节中，我们实现了搭建一个简单的窗口，并且添加了如菜单栏、工具栏等项目。</p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>但现在的窗口只是徒有其形，其内部的功能却一个都没有实现。</p><p>这节我们实现点击一个按钮，弹出一个对话框的功能。</p><h2 id="1-1-介绍">1.1 介绍</h2><p>对话框分为两种</p><ul><li>模态对话框：弹出后，可以对其他窗口进行操作</li><li>非模态对话框：弹出后，无法点击除了对话框以外的其他区域（代码阻塞）</li></ul><h2 id="1-2-代码创建">1.2 代码创建</h2><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span>`</span></span><br></pre></td></tr></table></figure><p>编写对话框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew,&amp;QAction::triggered,[=]()&#123;</span><br><span class="line"><span class="comment">//模态对话框 （不可以对其他窗口进行操作） 非模态对话框 （可以对其他窗口进行操作）</span></span><br><span class="line"><span class="comment">//模态创建 阻塞</span></span><br><span class="line">    QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">    dlg.<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;模态对话框弹出了&quot;</span>;   <span class="comment">//需要引入#include &lt;QDebug&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非模态对话框</span></span><br><span class="line">    QDialog * dlg2 = <span class="keyword">new</span> <span class="built_in">QDialog</span> (<span class="keyword">this</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    dlg2-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;非模态对话框弹出了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二、标准对话框</h1><p>Qt提供了很多内置对话框：</p><table><thead><tr><th>Qt内置对话框</th><th>功能</th></tr></thead><tbody><tr><td>QColorDialog</td><td>选择颜色</td></tr><tr><td>QFileDialog</td><td>选择文件或者目录</td></tr><tr><td>QFontDialog</td><td>选择字体</td></tr><tr><td>QInputDialog</td><td>允许用户输入一个值，并将其值返回</td></tr><tr><td>QMessageBox</td><td>模态对话框，用于显示信息、询问问题等</td></tr><tr><td>QPageSetupDialog</td><td>为打印机提供纸张相关的选项</td></tr><tr><td>QPrintDialog</td><td>打印机配置</td></tr><tr><td>QPrintPreviewDialog</td><td>打印预览</td></tr><tr><td>QProgressDialog</td><td>显示操作过程</td></tr></tbody></table><p>以下以消息对话框为例。</p>]]></content>
    
    
    <summary type="html">介绍了Qt中的模态/非模态对话框，以及标准对话框。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记03】UI设计</title>
    <link href="https://www.mahaofei.com/post/549bf258.html"/>
    <id>https://www.mahaofei.com/post/549bf258.html</id>
    <published>2022-09-01T07:36:06.000Z</published>
    <updated>2022-09-01T07:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、QMainWindow</h1><h2 id="1-1-QMainWindow结构概览">1.1 QMainWindow结构概览</h2><p>QMainWindow由一个菜单栏、多个工具栏、多个铆接部件、一个状态栏、一个中心部件组成。各部件的具体布局区域如图所示。</p><p><img src="https://img-blog.csdn.net/20180106132722303" alt=""></p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><blockquote><p>上面图片所用到的代码及注释附在本文的最后</p></blockquote><h2 id="1-2-菜单栏QMenuBar">1.2 菜单栏QMenuBar</h2><p>菜单栏是窗口最上方的区域，基本每个软件的标题栏下面都会有这么一行，这就是菜单栏。</p><p><img src="https://img.mahaofei.com/img/20220902161029.png" alt=""></p><p>注意：菜单栏只能创建一个</p><p><strong>代码示例</strong></p><p>引入菜单栏QMenuBar</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>菜单栏创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br></pre></td></tr></table></figure><p>将菜单栏放入到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br></pre></td></tr></table></figure><p>创建菜单栏的菜单（比如文件、编辑、工具、帮助等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建菜单项（比如文件菜单下的新建、打开项）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902161412.png" alt=""></p><h2 id="1-3-工具栏QToolBar">1.3 工具栏QToolBar</h2><p>工具栏一般位于菜单栏下方，或者左右两侧、或底部。</p><p><img src="https://img.mahaofei.com/img/20220902161816.png" alt=""></p><p>注意：工具栏可以创建多个。</p><p><strong>代码示例</strong></p><p>引入工具栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建工具栏（工具栏创建后可以随意拖动）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将工具栏放入窗口，Qt::TopToolBarArea是默认放上侧，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br></pre></td></tr></table></figure><p>设置只允许左右停靠</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br></pre></td></tr></table></figure><p>设置浮动（可以拖拽，但移动不了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>设置移动（总开关，设为False后无法拖拽）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在工具栏中添加内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将刚才创建的菜单项Action添加到工具栏中</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line"><span class="comment">//添加另一个菜单项</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line"><span class="comment">//工具栏中添加控件</span></span><br><span class="line">QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902162526.png" alt=""></p><h2 id="1-4-状态栏QStatusBar">1.4 状态栏QStatusBar</h2><p>状态栏是窗口最低不，显示软件状态的栏。（例如ppt、word最下面显示字数、幻灯片数量的那一行）</p><p><img src="https://img.mahaofei.com/img/20220902162734.png" alt=""></p><p>注意：状态栏最多有一个。</p><p><strong>代码示例</strong></p><p>引入状态栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建状态栏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br></pre></td></tr></table></figure><p>将状态栏设置到窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setStatusBar</span>(stBar);</span><br></pre></td></tr></table></figure><p>在菜单栏中放入标签控件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902163152.png" alt=""></p><h2 id="1-5-铆接部件QDockWidget">1.5 铆接部件QDockWidget</h2><p>铆接部件又称为浮动窗口，是窗口中，在中心窗口周围的部件，通常是可以修改位置，可以拖出来成为单独的窗口，也可以双击使其回到父窗口中。</p><p>常见的铆接部件包括（IDE左侧或右侧的项目栏、底部的编译输出栏等）</p><p><img src="https://img.mahaofei.com/img/Screenshot%20from%202022-09-02%2016-54-35.png" alt=""></p><p>铆接部件可以有多个</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建铆接部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将铆接部件添加到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br></pre></td></tr></table></figure><p>设置铆接部件的停靠区域，例如只允许上下（与工具栏设置参数一致）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902172602.png" alt=""></p><h2 id="1-6-中心部件QTextEdit">1.6 中心部件QTextEdit</h2><p>中心部件就是一个程序中心的部分，例如IDE的程序编写区域，WPS的文字编辑区域等。</p><p>中心部件只能设置一个。</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建中心部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>设置中心部件到父窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setCentralWidget</span>(edit);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>中间白色的区域就是中心部件。</p><h2 id="1-7-UI工具设计图形界面">1.7 UI工具设计图形界面</h2><p>在Qt中也提供了图形化的UI设计界面。</p><p>通过双击项目文件中的<code>xxx.ui</code>文件，就可以打开设计页面。</p><p><img src="https://img.mahaofei.com/img/20220902192942.png" alt=""></p><p>在这里，上文提到的所有项目（菜单栏、工具栏等），以及各自的属性，都可以直接拖拽放置，并在右下角修改其属性。</p><p>创建的控件，在代码中通过<code>ui-&gt;abcd</code>可以找到所有控件。</p><p>但是这种布局方式所产生的代码结构较差。</p><p>通常是在代码中编写大概，然后在设计中进行微调。</p><h1>二、资源文件</h1><p>很多时候，在窗口中我们不仅需要文字，还需要添加一些图标，图片等，让应用显得更人性化。这就需要我们在项目中导入资源文件。</p><h2 id="2-1-资源文件的导入">2.1 资源文件的导入</h2><ol><li><p>首先将图片复制到项目文件夹中（注意图片必须是png格式，直接更改用户名无效，必须通过图片编辑软件转换）</p></li><li><p>右键项目名 -&gt; 添加新文件 -&gt; Qt -&gt; QtResourceFile</p></li></ol><p><img src="https://img.mahaofei.com/img/20220902193453.png" alt=""></p><ol start="3"><li><p>得到一个<code>.qrc</code>文件，右键，<code>open in edit</code></p></li><li><p>添加 -&gt; 前缀，自己设置一个前缀</p></li><li><p>添加 -&gt; 文件 -&gt; 找到图片文件夹 -&gt; 选中所有图片 -&gt; 打开</p></li><li><p>可以看到<code>.qrc</code>文件下方多了一个“前缀”文件夹</p></li></ol><h2 id="2-2-代码中使用">2.2 代码中使用</h2><p>代码中使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ui-&gt;actionNew-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(``<span class="string">&quot;:/前缀/图片文件夹名/图片文件名.png&quot;</span>``));`</span><br></pre></td></tr></table></figure><h1>附</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏  只能最多有一个</span></span><br><span class="line">    <span class="comment">//菜单栏创建</span></span><br><span class="line">    QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br><span class="line">    <span class="comment">//将菜单栏放入到窗口中</span></span><br><span class="line">    <span class="built_in">setMenuBar</span>(bar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单</span></span><br><span class="line">    QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单项</span></span><br><span class="line">    QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏  可以有多个</span></span><br><span class="line">    QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后期设置 只允许 左右停靠</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置浮动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置移动 (总开关)</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏中可以设置内容</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    <span class="comment">//工具栏中添加控件</span></span><br><span class="line">    QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏 最多有一个</span></span><br><span class="line">    QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br><span class="line">    <span class="comment">//设置到窗口中</span></span><br><span class="line">    <span class="built_in">setStatusBar</span>(stBar);</span><br><span class="line">    <span class="comment">//放标签控件</span></span><br><span class="line">    QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//铆接部件 （浮动窗口） 可以有多个</span></span><br><span class="line">    QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br><span class="line">    <span class="comment">//设置后期停靠区域，只允许上下</span></span><br><span class="line">    dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置中心部件 只能一个</span></span><br><span class="line">    QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(edit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了QMainWindow相关的实现方法，包括菜单栏、工具栏、状态栏、铆接部件、中心部件等。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记02】自定义信号与槽函数</title>
    <link href="https://www.mahaofei.com/post/b61fb72.html"/>
    <id>https://www.mahaofei.com/post/b61fb72.html</id>
    <published>2022-08-27T12:43:15.000Z</published>
    <updated>2022-08-27T12:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自定义信号和槽</h1><p>实现功能：定义两个类，mysignal类，myslot类。mysignal类发出信号hello，myslot响应信号打印Hello World。</p><p><strong>（1）创建类</strong></p><p>首先右键项目-添加新文件-创建新的C++类，基类选择QObject。</p><p><img src="https://img.mahaofei.com/img/20220827210652.png" alt=""></p><p><strong>（2）自定义信号和槽函数</strong></p><p>自定义信号写到signals下。返回值是void，只需要声明，不需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysignal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSIGNAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSIGNAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySignal</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySignal</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;   <span class="comment">//添加了自定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSIGNAL_H</span></span></span><br></pre></td></tr></table></figure><p>自定义槽函数写在public slots下。返回值是void，需要声明，也需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSLOT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSLOT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySlot</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySlot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;    <span class="comment">//添加了自定义槽</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSLOT_H</span></span></span><br></pre></td></tr></table></figure><p>实现槽函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span>    <span class="comment">//QDebug可在底部打印输出字符串</span></span></span><br><span class="line"></span><br><span class="line">MySlot::<span class="built_in">MySlot</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义槽函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySlot::printhello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;Hello World!&quot;</span>);    <span class="comment">//输出HelloWorld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）创建两个类的对象并使用connect进行连接</strong></p><p>首先在widget.h中声明两个类的指针，然后在widget.cpp中new两个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span>  <span class="comment">//引入两个类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;    <span class="comment">//声明两个类的指针</span></span><br><span class="line">    MySlot * myslot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;    <span class="comment">//new两个对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）创建触发函数</strong></p><p>只有上面的代码，虽然创建了两个类，也定义了信号和槽函数，但是缺少触发条件，此时运行程序，程序无反应。</p><p>在widget.h的widget类的private中声明触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;</span><br><span class="line">    MySlot * myslot;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mytrigger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure><p>在widget.cpp下方定义触发函数，并在widget中添加触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;</span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">    <span class="built_in">mytrigger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">widget::mytrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit mysignal-&gt;<span class="built_in">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220827213040.png" alt=""></p><h1>二、信号的连接与断开</h1><h2 id="2-1-信号连接信号">2.1 信号连接信号</h2><p>connect不仅可以连接信号与槽，也可以连接信号与信号，实现当触发一个信号时，由该信号继续触发另一个信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello);</span><br></pre></td></tr></table></figure><h2 id="2-2-信号与槽断开">2.2 信号与槽断开</h2><p>断开信号使用disconnect关键字，其参数与connect完全相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">信号与槽是QT中最重要的概念之一，信号与槽可以实现发送端和接收端的信号传输，是qt各种操作的基础。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【QT学习笔记01】Qt基础、按钮、对象树以及信号和槽的基本使用</title>
    <link href="https://www.mahaofei.com/post/e1f7a4b6.html"/>
    <id>https://www.mahaofei.com/post/e1f7a4b6.html</id>
    <published>2022-08-27T02:50:59.000Z</published>
    <updated>2022-08-27T02:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Qt的介绍</h1><p><strong>Qt</strong>是一个<strong>跨平台</strong>的<strong>C++图形用户界面应用程序框架</strong>。为应用程序开发者提供建立艺术级图形界面所需的所有功能。Qt是完全面向对象的，很容易扩展，且允许真正的组件编程。</p><p>支持Windows、Linux、MacOS、嵌入式平台等全平台开发。</p><p>Qt的优点</p><ul><li>跨平台，几乎支持所有平台</li><li>接口简单，容易上手</li><li>简化了内存回收机制</li><li>开发效率高，可快速构建应用程序</li><li>社区氛围好</li><li>可进行嵌入式开发</li></ul><p>Qt的案例</p><ul><li>Linux桌面环境KDE</li><li>WPS Office</li><li>Skype</li><li>Google Earth</li><li>VirtualBox<br>以上都是使用Qt进行开发的。</li></ul><h1>二、第一个Qt程序</h1><h2 id="2-1-界面介绍">2.1 界面介绍</h2><p><img src="https://img.mahaofei.com/img/20220827133056.png" alt=""></p><ul><li>欢迎界面<ul><li>工程：创建、打开工程</li><li>示例：提供了各行各业一些现成的qt工程，可以直接打开学习其代码</li><li>教程：Qt官方提供的教程，感觉不如b站大学</li></ul></li><li>编辑<ul><li>进行应用程序代码编写，C++</li></ul></li><li>设计<ul><li>进行界面UI设计</li></ul></li><li>Debug<ul><li>如名</li></ul></li><li>项目<ul><li>进行一些项目配置</li></ul></li><li>帮助<ul><li>非常重要，很多想要实现的功能都可以通过查阅帮助文档实现</li></ul></li></ul><h2 id="2-2-第一个项目">2.2 第一个项目</h2><p>注意，项目名称和路径中都不要出现<strong>中文和空格</strong>。</p><p><strong>（1）创建项目</strong></p><p>基类：</p><ul><li>QWidget：是下面两种基类的父类，创建后什么都没有</li><li>QMainWindow：多了菜单栏和工具，以及底部状态栏</li><li>QDialog：多了对话框</li></ul><p>类名：</p><ul><li>创建自己的类</li></ul><p><img src="https://img.mahaofei.com/img/20220827135159.png" alt=""></p><p>创建完成后如图，注意这里没有勾选ui文件，因此工程目录如左面所示。</p><p><strong>（2）main文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span>  <span class="comment">//新建qt工程后的类.h文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>  <span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main程序入口，argc命令行变量的数量，argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//a是应用程序对象，在Qt中有且只有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//通过自定义的类，实例化一个对象（窗口对象）</span></span><br><span class="line">    <span class="comment">//其父类在创建项目时选择</span></span><br><span class="line">    learning01 w;</span><br><span class="line">    <span class="comment">//窗口对象默认不会显示，必须调用show方法显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让应用程序对象进入消息循环机制</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息循环机制：</p><p>在正常C++中，运行后窗口都会一闪而过，一般只有添加system(“pause”)才能看到输出窗口。而在qt中，应用程序会阻塞到return行，等待用户的鼠标键盘操作，或点击窗口右上角x才可以退出程序。</p><p><strong>（3）.pro文件</strong></p><p>注意：除非知道你在做什么，否则不要动.pro文件，里面的内容会根据项目自动更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt包含的模块</span></span><br><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于4版本以上，包含 wigdet 模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标，生成的.exe程序的名称</span></span><br><span class="line">TARGET = learning01</span><br><span class="line"><span class="comment"># 模板，应用程序模板</span></span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件，自动追加</span></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        learning01.cpp</span><br><span class="line"><span class="comment"># 头文件，自动追加</span></span><br><span class="line">HEADERS += \</span><br><span class="line">        learning01.h</span><br></pre></td></tr></table></figure><p><strong>（4）头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARNING01_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARNING01_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含头文件QWidget窗口类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">learning01</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">//Q_OBJECT宏，允许类中 使用信号和槽的机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">learning01</span>(QWidget *parent = <span class="number">0</span>);    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">learning01</span>();    <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LEARNING01_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（5）cpp文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;learning01.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;QApplication&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    learning01 w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（6）快捷键</strong></p><ul><li>注释：ctrl + /</li><li>运行：ctrl + r</li><li>编译：ctrl + b</li><li>查找：ctrl + f</li><li>整行移动：ctrl + shift +↑/↓</li><li>字体缩放：ctrl + 滚轮</li><li>自动对齐：ctrl + i</li><li>同名之间的.h和.cpp切换：F4</li></ul><h1>三、按钮控件</h1><p><strong>（1）创建按钮</strong></p><p>使用QPushButton创建按钮，需要指定父类（否则会新建窗口生成按钮），设置文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）其他操作</strong></p><p>见代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、对象树</h1><p>QObject是以对象树的形式组织的。</p><p>当创建一个QObject对象，并指定了父对象指针时，会自动将其添加到其父对象的children()列表。</p><p>当父对象析构时，children()列表的所有对象都会析构。</p><p><img src="https://img-blog.csdnimg.cn/2020121618000044.png" alt=""></p><h1>五、信号与槽</h1><p>实现点击按钮关闭窗口</p><p>具体过程如下：</p><ol><li>信号的发送者</li><li>发送具体信号</li><li>信号的接受者</li><li>对信号进行处理（槽函数）</li></ol><p>以上四个就是信号传递connect的四个参数。</p><p>信号槽的优点：松散耦合，信号发送端和接收端本身是没有关联的，通过connect函数进行连接。</p><p>connect()函数参数</p><ul><li>参数1：信号的发送者，按钮对象</li><li>参数2：发送的信号，clicked, pressed, released,toggled</li><li>参数3：信号的接受者，窗口，this</li><li>参数4：信号的处理，close</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/************* 创建按钮 ************/</span></span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************* 按钮关闭窗口 ************/</span></span><br><span class="line">    <span class="comment">//参数1：信号的发送者; 参数2：发送的信号;</span></span><br><span class="line">    <span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;QWidget::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了QT的基础，并给出了QT第一个程序的创建过程（空窗口与按钮）。介绍了信号和槽的概念与最简单的按下按钮关闭窗口功能的实现。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记08】经典神经网络</title>
    <link href="https://www.mahaofei.com/post/4a294477.html"/>
    <id>https://www.mahaofei.com/post/4a294477.html</id>
    <published>2022-08-21T10:57:11.000Z</published>
    <updated>2022-08-21T10:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、目标定位</h1><h2 id="1-1-基本思想">1.1 基本思想</h2><p>目标定位是在图像分类的基础上发展而来的，而目标检测又是建立在目标定位的基础之上。</p><p>对于一张图片来说，我们可以通过卷积神经网络以及softmax函数实现图像的分类，例如人、车、自行车等。</p><p><strong>如果我们想要定位目标在图像中的位置，我们可以让softmax函数多输出几个数字，例如多输出4个数字来描述边界框的位置(bx, by, w, h)</strong>。这样训练集就不仅是图像的分类数据了，还要包括图像中的边界框坐标。</p><h2 id="1-2-标签的定义">1.2 标签的定义</h2><p>根据上面的思想，我们可以将图像的标签定义为如下：</p><p>$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有物体（区分物体与背景）</li><li>$b_x, b_y, b_w, b_h$：边界框的中心坐标以及宽高</li><li>$c_1, c_2, c_3$：图像中物体属于三类的概率</li></ul><h2 id="1-3-损失函数的设计">1.3 损失函数的设计</h2><p>对于上面定义的标签，如果采用平方损失策略，则损失函数定义如下：</p><p>如果$y_1=1$，即图片中有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2+(\hat y_2-y_2)^2+\dots+(\hat y_8-y_8)^2$</p><p>（由于标签中共有8个元素，因此从$y_1$到$y_8$）</p><p>如果$y_1=0$，即图片中没有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2$</p><h1>二、特征点检测</h1><p>上面我们介绍了通过在标签中添加4个参数$b_x, b_y, b_w, b_h$来输出边界框的坐标。</p><p>特征点检测也是类似的原理。</p><p>加入我们出于某种原因，想要获取一个人的四个眼角在图像中的坐标，那么我们完全可以将其添加到标签中，事先标记好训练图像中每个人的眼角坐标，然后用神经网络进行训练。</p><p>$y = [P_c, l_{1x}, l_{1y}, l_{2x}, l_{2y}, \dots, l_{4x}, l_{4y}]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有人脸（图像分类）</li><li>$l_{1x}, l_{1y}, \dots, l_{4x}, l_{4y}$：四个眼角的xy坐标</li></ul><p>这与边界框的获取，图片的分类等等，都是同样的原理。</p><p>如果我们想更进一步，获取脸部表情，我们可以在人脸上设置多个特征点，然后再每一张图片上的人脸作标注，然后由神经网络来回归计算。</p><p>通过这种方式，就可以实现特征点的检测。</p><h1>三、目标检测</h1><p>目标检测的基础是图像分类。</p><h2 id="3-1-滑动窗口法">3.1 滑动窗口法</h2><p>以汽车检测为例：</p><p>首先在训练集来说，我们可以使用让汽车占满全部区域的图片来作为训练图片，可以通过在其他照片中裁减出来汽车所占据的区域。</p><p>对于一张给定图片，我们在图像上选取一个小窗口，将这个小窗口内的图像传入神经网络中，判断这个小窗口中的图像是不是一辆车，然后移动小窗口到下一个位置，继续检测。整幅图片遍历完成之后，再调整窗口的大小，重新遍历。</p><p><img src="https://img.mahaofei.com/img/20220910194902.png" alt=""></p><p>这种算法一般就被称为滑动窗口法。</p><p>这种算法的优点是算法设计简单，但也有很明显的缺点就是计算量太大，而且需要合理选择窗口大小和步幅，否则无法准确定位图像中的物体。</p><h2 id="3-2-获取更精准的边界框">3.2 获取更精准的边界框</h2><p>现有问题：使用滑动窗口法</p><ul><li>如果步长较大，所标出的窗口经常不能很好的完全覆盖目标物体，如果步长较小，计算量又过大。</li><li>目标物体有时不是规则的正方形，使用正方形的滑动窗口，获得的边界框精度不够</li></ul><p>解决思路</p><ol><li>利用图像定位算法，将图片分割成9个网格，对每一个网格进行图像定位，使用类似于$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$的标签进行训练。</li><li>这样每一个格子都会获得一个输出，例如$y = [1, b_x, b_y, b_w, b_h, 0, 1, 0]^T$，这样综合来看，输出的维度就是3x3x8。3x3是格子数量，8是输出参数个数。</li></ol><p>这样，相比于滑动窗口来说，滑动窗口是将覆盖范围最大的那个窗口，作为边界框输出。而这里则是将边界框作为四个参数作回归了。</p><p>优点：</p><ul><li>由于使用卷积处理不同格子时，很多计算步骤是共享的，因此大大提高了计算效率</li><li>并且由于是卷积实现，所以计算速度非常快，可以达到实时识别</li></ul><h2 id="3-3-非极大抑制NMS（Non-Max-Suppression）">3.3 非极大抑制NMS（Non-Max Suppression）</h2><p>问题：算法可能对同一个物体识别多次，我们需要采取某种措施使算法对每个对象只检测一次。</p><p><img src="https://img.mahaofei.com/img/20220911144627.png" alt=""></p><p>解决方法：</p><p>在输出结果中，找到识别结果概率最高的一个，例如图中的0.9，将与这个框交并比较大的其他框抑制掉，我们认为这个0.9的框就标出了一个对象。</p><p>然后找到剩余所有框中概率最高的一个，例如图中的0.8，将与这个框交并比较大的其他框抑制掉，得到预测结果。</p><blockquote><p>交并比$IOU=\frac{交集区域}{并集区域}$</p></blockquote><p>实现流程</p><ul><li>将图片分为nxn个格子，对每个格子进行预测，获得包括物体存在概率，边界框位置大小等参数</li><li>删除所有物体存在概率小于0.6的边界框</li><li>对剩余的边界框<ul><li>选取概率最高的边界框作为输出，认为其标出了某个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>在剩余的边界框中在找概率最高的边界框作为输出，认为其中也标出了另一个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>重复过程</li></ul></li></ul>]]></content>
    
    
    <summary type="html">目标检测的基本实现方法，从目标定位开始，总结了特征点检测、目标检测、滑动窗口法、NMS非极大抑制等目标检测的算法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记08】经典神经网络</title>
    <link href="https://www.mahaofei.com/post/4a294477.html"/>
    <id>https://www.mahaofei.com/post/4a294477.html</id>
    <published>2022-08-20T11:37:11.000Z</published>
    <updated>2022-08-20T11:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>LeNet-5</h1><p>该网络的作用可用于手写数字识别。</p><p><img src="https://img.mahaofei.com/img/20220820194640.png" alt=""></p><ul><li>输入：32x32x1的手写数字图片</li><li>卷积：f=5, s=1, filters=6，图像变为28x28x6</li><li>平均池化：f=2, s=2，图像变为14x14x6</li><li>卷积：f=5, s=2, filters=16，图像变为10x10x16</li><li>平均池化：f=2, s=2，图像变为5x5x16</li><li>全连接层：400 -&gt; 120</li><li>全连接层：120 -&gt; 84</li><li>分类：10类输出</li></ul><p>共计约6万个参数，使用sigmoid作为激活函数。</p><h1>AlexNet</h1><p><img src="https://img.mahaofei.com/img/20220821082332.png" alt=""></p><ul><li>输入：227x227x3的包含目标物体的图片</li><li>卷积：f=11, s=4, filters=96，图像变为55x55x96</li><li>最大池化：f=3, s=2，图像变为27x27x96</li><li>卷积same：f=5, padding=2,filters=256，图像变为27x27x256</li><li>最大池化：f=3, s=2，图像变为13x13x256</li><li>卷积same：f=3, padding=1, filters=384，图像变为13x13x384</li><li>卷积same：f=3, padding=1, filters=384，图像维度不变</li><li>卷积same：f=3, padding=1, filters=256，图像变为13x13x256</li><li>最大池化：f=3, s=2，图像变为6x6x256</li><li>全连接层：9216 -&gt; 4096</li><li>全连接层：4096 -&gt; 4096</li><li>分类输出：softmax分为1000类</li></ul><p>共计约6000万个参数，使用ReLU作为激活函数，</p><h1>VGG-16</h1><p><img src="https://img.mahaofei.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-08-21%20083422.png" alt=""></p><ul><li>输入：224x224x3的图片</li><li>卷积网络<ul><li>卷积：f=3, s=1, same</li><li>最大池化：f=2, s=2</li><li>重复16次</li></ul></li><li>全连接层</li><li>softmax</li></ul><p>共计约1.38亿参数，每一组卷积层后，图像缩小一倍，通道数量翻倍。</p><h1>ResNet</h1><p><img src="https://img.mahaofei.com/img/20220821092154.png" alt=""></p><h2 id="残差块">残差块</h2><p>ResNet网络是由残差块构成的。</p><p><img src="https://img.mahaofei.com/img/20220821084324.png" alt=""><br><img src="https://img.mahaofei.com/img/20220821084748.png" alt=""></p><p>这样$a^{[l+2]}=g(z^{[l+2]}+a^{[l]})$</p><h2 id="ResNet的意义">ResNet的意义</h2><p>对于没有残差连接的普通神经网络而言，网络越深，优化算法越难训练，并且随着网络深度的加深，训练错误会越来越多。</p><p>如果有了ResNet，即使网络深度很深，错误率也不会上升。</p><h2 id="为什么ResNet有效">为什么ResNet有效</h2><p>如果在很深的网络处，有某层网络出现了梯度消失的问题，即W=0。</p><p>根据$a^{[l+2]}=g(z^{[l+1]}+a^{[l]})=g(w^{[l+2]}a^{[l+1]}+b^{[l+2]}+a^{[l]})$</p><p>由于梯度消失，$w^{[l+2]}=0$，此时若$b^{[l+2]}=0$，则$a^{[l+2]}=g(0+0+a^{[l]})=g(a^{[l]})$，因为激活函数是ReLU函数，$a^{[l]}$已经激活过，因此$a^{[l+2]}=g(a^{[l]})=a^{[l]}$。</p><p>这样就相当于跳过了梯度消失的部分。</p><h1>Inception网络</h1><p><img src="https://img.mahaofei.com/img/20220821100948.png" alt=""></p><p>上图为Inception模块，原理就是将不同卷积核卷积出的结果，按通道叠加连接成一个具有所有卷积特征的大方块。</p><p>由于提供了各种不同的卷积核，因此网络训练时可以自动选择效果最好的一种或几种卷积核组合，避免了使用单一类型的卷积核的限制。</p><p><img src="https://img.mahaofei.com/img/20220821101431.png" alt=""></p><p>这是Inception网络的结构，其就是将传统的卷积层替换为了Inception模块。</p>]]></content>
    
    
    <summary type="html">本文介绍了一些经典的神经网络模型，包括实现LeNet-5，AlexNet，VGG-16，ResNet，Inception网络等的网络结构。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记07】卷积神经网络</title>
    <link href="https://www.mahaofei.com/post/c2525cf1.html"/>
    <id>https://www.mahaofei.com/post/c2525cf1.html</id>
    <published>2022-08-18T01:21:51.000Z</published>
    <updated>2022-08-18T01:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、卷积运算</h1><p>前面已经提到，对于一个神经网络来说，例如人脸识别，前面的层主要用来提取图像的边缘，中间的层主要用来检测部分如眼睛鼻子嘴等，后面的层主要用来检测整个人脸。</p><h2 id="1-1-如何检测边缘">1.1 如何检测边缘</h2><p>通常使用不同的卷积核或者称过滤器来实现各种边缘检测。</p><p><strong>（1）垂直边缘</strong></p><p>使用如下的卷积核进行检测：</p><p><img src="https://img.mahaofei.com/img/20220818095121.png" alt=""></p><p>例如，对于一张具有垂直边缘的图像，利用此卷积核进行卷积运算，输出结果在边缘处数值较大，在图像变化缓慢的区域数值较小。</p><p><img src="https://img.mahaofei.com/img/20220818095338.png" alt=""></p><p>上面的卷积运算可以很好的计算出图像中边缘在什么位置，并且，如果卷积的结果是正值，说明从左到右是从亮到暗的变化，如果是负值，说明从左到右是从暗到亮的变化。</p><p><strong>（2）水平边缘</strong></p><p><img src="https://img.mahaofei.com/img/20220818095712.png" alt=""></p><p>此卷积核可以计算图像的水平边缘，并且正值代表上方亮下方暗，数值越大边缘变化越明显。</p><p><strong>（3）其他滤波器</strong></p><p><img src="https://img.mahaofei.com/img/20220818100201.png" alt=""></p><p>通过定义卷积核中的值的分布，可以实现检测不同方向的，不仅是水平竖直，也可以是45°75°。</p><p>此外还可以改变各行的数值，例如1：2：1，来实现更有目标的检测。</p><h2 id="1-2-Padding">1.2 Padding</h2><p><strong>（1）普通卷积存在的问题</strong></p><ul><li>图像缩小：对于一个(n, n)的图像，使用(f, f)的卷积核做卷积，得到的图像大小是(n-f+1, n-f+1)，因此每做一次卷积，图像大小都会减小。</li><li>边缘信息丢失：图像角落的像素只会被一个卷积核处理，边缘像素相比于中间的像素，也会容易丢失很多信息。</li></ul><p><strong>（2）解决方法</strong></p><p>在进行卷积操作之前，先在图像边缘填充一层像素。</p><p>例如在图像边缘添加p层像素，那么卷积后图像大小是(n+2p-f+1, n+2p-f+1)。</p><p><strong>通常情况下，卷积核边长是奇数</strong></p><h2 id="1-3-卷积步长">1.3 卷积步长</h2><p>使用一个(f, f)的卷积核，卷积一个(n, n)的图像，padding为p，步长为s，输出的图像维度为$(\frac{n+2p-f}{s}+1, \frac{n+2p-f}{s}+1)$</p><h1>二、三维卷积</h1><h2 id="2-1-三维卷积基础">2.1 三维卷积基础</h2><p>例如对于一个RGB图像来说，其有(w, h, 3)的维度，对其进行卷积，必须是(f, f, 3)的维度。</p><p>即<strong>图像和卷积核的通道数要相同</strong>。</p><p><strong>卷积完成后的输出图像是(w-f+1, h-f+1, n)的n通道图像，其中n是卷积核的个数。</strong></p><p><img src="https://img.mahaofei.com/img/20220818205222.png" alt=""></p><h2 id="2-2-三维卷积在神经网络的应用">2.2 三维卷积在神经网络的应用</h2><p>三维卷积在神经网络的应用，与传统方法基本一致。</p><p>在传统方法中有，$z^{[1]}=w^{[1]}a^{[0]}+b^{[1]}$，其中$a^{[0]}$就是输入x，$a^{[1]}=g(z^{[1]})$</p><p>而若是卷积运算，则只需将输入图片替换x，卷积核替换w，然后同样添加偏差和非线性激活函数即可。</p><p><img src="https://img.mahaofei.com/img/20220818210442.png" alt=""></p><h1>三、池化层</h1><p>池化层可以缩小模型大小，提高运算速度，提高模型的鲁棒性。</p><h2 id="3-1-最大池化">3.1 最大池化</h2><p>例如对一个4x4的输入，最大池化选择2x2，那么输出就是将4x4的输入分成4部分，每部分取最大值填充到2x2中。最大池化输出维度的计算方法与卷积相同。</p><p><img src="https://img.mahaofei.com/img/20220818215833.png" alt=""></p><p>最大池化的作用是，如果卷积过滤提取到了某个特征，那么保留其最大值，如果没有提取到特征，那么最大值也还是很小。</p><h2 id="3-2-平均池化">3.2 平均池化</h2><p>平均池化与最大池化类似，是在不同区域内求平均值，主要用在很深的网络。</p><p>目前来说最大池化比平均池化更常用。</p><h2 id="3-3-池化总结">3.3 池化总结</h2><p>池化的参数主要有：</p><ul><li>f：池化过滤器大小</li><li>s：补偿</li><li>最大或平均池化</li></ul><p>由于池化层没有权重，只有上面一些超参数，因此一般来说会将卷积层和池化层合并称为一层。</p><h1>四、全连接层</h1><p>在神经网络的最后，经过多轮的卷积和池化处理，最后的输出往往是宽高较小，通道数较多。这是我们会将其展开成为一个向量，这个向量的长度就等于上一层输出的$w\times h\times c$，将向量中的所有参数作为同样数量单元的输入，进行常规神经网络计算，这就是全连接层。</p><h1>五、代码实现</h1><p><strong>（1）添加padding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero_pad</span>(<span class="params">X, pad</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对数据集X的所有图像添加pad，padding被应用再一张图片的宽和高方向上。</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- numpy数组，shape (m, n_H, n_W, n_C) 代表批量为m的图片</span></span><br><span class="line"><span class="string">    pad -- 整数，图片边缘填充的pad大小</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    X_pad -- 添加了以0填充的pad图片，shape (m, n_H + 2*pad, n_W + 2*pad, n_C)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    X_pad = np.pad(X, ((<span class="number">0</span>, <span class="number">0</span>), (pad, pad), (pad, pad), (<span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_pad</span><br></pre></td></tr></table></figure><p><strong>（2）单步卷积（numpy实现）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_single_step</span>(<span class="params">a_slice_prev, W, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在上一层的一个切片用卷积核W进行卷积, 并添加偏差b</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    a_slice_prev -- 输入数据的切片，shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- 权重参数，以卷积核的形式体现，shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    b -- 偏置参数，shape (1, 1, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    Z -- 标量，滑动窗口(W, b)与输入切片x的卷积计算的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># a_slice 和 W 按元素相乘并添加偏置.</span></span><br><span class="line">    S = np.multiply(W, a_slice_prev) + b</span><br><span class="line">    <span class="comment"># 求和</span></span><br><span class="line">    Z = np.<span class="built_in">sum</span>(S)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z</span><br></pre></td></tr></table></figure><p><strong>（3）三维卷积（numpy实现）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_forward</span>(<span class="params">A_prev, W, b, hparameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    卷积前向计算</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 上一层的激活输出，shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- 权重, shape (f, f, n_C_prev, n_C)</span></span><br><span class="line"><span class="string">    b -- 偏置, shape (1, 1, 1, n_C)</span></span><br><span class="line"><span class="string">    hparameters -- 包含 &quot;stride&quot; 和 &quot;pad&quot; 的字典</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    Z -- 卷积输出，shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- 缓存，用于conv_backward()函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 A_prev 的维度  </span></span><br><span class="line">    m, n_H_prev, n_W_prev, n_C_prev = A_prev.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取 W 的维度</span></span><br><span class="line">    f, _, n_C_prev, n_C = W.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 hparameters 中的参数</span></span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    pad = hparameters[<span class="string">&quot;pad&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算卷积输出的维度</span></span><br><span class="line">    n_H = (n_H_prev - f + <span class="number">2</span> * pad) // stride + <span class="number">1</span></span><br><span class="line">    n_W = (n_W_prev - f + <span class="number">2</span> * pad) // stride + <span class="number">1</span></span><br><span class="line">    n_C = W.shape[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 零初始化卷积输出变量Z</span></span><br><span class="line">    Z = np.zeros((m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用函数，填充0创建 A_prev_pad </span></span><br><span class="line">    A_prev_pad = zero_pad(A_prev, pad)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在训练样本的批量中循环</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 选择第e个填充样本</span></span><br><span class="line">        A_prev_pad_e = A_prev_pad[e]</span><br><span class="line">        <span class="comment"># 在输出Z的竖直方向遍历</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n_H):</span><br><span class="line">            <span class="comment"># 在输出Z的水平方向遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n_W):</span><br><span class="line">                <span class="comment"># 遍历所有通道，通道数为卷积核个数</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_C):</span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot; (≈4 lines)</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + pad</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 确定被卷积区域</span></span><br><span class="line">                    A_prev_pad_slice = A_prev_pad_e[vert_start:vert_end, horiz_start:horiz_end, :]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 使用卷积核W和偏置b进行卷积</span></span><br><span class="line">                    Z[e, h, w, c] = np.<span class="built_in">sum</span>(np.multiply(A_prev_pad_slice, W[:, :, :, c]) + b[:, :, :, c])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出维度正确</span></span><br><span class="line">    <span class="keyword">assert</span>(Z.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将信息保存在cache中，用于反向传播</span></span><br><span class="line">    cache = (A_prev, W, b, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z, cache</span><br></pre></td></tr></table></figure><p><strong>（4）池化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: pool_forward</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool_forward</span>(<span class="params">A_prev, hparameters, mode = <span class="string">&quot;max&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前向传播的池化层</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 输入数据，shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    hparameters -- 包含 &quot;f&quot; 和 &quot;stride&quot; 的python字典</span></span><br><span class="line"><span class="string">    mode -- 想要使用的池化模式, 定义为字符串 (&quot;max&quot; or &quot;average&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    A -- 池化层输出，shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- 保存池化层的数据，用于反向传播</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取输入数据的维度</span></span><br><span class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从 &quot;hparameters&quot; 中获取超参数</span></span><br><span class="line">    f = hparameters[<span class="string">&quot;f&quot;</span>]</span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义输出维度</span></span><br><span class="line">    n_H = <span class="built_in">int</span>(<span class="number">1</span> + (n_H_prev - f) / stride)</span><br><span class="line">    n_W = <span class="built_in">int</span>(<span class="number">1</span> + (n_W_prev - f) / stride)</span><br><span class="line">    n_C = n_C_prev</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化输出矩阵A</span></span><br><span class="line">    A = np.zeros((m, n_H, n_W, n_C))              </span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 在训练样本的批量中循环</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 在输出Z的竖直方向遍历</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n_H):</span><br><span class="line">            <span class="comment"># 在输出Z的水平方向遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n_W):</span><br><span class="line">                <span class="comment"># 遍历所有通道</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_C):</span><br><span class="line">                    <span class="comment"># 找到当前要进行池化的区域</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + f</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 使用上面的角坐标定义slice区域</span></span><br><span class="line">                    A_prev_slice = A_prev[e, vert_start:vert_end, horiz_start:horiz_end, c]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 根据池化模式在slice进行计算，求最大值或平均值</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">                        A[e, h, w, c] = np.<span class="built_in">max</span>(A_prev_slice)</span><br><span class="line">                    <span class="keyword">elif</span> mode == <span class="string">&quot;average&quot;</span>:</span><br><span class="line">                        A[e, h, w, c] = np.mean(A_prev_slice)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存输入和超参数，用于反向传播</span></span><br><span class="line">    cache = (A_prev, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保输出维度正确</span></span><br><span class="line">    <span class="keyword">assert</span>(A.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A, cache</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">为什么神经网络对图片进行分析时经常使用卷积，为什么会有padding和stride，池化层和全连接层的作用是什么？</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记06】参数调试处理</title>
    <link href="https://www.mahaofei.com/post/bd5d217b.html"/>
    <id>https://www.mahaofei.com/post/bd5d217b.html</id>
    <published>2022-08-14T09:09:52.000Z</published>
    <updated>2022-08-14T09:09:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、超参数的取值</h1><p><strong>需要处理的参数通常包括：</strong></p><table><thead><tr><th>参数</th><th>常用取值范围</th><th>调试重要度</th></tr></thead><tbody><tr><td>学习率$\alpha$</td><td>0.1</td><td>最重要</td></tr><tr><td>动量</td><td>0.9</td><td>重要</td></tr><tr><td>优化参数$\beta_1,\beta_2,\epsilon$</td><td>$\beta_1=0.9,\beta_2=0.999,\epsilon=10^{-8}$</td><td>一般不修改</td></tr><tr><td>层数layers</td><td></td><td>一般</td></tr><tr><td>隐藏单元数hidden units</td><td></td><td>重要</td></tr><tr><td>学习率衰减learning rate decay</td><td></td><td>一般</td></tr><tr><td>批量大小mini-batch size</td><td></td><td>重要</td></tr></tbody></table><p><strong>如何调试选择参数：</strong></p><ol><li>首先大范围随机选择参数，根据随机取点测试超参数的效果，确定影响最大的参数是哪个。因为对于实际问题而言，很难确定哪个超参数对结果的影响更大，在众多参数中如果一个一个测试往往找不到需要调试的参数。</li><li>采用由粗糙到精细的策略，找到随机测试中结果较好的参数范围，然后放大这一范围，在其中更密集的取值测试，搜索超参数的最优选择。</li></ol><p><strong>如何有效的随机取值</strong></p><p>例如在搜索学习率$\alpha$的取值，其取值可能范围是0.0001-1。如果使用常规的随机取值，那么取到的值将有90%在0.1-1，只有10%在0.0001-0.1，而实际情况是学习率在后者的可能性更大。</p><p>为了解决这个问题，可以采用对数轴。在对数轴上随机取值，这样就可以保证在0.0001-0.1的取值数量大幅增加。</p><p><img src="https://img.mahaofei.com/img/20220814172926.png" alt=""></p><p>又例如在搜索动量$\beta$的值，其取值范围可能是0.9-0.999，但是实际取值肯定会更接近0.9，因此也可以使用上面的方法，通过用上面的方法取$1-\beta$的值[0.001,0.1]，来间接取$\beta$的值。</p><blockquote><p>关于为什么要采用非线性轴取值？因为超参数在不同的范围，对结果的灵敏度不同，以动量$\beta$为例，其在0.9变化为0.9001，比从0.999变为0.9991，对结果的影响要大很多。因此需要更多的在灵敏度高的区间取值，故采用了非线性轴取值方法。</p></blockquote><h1>二、Batch-Normalization(BN)</h1><h2 id="2-1-BN的基本思路">2.1 BN的基本思路</h2><p>在logistic回归中，我们使用了归一化方法（计算平均值、方差），改善了训练样本，加快了梯度下降的速度。</p><p>但在深层网络中，下一层做梯度下降的数据是上一层网络的输出结果。实际中会将上一层的数据，在激活之前进行归一化，然后再激活，传递给下一层。</p><p>在神经网络中，假设有一些隐藏单元值$z^{(1)}\dots z^{(m)}$，计算：</p><p>$\mu=\frac{1}{m}\sum_i z^{(i)}$<br>$\sigma^2=\frac{1}{m}\sum_i(z_i-\mu)^2$<br>$Z^{(i)}_{norm}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\epsilon}}$</p><p>这样就实现了将每层网络的输出z进行了标准化，这时输出就是平均值0和方差1的数据，我们虽然想通过正则化规范数据，加快梯度下降，但我们不想让它们都服从同样均值和方差的分布，因此有了下面的变式：</p><p>$\widetilde z^{(i)}=\gamma z_{norm}^{(i)}+\beta$</p><p>这里的$\gamma,\beta$是新的超参数，作用是设置输出z的平均值和方差。</p><h2 id="2-2-BN为何有效">2.2 BN为何有效</h2><p>BN可以使权重比网络更滞后或更深层。</p><p>对于神经网络的某一层而言，其输入数据就是上一层的输出，由于随着参数的更新，上一层的输出是实时变化的，这就导致当前层的训练总是面对不同分布的输入。</p><p>使用BN后，可以将上一层的数据归一化到同一分布中，使上一层的输出数据更加稳定，进而保证之后的层有更好的基础。</p><p>总而言之，BN减弱了前层参数的作用与后层参数作用之间的联系，使网络每层都可以自己学习，稍微独立于整个网络，这样有助于加速整个网络的学习。</p><h1>三、Softmax</h1><h2 id="3-1-softmax数学表示">3.1 softmax数学表示</h2><p>前面提到的分类方法都是用于二分分类，而softmax回归则适用于多种分类。常用C表示输入类别个数，也等于输出层单元数。</p><p>使用时就是将最后一层的激活函数换成softmax。</p><p>例如设网络的最后一层为$l$，则该softmax层计算过程如下：</p><p>计算线性部分：<br>$z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$</p><p>计算临时变量：<br>$t=e^{z^{[L]}}$</p><p>计算输出，也就是各个分类的概率：<br>$a^{[l]}=\frac{t_i}{\sum t_i}$</p><p>假设$z^{[l]}$是一个(4,1)的向量，那么$t,a^{[l]}$的维度都是(4,1)，其中$a^{[l]}$内的四个值就是四种分类的概率。</p><h2 id="3-2-训练softmax网络">3.2 训练softmax网络</h2><p><strong>（1）损失函数</strong></p><p>由于softmax的输出与分类个数相同，因此需要新的损失函数。</p><p>$l(\hat y,y)=-\sum_{j=1}y_jlog\hat y_j$</p><p>要想让损失函数尽量小，就需要让$log\hat y_j$尽可能大，也就是对应的概率尽可能大。</p><p><strong>（2）梯度下降</strong></p><p>关键步骤是对softmax层求导：</p><p>$dz^{[l]}=\hat y-y$</p>]]></content>
    
    
    <summary type="html">介绍了神经网络中一些常用参数的选择原则和大概范围，以及BN和softmax的基本原理。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>6D位姿估计算法linemod的介绍与代码测试</title>
    <link href="https://www.mahaofei.com/post/95f99fd4.html"/>
    <id>https://www.mahaofei.com/post/95f99fd4.html</id>
    <published>2022-08-13T10:03:12.000Z</published>
    <updated>2022-08-13T10:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、LineMod算法介绍</h1><p>LineMod算法是Hinterstoisser等人在2011年提出的，通过采用模板匹配的方法，解决了杂乱场景下少纹理三维物体的实时监测与6D位姿估计定位问题。</p><p>算法使用3D物体的RGB-D数据作为输入，通过PCL数据处理库分析目标点云数据，利用预先采集好的三维物体的无噪声或少噪声模板经过较短时间训练得到物体各个方向每个像素点梯度方向和幅值变化，在较短的时间内完成模板训练。识别时用采集到的点云数据与模板对比得到物体信息、位姿和置信度。</p><p>需要注意的是由于LineMod算法是将整个物体作为一个单个模板用于之后的模板匹配，因此限制了其不具备多目标及遮挡场景的识别能力。</p><h1>二、LineMod算法原理</h1><p>总的来说，LineMod算法的实现可分为以下三个阶段。</p><ol><li>模板采集阶段：在多个视角、多种距离、多个方向上对目标物体的特征进行采集</li><li>模板训练阶段：计算目标物体的特征点和特征向量的计算，得到各特征点的坐标并进行存储</li><li>模板匹配阶段：对被测图像进行特征处理，延梯度方向展开得到预处理相应图，然后构造响应表进行线性化存储，最后通过滑窗匹配计算与模板的相似度。</li></ol><h2 id="2-1-模板采集阶段">2.1 模板采集阶段</h2><p>LineMod是基于模板匹配的算法，因此在进行三维物体识别前需要获取识别物体的低噪声、高精度的完成模型，获取模型有两种方法。</p><ol><li>通过深度相机从多个视角、多个距离、多个方向对目标进行模板采集，但这种方法容易产生较多的噪声，对之后的目标识别会产生干扰，且费时费力。</li><li>通过OpenGL手动渲染想要识别的三维物体的模型，利用Solidworks等三维仿真软件就可以对物体进行三维模型的创建和渲染，这种方法可以很好的控制噪声，有利于后续算法对物体的识别精度。</li></ol><p>目前网上已经出现了很多常见三维物体的模板库，例如：<a href="https://www.thingiverse.com/">Thingiverse</a>、<a href="https://www.youmagine.com/">YouMagine</a>、<a href="https://pinshape.com/">Pinshape</a>，等网站都提供常见物品的三维物体模型文件。</p><h2 id="2-2-模板训练">2.2 模板训练</h2><p>LineMod算法将模板图像上各视点的梯度和法向量方向的特征进行提取保存编码，这些根据特征生成的二进制字符串就是之后进行模板匹配的关键。在模板训练阶段需要进行特征点的特征向量的计算、特征点坐标的计算、以及信息的存储。</p><p><strong>1. 计算特征点的特征向量</strong></p><ol><li>将模型的RGB-D和物体的ID信息导入算法。</li><li>LineMod算法会在空间中进行不同角度、不同缩放尺度，进而得到待训练模板。</li><li>待训练模板、训练距离、掩模图像作为特征点的输入，通过高斯模糊和低通滤波完成候选点的去噪以及预处理。</li><li>通过Sobel算子计算候选点梯度幅度，得到物体图像边缘。</li><li>通过Phase函数计算候选点的梯度方向。</li><li>在360°空间范围内对候选点的梯度方向按照16个区间共十个方向进行投影，量化候选点的梯度方向</li><li>通过设置阈值和3x3梯度直方图统计3x3区域内的候选点梯度方向，将候选点最多的梯度方向作为整个区域的梯度方向</li><li>得到特征点的梯度方向和梯度幅值，保存特征计算结果。</li></ol><p><img src="https://img.mahaofei.com/img/20220405172556.png" alt=""></p><p><strong>2. 特征点坐标计算</strong></p><p>LineMod算法通过遍历输入图像的图像金字塔，通过下采样的方式提取金字塔每一层特征点所在的坐标位置，在训练中不断循环计算特征点坐标并进行修正，最后得到3x3区域内特征点对应的坐标位置。</p><p><strong>3. 特征点信息存储</strong></p><p>训练得到的特征向量（梯度幅度和梯度方向）和特征点的坐标位置后，结果通过<code>shapes.save_infos</code>保存训练信息，通过<code>detector.writerClasses</code>写入预设待匹配模板特征点信息。</p><h2 id="2-3-模板匹配">2.3 模板匹配</h2><p><img src="https://img.mahaofei.com/img/20220406083922.png" alt=""></p><p>输入的测试图会将图像的宽度和高度调整为16的倍数便于后续的图像处理，各个特征点的特征向量和坐标计算与模板训练阶段一样，在得到测试图像特征点的特征向量和坐标后，进行以下操作。</p><p><strong>1. 梯度方向展开</strong></p><p>将每一个像素点及其3x3的邻域按照离散化的方向进行或运算，并按邻域直径T循环TxT次完成邻域像素点的梯度方向值遍历，并在内存中存储为连续的特征信息数据。</p><p><img src="https://img.mahaofei.com/img/20220406084455.png" alt=""></p><p>梯度方向展开的过程如图：a)像素点的梯度方向；b)以该像素点为中心进行3x3邻域梯度方向展开；c)每个邻域对应方向量化值。计算结束后将会创建梯度响应表(图c)用于存储梯度方向量化值。</p><p><strong>2. 线性化存储</strong></p><p>LineMod算法会预处理相应图，将像素点x处的多个特征进行编码，由扩散得到的多个特征将编码的独一无二的字符串会在匹配阶段使用。LineMod算法通过预先为每个离散方向创建n0个查超标供与二进制字符串匹配搜索过程，而查找表的索引号对应该字符串、索引值对应像素点的位置与离散特征方向的余弦值。这样就完成了测试图像像素特征处理、方向扩散、构造响应表以及线性化存储梯度方向量化值的过程。</p><p><img src="https://img.mahaofei.com/img/20220406085830.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220406085837.png" alt=""></p><p><strong>3. 相似度计算</strong></p><p>LineMod提取出训练阶段的模板特征点信息，通过将模板在测试图像上进行水平和垂直方向上的滑窗匹配，比较训练模板特征点与测试图像对应像素点在查找表上对应的梯度值差异性，产生一个二维相似度矩阵，完成测试图像的一次滑窗匹配。</p><p>测试图像在不同的金字塔不断进行模板的滑窗匹配，得到不同的相似度（梯度方向余弦值）。对同一个模板进行相似度叠加得到整体相似度，这样就是一个测试图像对应不同位置方向角度模板得到不同的整体相似度，通过相似度即可判断是否匹配成功。</p><p><img src="https://img.mahaofei.com/img/20220406090244.png" alt=""></p><h1>三、LineMod算法实现</h1><h2 id="3-1-运行环境搭建">3.1 运行环境搭建</h2><p>系统环境：ROS系统（本文使用Ubuntu20.04+ROS Noetic）</p><blockquote><p>[[01_Ubuntu20.04安装ROS Noetic|ROS安装方法参考此文章]]</p></blockquote><p>硬件设备：3D相机（本文使用Realsense D435i）</p><blockquote><p>Realsense的安装参考<a href="https://github.com/IntelRealSense/librealsense/blob/master/doc/distribution_linux.md">Github主页</a></p><p>如果出现[camera/realsense2_camera_manager-2] process has died exit code 127的问题<br>则将LD_LIBRARY_PATH=/opt/ros/indigo/lib加入到.bashrc中</p></blockquote><p>这里使用realsense官网的例程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch realsense2_camera rs_rgbd.launch</span><br></pre></td></tr></table></figure><p>发布的RGBD信息为：</p><table><thead><tr><th>信息</th><th>话题</th></tr></thead><tbody><tr><td>rgb_frame_info</td><td>/camera/color/camera_info</td></tr><tr><td>rgb_image_topic</td><td>/camera/color/</td></tr><tr><td>depth_frame_info</td><td>/camera/depth/camera_info</td></tr><tr><td>depth_image_topic</td><td>/camera/depth/image_rect_raw</td></tr></tbody></table><h2 id="3-2-安装ork">3.2 安装ork</h2><p>在已经完整安装ROS的情况下，运行下面指令即可安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export DISTRO=noetic</span><br><span class="line">sudo apt-get install libopenni-dev ros-$&#123;DISTRO&#125;-catkin ros-$&#123;DISTRO&#125;-ecto* ros-$&#123;DISTRO&#125;-opencv-candidate ros-$&#123;DISTRO&#125;-moveit-msgs</span><br><span class="line">sudo apt-get install ros-$&#123;DISTRO&#125;-object-recognition-*</span><br></pre></td></tr></table></figure><p>进入<code>catkin_ws/src</code>文件夹下，运行下面的指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg-perception/object_recognition_msgs</span><br><span class="line">git clone https://github.com/wg-perception/object_recognition_ros</span><br><span class="line">git clone https://github.com/wg-perception/object_recognition_ros_visualization</span><br><span class="line">git clone https://github.com/wg-perception/object_recognition_core</span><br><span class="line">git clone https://github.com/wg-perception/linemod</span><br><span class="line">git clone https://github.com/wg-perception/ork_renderer</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h2 id="3-3-下载ork-tutorials">3.3 下载ork_tutorials</h2><p>进入<code>catkin_ws/src</code>文件夹，下载<code>ork_tutorials</code>包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg-perception/ork_tutorials</span><br></pre></td></tr></table></figure><p>进入刚下载的包中<code>ork_tutorials/data</code>文件夹，执行以下语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun object_recognition_core object_add.py -n &quot;coke &quot; -d &quot;A universal can of coke&quot; --commit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_ws/src</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_msgs</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_ros</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_ros_visualization</span><br><span class="line">cd ../ &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_ws/src</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_core</span><br><span class="line">git clone http://github.com/wg-perception/linemod</span><br><span class="line">git clone http://github.com/wg-perception/ork_renderer</span><br><span class="line">cd ../ &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure><blockquote><p>参考文章<br><a href="https://www.guyuehome.com/34796">LineMod模板匹配算法的原理与实现 （第一篇 原理及公式）</a><br><a href="https://www.guyuehome.com/34798"># LineMod模板匹配算法的原理与实现 （第三篇 原理及实现）</a></p></blockquote>]]></content>
    
    
    <summary type="html">LineMod算法是Hinterstoisser等人在2011年提出的，通过采用模板匹配的方法，解决了杂乱场景下少纹理三维物体的实时监测与6D位姿估计定位问题。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/tags/%E8%A7%86%E8%A7%89/"/>
    
    <category term="位姿估计" scheme="https://www.mahaofei.com/tags/%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记05】深度学习常用优化算法</title>
    <link href="https://www.mahaofei.com/post/6b1d78ca.html"/>
    <id>https://www.mahaofei.com/post/6b1d78ca.html</id>
    <published>2022-08-08T23:57:11.000Z</published>
    <updated>2022-08-08T23:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Mini-batch梯度下降法</h1><p><strong>（1）为什么需要mini-batch</strong></p><p>我们知道，在神经网络中常使用向量化的方法，来实现较快速的处理所有m个样本。</p><p>但是这样的方法，对于超大数量的样本来说，比如对于一个有100万样本的数据集，使用向量化的方法就代表将创建一个有100万列的超大矩阵，并且需要对整个数据集进行处理后才能进一步做梯度下降，这种方法称为batch梯度下降法。</p><p>为了解决这个问题，可以把训练集分割为小一些的子训练集，这些子集称为mini-batch，比如每次取出1000个样本进行训练，然后再取1000个样本训练。</p><p><strong>（2）如何理解mini-batch</strong></p><p>使用mini-batch梯度下降法时，每次迭代过程需要处理的是$X^$和$y^$，因此做出的成本函数图在取不同子集的过程中是不一样的，但由于权重和偏置是随着训练逐渐优化，因此整体的成本函数是震荡下降的。</p><p><img src="https://img.mahaofei.com/img/20220809182523.png" alt=""></p><p><strong>（3）超参数：batch_size</strong></p><p>在设置minibatch的过程中用到的一个超参数就是batch大小，如果训练集的大小是m的话：</p><ul><li>batch_size=m：mini-batch子集与整个训练集一样，其实就是batch梯度下降法，这种情况相对噪声低一些，幅度大一些，在此方法后可以继续寻找最小值。</li><li>batch_size=1：叫做梯度下降法，每个样本都是独立的mini-batch，这种方法大部分情况下会像最小值靠近，有时会远离最小值，且有很多噪声，而且该方法永远不会手链，而是会一直在最小值附近波动。</li></ul><p>实际工作中选择的mini-batch大小通常在两种极限情况之间，即1&lt;batch_size&lt;m。并且如果样本数量较小，就没必要划分子集了，直接使用batch梯度下降法即可，对于数目较大的数据，一般batch_size选择为64到512，根据电脑内存情况选取。</p><p><strong>（4）编程实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_mini_batches</span>(<span class="params">X, Y, mini_batch_size = <span class="number">64</span>, seed = <span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从(X, Y)创建随机的mini-batch</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入数据, shape (input size, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 真值向量, shape (1, number of examples)</span></span><br><span class="line"><span class="string">    mini_batch_size -- mini-batches的大小，整形</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    mini_batches -- 同步的列表 (mini_batch_X, mini_batch_Y)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    m = X.shape[<span class="number">1</span>]                  <span class="comment"># 训练样本的数量</span></span><br><span class="line">    mini_batches = []</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Step 1: 打乱 (X, Y)</span></span><br><span class="line">    permutation = <span class="built_in">list</span>(np.random.permutation(m))</span><br><span class="line">    shuffled_X = X[:, permutation]</span><br><span class="line">    shuffled_Y = Y[:, permutation].reshape((<span class="number">1</span>,m))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step 2: 分区 (shuffled_X, shuffled_Y). </span></span><br><span class="line">    num_complete_minibatches = math.floor(m/mini_batch_size) <span class="comment"># 以mini_batch_size为大小的分区的数量</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_complete_minibatches):</span><br><span class="line">        mini_batch_X = shuffled_X[:, k*mini_batch_size : (k+<span class="number">1</span>)*mini_batch_size]</span><br><span class="line">        mini_batch_Y = shuffled_Y[:, k*mini_batch_size : (k+<span class="number">1</span>)*mini_batch_size]</span><br><span class="line">        mini_batch = (mini_batch_X, mini_batch_Y)</span><br><span class="line">        mini_batches.append(mini_batch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余的样本（少于mini_batch_size的样本）</span></span><br><span class="line">    <span class="keyword">if</span> m % mini_batch_size != <span class="number">0</span>:</span><br><span class="line">        mini_batch_X = shuffled_X[:, num_complete_minibatches*mini_batch_size : m]</span><br><span class="line">        mini_batch_Y = shuffled_Y[:, num_complete_minibatches*mini_batch_size : m]</span><br><span class="line">        mini_batch = (mini_batch_X, mini_batch_Y)</span><br><span class="line">        mini_batches.append(mini_batch)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mini_batches</span><br></pre></td></tr></table></figure><h1>二、动量梯度下降法</h1><h2 id="2-1-指数加权平均数">2.1 指数加权平均数</h2><p><strong>（1）什么是指数加权平均数</strong></p><p>指数加权平均数，可以将震荡往复的噪声曲线拟合为一条平滑的曲线。</p><p><img src="https://img.mahaofei.com/img/20220809194847.png" alt=""></p><p>其数学表达式如下：</p><p>$V_t=\beta V_{t-1}+(1-\beta)\theta_t$</p><p><strong>（2）如何理解指数加权平均数</strong></p><p>以$\beta=0.9$为例，我们可以写出下面的式子</p><p>$V_{100}=0.9V_{99}+0.1\theta_{100}$<br>$V_{99}=0.9V_{98}+0.1\theta_{99}$<br>$V_{98}=0.9V_{97}+0.1\theta_{98}$</p><p>我们将后两式代入第一式就可以得到：</p><p>$V_{100}=0.9V_{99}+0.1\theta_{100}$<br>$=0.1\theta_{100}+0.9(0.9V_{98}+0.1\theta_{99})$<br>$=0.1\theta_{100}+0.9(0.1\theta_{99}+0.9(0.9V_{97}+0.1\theta_{98}))$<br>$=0.1\theta_{100}+0.1\times 0.9\theta_{99}+0.1\times 0.9^2\theta_{98}++0.1\times 0.9^3\theta_{97}+\dots$</p><p>可以看出来，这是一个对$\theta$的加和和平均，对于$V_{100}$来说，它由前99个数据决定，并且离100越近的数据，权重越大，离得越远的数据权重越小，权重是成指数衰减的函数。</p><p><strong>（3）超参数：$\beta$</strong></p><p>在公式$V_t=\beta V_{t-1}+(1-\beta)\theta_t$中，如果$\beta$较大，说明在加权过程中，权重衰减更慢，因此可以看作对更多个数据的平均。如果$\beta$较小，说明加权过程中，权重衰减更快，可以看作只对临近几个数据平均。</p><p><strong>指数加权平均公式的好处在于，它占用极少的内存，每次只存储上一次的变量，然后计算最新的数据并不断覆盖就可以了，而不需要为了拟合曲线读入所有的数据。</strong></p><h2 id="2-2-动量梯度下降法">2.2 动量梯度下降法</h2><p>基本思想为计算梯度的加权平均数，并利用该梯度更新权重。</p><p>比如要优化某个成本函数，梯度下降的过程中总是会慢慢摆动直到下降到最小值，这样的上下波动减慢了梯度下降的速度，并且不能使用更大的学习率，因为一旦学习率过大，结果就可能会超出函数的范围。</p><p><img src="https://img.mahaofei.com/img/20220809194602.png" alt=""></p><p><strong>总结来说，我们希望在b方向学习慢一些，减少不必要的摆动，在W方向上加快学习，快速接近最小值。</strong></p><p>因此，一个可以的解决方法是，使用动量梯度下降法。在每次迭代过程中，计算微分dW和db，并计算$V_{dW}=\beta V_{dW}+(1-\beta)dW$，同样计算$V_{db}=\beta V_{db}+(1-\beta)db$，并将计算后的值重新赋值给dW和db，这样做有什么好处呢。</p><p><img src="https://img.mahaofei.com/img/20220809194847.png" alt=""></p><p>类似于上面的图，通过加权平均，将震荡往复的梯度值dW和db转换为连续变化的梯度值，使得在b方向上正负抵消，dW的摆动减小了，W方向上由于所有微分方向一致，因此W方向运动更快了。</p><p>可以理解为成本函数是一个碗状函数，梯度下降就是在碗的边缘滚下一个球，$(1-\beta)dW$和$(1-\beta)db$项相当于在每一刻提供一个加速度，$\beta v_{dW}$和$\beta v_{db}$相当于上一时刻的瞬时速度。因此速度会越滚越快，并且由于$\beta$小于1，类似于表现出一些摩擦力，所以球不会无限加速下去。</p><p>因此动量梯度下降法过程如下：</p><p>$V_{dW}=\beta V_{dW}+(1-\beta)dW$<br>$V_{db}=\beta V_{db}+(1-\beta)db$<br>$W=W-\alpha v_{dW}$<br>$b=b-\alpha v_{db}$</p><p>这个过程中超参数有两个：动量$\beta$和学习率$\alpha$</p><h2 id="2-3-编程实现">2.3 编程实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters_with_momentum</span>(<span class="params">parameters, grads, v, beta, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用动量更新参数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的python字典:</span></span><br><span class="line"><span class="string">                    parameters[&#x27;W&#x27; + str(l)] = Wl</span></span><br><span class="line"><span class="string">                    parameters[&#x27;b&#x27; + str(l)] = bl</span></span><br><span class="line"><span class="string">    grads -- 包含所有参数的梯度的python字典:</span></span><br><span class="line"><span class="string">                    grads[&#x27;dW&#x27; + str(l)] = dWl</span></span><br><span class="line"><span class="string">                    grads[&#x27;db&#x27; + str(l)] = dbl</span></span><br><span class="line"><span class="string">    v -- 包含当前速度的python字典:</span></span><br><span class="line"><span class="string">                    v[&#x27;dW&#x27; + str(l)] = ...</span></span><br><span class="line"><span class="string">                    v[&#x27;db&#x27; + str(l)] = ...</span></span><br><span class="line"><span class="string">    beta -- 动量超参数，标量</span></span><br><span class="line"><span class="string">    learning_rate -- 学习率，标量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有更新后的参数的python字典</span></span><br><span class="line"><span class="string">    v -- 包含所有更新后的速度的python字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span> <span class="comment"># 神经网络的层数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每个参数的Momentum更新</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="comment"># 计算速度</span></span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta) * grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta) * grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        parameters[<span class="string">&#x27;W&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        parameters[<span class="string">&#x27;b&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> parameters, v</span><br></pre></td></tr></table></figure><h1>三、RMSprop</h1><p>RMSprop的全称是root mean square prop算法，也可以加速梯度下降。</p><p><strong>数学表示如下：</strong></p><p>$S_{dW}=\beta S_{dW}+(1-\beta)dW^2$<br>$S_{dW}=\beta S_{dW}+(1-\beta)dW^2$</p><p><strong>参数更新过程如下：</strong></p><p>$W=W-\alpha \frac{dW}{\sqrt{S_{dW}}}$<br>$b=b-\alpha \frac{db}{\sqrt{S_{db}}}$</p><p><strong>原理如下：</strong></p><p>我们希望学习速度快，并且要减缓摆动。于是有了$S_{dW}$和$S_{db}$，我们希望$S_{dW}$较小，所以要除以一个较小的数，希望$S_{db}$较大，所以要除以一个较大的数，这样就可以减缓b上的摆动。而且这些微分项里面，由于斜率在b的方向上要大于在W的方向，因此db大一些，dW小一些，$S_{dW}$除以一个较小的数也就是dW$S_{db}$除以一个较小的数也就是db，因此有了上面的式子。</p><h1>四、Adam</h1><p>Adam优化算法全称为Adaptive Moment Estimation。是动量梯度下降法Momentum和RMSprop的结合。</p><p>具体步骤如下：</p><p>$V_{dW}=\beta_1 v_{dW}+(1-\beta_1)dW$<br>$V_{db}=\beta_1 v_{db}+(1-\beta_1)db$<br>$S_{dW}=\beta_2 S_{dW}+(1-\beta_2)dW^2$<br>$S_{dW}=\beta_2 S_{dW}+(1-\beta_2)dW^2$</p><p>$W=W-\alpha \frac{V_{dW}}{\sqrt{S_{dW}}+\epsilon}$<br>$b=b-\alpha \frac{V+{db}}{\sqrt{S_{db}}+\epsilon}$</p><p>其中的$\epsilon$常取$10^{-8}$，是为了避免出现除以0的情况，所以附加的微小值。</p><p>该算法结合了Momentum和RMSprop两种方法，被证明有效适用于不同的神经网络。</p><p><strong>本算法涉及了多个超参数</strong></p><ul><li>$\alpha$：学习率</li><li>$\beta_1$：Momentum相关的项，常用的缺省值为0.9</li><li>$\beta_2$：Adam相关的项，常用的缺省值为0.99</li><li>$\epsilon$：常用$10^{-8}$，该参数对算法没什么影响</li></ul><p><strong>编程实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters_with_adam</span>(<span class="params">parameters, grads, v, s, t, learning_rate = <span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                                beta1 = <span class="number">0.9</span>, beta2 = <span class="number">0.999</span>,  epsilon = <span class="number">1e-8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用Adam进行参数更新</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的python字典</span></span><br><span class="line"><span class="string">                    parameters[&#x27;W&#x27; + str(l)] = Wl</span></span><br><span class="line"><span class="string">                    parameters[&#x27;b&#x27; + str(l)] = bl</span></span><br><span class="line"><span class="string">    grads -- 包含所有参数梯度的python字典</span></span><br><span class="line"><span class="string">                    grads[&#x27;dW&#x27; + str(l)] = dWl</span></span><br><span class="line"><span class="string">                    grads[&#x27;db&#x27; + str(l)] = dbl</span></span><br><span class="line"><span class="string">    v -- Adam变量, 梯度一次项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    s -- Adam变量, 梯度平方项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    learning_rate -- 学习率，标量</span></span><br><span class="line"><span class="string">    beta1 -- 第一种动量优化Momentum的指数衰减超参数</span></span><br><span class="line"><span class="string">    beta2 -- 第二种动量优化RMSprop的指数衰减超参数</span></span><br><span class="line"><span class="string">    epsilon -- 放置Adam参数更新过程中可能出现的0除现象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有更新后参数的字典</span></span><br><span class="line"><span class="string">    v -- Adam变量, 梯度一次项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    s -- Adam变量, 梯度平方项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span>                 <span class="comment"># 神经网络的层数</span></span><br><span class="line">    v_corrected = &#123;&#125;                         <span class="comment"># 初始化第一种动量优化，字典</span></span><br><span class="line">    s_corrected = &#123;&#125;                         <span class="comment"># 初始化第二种动量优化，字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用Adam方法更新所有参数</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="comment"># 移动梯度的平均值. 输入: &quot;v, grads, beta1&quot;. 输出: &quot;v&quot;.</span></span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta1 * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta1) * grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta1 * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta1) * grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算第一种动量优化的偏差矫正项. 输入: &quot;v, beta1, t&quot;. 输出: &quot;v_corrected&quot;.</span></span><br><span class="line">        v_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta1 ** t)</span><br><span class="line">        v_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta1 ** t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动平方梯度的平均值. 输入: &quot;s, grads, beta2&quot;. 输出: &quot;s&quot;.</span></span><br><span class="line">        s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta2 * s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta2) * (grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] ** <span class="number">2</span>)</span><br><span class="line">        s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta2 * s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta2) * (grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算第二种动量优化的偏差矫正项. 输入: &quot;s, beta2, t&quot;. 输出: &quot;s_corrected&quot;.</span></span><br><span class="line">        s_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta2 ** t)</span><br><span class="line">        s_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta2 ** t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新参数. 输入: &quot;parameters, learning_rate, v_corrected, s_corrected, epsilon&quot;. 输出: &quot;parameters&quot;.</span></span><br><span class="line">        parameters[<span class="string">&#x27;W&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] -= learning_rate * v_corrected[<span class="string">&#x27;dW&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] / (np.sqrt(s_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]) + epsilon)</span><br><span class="line">        parameters[<span class="string">&#x27;b&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] -= learning_rate * v_corrected[<span class="string">&#x27;db&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] / (np.sqrt(s_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]) + epsilon)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters, v, s</span><br></pre></td></tr></table></figure><h1>五、学习率衰减</h1><p>由于在梯度下降过程中，会围绕最小值往复震荡，但是不会精确的收敛，为了保证算法的效率。可以在初期设置较大的学习率，这样学习相对较快，梯度下降速度较快。接近最小值附近时，减小学习率，也就是减小步伐，逐渐逼近最小值。</p><p>因此可以这样操作，每一次遍历所有数据集，都让学习率减小一些。</p><p><strong>（1）最常用的衰减公式</strong></p><p>$\alpha=\frac{1}{1+decay_rate\times epoch_num}$</p><p>其中decay_rate为衰减率，epoch_num为迭代次数。随着epoch_num的增大，学习率$\alpha$会逐渐减小。</p><p><strong>（2）指数衰减</strong></p><p>$\alpha=0.95^{epoch_num}\cdot\alpha_0$</p><p><strong>（3）反比衰减</strong></p><p>$\alpha=\frac{k}{\sqrt{epoch_num}}\cdot a_0$</p>]]></content>
    
    
    <summary type="html">本文介绍了最常用的几种优化算法，从划分子集mini-batch开始，介绍了动量梯度下降法Momentum，RMSprop，以及两者的结合体Adam，几种方法的实现方法和基本原理。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简单理解时间复杂度</title>
    <link href="https://www.mahaofei.com/post/b260c83a.html"/>
    <id>https://www.mahaofei.com/post/b260c83a.html</id>
    <published>2022-08-02T07:48:43.000Z</published>
    <updated>2022-08-02T07:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1>关于代码执行次数</h1><p>给出一段代码，这段代码的总执行次数可以用T(n)表示，其中n是输入数据的大小或数据量，<strong>T(n)是在输入数量为n时，某段代码的总执行次数</strong>。</p><p>以下面两段代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码的执行次数为T(n)=2<br>（两条语句各执行一次）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码的执行次数为T(n)=3n+3<br>（int i = 0执行1次，i&lt;n执行n+1次，i++执行n次，printf执行n次，return执行1次）</p><p>但实际中一般不会一条一条语句去数，而是采用估算。</p><h1>时间复杂度</h1><p><strong>代码执行次数的简化估算值就是时间复杂度。</strong></p><h2 id="如何通过代码执行次数得到时间复杂度">如何通过代码执行次数得到时间复杂度</h2><p>代码执行次数T和时间复杂度O的简化估算关系如下：</p><table><thead><tr><th>代码执行次数T</th><th>时间复杂度O</th></tr></thead><tbody><tr><td>常数</td><td>O(1)</td></tr><tr><td>常数 × n + 常数</td><td>O(n)</td></tr><tr><td>常数 × n^2 + 常数 × n + 常数</td><td>O(n^2)</td></tr><tr><td>常数 × n^a + 常数 × n^(a-1) …</td><td>O(n^a)</td></tr></tbody></table><p>例如，如果T(n)=常数，那么时间复杂度可以估算为1。</p><p>例如，对于多项式，只选取最高此项并忽略系数，因为低次项的增长远远不及最高次项</p><h2 id="常见代码的时间复杂度">常见代码的时间复杂度</h2><h3 id="常规情况">常规情况</h3><p><strong>（1）没有循环</strong></p><p>时间复杂度：O(1)</p><p><strong>（2）有一重循环</strong></p><p>时间复杂度：O(n)</p><p><strong>（3）有二重循环</strong></p><p>时间复杂度：O(n^2)</p><p><strong>（4）有多重循环</strong></p><p>时间复杂度：O(n^a)<br>其中a为循环层数</p><p><strong>（5）有多个循环</strong></p><p>时间复杂度：O(n^a)<br>其中a为层数最多的循环层数</p><p><strong>（6）if…else…嵌套循环</strong></p><p>以时间复杂度最多的分支计算</p><h3 id="特殊情况">特殊情况</h3><p><strong>（1）i成比例增长</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码总执行次数：T(n)=3log2(n)+2<br>时间复杂度：O(log(n))</p><h2 id="时间复杂度的意义">时间复杂度的意义</h2><p>时间复杂度不同，随着输入数据量的增加，代码运行的时间也会增加。</p><p>例如O(1)无论输入数据如何增多，代码运行时间都不变。而O(n)的运行时间和输入数据量成正比。如果时间复杂度过高，例如O(2^n)，那么在小数据情况下，代码还可以运行，一旦数据量增大，则代码的运行时间将会几何级增加。</p><p><img src="https://img.mahaofei.com/img/20220802162544.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220802162602.png" alt=""></p><p>代码执行时间总结如下：</p><table><thead><tr><th>名称</th><th>时间复杂度</th></tr></thead><tbody><tr><td>常数时间</td><td>O(1)</td></tr><tr><td>对数时间</td><td>O(log n)</td></tr><tr><td>线性时间</td><td>O(n)</td></tr><tr><td>线性对数时间</td><td>O(nlog n)</td></tr><tr><td>二次时间</td><td>O(n^2)</td></tr><tr><td>三次时间</td><td>O(n^3)</td></tr><tr><td>指数时间</td><td>O(2^n)</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">解释时间复杂度如O(n)的概念，以及相关时间复杂度的计算方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法" scheme="https://www.mahaofei.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
