<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马浩飞丨博客</title>
  
  <subtitle>无限进步！！！</subtitle>
  <link href="https://www.mahaofei.com/atom.xml" rel="self"/>
  
  <link href="https://www.mahaofei.com/"/>
  <updated>2023-05-15T09:05:05.000Z</updated>
  <id>https://www.mahaofei.com/</id>
  
  <author>
    <name>马浩飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROS系统Buglist（不定时更新）</title>
    <link href="https://www.mahaofei.com/post/4add66b0.html"/>
    <id>https://www.mahaofei.com/post/4add66b0.html</id>
    <published>2023-05-15T09:05:05.000Z</published>
    <updated>2023-05-15T09:05:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、安装问题</h1><h2 id="ROS安装时rosdep-init与rosdep-update问题解决方法">ROS安装时rosdep_init与rosdep_update问题解决方法</h2><p><strong>解决方法</strong></p><p>使用下面的命令替代上面两行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo pip3 install rosdepc</span><br><span class="line">sudo rosdepc init</span><br><span class="line">rosdepc update</span><br></pre></td></tr></table></figure><h1>二、环境问题</h1><h2 id="Unable-to-find-either-executable-‘empy’-or-Python-module-‘em’…-try-installing-the-package-‘python3-empy’">Unable to find either executable ‘empy’ or Python module ‘em’…  try  installing the package ‘python3-empy’</h2><p><strong>（1）问题原因</strong></p><p>Anaconda使用的是Python3版本，但是ROS使用的Python2</p><p><strong>（2）解决方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h2 id="Could-not-find-a-package-configuration-file-provided-by-“某某包”-with-any-of-the-following-names">Could not find a package configuration file provided by “某某包” with any of  the following names</h2><p><strong>（1）问题原因</strong></p><p>缺少<code>某某包</code></p><p><strong>（2）解决方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-某某包</span><br></pre></td></tr></table></figure><h1>三、配置问题</h1><h2 id="ERROR-cannot-launch-node-of-type-robot-state-publisher-state-publisher-Cannot-locate-node-of-type-state-publisher-in-package-robot-state-publisher-Make-sure-file-exists-in-package-path-and-permission-is-set-to-executable-chmod-x）">ERROR: cannot launch node of type [robot_state_publisher/state_publisher]: Cannot locate node of type [state_publisher] in package [robot_state_publisher]. Make sure file exists in package path and permission is set to executable (chmod +x）</h2><p><strong>（1）问题原因</strong></p><p>使用launch文件启动某个节点时出现这个问题，是因为launch文件中name、pkg、type不统一导致的。</p><p><strong>（2）解决方法</strong></p><p>检查launch文件，确保name、pkg、type一样，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="joint-state-publisher-gui没有显示">joint state publisher gui没有显示</h2><p><strong>（1）问题描述</strong></p><p>使用ROS进行仿真，想用joint state publisher进行机械臂控制，但是启动launch文件后没有报错信息，但也没有joint state publisher gui。</p><p><strong>（2）解决方法</strong></p><p>2020年开始，gui已经移出了 joint state publisher, 并且成为了一个新的package：joint state publisher gui. 之前那种使用gui参数的方式调用joint state publisher 是仍然可行的，但是不会调用gui。</p><p>在launch文件中，将joint state publisher 替换成joint__state__publisher_gui。</p>]]></content>
    
    
    <summary type="html">在使用ROS系统进行机器人实验中，遇到的各种错误信息汇总，不定时更新。</summary>
    
    
    
    <category term="机器人" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
    <category term="ros" scheme="https://www.mahaofei.com/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/ros/"/>
    
    
    <category term="bugs" scheme="https://www.mahaofei.com/tags/bugs/"/>
    
    <category term="ROS" scheme="https://www.mahaofei.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Git管理项目代码</title>
    <link href="https://www.mahaofei.com/post/dd16f220.html"/>
    <id>https://www.mahaofei.com/post/dd16f220.html</id>
    <published>2023-04-17T07:00:50.000Z</published>
    <updated>2023-04-17T07:00:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、注册Github并创建仓库</h1><p>这一步不细说了，需要科学上网，参考<a href="https://www.mahaofei.com/post/96c83ac9.html">这篇文章</a>，[[03_如何访问Google。。学术来查阅文献|Google学术访问方法]]。</p><p>下载安装<a href="https://link.zhihu.com/?target=http%3A//git-scm.com/downloads">Git</a>。</p><h1>二、下载Git并配置</h1><h2 id="2-1-Git安装">2.1 Git安装</h2><p>下载安装<a href="https://link.zhihu.com/?target=http%3A//git-scm.com/downloads">Git</a>。</p><p>在资源管理器内右键，选择<code>Git bash here</code>打开Git界面。</p><h2 id="2-2-Git配置">2.2 Git配置</h2><p>输入下面的代码，按下回车，生成ssh密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>出现要求设置密码，可以不用设置，连续回车两次就可以。</p><p>打开<code>C:\Users\用户名\.ssh</code>，可以看到有一个<code>id_rsa.pub</code>文件，这就是刚才生成的密钥。</p><p>使用记事本打开此文件，复制里面的密钥内容。</p><h2 id="2-3-Github添加ssh-key">2.3 Github添加ssh key</h2><p>进入<a href="https://github.com/">Github官网</a>，点击右上角【setting --&gt; SSH and GPG keys --&gt; New SSH key】，在这里添加密钥，其中</p><ul><li>Title：自己写一个ssh key的名字，用于区分多个ssh key</li><li>Key：刚刚复制的密钥<br>填写完成后点击Add SSH key添加。</li></ul><p>然后在git bash中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果连接成功，会让你输入<code>yes/no</code>，输入yes即可。</p><h2 id="2-4-配置用户名和邮箱">2.4 配置用户名和邮箱</h2><p>输入下面的代码配置自己的用户名和邮箱，两个信息都要和Github账号的信息一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><h1>三、代码管理</h1><h2 id="3-1-代码上传">3.1 代码上传</h2><p><strong>（1）初始化</strong></p><p>创建一个文件夹，在这个文件夹内，右键<code>git bash here</code>，然后输入<code>git init</code>完成初始化。</p><p>可以看到目录中出现了一个<code>.git</code>隐藏文件夹，这说明已经完成了初始化。</p><p><strong>（2）链接远程仓库</strong></p><p>在刚刚的<code>git bash</code>窗口，输入下面的命令同步到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p>如果出现fatal: remote origin already exists.可按以下步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:用户名/仓库名.git</span><br><span class="line">git pull git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p><strong>（3）上传本地文件</strong></p><p>添加本地文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add.</span><br></pre></td></tr></table></figure><p>提交本地文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;说明信息，一般说明本次提交更新了什么&quot;</span><br></pre></td></tr></table></figure><p>推送到远端仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push git@github.com:用户名/仓库名.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="3-2-拉取代码">3.2 拉取代码</h2><p>从项目中拉取代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>如果出现<code>fatal: refusing to merge unrelated histories</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h2 id="3-3-分支管理">3.3 分支管理</h2><p><strong>（1）查看分支</strong></p><p>在命令行窗口的光标处，输入git branch命令，查看 Git 仓库的分支情况。分支前有*表示是当前所在的分支。</p><p><strong>（2）创建分支</strong></p><p>使用下面的命令创建一个名为a的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch a</span><br></pre></td></tr></table></figure><p><strong>（3）分支切换</strong></p><p>在命令行窗口的光标处，输入git checkout a命令，切换到a分支。</p><p><strong>（4）合并分支</strong></p><p>切换到master分支，然后输入git merge a命令，将a分支合并到master分支。</p><p><strong>（5）删除分支</strong></p><p>在命令行窗口的光标处，输入git branch -d a命令，删除a分支。</p><p><strong>（6）为分支添加标签</strong></p><p>在命令行窗口的光标处，输入git tag test_tag命令，为当前分支添加标签test_tag</p><h2 id="3-4-修改分支名称">3.4 修改分支名称</h2><p>假设分支名称为oldName，想要修改为 newName</p><ol><li>本地分支重命名(还没有推送到远程)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><ol start="2"><li>远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</li></ol><p>重命名远程分支对应的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p>到github修改默认分支的分支名。</p><p>上传新命名的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure><p>把修改后的本地分支与远程分支关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><p>注意：如果本地分支已经关联了远程分支，需要先解除原先的关联关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --unset-upstream </span><br></pre></td></tr></table></figure><h2 id="3-5-报错信息">3.5 报错信息</h2><p><strong>（1）error: src refspec master does not match any. error: failed to push some refs to</strong></p><p>仔细检查push的是<code>master</code>分支还是<code>main</code>分支。</p>]]></content>
    
    
    <summary type="html">当有多台设备，或者同一个项目有多个版本的代码时，利用git管理项目代码就十分必要了。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="科研利器" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E7%A7%91%E7%A0%94%E5%88%A9%E5%99%A8/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="科研利器" scheme="https://www.mahaofei.com/tags/%E7%A7%91%E7%A0%94%E5%88%A9%E5%99%A8/"/>
    
    <category term="Git" scheme="https://www.mahaofei.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用内网穿透SakuraFrp远程连接服务器</title>
    <link href="https://www.mahaofei.com/post/9ed2c32f.html"/>
    <id>https://www.mahaofei.com/post/9ed2c32f.html</id>
    <published>2023-04-05T05:59:35.000Z</published>
    <updated>2023-04-05T05:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux端配置</h1><p><strong>（1）ssh配置</strong></p><p>安装ssh服务器与客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install openssh-server</span><br><span class="line">sudo apt -y install openssh-client</span><br></pre></td></tr></table></figure><p>配置ssh客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>​将<code>PermitRootLogin prohibt-password</code> 修改为 <code>PermitRootLogin yes</code></li><li>将<code>PasswordAuthentication yes</code> 前的#删除，取消注释</li></ul><p>重启ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>查看ssh服务运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh status</span><br></pre></td></tr></table></figure><p><strong>（2）Sakura配置</strong></p><p><a href="https://www.natfrp.com/user/">SakuraFrp</a></p><p>进入隧道列表新建隧道</p><ul><li>尽量选择国内节点</li><li>隧道类型为TCP隧道</li><li>本机端口为SSH</li><li>主机ip默认127.0.0.1即可(代指内网穿透本机)</li></ul><p><img src="https://img.mahaofei.com/img/20230405140317.png" alt=""></p><p>在官网下载对应版本的frpc，复制下载链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O frpc &lt;下载地址&gt;</span><br><span class="line">chmod 755 frpc</span><br><span class="line">ls -ls frpc</span><br><span class="line">md5sum frpc</span><br><span class="line">frpc -v</span><br></pre></td></tr></table></figure><p>隧道配置文件中复制隧道密钥</p><p>Ubuntu中使用下面的命令开启隧道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc -f &lt;复制的密钥&gt;</span><br></pre></td></tr></table></figure><h1>Windows端配置</h1><p>打开【设置-应用-添加功能】，添加OpenSSH 服务器和OpenSSH 客户端。</p><p>打开服务，找到 OpenSSH SSH Server 和 OpenSSH Authentication Agent -&gt; 启动服务并设为自动。</p><p>打开 power shell，使用以下命令检查安装和运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Service sshd</span><br></pre></td></tr></table></figure><p>打开Sakura官网，打开隧道列表，点击要连接的隧道，点击一键认证，下载exe认证程序并运行。</p><p>然后使用<code>ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;地址&gt;</code>进行远程连接</p><h1>VSCode远程ssh开发环境</h1><p>安装插件 <code>Remote - SSH</code></p>]]></content>
    
    
    <summary type="html">不想使用向日葵和todesk等工具远程连接桌面，而且个人电脑和服务器也不在一个局域网下，想要远程连接服务器，因此考虑使用内网穿透。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>TensorBoard的使用丨深度学习曲线生成</title>
    <link href="https://www.mahaofei.com/post/6db9da8f.html"/>
    <id>https://www.mahaofei.com/post/6db9da8f.html</id>
    <published>2023-03-23T14:14:20.000Z</published>
    <updated>2023-03-23T14:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1>TensorBoard的安装</h1><p>要求Pytorch版本必须在1.2.0以上。</p><p>使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from torch.utils.tensorboard import SummaryWriter</span><br></pre></td></tr></table></figure><h1>TensorBoard的代码调用</h1><p><strong>（1）导入包，并创建TensorBoard回调对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> TensorBoard</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs/learning_rate_scheduler&quot;</span>) <span class="comment">#指定TensorBoard日志目录</span></span><br></pre></td></tr></table></figure><p><strong>（2）在模型的训练过程中导入回调</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global_step = <span class="number">0</span> <span class="comment"># 初始化 global_step 为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 训练过程</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将学习率和训练损失添加到 TensorBoard</span></span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Train/Loss&#x27;</span>, loss, global_step=global_step)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Train/Learning_Rate&#x27;</span>, lr, global_step=global_step)</span><br><span class="line">global_step += <span class="number">1</span>  <span class="comment"># 为每个batch更新 global_step 计数器</span></span><br></pre></td></tr></table></figure><h1>查看曲线</h1><p>训练开始后，打开一个终端，输入下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir logs/learning_rate_scheduler</span><br></pre></td></tr></table></figure><p>然后打开浏览器的<a href="http://localhost:6006/">http://localhost:6006/</a>页面，就可以看到曲线。</p><p><img src="https://img.mahaofei.com/img/20230323221410.png" alt=""></p>]]></content>
    
    
    <summary type="html">在深度学习训练过程中，我们必定会需要观察系统的Loss、Learning_rate等参数的变化，因此实时绘制曲线图是十分有必要的。本文就介绍了如何利用Pytorch的TensorBoard绘制曲线图。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="基础知识" scheme="https://www.mahaofei.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Windows设置共享文件夹给Ubuntu或其它设备</title>
    <link href="https://www.mahaofei.com/post/76e8a448.html"/>
    <id>https://www.mahaofei.com/post/76e8a448.html</id>
    <published>2023-03-11T04:11:46.000Z</published>
    <updated>2023-03-11T04:11:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Windows系统设置</h1><p>在需要的位置新建一个文件夹，然后【右键-共享】，将其设置为共享文件夹。</p><p><img src="https://img.mahaofei.com/img/202303111048877.png" alt=""></p><p>然后打开【设置-网络和Internet-高级网络设置-高级共享设置】，设置为如下的形式。<strong>主要是公用网络的两个都要打开，所有网络的共享打开，密码保护关闭</strong></p><p><img src="https://img.mahaofei.com/img/202303111048312.png" alt=""></p><h1>二、Ubuntu系统设置</h1><h2 id="2-1-临时挂载">2.1 临时挂载</h2><p>挂载方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.3.67/home/Share ~/Share -o username=&#x27;admin&#x27;,password=&#x27;123456&#x27;,dir_mode=0777,file_mode=0777,vers=2.0</span><br></pre></td></tr></table></figure><h2 id="2-2-自动挂载">2.2 自动挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/fstab</span><br></pre></td></tr></table></figure><p>在最后面按照下面的格式添加</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//192.168.1.143/home/Share ~/share cifs defaults,username=admin,password=123456,dir_mode=0777,file_mode=0777,vers=2.0 0 2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">局域网内，共享win电脑上的某个文件夹，使局域网内其它系统可以直接访问</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Windows工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Windows%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu使用OneDrive</title>
    <link href="https://www.mahaofei.com/post/ba007624.html"/>
    <id>https://www.mahaofei.com/post/ba007624.html</id>
    <published>2023-03-10T07:31:33.000Z</published>
    <updated>2023-03-10T07:31:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1>安装</h1><p><strong>（1）安装依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install build-essential </span><br><span class="line">apt install libcurl4-openssl-dev -y</span><br><span class="line">apt install libsqlite3-dev -y</span><br><span class="line">apt install pkg-config -y</span><br><span class="line">apt install libnotify-dev -y</span><br><span class="line">curl -fsS https://dlang.org/install.sh | bash -s dmd</span><br></pre></td></tr></table></figure><p>激活DMD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/dlang/dmd-2.082.0/activate</span><br></pre></td></tr></table></figure><p><strong>（2）安装onedrive客户端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/abraunegg/onedrive.git</span><br><span class="line">cd onedrive</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1>使用</h1><p>输入以下命令登录onedrive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive</span><br></pre></td></tr></table></figure><p>下载config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/onedrive</span><br><span class="line">wget https://raw.githubusercontent.com/abraunegg/onedrive/master/config -O ~/.config/onedrive/config</span><br><span class="line">nano ~/.config/onedrive/config</span><br></pre></td></tr></table></figure><p>打开config文件中的下面几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sync_dir = &quot;~/disk/ubuntu/onedrive&quot;</span><br><span class="line">monitor_interval = &quot;60&quot;</span><br></pre></td></tr></table></figure><h1>同步</h1><p>第一次同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --synchronize</span><br></pre></td></tr></table></figure><p>实时同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --monitor</span><br></pre></td></tr></table></figure><blockquote><p>参考链接</p><ol><li><a href="https://github.com/abraunegg/onedrive">abraunegg/onedrive</a></li><li><a href="https://www.moerats.com/archives/740/">Rat’s. 适用于Linux的OneDrive客户端，支持VPS和OneDrive之间实时同步/备份</a></li></ol></blockquote><h1>替代方法</h1><p>此方法不太推荐，同步速度较慢，而且一旦取消同步本地文件都会清空。</p><h2 id="1-安装OneDriver">1. 安装OneDriver</h2><p>参考项目：<a href="https://github.com/jstaf/onedriver">https://github.com/jstaf/onedriver</a></p><p>根据作者的说明，对于Ubuntu系统，可以直接下载deb文件安装，下载链接为：<a href="https://software.opensuse.org/download.html?project=home%3Ajstaf&amp;package=onedriver">https://software.opensuse.org/download.html?project=home%3Ajstaf&amp;package=onedriver</a></p><p>选择Ubuntu，找到自己的Ubuntu版本，以及amd64/arm64，下载deb安装包并安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i onedriver_0.13.0-1_amd64.deb</span><br></pre></td></tr></table></figure><h1>2. OneDriver使用</h1><p>点击左上角<code>+</code>，选择本地同步文件夹。</p><p>然后输入用户名密码登录自己的OneDrive网盘。</p><p>点击右面的√，勾选系统登录时启动OneDriver。</p>]]></content>
    
    
    <summary type="html">之前一直使用坚果云做多设备同步，但是坚果云每个月只有1G流量，不够用。因此改到OneDrive，本文记录在Ubuntu上进行OneDrive的配置过程。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【浏览器插件】iTab新建标签页</title>
    <link href="https://www.mahaofei.com/post/999804d5.html"/>
    <id>https://www.mahaofei.com/post/999804d5.html</id>
    <published>2023-03-10T00:28:23.000Z</published>
    <updated>2023-03-10T00:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1>介绍</h1><p>本人之前很长一段时间都是实用的默认主页，并且只保留一个搜索框使主页尽可能简洁。</p><p>但是后来随着要用的网页越来越多，很多网站记不住经常需要搜索才能找到。</p><p>收藏夹又因为网站太多，我的收藏夹都是文件夹套文件夹套网址。</p><p>正巧看到了这个新建标签页，感觉还不错，有兴趣的可以体验一下，有点像之前用的infinite和青柠，但个人觉得这个更好一些。</p><h1>主页</h1><p>主页侧面是不同的分区，每个分区内可以添加很多不同的图标。</p><p><img src="https://img.mahaofei.com/img/20230310082742.png" alt=""></p><p>有官方给的图标，也可以自定义添加。</p><p><img src="https://img.mahaofei.com/img/20230310082814.png" alt=""></p><h1>其它</h1><p>而且itab支持网页版主页，也就是说，手机edge等无法安装浏览器扩展的应用，可以在设置里将主页改成<a href="https://go.itab.link/">https://go.itab.link/</a>就可以实现手机电脑使用同样的主页了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;本人之前很长一段时间都是实用的默认主页，并且只保留一个搜索框使主页尽可能简洁。&lt;/p&gt;
&lt;p&gt;但是后来随着要用的网页越来越多，很多网站记不住经常需要搜索才能找到。&lt;/p&gt;
&lt;p&gt;收藏夹又因为网站太多，我的收藏夹都是文件夹套文件夹套网址。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="浏览器插件" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记04】朴素贝叶斯法</title>
    <link href="https://www.mahaofei.com/post/7bc6ebb.html"/>
    <id>https://www.mahaofei.com/post/7bc6ebb.html</id>
    <published>2023-03-04T11:14:19.000Z</published>
    <updated>2023-03-04T11:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、贝叶斯定理</h1><h2 id="1-1-条件概率">1.1 条件概率</h2><p>条件概率属于概率论的内容，指的是已知在情况A的条件下，求发生事件B的概率，即P(B|A)，计算方法如下。</p><p>$$P(B|A)=\frac{P(AB)}{P(A)}$$</p><h2 id="1-2-贝叶斯定理">1.2 贝叶斯定理</h2><p>相对于条件概率，贝叶斯定理是其逆过程。已知发生事件B，求事件发生的情况A的概率，即P(A|B)，计算方法如下，其中分母是全概率公式。</p><p>$$P(A|B)=\frac{P(AB)}{P(B)}=\frac{P(A|B)\cdot P(B)}{P(B|A)\cdot P(A)+P(B|\hat A)\cdot P(\hat A)}$$</p><p>同理推广到分类问题，已知存在K类$c_1,c_2\dots c_k$，给定一个新的实例$x=(x^{(1)},x^{(2)}\dots x^{(n)})$，求该实例点归属于$c_i$类的可能。</p><p>$$P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{P(X=x)}=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{\sum^K_{i=1}P(X=x|Y=c_i)\cdot P(Y=c_i)}$$</p><h2 id="1-3-朴素贝叶斯">1.3 朴素贝叶斯</h2><p>朴素贝叶斯相较于贝叶斯，多了<strong>实例特征之间相互独立</strong>这个条件，这样更便于计算</p><p>即$P(X=x|Y=c_i)=\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)$</p><p>因此</p><p>$$P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{\sum^K_{c_i}P(Y=c_i)\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}$$</p><p>$$P(Y=c_i|X=x)=\frac{P(Y=c_i)\cdot \prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}{\sum^K_{c_i}P(Y=c_i)\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}$$</p><p>可以看出$x$属于任何分类$c_i$的概率，其分母都是一样的，因此实际计算时只需要比较分子即可，即</p><p>$$argmax P(Y=c_i)\cdot \prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)$$</p><p>通过训练数据集，我们可以得到联合概率分布。</p><h1>二、后验概率最大化准则</h1><h1>三、极大似然估计</h1>]]></content>
    
    
    <summary type="html">统计学习方法的学习笔记</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Terminator终端终结者常用快捷键</title>
    <link href="https://www.mahaofei.com/post/79fdfcf6.html"/>
    <id>https://www.mahaofei.com/post/79fdfcf6.html</id>
    <published>2023-03-04T00:52:28.000Z</published>
    <updated>2023-03-04T00:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20230304085853.png" alt=""></p><h1>快捷键</h1><p><strong>常用快捷键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端（有按键冲突）</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+Shift+W                    //关闭当前标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="（1）同一个窗口">（1）同一个窗口</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //★移动到上面的终端</span><br><span class="line">Alt+Down                        //★移动到下面的终端</span><br><span class="line">Alt+Left                        //★移动到左边的终端</span><br><span class="line">Alt+Right                       //★移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //★水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端（有按键冲突）</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //★复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //★粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //★关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //★最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br></pre></td></tr></table></figure><h2 id="（2）不同窗口之间">（2）不同窗口之间</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一个比较好用的终端工具。</summary>
    
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux工具" scheme="https://www.mahaofei.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/Linux%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="实用工具" scheme="https://www.mahaofei.com/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>多版本OpenCV共存安装</title>
    <link href="https://www.mahaofei.com/post/96a605ae.html"/>
    <id>https://www.mahaofei.com/post/96a605ae.html</id>
    <published>2023-03-03T13:28:49.000Z</published>
    <updated>2023-03-03T13:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>假设此电脑已经安装了opencv4.0，现在需要安装opencv3，（其它版本同理）</p><h1>下载OpenCV并构建库</h1><p>为了避免冲突，在<code>/usr/local/</code>目录中新建<code>opencv3</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/opencv3</span><br></pre></td></tr></table></figure><p>照常从<a href="https://opencv.org/releases/">opencv官网</a>中下载另一版本的opencv，使用以下命令build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=RELEASE -DWITH_TBB=ON  -DWITH_V4L=ON -DCMAKE_INSTALL_PREFIX=/usr/local/opencv3 ..  </span><br></pre></td></tr></table></figure><p>进入<code>build</code>文件夹后，你需要输入下面这种格式的cmake指令，<strong>需要根据你的实际情况，对下面的指令参数进行修改，不要复制过去就直接运行。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/opencv3 -D OPENCV_EXTRA_MODULES_PATH=~/ros/sitepackages/opencv-3.4.2/opencv_contrib/modules/ -DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython2.7 ..</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1>切换opencv版本</h1><p>打开~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾增加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Change OpenCV3</span></span><br><span class="line">export PKG_CONFIG_PATH=/usr/local/opencv3/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/opencv3/lib</span><br></pre></td></tr></table></figure><p>更新~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc </span><br></pre></td></tr></table></figure><p>查询OpenCV版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure><p>如果输出3.4.2，就表明配置成功。</p><p><strong>如果想使用之前的版本，在~/.bashrc中注释掉增加的内容，然后source ~/.bashrc即可。</strong></p><p>如果只有一个版本的OpenCV，在CMakeList.txt中使用以下语句即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_PACKAGE</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure><p>在OpenCV编译好后，所在目录中会生成OpenCVConfig.cmake文件，这个文件中指定了CMake要去哪里找OpenCV，其.h文件在哪里等。</p><p>存在多版本OpenCV时，需要找到所需版本对应的OpenCVConfig.cmake文件，并将其路径添加到工程的CMakeLists.txt中。<br>示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(OpenCV_INCLUDE_DIRS <span class="string">&quot;/usr/local/opencv3/include&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(OpenCV_LIB_DIR <span class="string">&quot;/usr/local/opencv3/lib&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(OpenCV_LIBS opencv_core opencv_highgui opencv_imgproc)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;OpenCV_LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target_name <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p><ol><li><a href="https://immortalqx.github.io/2021/07/06/opencv-notes-0/">刘权祥. Ubuntu配置OpenCV及多版本OpenCV共存</a></li><li><a href="https://blog.csdn.net/learning_tortosie/article/details/80594399">W_Tortoise. Ubuntu下多版本OpenCV共存和切换</a></li></ol></blockquote>]]></content>
    
    
    <summary type="html">由于跑一些项目的时候，由于时代问题，有些程序是使用opencv2写的，现在大家普遍都安装的opencv4，由于项目代码繁多，修改源码过于麻烦，因此考虑多版本opencv共存安装。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="视觉" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/"/>
    
    <category term="OpenCV" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E8%A7%86%E8%A7%89/OpenCV/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="OpenCV" scheme="https://www.mahaofei.com/tags/OpenCV/"/>
    
    <category term="C++" scheme="https://www.mahaofei.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Docker的安装与常用命令</title>
    <link href="https://www.mahaofei.com/post/aa6eef91.html"/>
    <id>https://www.mahaofei.com/post/aa6eef91.html</id>
    <published>2023-03-03T12:31:52.000Z</published>
    <updated>2023-03-03T12:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Docker安装</h1><p>如果已经安装使用过Docker，可以跳过。</p><p>先删除旧版的docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>出现这样的信息就是ok的</p><p><img src="https://img.mahaofei.com/img/20230226193326.png" alt=""></p><p>安装一些docker的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><p>设置秘钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置软件源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>可以安装docker了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h1>二、Docker镜像拉取</h1><p>以Autoware为例，拉取了Autoware的官方docker。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/autowarefoundation/autoware.ai/docker.git</span><br><span class="line"><span class="built_in">cd</span> docker/generic/</span><br></pre></td></tr></table></figure><p>如果显卡显存大于4G，且装了CUDA，使用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./run.sh</span><br></pre></td></tr></table></figure><p>如果没有装cuda，或者显存容量小于4G，或者用上面命令安装出现报错，就不要安装带有CUDA的版本了，使用下面的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./run.sh -c off</span><br></pre></td></tr></table></figure><h1>三、Docker常用命令</h1><p><strong>（1）镜像列表 image</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p><strong>（2）容器列表 container</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>（3）进入特定镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 90e973a21691</span><br></pre></td></tr></table></figure><p><strong>（4）多个终端进入同一个docker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it containerID bash</span><br></pre></td></tr></table></figure><p>这种情况下进入系统后，想要使用ros需要先<code>source /opt/ros/melodic/setup.bash</code></p><p><strong>（5）docker停止</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop containerID</span><br></pre></td></tr></table></figure><p><strong>（6）docker传输文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 本地文件的路径 container_id:&lt;docker容器内的路径&gt;</span><br><span class="line">docker cp container_id:&lt;docker容器内的路径&gt; &lt;本地保存文件的路径&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">环境配置有时非常麻烦，而且有很多程序的依赖环境会和本地环境冲突，为了避免这些情况，docker就是一个比较好的解决方案。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Linux" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Linux/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Ubuntu" scheme="https://www.mahaofei.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记03】k近邻法</title>
    <link href="https://www.mahaofei.com/post/72393bb6.html"/>
    <id>https://www.mahaofei.com/post/72393bb6.html</id>
    <published>2023-02-14T02:56:06.000Z</published>
    <updated>2023-02-14T02:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、k近邻算法</h1><h2 id="1-1-算法">1.1 算法</h2><p>k近邻算法，假设给定了一个训练数据集，其中实例类别已定。</p><p>分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。 因此，k近邻法不具有显式的学习过程。</p><h2 id="1-2-模型">1.2 模型</h2><p>三个基本要素：距离度量、k值、分类决策规则</p><p>一般将特征空间，按照每个训练实例点xi，距离该点比其它点更近的所有点组合成一个单元。每个训练实例点拥有一个单元，单元内所有点都标记上类yi。</p><p>这样特征空间中每个点的类别都是确定的。</p><p><strong>（1）距离</strong></p><p>特征空间中两个实例点的距离一般使用欧式距离，或者更一般的$L_p$距离</p><p>$$L_p(x_i,x_j)=(\sum^n_{l=1}|x^{(l)}_i-x^{(l)}_j|)^{\frac{1}{p}}$$</p><p>其中l=2时为欧式距离，l=1时为曼哈顿距离，l=∞时为各个坐标距离的最大值。</p><p><strong>（2）k值</strong></p><p>如果k值过小，虽然可能会预测的比较准，但预测结果受邻近点影响过大，如果邻近点恰好为噪声，则会预测错误。</p><p>如果k值过大，与输入距离较远的示例也会起到预测作用。</p><p>如果k=N，那么总是输出实例中最多的类。</p><p><strong>（3）分类决策规则</strong></p><p>通常为k个近邻的实例中的最多数类。</p><h1>二、kd-tree</h1><p>在进行预测时，需要在训练数据中进行k近邻搜索，如果使用线性扫描，则需要计算输入点与所有训练实例的距离，速度过慢。</p><h2 id="2-1-构造kd-tree">2.1 构造kd-tree</h2><p>kd-tree的构造相当于不断用垂直于坐标轴的超平面将k维空间切分，每个节点对应一个k维超矩形区域。</p><p>构造过程：</p><ul><li>构造根结点：根结点对应的k维空间包含所有实例点的超矩形区域</li><li>递归切分：在超矩形区域中选择一个坐标轴和此坐标轴上的切分点，确定一个超平面，用此超平面将当前超矩形区域切分为左右两个子区域（子结点）</li><li>重复此过程，直到子区域内没有实例时终止（叶结点）</li></ul><h2 id="2-2-搜索kd-tree">2.2 搜索kd-tree</h2><p>输入：己构造的kd-tree， 目标点x<br>输出：x的最近邻</p><ul><li>在kd树中找出包含目标点x的叶结点：从根结点出发，递归地向下访问kd-tree。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。 直到子结点为叶结点为止。（有点类似二分法）</li><li>以此叶结点为“当前最近点”</li><li>递归地向上回退，在每个结点进行以下操作：<ul><li>如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。</li><li>当前最近点一定存在于该结点一个子结点对应的区域。 检査该子结点的父结点的另一子结点对应的区域是否有更近的点。即检査另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点” 间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点， 移动到另一个子结点。接着，递归地进行最近邻搜索；如果不相交， 向上回退。</li></ul></li><li>当回退到根结点时，搜索结束。最后的“当前最近点” 即为x的最近邻点。</li></ul>]]></content>
    
    
    <summary type="html">近邻算法，假设给定了一个训练数据集，其中实例类别已定。分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。因此，k近邻法不具有显式的学习过程。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记02】感知机</title>
    <link href="https://www.mahaofei.com/post/6d27098f.html"/>
    <id>https://www.mahaofei.com/post/6d27098f.html</id>
    <published>2022-12-07T06:35:06.000Z</published>
    <updated>2022-12-07T06:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、感知机模型</h1><p>感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</p><p>假设输入空间$X\subseteq R^n$，输出空间$Y={+1,-1}$。输入$x\in X$表示实例的特征向量，对应于输入空间的点。输出$y\in Y$表示实例的类别，则输入空间到输出空间的函数：</p><p>$$f(x)=sign(w\cdot x+b)$$</p><p>称为感知机。其中$w$称为权值向量，$b$称为偏置，sign时符号函数sign(x)= {+1(if x&gt;=0), -1(if x&lt;0)}。</p><h1>二、感知机学习策略</h1><h2 id="2-1-数据集的线性可分性">2.1 数据集的线性可分性</h2><p>给定一个数据集，如果存在某个超平面能够将数据集的正实例点和负实例点完全正确的划分到超平面的两侧，则数据集称为线性可分数据集，否则称线性不可分。</p><h2 id="2-2-学习策略">2.2 学习策略</h2><p>输入空间中任意一点$x_0$到超平面S的距离为：$\frac{1}{||w||}|w\cdot x_0+b|$</p><p>因此误分类点到超平面S的距离为：$-\frac{1}{||w||}y_i(w\cdot x_0+b)$</p><p>所有误分类点的总距离，即损失函数为：$L(w,b)=-\sum_{i=0}^M y_i(w\cdot x_0+b)$</p><p>显然损失函数是非负的，感知机的学习策略就是在假设空间中找到使损失函数最小的模型参数$w,b$</p><h2 id="2-3-学习算法">2.3 学习算法</h2><p>感知机的学习算法采用随机梯度下降法。每次随机选取一个误分类点使其梯度下降。</p><p>输入：线性可分数据集T，学习率$\eta$</p><p>输出：感知机模型$w,b$</p><p>（1）选取初值$w_0,b_0$<br>（2）在训练集中选取数据$(x_i,y_i)$<br>（3）如果$y_i(w\cdot x_i+b)\le0$，更新参数$w=w+\eta y_i x_i$，$b=b+\eta y_i$，其中$\eta$为学习率，后项为两个参数的梯度<br>（4）重复上述过程，直到训练集中没有误分类点</p><p>当训练数据集线性可分时，感知机学习算法是收敛的，即经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。</p><h1>三、习题</h1><h2 id="3-1-为什么感知机不能表示异或">3.1 为什么感知机不能表示异或</h2><p>画出训练集的分布情况，易知无法使用一个线性平面将±区域分开。</p><p><img src="https://img.mahaofei.com/img/20221208104808.png" alt=""></p>]]></content>
    
    
    <summary type="html">感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【统计学习方法笔记01】统计学习概论</title>
    <link href="https://www.mahaofei.com/post/fba31b0c.html"/>
    <id>https://www.mahaofei.com/post/fba31b0c.html</id>
    <published>2022-12-03T03:21:21.000Z</published>
    <updated>2022-12-03T03:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、统计学习</h1><h2 id="1-1-统计学习的概念">1.1 统计学习的概念</h2><p><strong>（1）概念</strong></p><p>统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。</p><p>统计学习是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><p><strong>（2）对象</strong></p><p>数据，如数字、文字、图像、视频、音频等。</p><p><strong>（3）目的</strong></p><p>从数据出发，提取数据的特征，抽象数据的模型，发现数据的知识，最后回到数据的分析与预测中。</p><h2 id="1-2-统计学习的分类">1.2 统计学习的分类</h2><h3 id="1-2-1-基本分类">1.2.1 基本分类</h3><p><strong>（1）监督学习</strong></p><p>从标注数据中学习预测模型的机器学习问题。即学习从输入到输出的映射的统计规律。</p><ul><li>输入空间与输出空间：输入与输出的所有可能取值。<ul><li>输入变量与输出变量均为连续变量，回归问题</li><li>输出变量为离散变量，分类问题</li><li>输入变量与输出变量均为变量序列，标注问题</li></ul></li><li>特征空间：输入可以用特征向量表示，所有特征向量存在的空间。</li><li>联合概率分布：假设训练数据与测试数据是一句联合概率分布P(X,Y)独立同分布产生的。</li><li>假设空间：由输入到输出的映射的集合。</li></ul><p><strong>（2）无监督学习</strong></p><p>从无标注数据中学习预测模型的机器学习问题。即学习数据的统计规律或潜在结构。</p><ul><li>输入空间与输出空间：模型的输入与输出的所有可能取值的集合。<ul><li>输入是实例，由特征向量表示。</li><li>输出是对输入的分析结果，由输入的类别、转换或概率表示。</li></ul></li><li>假设空间：所有模型z=g(x)的集合，其中X是输入空间，Z是隐式结构空间。</li></ul><p><strong>（3）强化学习</strong></p><p>智能系统在于环境的连续互动中学习最优行为策略的机器学习问题。智能系统观测到与环境互动得到的数据序列，本质是学习最优的序贯决策。</p><p>智能系统与环境的互动过程：每一步$t$，智能系统从环境观测到一个状态$s_t$和奖励$r_t$，采取一个动作$a_t$。环境根据智能系统的动作，确定下一步$t+1$的状态$s_{t+1}$和$r_{t+1}$。使系统实现长期累计奖励的最大化。</p><p>强化学习的马尔可夫决策过程由五元组&lt;S, A, P, r, $\gamma$&gt;组成：</p><ul><li>S：有限状态的集合</li><li>A：有限动作的集合</li><li>P：状态转移概率函数</li><li>r：奖励函数</li><li>$\gamma$：衰减系数</li></ul><p>策略：给定状态下的动作的函数<br>价值函数：策略从某一个状态开始的长期累积奖励的数学期望<br>动作价值函数：策略从某一个状态和动作开始的长期累计奖励的数学期望</p><p><strong>（4）半监督学习与主动学习</strong></p><p>半监督学习：利用标注数据和未标注数据学习预测模型的机器学习问题。</p><p>主动学习：机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。</p><h3 id="1-2-2-按模型分类">1.2.2 按模型分类</h3><p><strong>（1）概率模型与非概率模型</strong></p><ul><li>概率模型：取条件分布形式P(y|x)</li><li>非概率模型：函数形式y=f(x)</li></ul><p><strong>（2）线性模型与非线性模型</strong></p><ul><li>线性模型：感知机、线性支持向量机、k近邻、潜在语义分析</li><li>非线性模型：支持向量机、神经网络</li></ul><p><strong>（3）参数化模型与非参数化模型</strong></p><ul><li>参数化模型：假设模型参数的维度固定，模型可以由有限维参数完全刻画</li><li>非参数化模型：假设模型参数的维度不固定或者无穷大，随着训练数据量的增加而不断增大</li></ul><h3 id="1-2-2-按算法分类">1.2.2 按算法分类</h3><p><strong>（1）在线学习</strong></p><p>每次接受一个样本，进行预测，之后学习模型，并不断重复。</p><p><strong>（2）批量学习</strong></p><p>一次接受所有数据，学习模型，之后进行预测。</p><h3 id="1-2-3-按技巧分类">1.2.3 按技巧分类</h3><p><strong>（1）按贝叶斯学习</strong></p><p>在概率模型的学习和推理中，利用贝叶斯定理，计算在给定数据条件下模型的条件概率，并应用这个原理进行模型的估计。</p><p><strong>（2）核方法</strong></p><p>使用核函数表示和学习非线性模型的一种机器学习方法。</p><h1>二、统计学习的三要素</h1><h2 id="2-1-模型">2.1 模型</h2><ul><li>概率模型：假设空间为条件概率的集合。{f|Y=f(X)}</li><li>非概率模型：假设空间为决策函数的集合。{P|P(Y|X)}</li></ul><h2 id="2-2-策略">2.2 策略</h2><p><strong>（1）损失函数</strong></p><ul><li>0-1损失函数：$L(Y,f(x))=0,1$</li><li>平方损失函数：$L(Y,f(x))=(Y-f(X))^2$</li><li>绝对损失函数：$L(Y,f(x))=|Y-f(X)|$</li><li>对数损失函数：$L(Y,f(x))=-logP(Y|X)$</li></ul><p><strong>（2）风险函数</strong></p><p>损失函数的平均值，或称为期望损失。</p><p>当样本容量足够大时，经验风险最小化有利于保证很好的学习效果。当样本容量较小时，学习效果未必好，可能会产生过拟合。</p><p><strong>（3）结构风险</strong></p><p>结构风险在经验风险上加上表示模型复杂度的正则化项。</p><p>$R(f)=\frac{1}{N}\sum^N_{i=1}L(y_i,f(x_i))+\lambda J(f)$</p><p>其中$J(f)$为模型复杂度，模型越复杂其值越大。常取L1范数$||\omega||_1$或L2范数$\frac{||\omega||^2}{2}$<br>$\lambda$为系数，用于权衡风险函数与模型复杂度。</p><p>结构风险的思想其实就是奥卡姆剃刀原理，即在所有可能的模型函数中，选择能够很好的解释已知数据，并且最简单的模型。</p><h2 id="2-3-算法">2.3 算法</h2><h1>三、泛化能力</h1><p>泛化能力是学习到的模型对未知数据的预测能力。</p><h1>五、生成模型与判别模型</h1><p>极大似然估计：已知一组数据输出，定义该组数据的概率函数，通过求概率函数的极大值点，确定数据输入。</p>]]></content>
    
    
    <summary type="html">统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。本文是对李航老师的《统计学习方法》一书学习笔记。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="统计学习方法" scheme="https://www.mahaofei.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记05】Qt中调用ROS库</title>
    <link href="https://www.mahaofei.com/post/eb9b1ae6.html"/>
    <id>https://www.mahaofei.com/post/eb9b1ae6.html</id>
    <published>2022-09-03T01:45:22.000Z</published>
    <updated>2022-09-03T01:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>前提</h1><ol><li>安装配置好QT</li><li>安装配置好ROS</li></ol><h1>方法</h1><p><strong>（1）在QT配置文件中添加ros库</strong></p><p>在写的QT工程中加入:即在.pro文件中添加ros头文件路径和动态链接库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /opt/ros/noetic/include</span><br><span class="line">DEPENDPATH += /opt/ros/noetic/include</span><br><span class="line">LIBS += -L/opt/ros/noetic/lib -lroscpp -lroslib -lrosconsole -lroscpp_serialization -lrostime</span><br></pre></td></tr></table></figure><p><strong>（2）修改QT执行程序</strong></p><p>修改执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.local/share/applications/DigiaQt-qtcreator-community.desktop</span><br></pre></td></tr></table></figure><p>修改<code>Exec</code>行为下面的格式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -i -c /home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p><strong>但是这样修改之后，每次开机只能启动一次QT，第二次点击QT快捷方式就启动不起来了。</strong></p><p>可以修改<code>~/.bashrc</code>，在最后一行添加下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias qt=/home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p>然后每次启动都在终端使用<code>qt</code>命令启动QT，这样就ok了。</p>]]></content>
    
    
    <summary type="html">对机器人的软件开发的离不开ROS，可操作界面离不开Qt，本文介绍在Qt中调用ROS库的方法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记04】对话框</title>
    <link href="https://www.mahaofei.com/post/e0de5819.html"/>
    <id>https://www.mahaofei.com/post/e0de5819.html</id>
    <published>2022-09-02T11:45:22.000Z</published>
    <updated>2022-09-02T11:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、模态和非模态对话框</h1><p>上一节中，我们实现了搭建一个简单的窗口，并且添加了如菜单栏、工具栏等项目。</p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>但现在的窗口只是徒有其形，其内部的功能却一个都没有实现。</p><p>这节我们实现点击一个按钮，弹出一个对话框的功能。</p><h2 id="1-1-介绍">1.1 介绍</h2><p>对话框分为两种</p><ul><li>模态对话框：弹出后，可以对其他窗口进行操作</li><li>非模态对话框：弹出后，无法点击除了对话框以外的其他区域（代码阻塞）</li></ul><h2 id="1-2-代码创建">1.2 代码创建</h2><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span>`</span></span><br></pre></td></tr></table></figure><p>编写对话框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew,&amp;QAction::triggered,[=]()&#123;</span><br><span class="line"><span class="comment">//模态对话框 （不可以对其他窗口进行操作） 非模态对话框 （可以对其他窗口进行操作）</span></span><br><span class="line"><span class="comment">//模态创建 阻塞</span></span><br><span class="line">    QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">    dlg.<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;模态对话框弹出了&quot;</span>;   <span class="comment">//需要引入#include &lt;QDebug&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非模态对话框</span></span><br><span class="line">    QDialog * dlg2 = <span class="keyword">new</span> <span class="built_in">QDialog</span> (<span class="keyword">this</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    dlg2-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;非模态对话框弹出了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二、标准对话框</h1><p>Qt提供了很多内置对话框：</p><table><thead><tr><th>Qt内置对话框</th><th>功能</th></tr></thead><tbody><tr><td>QColorDialog</td><td>选择颜色</td></tr><tr><td>QFileDialog</td><td>选择文件或者目录</td></tr><tr><td>QFontDialog</td><td>选择字体</td></tr><tr><td>QInputDialog</td><td>允许用户输入一个值，并将其值返回</td></tr><tr><td>QMessageBox</td><td>模态对话框，用于显示信息、询问问题等</td></tr><tr><td>QPageSetupDialog</td><td>为打印机提供纸张相关的选项</td></tr><tr><td>QPrintDialog</td><td>打印机配置</td></tr><tr><td>QPrintPreviewDialog</td><td>打印预览</td></tr><tr><td>QProgressDialog</td><td>显示操作过程</td></tr></tbody></table><p>以下以消息对话框为例。</p>]]></content>
    
    
    <summary type="html">介绍了Qt中的模态/非模态对话框，以及标准对话框。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记03】UI设计</title>
    <link href="https://www.mahaofei.com/post/549bf258.html"/>
    <id>https://www.mahaofei.com/post/549bf258.html</id>
    <published>2022-09-01T07:36:06.000Z</published>
    <updated>2022-09-01T07:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、QMainWindow</h1><h2 id="1-1-QMainWindow结构概览">1.1 QMainWindow结构概览</h2><p>QMainWindow由一个菜单栏、多个工具栏、多个铆接部件、一个状态栏、一个中心部件组成。各部件的具体布局区域如图所示。</p><p><img src="https://img-blog.csdn.net/20180106132722303" alt=""></p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><blockquote><p>上面图片所用到的代码及注释附在本文的最后</p></blockquote><h2 id="1-2-菜单栏QMenuBar">1.2 菜单栏QMenuBar</h2><p>菜单栏是窗口最上方的区域，基本每个软件的标题栏下面都会有这么一行，这就是菜单栏。</p><p><img src="https://img.mahaofei.com/img/20220902161029.png" alt=""></p><p>注意：菜单栏只能创建一个</p><p><strong>代码示例</strong></p><p>引入菜单栏QMenuBar</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>菜单栏创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br></pre></td></tr></table></figure><p>将菜单栏放入到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br></pre></td></tr></table></figure><p>创建菜单栏的菜单（比如文件、编辑、工具、帮助等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建菜单项（比如文件菜单下的新建、打开项）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902161412.png" alt=""></p><h2 id="1-3-工具栏QToolBar">1.3 工具栏QToolBar</h2><p>工具栏一般位于菜单栏下方，或者左右两侧、或底部。</p><p><img src="https://img.mahaofei.com/img/20220902161816.png" alt=""></p><p>注意：工具栏可以创建多个。</p><p><strong>代码示例</strong></p><p>引入工具栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建工具栏（工具栏创建后可以随意拖动）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将工具栏放入窗口，Qt::TopToolBarArea是默认放上侧，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br></pre></td></tr></table></figure><p>设置只允许左右停靠</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br></pre></td></tr></table></figure><p>设置浮动（可以拖拽，但移动不了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>设置移动（总开关，设为False后无法拖拽）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在工具栏中添加内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将刚才创建的菜单项Action添加到工具栏中</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line"><span class="comment">//添加另一个菜单项</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line"><span class="comment">//工具栏中添加控件</span></span><br><span class="line">QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902162526.png" alt=""></p><h2 id="1-4-状态栏QStatusBar">1.4 状态栏QStatusBar</h2><p>状态栏是窗口最低不，显示软件状态的栏。（例如ppt、word最下面显示字数、幻灯片数量的那一行）</p><p><img src="https://img.mahaofei.com/img/20220902162734.png" alt=""></p><p>注意：状态栏最多有一个。</p><p><strong>代码示例</strong></p><p>引入状态栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建状态栏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br></pre></td></tr></table></figure><p>将状态栏设置到窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setStatusBar</span>(stBar);</span><br></pre></td></tr></table></figure><p>在菜单栏中放入标签控件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902163152.png" alt=""></p><h2 id="1-5-铆接部件QDockWidget">1.5 铆接部件QDockWidget</h2><p>铆接部件又称为浮动窗口，是窗口中，在中心窗口周围的部件，通常是可以修改位置，可以拖出来成为单独的窗口，也可以双击使其回到父窗口中。</p><p>常见的铆接部件包括（IDE左侧或右侧的项目栏、底部的编译输出栏等）</p><p><img src="https://img.mahaofei.com/img/Screenshot%20from%202022-09-02%2016-54-35.png" alt=""></p><p>铆接部件可以有多个</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建铆接部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将铆接部件添加到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br></pre></td></tr></table></figure><p>设置铆接部件的停靠区域，例如只允许上下（与工具栏设置参数一致）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902172602.png" alt=""></p><h2 id="1-6-中心部件QTextEdit">1.6 中心部件QTextEdit</h2><p>中心部件就是一个程序中心的部分，例如IDE的程序编写区域，WPS的文字编辑区域等。</p><p>中心部件只能设置一个。</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建中心部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>设置中心部件到父窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setCentralWidget</span>(edit);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>中间白色的区域就是中心部件。</p><h2 id="1-7-UI工具设计图形界面">1.7 UI工具设计图形界面</h2><p>在Qt中也提供了图形化的UI设计界面。</p><p>通过双击项目文件中的<code>xxx.ui</code>文件，就可以打开设计页面。</p><p><img src="https://img.mahaofei.com/img/20220902192942.png" alt=""></p><p>在这里，上文提到的所有项目（菜单栏、工具栏等），以及各自的属性，都可以直接拖拽放置，并在右下角修改其属性。</p><p>创建的控件，在代码中通过<code>ui-&gt;abcd</code>可以找到所有控件。</p><p>但是这种布局方式所产生的代码结构较差。</p><p>通常是在代码中编写大概，然后在设计中进行微调。</p><h1>二、资源文件</h1><p>很多时候，在窗口中我们不仅需要文字，还需要添加一些图标，图片等，让应用显得更人性化。这就需要我们在项目中导入资源文件。</p><h2 id="2-1-资源文件的导入">2.1 资源文件的导入</h2><ol><li><p>首先将图片复制到项目文件夹中（注意图片必须是png格式，直接更改用户名无效，必须通过图片编辑软件转换）</p></li><li><p>右键项目名 -&gt; 添加新文件 -&gt; Qt -&gt; QtResourceFile</p></li></ol><p><img src="https://img.mahaofei.com/img/20220902193453.png" alt=""></p><ol start="3"><li><p>得到一个<code>.qrc</code>文件，右键，<code>open in edit</code></p></li><li><p>添加 -&gt; 前缀，自己设置一个前缀</p></li><li><p>添加 -&gt; 文件 -&gt; 找到图片文件夹 -&gt; 选中所有图片 -&gt; 打开</p></li><li><p>可以看到<code>.qrc</code>文件下方多了一个“前缀”文件夹</p></li></ol><h2 id="2-2-代码中使用">2.2 代码中使用</h2><p>代码中使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ui-&gt;actionNew-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(``<span class="string">&quot;:/前缀/图片文件夹名/图片文件名.png&quot;</span>``));`</span><br></pre></td></tr></table></figure><h1>附</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏  只能最多有一个</span></span><br><span class="line">    <span class="comment">//菜单栏创建</span></span><br><span class="line">    QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br><span class="line">    <span class="comment">//将菜单栏放入到窗口中</span></span><br><span class="line">    <span class="built_in">setMenuBar</span>(bar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单</span></span><br><span class="line">    QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单项</span></span><br><span class="line">    QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏  可以有多个</span></span><br><span class="line">    QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后期设置 只允许 左右停靠</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置浮动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置移动 (总开关)</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏中可以设置内容</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    <span class="comment">//工具栏中添加控件</span></span><br><span class="line">    QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏 最多有一个</span></span><br><span class="line">    QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br><span class="line">    <span class="comment">//设置到窗口中</span></span><br><span class="line">    <span class="built_in">setStatusBar</span>(stBar);</span><br><span class="line">    <span class="comment">//放标签控件</span></span><br><span class="line">    QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//铆接部件 （浮动窗口） 可以有多个</span></span><br><span class="line">    QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br><span class="line">    <span class="comment">//设置后期停靠区域，只允许上下</span></span><br><span class="line">    dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置中心部件 只能一个</span></span><br><span class="line">    QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(edit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了QMainWindow相关的实现方法，包括菜单栏、工具栏、状态栏、铆接部件、中心部件等。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【Qt学习笔记02】自定义信号与槽函数</title>
    <link href="https://www.mahaofei.com/post/b61fb72.html"/>
    <id>https://www.mahaofei.com/post/b61fb72.html</id>
    <published>2022-08-27T12:43:15.000Z</published>
    <updated>2022-08-27T12:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自定义信号和槽</h1><p>实现功能：定义两个类，mysignal类，myslot类。mysignal类发出信号hello，myslot响应信号打印Hello World。</p><p><strong>（1）创建类</strong></p><p>首先右键项目-添加新文件-创建新的C++类，基类选择QObject。</p><p><img src="https://img.mahaofei.com/img/20220827210652.png" alt=""></p><p><strong>（2）自定义信号和槽函数</strong></p><p>自定义信号写到signals下。返回值是void，只需要声明，不需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysignal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSIGNAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSIGNAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySignal</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySignal</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;   <span class="comment">//添加了自定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSIGNAL_H</span></span></span><br></pre></td></tr></table></figure><p>自定义槽函数写在public slots下。返回值是void，需要声明，也需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSLOT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSLOT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySlot</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySlot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;    <span class="comment">//添加了自定义槽</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSLOT_H</span></span></span><br></pre></td></tr></table></figure><p>实现槽函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span>    <span class="comment">//QDebug可在底部打印输出字符串</span></span></span><br><span class="line"></span><br><span class="line">MySlot::<span class="built_in">MySlot</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义槽函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySlot::printhello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;Hello World!&quot;</span>);    <span class="comment">//输出HelloWorld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）创建两个类的对象并使用connect进行连接</strong></p><p>首先在widget.h中声明两个类的指针，然后在widget.cpp中new两个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span>  <span class="comment">//引入两个类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;    <span class="comment">//声明两个类的指针</span></span><br><span class="line">    MySlot * myslot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;    <span class="comment">//new两个对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）创建触发函数</strong></p><p>只有上面的代码，虽然创建了两个类，也定义了信号和槽函数，但是缺少触发条件，此时运行程序，程序无反应。</p><p>在widget.h的widget类的private中声明触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;</span><br><span class="line">    MySlot * myslot;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mytrigger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure><p>在widget.cpp下方定义触发函数，并在widget中添加触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;</span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">    <span class="built_in">mytrigger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">widget::mytrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit mysignal-&gt;<span class="built_in">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220827213040.png" alt=""></p><h1>二、信号的连接与断开</h1><h2 id="2-1-信号连接信号">2.1 信号连接信号</h2><p>connect不仅可以连接信号与槽，也可以连接信号与信号，实现当触发一个信号时，由该信号继续触发另一个信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello);</span><br></pre></td></tr></table></figure><h2 id="2-2-信号与槽断开">2.2 信号与槽断开</h2><p>断开信号使用disconnect关键字，其参数与connect完全相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">信号与槽是QT中最重要的概念之一，信号与槽可以实现发送端和接收端的信号传输，是qt各种操作的基础。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【QT学习笔记01】Qt基础、按钮、对象树以及信号和槽的基本使用</title>
    <link href="https://www.mahaofei.com/post/e1f7a4b6.html"/>
    <id>https://www.mahaofei.com/post/e1f7a4b6.html</id>
    <published>2022-08-27T02:50:59.000Z</published>
    <updated>2022-08-27T02:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Qt</h1><h2 id="1-1-Qt介绍">1.1 Qt介绍</h2><p><strong>Qt</strong>是一个<strong>跨平台</strong>的<strong>C++图形用户界面应用程序框架</strong>。为应用程序开发者提供建立艺术级图形界面所需的所有功能。Qt是完全面向对象的，很容易扩展，且允许真正的组件编程。</p><p>支持Windows、Linux、MacOS、嵌入式平台等全平台开发。</p><p>Qt的优点</p><ul><li>跨平台，几乎支持所有平台</li><li>接口简单，容易上手</li><li>简化了内存回收机制</li><li>开发效率高，可快速构建应用程序</li><li>社区氛围好</li><li>可进行嵌入式开发</li></ul><p>Qt的案例</p><ul><li>Linux桌面环境KDE</li><li>WPS Office</li><li>Skype</li><li>Google Earth</li><li>VirtualBox<br>以上都是使用Qt进行开发的。</li></ul><h2 id="1-2-Qt的安装">1.2 Qt的安装</h2><p><strong>（1）Qt主程序与Qt Creator</strong></p><p>到QT官网下载windows安装包：[<a href="https://download.qt.io/archive/qt/5.12/5.12.12/">Index of /archive/qt/5.12/5.12.12</a>](<a href="https://download.qt.io/archive/qt/5.12/5.12.12/">Index of /archive/qt/5.12/5.12.12</a>)</p><p>从上面网站中找到<a href="https://download.qt.io/archive/qt/5.12/5.12.12/qt-opensource-windows-x86-5.12.12.exe">qt-opensource-windows-x86-5.12.12.exe</a>下载并安装，安装过程中选择下面这些组件：</p><p><img src="https://img.mahaofei.com/img/202305202149400.png" alt="image.png"></p><p><strong>（2）Visual Studio中配置Qt扩展</strong></p><p>在扩展菜单栏中点击管理扩展，点击联机扩展，搜索QT，下载<code>Qt Visual Studio Tools</code>插件，下载成功后重启VS2022并安装插件（关闭时会自动弹出安装插件界面，点击Modify即可）。</p><p>打开【扩展 -&gt; Qt VS Tools -&gt; Qt Versions】。</p><p>添加环境，路径就是刚刚安装QT5的路径中的<code>msvc2017</code>.</p><p>配置完成点击确定，关闭VS2022。</p><p>打开VS2022，创建新项目，选择<code>Qt Widgets Application</code>项目，选择<code>debug</code>调试版，有调试信息的，ok结束。</p><h1>二、第一个Qt程序</h1><h2 id="2-1-界面介绍">2.1 界面介绍</h2><p><img src="https://img.mahaofei.com/img/20220827133056.png" alt=""></p><ul><li>欢迎界面<ul><li>工程：创建、打开工程</li><li>示例：提供了各行各业一些现成的qt工程，可以直接打开学习其代码</li><li>教程：Qt官方提供的教程，感觉不如b站大学</li></ul></li><li>编辑<ul><li>进行应用程序代码编写，C++</li></ul></li><li>设计<ul><li>进行界面UI设计</li></ul></li><li>Debug<ul><li>如名</li></ul></li><li>项目<ul><li>进行一些项目配置</li></ul></li><li>帮助<ul><li>非常重要，很多想要实现的功能都可以通过查阅帮助文档实现</li></ul></li></ul><h2 id="2-2-第一个项目">2.2 第一个项目</h2><p>注意，项目名称和路径中都不要出现<strong>中文和空格</strong>。</p><p><strong>（1）创建项目</strong></p><p>基类：</p><ul><li>QWidget：是下面两种基类的父类，创建后什么都没有</li><li>QMainWindow：多了菜单栏和工具，以及底部状态栏</li><li>QDialog：多了对话框</li></ul><p>类名：</p><ul><li>创建自己的类</li></ul><p><img src="https://img.mahaofei.com/img/20220827135159.png" alt=""></p><p>创建完成后如图，注意这里没有勾选ui文件，因此工程目录如左面所示。</p><p><strong>（2）main文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span>  <span class="comment">//新建qt工程后的类.h文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>  <span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main程序入口，argc命令行变量的数量，argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//a是应用程序对象，在Qt中有且只有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//通过自定义的类，实例化一个对象（窗口对象）</span></span><br><span class="line">    <span class="comment">//其父类在创建项目时选择</span></span><br><span class="line">    learning01 w;</span><br><span class="line">    <span class="comment">//窗口对象默认不会显示，必须调用show方法显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让应用程序对象进入消息循环机制</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息循环机制：</p><p>在正常C++中，运行后窗口都会一闪而过，一般只有添加system(“pause”)才能看到输出窗口。而在qt中，应用程序会阻塞到return行，等待用户的鼠标键盘操作，或点击窗口右上角x才可以退出程序。</p><p><strong>（3）.pro文件</strong></p><p>注意：除非知道你在做什么，否则不要动.pro文件，里面的内容会根据项目自动更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt包含的模块</span></span><br><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于4版本以上，包含 wigdet 模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标，生成的.exe程序的名称</span></span><br><span class="line">TARGET = learning01</span><br><span class="line"><span class="comment"># 模板，应用程序模板</span></span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件，自动追加</span></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        learning01.cpp</span><br><span class="line"><span class="comment"># 头文件，自动追加</span></span><br><span class="line">HEADERS += \</span><br><span class="line">        learning01.h</span><br></pre></td></tr></table></figure><p><strong>（4）头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARNING01_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARNING01_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含头文件QWidget窗口类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">learning01</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">//Q_OBJECT宏，允许类中 使用信号和槽的机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">learning01</span>(QWidget *parent = <span class="number">0</span>);    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">learning01</span>();    <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LEARNING01_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（5）cpp文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;learning01.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;QApplication&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    learning01 w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（6）快捷键</strong></p><ul><li>注释：ctrl + /</li><li>运行：ctrl + r</li><li>编译：ctrl + b</li><li>查找：ctrl + f</li><li>整行移动：ctrl + shift +↑/↓</li><li>字体缩放：ctrl + 滚轮</li><li>自动对齐：ctrl + i</li><li>同名之间的.h和.cpp切换：F4</li></ul><h1>三、按钮控件</h1><p><strong>（1）创建按钮</strong></p><p>使用QPushButton创建按钮，需要指定父类（否则会新建窗口生成按钮），设置文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）其他操作</strong></p><p>见代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、对象树</h1><p>QObject是以对象树的形式组织的。</p><p>当创建一个QObject对象，并指定了父对象指针时，会自动将其添加到其父对象的children()列表。</p><p>当父对象析构时，children()列表的所有对象都会析构。</p><p><img src="https://img-blog.csdnimg.cn/2020121618000044.png" alt=""></p><h1>五、信号与槽</h1><p>实现点击按钮关闭窗口</p><p>具体过程如下：</p><ol><li>信号的发送者</li><li>发送具体信号</li><li>信号的接受者</li><li>对信号进行处理（槽函数）</li></ol><p>以上四个就是信号传递connect的四个参数。</p><p>信号槽的优点：松散耦合，信号发送端和接收端本身是没有关联的，通过connect函数进行连接。</p><p>connect()函数参数</p><ul><li>参数1：信号的发送者，按钮对象</li><li>参数2：发送的信号，clicked, pressed, released,toggled</li><li>参数3：信号的接受者，窗口，this</li><li>参数4：信号的处理，close</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/************* 创建按钮 ************/</span></span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************* 按钮关闭窗口 ************/</span></span><br><span class="line">    <span class="comment">//参数1：信号的发送者; 参数2：发送的信号;</span></span><br><span class="line">    <span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;QWidget::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍了QT的基础，并给出了QT第一个程序的创建过程（空窗口与按钮）。介绍了信号和槽的概念与最简单的按下按钮关闭窗口功能的实现。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Qt/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Qt" scheme="https://www.mahaofei.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>【深度学习笔记08】经典神经网络</title>
    <link href="https://www.mahaofei.com/post/4a294477.html"/>
    <id>https://www.mahaofei.com/post/4a294477.html</id>
    <published>2022-08-21T10:57:11.000Z</published>
    <updated>2022-08-21T10:57:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1>一、目标定位</h1><h2 id="1-1-基本思想">1.1 基本思想</h2><p>目标定位是在图像分类的基础上发展而来的，而目标检测又是建立在目标定位的基础之上。</p><p>对于一张图片来说，我们可以通过卷积神经网络以及softmax函数实现图像的分类，例如人、车、自行车等。</p><p><strong>如果我们想要定位目标在图像中的位置，我们可以让softmax函数多输出几个数字，例如多输出4个数字来描述边界框的位置(bx, by, w, h)</strong>。这样训练集就不仅是图像的分类数据了，还要包括图像中的边界框坐标。</p><h2 id="1-2-标签的定义">1.2 标签的定义</h2><p>根据上面的思想，我们可以将图像的标签定义为如下：</p><p>$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有物体（区分物体与背景）</li><li>$b_x, b_y, b_w, b_h$：边界框的中心坐标以及宽高</li><li>$c_1, c_2, c_3$：图像中物体属于三类的概率</li></ul><h2 id="1-3-损失函数的设计">1.3 损失函数的设计</h2><p>对于上面定义的标签，如果采用平方损失策略，则损失函数定义如下：</p><p>如果$y_1=1$，即图片中有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2+(\hat y_2-y_2)^2+\dots+(\hat y_8-y_8)^2$</p><p>（由于标签中共有8个元素，因此从$y_1$到$y_8$）</p><p>如果$y_1=0$，即图片中没有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2$</p><h1>二、特征点检测</h1><p>上面我们介绍了通过在标签中添加4个参数$b_x, b_y, b_w, b_h$来输出边界框的坐标。</p><p>特征点检测也是类似的原理。</p><p>加入我们出于某种原因，想要获取一个人的四个眼角在图像中的坐标，那么我们完全可以将其添加到标签中，事先标记好训练图像中每个人的眼角坐标，然后用神经网络进行训练。</p><p>$y = [P_c, l_{1x}, l_{1y}, l_{2x}, l_{2y}, \dots, l_{4x}, l_{4y}]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有人脸（图像分类）</li><li>$l_{1x}, l_{1y}, \dots, l_{4x}, l_{4y}$：四个眼角的xy坐标</li></ul><p>这与边界框的获取，图片的分类等等，都是同样的原理。</p><p>如果我们想更进一步，获取脸部表情，我们可以在人脸上设置多个特征点，然后再每一张图片上的人脸作标注，然后由神经网络来回归计算。</p><p>通过这种方式，就可以实现特征点的检测。</p><h1>三、目标检测</h1><p>目标检测的基础是图像分类。</p><h2 id="3-1-滑动窗口法">3.1 滑动窗口法</h2><p>以汽车检测为例：</p><p>首先在训练集来说，我们可以使用让汽车占满全部区域的图片来作为训练图片，可以通过在其他照片中裁减出来汽车所占据的区域。</p><p>对于一张给定图片，我们在图像上选取一个小窗口，将这个小窗口内的图像传入神经网络中，判断这个小窗口中的图像是不是一辆车，然后移动小窗口到下一个位置，继续检测。整幅图片遍历完成之后，再调整窗口的大小，重新遍历。</p><p><img src="https://img.mahaofei.com/img/20220910194902.png" alt=""></p><p>这种算法一般就被称为滑动窗口法。</p><p>这种算法的优点是算法设计简单，但也有很明显的缺点就是计算量太大，而且需要合理选择窗口大小和步幅，否则无法准确定位图像中的物体。</p><h2 id="3-2-获取更精准的边界框">3.2 获取更精准的边界框</h2><p>现有问题：使用滑动窗口法</p><ul><li>如果步长较大，所标出的窗口经常不能很好的完全覆盖目标物体，如果步长较小，计算量又过大。</li><li>目标物体有时不是规则的正方形，使用正方形的滑动窗口，获得的边界框精度不够</li></ul><p>解决思路</p><ol><li>利用图像定位算法，将图片分割成9个网格，对每一个网格进行图像定位，使用类似于$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$的标签进行训练。</li><li>这样每一个格子都会获得一个输出，例如$y = [1, b_x, b_y, b_w, b_h, 0, 1, 0]^T$，这样综合来看，输出的维度就是3x3x8。3x3是格子数量，8是输出参数个数。</li></ol><p>这样，相比于滑动窗口来说，滑动窗口是将覆盖范围最大的那个窗口，作为边界框输出。而这里则是将边界框作为四个参数作回归了。</p><p>优点：</p><ul><li>由于使用卷积处理不同格子时，很多计算步骤是共享的，因此大大提高了计算效率</li><li>并且由于是卷积实现，所以计算速度非常快，可以达到实时识别</li></ul><h2 id="3-3-非极大抑制NMS（Non-Max-Suppression）">3.3 非极大抑制NMS（Non-Max Suppression）</h2><p>问题：算法可能对同一个物体识别多次，我们需要采取某种措施使算法对每个对象只检测一次。</p><p><img src="https://img.mahaofei.com/img/20220911144627.png" alt=""></p><p>解决方法：</p><p>在输出结果中，找到识别结果概率最高的一个，例如图中的0.9，将与这个框交并比较大的其他框抑制掉，我们认为这个0.9的框就标出了一个对象。</p><p>然后找到剩余所有框中概率最高的一个，例如图中的0.8，将与这个框交并比较大的其他框抑制掉，得到预测结果。</p><blockquote><p>交并比$IOU=\frac{交集区域}{并集区域}$</p></blockquote><p>实现流程</p><ul><li>将图片分为nxn个格子，对每个格子进行预测，获得包括物体存在概率，边界框位置大小等参数</li><li>删除所有物体存在概率小于0.6的边界框</li><li>对剩余的边界框<ul><li>选取概率最高的边界框作为输出，认为其标出了某个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>在剩余的边界框中在找概率最高的边界框作为输出，认为其中也标出了另一个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>重复过程</li></ul></li></ul>]]></content>
    
    
    <summary type="html">目标检测的基本实现方法，从目标定位开始，总结了特征点检测、目标检测、滑动窗口法、NMS非极大抑制等目标检测的算法。</summary>
    
    
    
    <category term="程序设计" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="深度学习基础" scheme="https://www.mahaofei.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="笔记" scheme="https://www.mahaofei.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="深度学习" scheme="https://www.mahaofei.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
