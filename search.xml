<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【论文笔记】ACT 使用低成本硬件的双手操作模仿学习</title>
      <link href="/post/24d9497f.html"/>
      <url>/post/24d9497f.html</url>
      
        <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware<br><strong>中文标题</strong>：使用低成本硬件学习细粒度双手操作<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/tonyzhaozh/act">https://github.com/tonyzhaozh/act</a></p></blockquote><h2 id="1-1-目标问题">1.1 目标问题</h2><p>对于机器人而言，学习实现一些精细操作是较为困难的，因为涉及精确的力控以及闭环视觉反馈，这有需要先进的机器人，精确的传感器和准确的标定。</p><p><strong>能否使用低成本、不精确的硬件来执行这些精细的操作任务？</strong></p><h2 id="1-2-方法">1.2 方法</h2><p>本文提出了一种简单的算法，ACT (Action Chunking with Transformers)。</p><p>首先使用 ALOHA 收集人类演示的引导机器人的关节位置，并将其作为动作，观测结果由机器人的当前关节位置和相机的输入图像组成。然后训练 ACT 根据当前观测预测未来的动作序列，也就是下一个时间步中双臂的目标关节位置。</p><p><img src="https://img.mahaofei.com/img/202401051026095.png" alt="image.png"></p><p><strong>（1）动作分块和时间集成</strong></p><p>为了利用像素到动作的策略，通过对抗模仿学习解决复合错误。本文使用了动作分块的思想，将多个动作分组在一起平作为一个单元执行，从而使他们更有效的存储和执行。</p><p>本文将动作块的大小固定为 k ，每 k 步，智能体接收一个观测结果，生成接下来的 k 个操作，并按顺序执行这些操作，因此任务的有效范围被减小了 k 倍。</p><p>但是这种方法得到的动作块可能不是最理想的动作，因此可能导致机器人的运动不稳定。为了提高平滑型，本文在每个时间步内执行策略，得到不同的动作块相互重叠，因此会有多个预测动作，本文对这些预测进行指数加权 $w_i=exp(-m*i)$，其中 $w_0$ 是最旧的动作的权重，$m$ 越小则合并的速度越快。</p><p><strong>（2）人类数据建模</strong></p><p>人类可以从不同个轨迹来解决同一个任务，尤其是在不要求精度的区域，人类的动作会非常随机，因此策略重点关注高精度区域也是非常重要的。</p><p>本文将策略训练为条件变分自动编码器 CVAE 来生成当前观测为条件的动作序列。</p><ul><li>CVAE 编码器：输入当前观测（机器人本体状态）和动作序列，编码后得到变量 z 分布，将其参数化为高斯分布，输出该分布的均值和方差</li><li>CVAE 解码器：以 z 和当前观测（图像+机器人本体状态）为条件，预测动作序列。</li></ul><h1>二、代码复现 (act)</h1><blockquote><p>该部分参考论文原仓库：<a href="https://github.com/tonyzhaozh/act">https://github.com/tonyzhaozh/act</a></p></blockquote><h2 id="2-1-环境准备">2.1 环境准备</h2><p>创建虚拟环境并安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conda create -n aloha python=3.8.10</span><br><span class="line">conda activate aloha</span><br><span class="line">pip install torchvision</span><br><span class="line">pip install torch</span><br><span class="line">pip install pyquaternion</span><br><span class="line">pip install pyyaml</span><br><span class="line">pip install rospkg</span><br><span class="line">pip install pexpect</span><br><span class="line">pip install mujoco</span><br><span class="line">pip install dm_control</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install matplotlib</span><br><span class="line">pip install einops</span><br><span class="line">pip install packaging</span><br><span class="line">pip install h5py</span><br><span class="line">pip install ipython</span><br><span class="line">cd act/detr &amp;&amp; pip install -e .</span><br></pre></td></tr></table></figure><h2 id="2-2-数据收集">2.2 数据收集</h2><p>首先激活虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate aloha</span><br></pre></td></tr></table></figure><p>进入到代码根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;path to act&gt;</span><br></pre></td></tr></table></figure><p>创建两个目录，分别用于保存数据集和训练好后的模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p datasets/sim_transfer_cube_scripted</span><br><span class="line">mkdir checkpoints</span><br></pre></td></tr></table></figure><p>以 <code>sim_transfer_cube_scripted</code> 任务为例，使用下面的脚本产生 50 个 episodes 的数据（可以添加 <code>--onscreen_render</code> 来实现实时渲染）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 record_sim_episodes.py --task_name sim_transfer_cube_scripted --dataset_dir datasets/sim_transfer_cube_scripted/ --num_episodes 50</span><br></pre></td></tr></table></figure><p>产生的 50 个数据会以 50 个 hdf5 文件的格式保存在文件夹中，要想可视化这些数据集，可以使用下面的命令，以可视化第一个数据为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 visualize_episodes.py --dataset_dir datasets/sim_transfer_cube_scripted/ --episode_idx 0</span><br></pre></td></tr></table></figure><h2 id="2-3-训练">2.3 训练</h2><p>首先需要修改 <code>constants.py</code> 中的 DATA_DIR 参数，将其改为自己的数据集文件夹名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_DIR = <span class="string">&#x27;/home/mahaofei/Programs/Imitation/act/datasets&#x27;</span></span><br></pre></td></tr></table></figure><p>开始训练：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 8 --dim_feedforward 3200 --num_epochs 2000  --lr 1e-5 --seed 0</span><br></pre></td></tr></table></figure><p>如果 ACT 策略在一个 episode 中是不稳定的或者是停止不变的，那么就训练更长时间，在平台期过后成功率和轨迹平滑性都会得到提高。</p><h2 id="2-4-评估">2.4 评估</h2><p>还是和训练使用同一个脚本，只不过需要加入 <code>--eval</code>，该程序会把评估过程中的视频保存到 <code>checkpoints</code> 文件夹中，也可以添加 <code>--onscreen_render</code> 在评估是实时渲染。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 8 --dim_feedforward 3200 --num_epochs 2000  --lr 1e-5 --seed 0 --eval</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202401051053987.png" alt="image.png"></p><p>经测试，实际成功率并不高，在抓取时总会出现错位，且传递过程很难成功。</p><p>~~暂未知原因，等待后续检查。~~已查明原因，需使用特定版本的 mujoco，参考 <a href="https://github.com/MarkFzp/act-plus-plus/issues/12">issue #12</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mojoco==2.3.7 dm_env==1.6 dm_control==1.0.14</span><br></pre></td></tr></table></figure><h1>三、代码复现 (act-plus-plus)</h1><p>最近发现作者在一篇新的论文中 Mobile ALOHA Learning Bimanual Mobile Manipulation with Low-Cost Whole-Body Teleoperation，对 ACT 算法进行了更新，基本复现流程一致，部分进行了修改。</p><blockquote><p>该部分参考论文原仓库：<a href="https://github.com/MarkFzp/act-plus-plus">https://github.com/MarkFzp/act-plus-plus</a></p></blockquote><h2 id="2-1-环境准备-2">2.1 环境准备</h2><p>下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/MarkFzp/act-plus-plus</span><br></pre></td></tr></table></figure><p>创建虚拟环境并安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">conda create -n act python=3.8.10</span><br><span class="line">conda activate act</span><br><span class="line">pip install torchvision</span><br><span class="line">pip install torch</span><br><span class="line">pip install pyquaternion</span><br><span class="line">pip install pyyaml</span><br><span class="line">pip install rospkg</span><br><span class="line">pip install pexpect</span><br><span class="line">pip install mujoco==2.3.7</span><br><span class="line">pip install dm_control==1.0.14</span><br><span class="line">pip install dm_env==1.6</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install matplotlib</span><br><span class="line">pip install einops</span><br><span class="line">pip install packaging</span><br><span class="line">pip install h5py</span><br><span class="line">pip install ipython</span><br><span class="line">cd act-plus-plus/detr &amp;&amp; pip install -e .</span><br></pre></td></tr></table></figure><p>实际上没有提到但却调用的库还有</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip install diffusers</span><br><span class="line">pip install wandb</span><br><span class="line"></span><br><span class="line">git clone git@github.com:ARISE-Initiative/robomimic.git</span><br><span class="line">cd robomimic</span><br><span class="line">git checkout diffusion-policy-mg</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p>修改 <code>constants.py</code> 中的 DATA_DIR 参数，将其改为自己的数据集文件夹名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_DIR = <span class="string">&#x27;/home/mahaofei/Programs/Imitation/act/datasets&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <a href="https://wandb.ai/">wandb 官网</a>创建账号，并创建一个项目，将 <code>imitate_episodes.py</code> 的第 148 行修改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wandb.init(project=<span class="string">&quot;项目名称&quot;</span>, reinit=<span class="literal">True</span>, entity=<span class="string">&quot;wandb用户名&quot;</span>, name=expr_name)</span><br></pre></td></tr></table></figure><p>截至 2023-01-05 开源的代码还存在一些问题，需要修改 <code>detr/models/detr_vae.py</code> 的第 285 行为 <code>encoder = build_encoder(args)</code>，参考 <a href="https://github.com/MarkFzp/act-plus-plus/issues/3#issuecomment-1876588075">issue</a></p><h2 id="2-2-数据收集-2">2.2 数据收集</h2><p>首先激活虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate act</span><br></pre></td></tr></table></figure><p>进入到代码根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;path to act&gt;</span><br></pre></td></tr></table></figure><p>创建两个目录，分别用于保存数据集和训练好后的模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p datasets/sim_transfer_cube_scripted</span><br><span class="line">mkdir checkpoints</span><br></pre></td></tr></table></figure><p><strong>收集数据</strong>：以 <code>sim_transfer_cube_scripted</code> 任务为例，使用下面的脚本产生 50 个 episodes 的数据（可以添加 <code>--onscreen_render</code> 来实现实时渲染）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 record_sim_episodes.py --task_name sim_transfer_cube_scripted --dataset_dir datasets/sim_transfer_cube_scripted/ --num_episodes 50</span><br></pre></td></tr></table></figure><p><strong>可视化收集的数据</strong>：产生的 50 个数据会以 50 个 hdf5 文件的格式保存在文件夹中，要想可视化这些数据集，可以使用下面的命令，以可视化第一个数据为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 visualize_episodes.py --dataset_dir datasets/sim_transfer_cube_scripted/ --episode_idx 0</span><br></pre></td></tr></table></figure><h2 id="2-3-训练-2">2.3 训练</h2><p><strong>开始训练</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 4 --dim_feedforward 3200 --num_steps 2000  --lr 1e-5 --seed 0</span><br></pre></td></tr></table></figure><p>如果爆显存了(CUDA out of memory)，可以减小 <code>batch_size</code>。</p><p>如果 ACT 策略在一个 episode 中是不稳定的或者是停止不变的，那么就训练更长时间，在平台期过后成功率和轨迹平滑性都会得到提高。</p><h2 id="2-4-评估-2">2.4 评估</h2><p>还是和训练使用同一个脚本，只不过需要加入 <code>--eval</code>，该程序会把评估过程中的视频保存到 <code>checkpoints</code> 文件夹中，也可以添加 <code>--onscreen_render</code> 在评估是实时渲染。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 imitate_episodes.py --task_name sim_transfer_cube_scripted --ckpt_dir checkpoints/ --policy_class ACT --kl_weight 10 --chunk_size 100 --hidden_dim 512 --batch_size 8 --dim_feedforward 3200 --num_steps 10000  --lr 1e-5 --seed 0 --eval --onscreen_render</span><br></pre></td></tr></table></figure><h1>三、代码解析</h1><h2 id="3-1-训练数据格式">3.1 训练数据格式</h2><p>ACT 的训练数据生成为多个 hdf5 文件，每个文件对应一个演示数据，每个 hdf5 文件的结构如下：</p><ul><li>episode_1.hdf5<ul><li><strong>action</strong>: dateset 数据，存储机器人的动作，shape 为 (400, 14)，包括末端执行器的位置和四元数，归一化的夹爪位置（0 关闭，1 打开）<br>[left_arm_qpos (6), left_gripper_positions (1), right_arm_qpos (6), right_gripper_positions (1),]，</li><li><strong>observations</strong>: group 组，存储观测数据<ul><li><strong>images</strong>: gropu 组，存储图像数据<ul><li><strong>left_wrist</strong>：dataset 数据，存储左侧机器人末端相机图像数据，shape 为 (400, 480, 640, 3)，即长度 400，每个图像为 (480, 640, 3) 大小。</li><li><strong>right_wrist</strong>：dataset 数据，存储右侧机器人末端相机图像数据，shape 为 (400, 480, 640, 3)，即长度 400，每个图像为 (480, 640, 3) 大小。</li><li><strong>top</strong>：dataset 数据，存储顶部相机图像数据，shape 为 (400, 480, 640, 3)，即长度 400，每个图像为 (480, 640, 3) 大小。</li></ul></li><li><strong>qpos</strong>：dateset 数据，shape 为 (400, 14)，包括绝对关节位置，归一化的夹爪位置（0 关闭，1 打开）<br>[left_arm_qpos (6), left_gripper_position (1), right_arm_qpos (6), right_gripper_qpos (1)]</li><li><strong>qvel</strong>：dateset 数据，shape 为 (400, 14)，包括绝对关节速度（rad），归一化的夹爪速度（正数为正在打开，负数为正在关闭）<br>[left_arm_qvel (6), left_gripper_velocity (1), right_arm_qvel (6), right_gripper_qvel (1)]</li></ul></li></ul></li></ul><h2 id="3-2-替换-Gym-环境">3.2 替换 Gym 环境</h2><p><strong>（1）补充依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install gym==0.12.1</span><br><span class="line">pip install &quot;cython&lt;3&quot;</span><br><span class="line">pip install perlin_noise</span><br></pre></td></tr></table></figure><p><strong>（2）编写脚本生成与 ACT 训练数据格式相同的 HDF5 数据</strong></p><p><strong>（3）进行训练</strong></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模仿学习 </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDF5数据文件格式</title>
      <link href="/post/87290c9f.html"/>
      <url>/post/87290c9f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!abstract]<br>HDF5数据文件格式的简单介绍与基本使用方法。</p></blockquote><h1>1 HDF5 格式简介</h1><h2 id="1-1-什么是-hdf5-文件">1.1 什么是 hdf5 文件</h2><p>HDF5是一种常见的跨平台数据储存文件，可以存储不同类型的图像和数据，并且可以在不同类型的机器上传输，同时还有统一处理这种文件格式的函数库。</p><p>可以把HDF5文件想象成一个容器，这个容器由多个不同类型的数据对象组成。数据对象可以是任意类型，例如：图片、表格、图像，甚至文档（PDF、Excel）。</p><h2 id="1-2-hdf5-文件结构">1.2 hdf5 文件结构</h2><p>HDF5 文件一般以 <code>.h5</code> 或 <code>.hdf5</code> 作为后缀名，其文件结构包括两部分：<code>Groups</code> 和 <code>Datasets</code>。</p><ul><li><strong>Group</strong>: 类似于文件夹，负责管理数据对象</li><li><strong>Datasets</strong>: 类似于 numpy 中的数组 array，一个数据集由元数据（metadata）和数据本身（data）组成<ul><li><strong>Metadata</strong>: 元数据<ul><li><strong>Datatype</strong>: 数据类型</li><li><strong>Dataspace</strong>: 原始数据的秩和维度</li><li><strong>Properties</strong>: 该数据集的分块存储以及压缩情况<ul><li><strong>Chunked</strong>:</li><li><strong>Chunked &amp; Compressed</strong>:</li></ul></li><li><strong>Attributes</strong>: 为该数据的其它自定义属性</li></ul></li><li><strong>Data Values</strong>:</li></ul></li></ul><p><strong>（1）Group 组</strong></p><p>组负责管理数据对象。每个HDF5文件含有一个根组，根组包含其他组或者链接到其他文件的对象。组和组的成员与文件和文件夹类似，HDF5中对象也可以使用路径来表示：</p><ul><li><code>/</code> 代表根组</li><li><code>/a</code> 代表根组下的 <code>a</code> 成员</li><li><code>/a/b</code> 代表组 <code>a</code> 下的一个成员，<code>a</code> 是根组 <code>/</code> 下的成员</li></ul><p><strong>（2）Datasets 数据集</strong></p><p>一个数据集由元数据（metadata）和数据本身（data）组成。</p><p><img src="https://img.mahaofei.com/img/202401011439226.png" alt="image.png"></p><p>其中的 <code>Metadata</code> 包括一下几个部分：数据类型（datatype）、数据空间（dataspace）、性质（property）、属性（attribute）。</p><p><strong>（3）Datatype 数据类型</strong></p><p>数据类型描述数据集中元素的数据类型，例如 <code>float</code>。</p><ul><li>内置数据类型：包括标准数据类型和原生数据类型</li><li>衍生数据类型：例如符合数据类型（16位整型、1个字符、一个2x3x2的浮点数组组合而成）</li></ul><p><img src="https://img.mahaofei.com/img/202401011453368.png" alt="image.png"></p><p><strong>（4）Dataspace数据空间</strong></p><p>描述数据集内部数据元素（data element）的分布情况：</p><ul><li>Rank：表示数据集维度的个数（例如下图中数据维度个数为2，即2维数组）</li><li>Dimensions：数据空间的维度（数据空间的维度为5x3）<ul><li>NULL：代表数据集内没有任何数据元素</li><li>标量：代表只有一个元素</li><li>向量：代表数据集是一个数组</li></ul></li></ul><p>数据空间的维度可以是固定的，也可以是不固定的。如果是不固定的，代表该数据集的大小是可变的（例如，可扩展的数据集）。</p><p><img src="https://img.mahaofei.com/img/202401011454062.png" alt="image.png"></p><p><strong>（5）Properties 性质</strong></p><p>HDF5包含很多默认的性质，可以是用<code>HDF5 Property List API</code>来修改这些性质。</p><p><strong>（6）Attribute 属性</strong></p><p>属性包含一个名称（name）和一个值（value），是对HDF5对象的一些额外描述。通常都是一些很小的、用户自定义的元数据。</p><h1>二、Python 操作HDF5文件</h1><p><strong>（1）使用 <code>h5py</code> 包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span><br></pre></td></tr></table></figure><p><strong>（2）创建 <code>hdf5</code> 文件：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 hdf5文件</span></span><br><span class="line">f = h5py.File(<span class="string">&quot;h5py_example.hdf5&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在根目录`/` 下创建两个组</span></span><br><span class="line">g1 = f.create_group(<span class="string">&quot;bar1&quot;</span>)</span><br><span class="line">g2 = f.create_group(<span class="string">&quot;bar2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在根目录 `/` 下创建一个数据集(4x4的数组)</span></span><br><span class="line">d = f.create_dataset(<span class="string">&quot;dset&quot;</span>, data=np.arange(<span class="number">16</span>).reshape([<span class="number">4</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据集添加两个属性</span></span><br><span class="line">d.attrs[<span class="string">&quot;myAttr1&quot;</span>] = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">d.attrs[<span class="string">&quot;myAttr2&quot;</span>] = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 `bar1` 组下创建一个组和一个数据集</span></span><br><span class="line">c1 = g1.create_group(<span class="string">&quot;car1&quot;</span>)</span><br><span class="line">d1 = g1.create_dataset(<span class="string">&quot;dset1&quot;</span>, data=np.arange(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 `bar2` 组下创建一个组和一个数据集</span></span><br><span class="line">c2 = g2.create_group(<span class="string">&quot;car2&quot;</span>)</span><br><span class="line">d2 = g2.create_dataset(<span class="string">&quot;dset2&quot;</span>, data=np.arange(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>最后得到的 <code>hdf5</code> 文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-- &#x27;/&#x27;</span><br><span class="line">|   +--group &quot;bar1&quot;</span><br><span class="line">|   |   +-- group &quot;car1&quot;</span><br><span class="line">|   |   |   +-- None</span><br><span class="line">|   |   |   </span><br><span class="line">|   |   +-- dataset &quot;dset1&quot;</span><br><span class="line">|   |</span><br><span class="line">|   +-- group &quot;bar2&quot;</span><br><span class="line">|   |   +-- group &quot;car2&quot;</span><br><span class="line">|   |   |   +-- None</span><br><span class="line">|   |   |</span><br><span class="line">|   |   +-- dataset &quot;dset2&quot;</span><br><span class="line">|   |   </span><br><span class="line">|   +-- dataset &quot;dset&quot;</span><br><span class="line">|   |   +-- attribute &quot;myAttr1&quot;</span><br><span class="line">|   |   +-- attribute &quot;myAttr2&quot;</span><br><span class="line">|   |   </span><br><span class="line">|   </span><br></pre></td></tr></table></figure><p><strong>（3）读取 <code>hdf5</code> 文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取 hdf5 文件</span></span><br><span class="line">f = h5py.File(<span class="string">&quot;h5py_example.hdf5&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 `/` 下所有的组和数据集的 keys</span></span><br><span class="line"><span class="built_in">print</span>(f.filename, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>([key <span class="keyword">for</span> key <span class="keyword">in</span> f.keys()], <span class="string">&quot;\n&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 `/` 下的数据集 `dset`</span></span><br><span class="line">d = f[<span class="string">&quot;dset&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(d.name, <span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d[:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 `dset` 数据集的属性</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.attrs.keys():</span><br><span class="line"><span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, d.attrs[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取组`bar1`</span></span><br><span class="line">g = f[<span class="string">&quot;bar1&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 `bar1` 下所有的组和数据集的 keys</span></span><br><span class="line"><span class="built_in">print</span>([key <span class="keyword">for</span> key <span class="keyword">in</span> g.keys()])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三种方式打印 `dset1` 的数据</span></span><br><span class="line"><span class="built_in">print</span>(f[<span class="string">&quot;/bar1/dset1&quot;</span>][:])   <span class="comment"># 绝对路径</span></span><br><span class="line"><span class="built_in">print</span>(f[<span class="string">&quot;bar1&quot;</span>][<span class="string">&quot;dset1&quot;</span>][:]) <span class="comment"># 相对路径：file[][]</span></span><br><span class="line"><span class="built_in">print</span>(g[<span class="string">&#x27;dset1&#x27;</span>][:])         <span class="comment"># 相对路径：g[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><ol><li><a href="https://www.hdfgroup.org/solutions/hdf5/">HDF Group</a></li><li><a href="https://zhuanlan.zhihu.com/p/656178708">仙棠生信. HDF5简介. 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/104145585">NoNo721. HDF5 数据文件简介. 知乎</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 模仿学习 </tag>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【仿真实验】基于强化学习机器人动作模仿方法</title>
      <link href="/post/7b6b37f0.html"/>
      <url>/post/7b6b37f0.html</url>
      
        <content type="html"><![CDATA[<h1>一、仿真环境</h1><h2 id="1-1-动作-观测定义">1.1 动作-观测定义</h2><p><strong>（1）机器人动作</strong></p><p>代码中机器人的动作通过<code>_set_action()</code>函数设置。</p><p>机器人的动作定义为长度为8的数组，分别代表末端的空间位置3个变量，末端的空间姿态四元数，夹爪平行板的动作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = [x, y, z, quat1, quat2, quat3, quat4, gripper]</span><br></pre></td></tr></table></figure><p><strong>（2）观测值</strong></p><p>观测状态通过<code>_get_obs()</code>函数获取。</p><p>可以看出观测状态是一个字典：</p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">observation</td><td style="text-align:left">[grip_x, grip_y, grip_z,</td><td style="text-align:left">grip_pos，末端位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_q1, grip_q2, grip_q3, grip_q4,</td><td style="text-align:left">grip_quat，末端姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">gripper_left, gripper_right,</td><td style="text-align:left">gripper_state，夹爪两侧状态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_vx, grip_vy, grip_vz,</td><td style="text-align:left">grip_vel，末端速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_wx, grip_wy, grip_wz</td><td style="text-align:left">grip_w，末端角速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">gripper_vl, gripper_vr,</td><td style="text-align:left">gripper_vel，夹爪两侧速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_x, obj1_y, obj1_z,</td><td style="text-align:left">obj_i_pos，方块i位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_q1, obj1_q2, obj1_q3, obj1_q4</td><td style="text-align:left">obj_i_quat，方块i姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_rx, obj1_ry, obj1_rz,</td><td style="text-align:left">obj_i_rel_pos，方块i相对末端位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_rq1, obj1_rq2, obj1_rq3, obj1_rq4</td><td style="text-align:left">obj_i_rel_quat，方块i相对末端姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_vx, obj1_vy, obj1_vz,</td><td style="text-align:left">obj_i_velp, 方块i相对末端速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_wx, obj1_wy, obj1_wz,</td><td style="text-align:left">obj_i_wp，方块i相对末端角速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj2…</td><td style="text-align:left">方块2位置、相对位置、相对速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obji…]</td><td style="text-align:left">方块i位置、相对位置、相对速度</td></tr><tr><td style="text-align:left">achieved_goal</td><td style="text-align:left">[obj1_x, obj1_y, obj1_z,<br>obj1_q1, obj1_q2, obj1_q3, obj1_q4,<br>…</td><td style="text-align:left">每调用一次_get_obs()方法<br>保存所有方块的位置姿态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_x, grip_y, grip_z,<br>grip_q1, grip_q2, grip_q3, grip_q4<br>…]</td><td style="text-align:left">将当前末端位置<br>添加到achieved_goal最后</td></tr><tr><td style="text-align:left">desired_goal</td><td style="text-align:left">[[x1, y1, z1], [x2, y2, z2], … ]</td><td style="text-align:left">多个目标位置</td></tr><tr><td style="text-align:left">force_sensor</td><td style="text-align:left">[f_x, f_y, f_z]</td><td style="text-align:left">force_reading，末端力，默认[0,0,0]</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="1-2-奖励函数设计">1.2 奖励函数设计</h2><p>参考robomimic的检查式奖励设计，将任务过程使用一个个检查事项代替。</p><p>例如，将物体抓取移动到指定位置，可以使用以下检查事项：</p><ol><li>物体足够接近目标</li><li>机器人正在抓取物体（不只是触碰）</li></ol><h1>附：测试</h1><p><strong>DEX 相关算法测试：</strong></p><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">SuccessReward+D10000</th></tr></thead><tbody><tr><td style="text-align:center">DDPGBC</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">SAC</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">SQIL</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">COL</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">AWAC</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">AMP</td><td style="text-align:center">失败</td></tr><tr><td style="text-align:center">DEX</td><td style="text-align:center">失败</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 模仿学习 </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【仿真实验】robomimic项目复现</title>
      <link href="/post/8cdbc8de.html"/>
      <url>/post/8cdbc8de.html</url>
      
        <content type="html"><![CDATA[<p>robomimic 是一个用于机器人从演示学习的框架，该项目提供了一系列机器人操作的演示数据和离线学习算法，可以让人们对任务和算法进行标准化测试。</p><p>本文测试的版本为 robomimic v0.3</p><h1>一、安装与环境搭建</h1><p>在安装之前确保运行 Linux 系统，并安装有 conda。</p><h2 id="1-1-安装-robomimic">1.1 安装 robomimic</h2><p><strong>（1）创建并激活虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n robomimic python=3.8.0 -y</span><br><span class="line">conda activate robomimic</span><br></pre></td></tr></table></figure><p><strong>（2）安装Pytorch</strong></p><p>其中的 pytorch 版本和 torchvision 版本官方说可以修改，暂未测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==2.0.0 torchvision==0.15.1 -c pytorch</span><br></pre></td></tr></table></figure><p><strong>（3）安装 robomimic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;你想保存robomimic代码的位置&gt;</span><br><span class="line">git clone https://github.com/ARISE-Initiative/robomimic.git</span><br><span class="line">cd robomimic</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h2 id="1-2-安装模拟器">1.2 安装模拟器</h2><p><strong>（1）robosuite</strong></p><p>运行大多数 robomimic 示例和发布的数据集需要使用 robosuite 模拟器，安装方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;你想保存robosuite代码的位置&gt;</span><br><span class="line">git clone https://github.com/ARISE-Initiative/robosuite.git</span><br><span class="line">cd robosuite</span><br><span class="line">git checkout v1.4.1</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p><strong>（2）D4RL</strong></p><p>D4RL也提供了标准化的训练环境和数据集，安装方式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Farama-Foundation/d4rl.git</span><br><span class="line">cd d4rl</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h2 id="1-3-安装测试">1.3 安装测试</h2><p><strong>简单测试：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;robomimic代码安装位置&gt;</span><br><span class="line">python examples/train_bc_rnn.py --debug</span><br></pre></td></tr></table></figure><blockquote><p>[!question]- 问题：<code>AttributeError: module 'mujoco_py' has no attribute 'builder'</code><br>目前我的解决方法如下：</p><ol><li>安装 mujoco-210，可参考<a href="https://github.com/HaofeiMa/E05_Robotiq-2f-85#quick-start">3(3) Prepare the mujoco environment</a></li><li>安装 mujoco-py：<code>pip install mujoco-py</code></li><li>安装 Cython：<code>pip install &quot;cython&lt;3&quot;</code></li></ol></blockquote><blockquote><p>[!question]- 问题：<code>Error compiling Cython file</code><br>解决方法如下：</p><ol><li><code>pip install &quot;cython&lt;3&quot;</code></li></ol></blockquote><blockquote><p>[!question]- 问题：<code>EGL_NOT_INITIALIZED</code><br>解决方法如下：</p><ol><li>替换<code>robosuite/robosuite/renderers/context/egl_context.py</code>的155行<code>self.free()</code>为<code>pass</code></li><li>注释掉<code>robosuite/robosuite/utils/binding_utils.py</code>的199行<code>self.gl_ctx.free()</code></li></ol></blockquote><p><strong>全面测试：</strong></p><p>运行一个调试环境，以确保robomimic安装正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;robomimic代码安装位置&gt;/test</span><br><span class="line">bash test.sh</span><br></pre></td></tr></table></figure><p>运行过程可能持续几分钟，命令行会出现很多passed，说明没有问题，中间如果出现和EGL有关的问题，可以先不用管，EGL是用于没有显示器的server版服务器进行渲染的时候使用的。</p><h1>二、实验复现</h1><h2 id="2-1-论文结果复现">2.1 论文结果复现</h2><p><strong>（1）数据集下载</strong></p><p>这里下载了 <code>tool_hang</code> 场景进行了测试，其它可用的场景参考<a href="https://robomimic.github.io/docs/datasets/robomimic_v0.1.html">官方文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;robomimic代码安装位置&gt;/robomimic/scripts</span><br><span class="line">python download_datasets.py --tasks tool_hang</span><br></pre></td></tr></table></figure><p><strong>（2）生成配置文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python generate_paper_configs.py --output_dir &lt;想要保存试验结果的绝对路径&gt;</span><br></pre></td></tr></table></figure><p>生成的配置文件默认在<code>robomimic/exps/paper</code>路径下，可以在<code>core.sh</code>文件中复制命令进行训练测试。</p><p><strong>（3）执行训练</strong></p><p>在<code>core.sh</code>中找到想要测试的命令，执行命令例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /home/mahaofei/Programs/Imitation/RoboMimic/robomimic/robomimic/scripts/train.py --config /home/mahaofei/Programs/Imitation/RoboMimic/robomimic/robomimic/exps/paper/core/tool_hang/ph/low_dim/bc.json</span><br></pre></td></tr></table></figure><p>训练生成的可视化视频默认在</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/experiment_results/core/bc/tool_hang/ph/low_dim/trained_models/core_bc_tool_hang_ph_low_dim/20231227161534/videos/ToolHang_epoch_100.mp4</span><br></pre></td></tr></table></figure><h2 id="2-2-数据集分析">2.2 数据集分析</h2><p><strong>（1）官方数据 hdf5 内容说明</strong></p><p>官方对每一项任务提供了两种类型的数据集：<code>image</code> 和 <code>low_dim</code>，但两种数据结构基本相同：</p><ul><li>data (group)<ul><li>total (attribute): 数据集中的 state-action 样本数量</li><li>env_args (attribute): 一个 json 字符串，包含环境的 metadata 和用于收集数据的相关参数，包含三个keys<ul><li>env_name: 要创建的环境或任务名称</li><li>env_type: robomimic 支持的环境类型之一</li><li>env_kwargs: 要传递到 env_name 的关键字参数的字典</li></ul></li><li>demo_0 (group): 第一个轨迹的组<ul><li>num_samples (attribute): 该轨迹中的 state-action 样本数</li><li>model_file (attribute): 对应 mujoco 模型的 xml 字符串，仅适用于 robosuite 数据集</li><li>states (dataset): 展开的 mujoco 状态，按时间排序，shape(N,D)，其中 N 是轨迹的长度，D 是状态向量的维度，对于非 robosuite 数据集，应该为空。</li><li>actions (dataset): 环境动作，按时间排序，shape(N,A)，其中 N 是轨迹的长度，A 是动作空间维度。</li><li>rewards (datasets): 完成信号，如果当前动作对应的状态代表 eposide 应该结束了，则为1</li><li>obs (group): 存储 observation 的键的组，每个键都是一个 dataset<ul><li>obs_key_1 (dataset): 第一个 observation key，该数据集名称和形状可能会不同</li><li>…</li></ul></li><li>next_obs (group): 下一个 observation 的组<ul><li>obs_key_1 (dataset): 第一个 observation key</li><li>…</li></ul></li></ul></li><li>demo_1 (group): 第二个轨迹的组</li><li>…</li></ul></li><li>mask (group): 存在于包含 filter keys 的数据集中<ul><li>filter_key_1: 第一个 filter key，例如列表[“demo_0”, “demo_19”, “demo_35”]</li></ul></li></ul><p><strong>（2）下载 raw、low_dim、image 三种格式的数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;你想保存数据集的位置&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载原始数据和 low_dim 数据</span></span><br><span class="line">wget http://downloads.cs.stanford.edu/downloads/rt_benchmark/tool_hang/ph/demo_v141.hdf5</span><br><span class="line">wget http://downloads.cs.stanford.edu/downloads/rt_benchmark/tool_hang/ph/low_dim_v141.hdf5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">cd robomimic/robomimic/scripts</span><br><span class="line">python download_datasets.py --tasks &lt;任务名称&gt; --dataset_types all --hdf5_types all --download_dir &lt;数据保存路径&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转换得到 image 数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意，如果训练image数据，需要修改对应json文件中crop_height和crop_width为76</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意，转换后数据文件可能在 10GB 左右，注意磁盘空间</span></span><br><span class="line">python dataset_states_to_obs.py --dataset=&lt;原始数据的路径&gt; --output_name=image_v141.hdf5  --done_mode 2 --camera_names agentview robot0_eye_in_hand sideview --camera_height 84 --camera_width 84</span><br></pre></td></tr></table></figure><p>下载 <code>image</code> 格式数据，使用 <code>download_datasets.py</code> 下载会提示无 url，从 raw 数据转换 image 在训练时会提示图片格式错误。经查找，在 <a href="https://robomimic.github.io/docs/v0.2/datasets/robomimic_v0.1.html">v2.0 文档</a>中提供了 image 格式数据，如有需要请从此处下载。</p><p>例如 robomimic 的 tool_hang 环境的 <code>image</code> 类型数据集的  <code>demo_0</code> 中内容如下：</p><ul><li><strong>actions</strong>: shape (n, 7)，n 为轨迹长度，7为动作维度</li><li><strong>dones</strong>: shape (n, )，n 为轨迹长度</li><li><strong>obs</strong><ul><li><strong>agentview_image</strong>: shape (n, 256, 256, 3)，agent 视角图像，分别对应(n, H, W, C)，n 为轨迹长度，H 为图像高，W 为宽，C 为图像通道数，所有图像需为 np.uint8 类型</li><li><strong>object</strong>: shape (n, 44)，n 为轨迹长度，三个物体 base, frame, tool 的位置，姿态，相对机械臂末端的位置姿态(pos3, quat4, to_eef_pos3, to_eef_quat4)，共计 3x14 个值，以及 frame_is_assembled 与 tool_on_frame 两个布尔值</li><li><strong>robot0_eef_pos</strong>: shape (n, 3)，机器人末端位置</li><li><strong>robot0_eef_quat</strong>: shape (n, 4)，机器人末端姿态四元数</li><li><strong>robot0_eef_vel_ang</strong>: shape (n, 3)，机器人末端角速度</li><li><strong>robot0_eef_vel_lin</strong>: shape (n, 3)，机器人末端线速度</li><li><strong>robot0_eye_in_hand_image</strong>: shape (n, 256, 256, 3)，机器人末端相机图像</li><li><strong>robot0_gripper_qpos</strong>: shape (n, 2)，末端夹爪动作状态，左右两侧</li><li><strong>robot0_gripper_qvel</strong>: shape (n, 2)，末端夹爪动作速度，左右两侧</li><li><strong>robot0_joint_pos</strong>: shape (n, 7)，机器人各关节转角</li><li><strong>robot0_joint_pos_cos</strong>: shape (n, 7)，机器人各关节转角 cos 值</li><li><strong>robot0_joint_pos_sin</strong>: shape (n, 7)，机器人各关节转角 sin 值</li><li><strong>robot0_joint_vel</strong>: shape (n, 7)，机器人各关节速度</li><li><strong>sideview_image</strong>: shape (n, 256, 256, 3)，侧方位相机图像</li></ul></li><li><strong>next_obs</strong><ul><li>同上</li></ul></li><li><strong>rewards</strong>: shape (n, )，n 为轨迹长度</li><li><strong>states</strong>: shape (n, 58)，n 为轨迹长度，58 是状态向量的维度，对于非 robosuite 数据集，应该为空</li></ul><p>而 <code>low_dim</code> 类型的数据集的中内容与 <code>image</code> 基本相同，只是 obs 中少了所有的 image。</p><p><strong>（3）数据集可视化</strong></p><p>使用 <code>playback_dataset.py</code> 脚本查看数据集轨迹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python playback_dataset.py --dataset &lt;path/to/.hdf5&gt; --video_path &lt;path/to/.mp4&gt; --n 5</span><br></pre></td></tr></table></figure><h1>三、自定义</h1><h2 id="3-1-生成自定义数据集">3.1 生成自定义数据集</h2><p>该项目中收集人类演示数据的脚本为 <code>robosuite/robosuite/scripts/collect_human_demonstrations.py</code>，其中可以指定环境，指定所使用的机器人，控制单臂还是双臂，用于收集演示数据的相机等等。</p><p>但是这些都是 robomimic 所提供的，如果我想要使用自己的机器人模型，在自定义环境中记录任务数据，则需要修改的较多，因此考虑在自己的 mujoco 环境中按照前文分析的 hdf5 数据格式直接生成数据。</p><blockquote><p>参考链接：</p><ol><li><a href="https://robomimic.github.io/docs/">Robotmimic 官方文档 (robomimic documentation)</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模仿学习 </tag>
            
            <tag> 机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【课程笔记】Stanford CS25 V2 - Robotics and Imitation Learning</title>
      <link href="/post/1aebe4e4.html"/>
      <url>/post/1aebe4e4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Video Link: <a href="https://www.youtube.com/watch?v=ct4tdyyNDY4">https://www.youtube.com/watch?v=ct4tdyyNDY4</a></p></blockquote><p>过去两年，由于大语言模型、语音技术、视觉技术的发展，机器人技术的研究思路发生了180度的转变。</p><h1>机器人基础模型</h1><p>目前在大量数据上进行大规模模型训练时，通常由两个比较重要的属性：</p><ul><li>涌现：当非常简单地事情在小范围发挥作用时，当扩大范围，它的表现会更好，例如更多的数据、更大的模型。</li><li>均质化：模型可以组合许多下游任务来实现泛化能力</li></ul><p>当然我们可能会思考一个问题，为什么目前还没有机器人领域的基础模型。不像音频、语言、图像等领域，这些领域已经出现了较为通用的基础模型，机器人技术的基础模型还没有人研究出来。</p><p>那么如果想要实现机器人的基础模型，可以如何做：</p><p><strong>（1）设计强化学习算法</strong></p><ol><li>利用高性能的架构，例如self-attention</li><li>利用比例法则，不仅要扩大模型大小，还有扩展计算，还需要扩大数据集语料库以及标记数量</li><li>数据集大小比数据质量更重要</li></ol><p><strong>（2）互联网规模的模型扩散</strong></p><ol><li>生成式模型在语言、编程、视觉、音频等领域已经展现出了涌现的能力，并且一次次超出了我们的预期，这个趋势在可见的未来中还会一直保持下去。</li><li>涌现和加速意味着这些模型可以“自己”变的更好</li></ol><p><strong>（3）从在线机器人学习转移到离线学习</strong></p><ol><li>目前的大模型都是在巨大规模的离线数据集上训练完成的</li></ol><h1>Google Brain 相关工作</h1><h2 id="过去工作">过去工作</h2><p><strong>（1）2016 - 机器人工厂</strong></p><ol><li><strong>强化学习</strong>：Google建立了一个包含7个Kuka机械臂的机器人工厂，7x24小时执行抓取动作，进行强化学习训练。</li><li><strong>Qt-Opt</strong>：Q-学习算法，接受视觉输入的同时进行连续控制。</li><li><strong>RL-CycleGan</strong>：将房展环境的图像转换为真实的图像，让机器人在显示世界中更好地完成任务。</li></ol><p><strong>（2）2020 - 厨房环境</strong></p><ol><li><strong>BC-Z</strong>：多任务模仿学习</li><li><strong>AW-Opt</strong>：将强化学习与模仿学习引导相结合</li></ol><p><strong>（3）2022</strong></p><p>遇到了一些问题，例如在一些场景任务中，成功率已经稳定到了50~70%，一些方法需要非常特定的数据分布，如果策略没有训练过当前的数据，那么任务很可能失败。为了解决这个问题，Google 进行了以下工作</p><ol><li>多任务模仿学习</li><li>使用大规模数据集</li></ol><h2 id="近期工作">近期工作</h2><p><strong>（1）RT-1</strong></p><p>主要聚焦于如何扩展模仿学习。</p><ol><li>使用一年半时间从13个机器人中收集了100k的演示数据，包括700个任务</li><li>使用BC-Z进行训练</li><li>由于基于Transformer的算法在处理图像时，现在还不足以支撑机器人学习中的高频率、实时性要求，因此希望数据集能够理解语言模型。</li></ol><p>从较高的层面来看，RT-1是一个机器人Transformer，它接受机器人摄像头的视觉输入，以及自然语言指令，仅仅使用transformer进行解码，分离目标物体类别，使用预训练的EfficientNet主干网络得到离散化动作。</p><p><strong>（2）SayCan</strong></p><p>机器人的技能能够是有限的，大语言模型也是受限制的，他不知道机器人的状态，不知道周围环境。</p><p>因此这项工作主要实现让语言模型说机器人的语言。</p><p><strong>（3）Inner-Monologue</strong></p><p>将环境的动态环境反馈加入到闭环中，也使用语言的API来传达环境中有什么。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模仿学习 </tag>
            
            <tag> 机器人 </tag>
            
            <tag> 课程笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows与Ubuntu双系统绑定同一个蓝牙设备（无需重新配对）</title>
      <link href="/post/e0777253.html"/>
      <url>/post/e0777253.html</url>
      
        <content type="html"><![CDATA[<h1>1、Ubuntu 下配对蓝牙设备</h1><p>会生成一个配置文件。</p><h1>2、Windows 下再配对蓝牙设备</h1><p>读取蓝牙配对信息，Windows下的蓝牙配对信息存储在注册表中，并且此信息需要使用特殊方法才能查看。</p><p>下载 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">PsTools</a>，将PSTools.zip 中的 PsExec.exe 或 PsExec64.exe 解压出来，并以管理员权限运行 cmd，<code>cd</code> 到<code>PsExec64.exe</code> 所在目录，使用下面的命令启动regedit.exe</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec64.exe -si regedit</span><br></pre></td></tr></table></figure><p>找到下面的蓝牙配对信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTHPORT\Parameters\Keys\【本机蓝牙 MAC】</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312132218479.png" alt="image.png"></p><p>可以看到其中有类型为<code>REG_BINARY</code>的值，每个值对应一个设备，将其名称和数据记下来，或者直接导出，我导出后用记事本打开如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTHPORT\Parameters\Keys\d4d853556b34]</span><br><span class="line">&quot;CentralIRK&quot;=hex:38,a5,32,96,6c,bf,c2,31,7b,e9,43,e0,b9,cc,9d,d6</span><br><span class="line">&quot;6468761a6934&quot;=hex:6b,bf,d8,14,d8,aa,2f,d8,f7,68,73,a7,83,64,6e,8f</span><br></pre></td></tr></table></figure><blockquote><p>此外如果是罗技设备，例如本人的罗技鼠标，则需要<strong>导出</strong> <code>【本机蓝牙 MAC】</code> 下的子项，项名称为罗技鼠标的 MAC 地址，项中的各个值则是需要填写到 Ubunut 中的内容<br><img src="https://img.mahaofei.com/img/202401261931186.png" alt="image.png"></p></blockquote><h1>3、修改Linux下的蓝牙配对信息</h1><h2 id="3-1-一般设备">3.1 一般设备</h2><p>Linux 下蓝牙设备的配对信息存储在 <code>/var/lib/bluetooth/【本机蓝牙 MAC】</code>目录下，例如 <code>/var/lib/bluetooth/D4:D8:53:55:6B:34</code>，MAC 地址中的字母全为大写，且含冒号分隔符。</p><p>进入该目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd /var/lib/bluetooth/D4\:D8\:53\:55\:6B\:34/</span><br></pre></td></tr></table></figure><p>可以看到系统已配对的蓝牙设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Victus-Ubuntu:/var/lib/bluetooth/D4:D8:53:55:6B:34# ll</span><br><span class="line">total 44</span><br><span class="line">drwx------ 7 root root  4096 12月 13 22:19 ./</span><br><span class="line">drwxr-xr-x 3 root root  4096 5月  13  2023 ../</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:19 64:68:76:1A:69:34/</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:19 A4:C1:38:AB:43:5C/</span><br><span class="line">drwx------ 2 root root 16384 12月 13 22:20 cache/</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:19 EC:B3:D5:3C:5F:92/</span><br><span class="line">drwx------ 2 root root  4096 12月 13 22:20 F9:E7:70:AD:8C:64/</span><br><span class="line">-rw------- 1 root root    50 12月 13 22:19 settings</span><br></pre></td></tr></table></figure><p>根据我们导出的reg文件，可以知道进入我们要配置的蓝牙鼠标的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd 64\:68\:76\:1A\:69\:34/</span><br></pre></td></tr></table></figure><p>我们需要修改的就是这个目录下的 info 文件，以我的为例，文件如下（这里已经改好了，只需要将Key换成windows下导出的注册表里面的key，具体就是win下的逗号删除小写变大写）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">Name=EDIFIER W820NB 双金标版</span><br><span class="line">Class=0x240404</span><br><span class="line">SupportedTechnologies=BR/EDR;</span><br><span class="line">Trusted=true</span><br><span class="line">Blocked=false</span><br><span class="line">Services=00001101-0000-1000-8000-00805f9b34fb;0000110b-0000-1000-8000-00805f9b34fb;0000110c-0000-1000-8000-00805f9b34fb;0000110d-0000-1000-8000-00805f9b34fb;0000110e-0000-1000-8000-00805f9b34fb;0000111e-0000-1000-8000-00805f9b34fb;66666666-6666-6666-6666-666666666666;edf00000-edfe-dfed-fedf-edfedfedfedf;</span><br><span class="line"></span><br><span class="line">[LinkKey]</span><br><span class="line">Key=6BBFD814D8AA2FD8F76873A783646E8F</span><br><span class="line">Type=4</span><br><span class="line">PINLength=0</span><br></pre></td></tr></table></figure><h2 id="3-2-罗技设备">3.2 罗技设备</h2><p>将 Windows 下的 IRK 字符<strong>倒序大写删除逗号</strong>，即为 Ubuntu 下的 IdentityResolvingKey</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;IRK&quot;=hex:d3,1f,03,20,e5,be,13,64,33,8b,63,09,d3,01,bd,33</span><br><span class="line"></span><br><span class="line">[IdentityResolvingKey]</span><br><span class="line">Key=33BD01D309638B6413BEE520031FD3</span><br></pre></td></tr></table></figure><p>Windows 下的 <strong>LTK</strong> <strong>大写删除逗号</strong>，即为 Ubuntu 下的 <strong>LontermKey</strong><br><strong>EDIV</strong> 需要<strong>转换成 10 进制</strong>，为 Ubuntu 的 <strong>EDiv</strong><br><strong>ERand</strong> 需要<strong>删除逗号并转换成 10 进制</strong>，为 Ubuntu 的 <strong>Rand</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;LTK&quot;=hex:ae,4b,59,52,fa,32,7d,2b,aa,0a,a7,de,33,ac,2b,20</span><br><span class="line">&quot;ERand&quot;=hex(b):cd,d7,f7,f8,01,f9,49,f2</span><br><span class="line">&quot;EDIV&quot;=dword:00006f5f</span><br><span class="line"></span><br><span class="line">[LongTermKey]</span><br><span class="line">Key=AE4B5952FA327D2BAA0AA7DE33AC20</span><br><span class="line">Authenticated=0</span><br><span class="line">EncSize=16</span><br><span class="line">EDiv=28511</span><br><span class="line">Rand=14832596542325082602</span><br></pre></td></tr></table></figure><p>然后重启电脑，可以直接连接蓝牙。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】机器人动作、轨迹、过程模仿</title>
      <link href="/post/5e168247.html"/>
      <url>/post/5e168247.html</url>
      
        <content type="html"><![CDATA[<h1>1 AW-Opt: Learning Robotic Skills with Imitation and Reinforcement at Scale</h1><blockquote><p><strong>标题</strong>：AW-Opt：通过大规模模仿和强化学习机器人技能<br><strong>作者团队</strong>：Google<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://awopt.github.io/">https://awopt.github.io/</a></p></blockquote><h2 id="1-1-目标问题">1.1 目标问题</h2><p>强化学习可以实现目标任务，但是需要大量自主数据收集。模仿学习只能学习和演示一样程度的动作。</p><p>本文探索如何最好的结合两种方法，并进行扩展。实现大规模机器人学习。</p><h2 id="1-2-方法">1.2 方法</h2><p><strong>（1）任务场景与基础算法</strong></p><p>本文以基于视觉的垃圾分类任务为例，机器人从不同对象类型（可回收物、不可回收对象）等垃圾箱中拾取特定类型的对象。</p><p>本文的算法为了研究IL+RL的扩展性，在QT-Opt和AWAC两种IL+RL算法的基础上进行研究。</p><p><strong>（2）正样本过滤</strong></p><p>两种基础算法性能不够好的原因可能有以下两点：</p><ul><li>探索过程中增加了大量的失败事件、掩盖了最初的成功演示</li><li>算法在学习有效的Q函数，对actor进行更新之前，会删除预训练初始化。</li></ul><p>为了解决这个问题，本文进行了以下两个修改：</p><ul><li>为critic使用优先缓冲区，其中一半来自于成功事件奖励</li><li>对actor使用正向过滤，仅对通过过滤器的样本进行更新</li></ul><p><strong>（3）混合 actor-critic 探索</strong></p><p>QT-Opt方法没有明确的actor，由于任务使用交叉熵利用critic来优化动作，因此可以视为隐式策略。</p><p>AWAC是一种actor-critic算法，通过对actor的动作采样来实现，而这种方式在训练初期，主要是critic进行学习，来确定哪些动作是好的。这种方式对于复杂的任务学习存在限制。</p><p>本文为了解决以上问题，结合两种算法，并比较了四种策略：仅actor探索、隐式critic策略、episode级随机切换策略（80%critic策略、20%actor）、step级随机切换策略、</p><h1>2 DexMV: Imitation Learning for Dexterous Manipulation from Human Videos</h1><blockquote><p><strong>标题</strong>：DexMV：模仿学习，从人类视频中进行灵巧操作<br><strong>作者团队</strong>：University of California San Diego<br><strong>期刊会议</strong>：ECCV<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/yzqin/dexmv-sim">https://github.com/yzqin/dexmv-sim</a></p></blockquote><h2 id="2-1-目标问题">2.1 目标问题</h2><p>由于多指机器人拥有高自由度关节、非线性驱动，因此需要大量的强化学习训练数据，而机器人数据收集困难，且仅使用仿真数据训练机器人运动也很不自然，能否利用人类与真实世界的交互经验来引导机器人？</p><h2 id="2-2-方法">2.2 方法</h2><p>设计了一个基于模仿学习的平台</p><ul><li>多指机器人复杂灵巧操作的模拟系统</li><li>记录人手执行相同任务的大规模演示（从视频中提取手部3D位置和物体姿态）</li><li>演示翻译方法：将人体动作转换为机器人演示</li></ul><p><img src="https://img.mahaofei.com/img/202312131522496.png" alt="image.png"></p><h3 id="2-2-1-姿态估计">2.2.1 姿态估计</h3><p><strong>物体位姿估计</strong>：使用在YCB数据集上训练的PVN3D实现物体6D位姿的估计。</p><p><strong>人手姿态估计</strong>：使用MANO模型表示人手关节，进行手部检测和实例分割，利用现有的模型估计手部关节。</p><h3 id="2-2-2-演示数据转换">2.2.2 演示数据转换</h3><p>常见的模仿学习算法使用==机器人状态和动作==作为训练数据，而不是人手姿态。并且人手和灵巧手的运动学模型也不同。</p><p><strong>（1）手部运动重定向</strong></p><p>给定视频中估计的人手姿态序列，将其重定向为机器人关节角度序列。改过程可视为优化问题。</p><p>在大多数操作任务中，人类和机器人都是指尖接触物体，因此保留手掌根的指尖的空间向量。</p><p>但是这样可能会导致手指弯曲信息丢失，导致手指穿透物体，因此考虑同时优化手掌根到中指骨的向量。</p><p><strong>（2）机器人动作估计</strong></p><p>手部运动重定向提供了手部姿态到机器人关节角度的转换，但是关节扭矩是位置的，因此通过逆动力学函数，将关节角度拟合到连续的关节轨迹函数中，计算扭矩。在这个过程中，需要保证q’‘’(t)加加速度尽可能小。</p><p><strong>（3）时间对齐</strong></p><p>录制的视频帧率为30Hz，模拟运行的频率为120Hz，因此在训练之前，需要进行时间对齐，以模拟频率对机器人动作q(t)进行采样。</p><h3 id="2-2-3-模仿学习">2.2.3 模仿学习</h3><p>本文使用转换后的演示进行模仿学习，不使用行为克隆方法，而是使用模仿学习算法，并将演示合并到强化学习中。</p><p>本文考虑使用 $&lt;S, A, P, R, \gamma&gt;$ 的马尔科夫决策链，其中：</p><ul><li>$S$: 状态空间</li><li>$A$: 动作空间</li><li>$P(s_{t+1}|s_t, a_t)$: 是状态转移函数，在$t+1$步，给定动作$a_t$时，下一个状态$s_{t+1}$的概率密度</li><li>$R(S, a)$: 奖励函数</li><li>$\gamma$: 折扣因子</li></ul><p>强化学习的目的是最大化策略$\pi(a|s)$下的预期奖励。给定演示轨迹${(s_i, a_i)}^n_{i=1}$，使用该轨迹和奖励，优化策略$\pi$。</p><p>本文使用<strong>生成对抗模仿学习GAIL</strong>，这是一种使用state-action动作密度匹配来学习策列的SOTA IL方法。通过最大限度的减小演示和动作的距离函数，实现动作模仿。</p><p>本文使用<strong>演示增强策略梯度</strong>进行强化学习。</p><h2 id="2-3-总结">2.3 总结</h2><ol><li>将真实世界人手姿态转换为机器人动作，加上物体位姿估计，作为演示数据用于后续模仿学习与强化学习。</li><li>使用生成对抗模仿学习GAIL</li><li>使用演示增强策略梯度进行强化学习</li></ol><h1>3 Learning and Retrieval from Prior Data for Skill-based Imitation Learning</h1><blockquote><p><strong>标题</strong>：基于技能的模仿学习的先验数据的学习和检索<br><strong>作者团队</strong>：The University of Texas at Austin<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://ut-austin-rpl.github.io/sailor">https://ut-austin-rpl.github.io/sailor</a></p></blockquote><h2 id="3-1-目标问题">3.1 目标问题</h2><p>模仿学习由于需要进行监督学习和较弱的泛化能力，因此可扩展性有限。</p><p>本文研究如何使用其他任务的先验数据，来稳定高效地学习新任务。</p><h2 id="3-2-方法">3.2 方法</h2><p>本文提出了一种基于技能的模仿学习框架，从先前的数据中提取运动技能，并随后调用这些学到的技能的目标函数策略。</p><p><strong>（1）学习可预测的技能表示</strong></p><p>通过使用变分自动编码器VAE编码小段轨迹来学习技能表示。为了提高技能的可预测性，将小段轨迹使用LSTM编码器编码为潜在技能的高斯分布，解码器也是一个LSTM网络。</p><p>对于每个时间步，将潜在特征z和给定的观察o，解码为动作a。</p><p><strong>（2）基于检索的策略学习</strong></p><p>为了提高任务策略的学习效果，从先前的数据集中检索与目标任务相关的数据。</p><p>策略学习阶段，使用LSTM策略通过观察历史的潜在技能，预测输出接下来要执行的技能z，这种方式可以利用丰富多样的先验交互知识，将其融入到策略中，从而在新环境中更有效的执行任务。</p><h2 id="3-3-总结">3.3 总结</h2><p>使用变分自动编码器VAE处理子轨迹，形成一致的潜在技能表示。</p><p>使用LSTM编码解码技能表示，根据状态预测需要输出的技能。</p><h1>4 VIOLA: Imitation Learning for Vision-Based Manipulation with Object Proposal Priors</h1><blockquote><p><strong>标题</strong>：VIOLA：使用对象提议先验进行基于视觉的操作的模仿学习<br><strong>作者团队</strong>：The University of Texas at Austin<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://ut-austin-rpl.github.io/VIOLA">https://ut-austin-rpl.github.io/VIOLA</a></p></blockquote><h2 id="4-1-目标问题">4.1 目标问题</h2><p>一种先进的模仿学习算法。</p><h2 id="4-2-方法">4.2 方法</h2><p>本文实现了一种基于视觉的机器人操作任务模仿学习算法：</p><ul><li>使用预训练的视觉模型生成通用的对象表示；</li><li>采用基于Transformer的策略，来推理这些表示，根据视觉预测动作；</li></ul><p><strong>（1）构建面向对象的表示</strong></p><ol><li>对象识别：使用预训练的RPN区域建议网络在工作空间图像上生成对象建议，并选择执行度最高的前K个建议。</li><li>对象特征表示：包含区域特征和上下文特征<ol><li>区域特征：为每个建议区域设计视觉特征和位置特征，使用ROI Align从工作空间图像的ResNet18编码的特征途中提取特征；</li><li>上下文特征，包括全局特征、手眼相机图像特征和机器人状态的本体感知特征组成；</li></ol></li><li>时间组合，将过去H+1步的特征和时间编码组合，构成面向对象的表示，来获得对象状态的时间依赖性和动态变化。</li></ol><p><strong>（2）基于Transformer的策略</strong></p><p>使用多个Transformer编码器，处理一系列特征向量。</p><p>该策略网络将面向对象的区域特征和上下文特征作为输入token，并加入了一个动作token，通过动作监督学习，能够关注任务相关的区域。</p><p>最后利用两层全连接层和高斯混合模型输出动作。</p><h2 id="4-3-总结">4.3 总结</h2><ol><li>构建面向对象的特征（图像区域特征+机器人状态特征）</li><li>使用Transformer进行特征编码与预测</li><li>使用高斯混合模型输出动作。</li></ol><h1>5 SEIL: Simulation-augmented Equivariant Imitation Learning</h1><blockquote><p><strong>标题</strong>：SEIL: Simulation-augmented Equivariant Imitation Learning<br><strong>作者团队</strong>：Northeastern University<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://saulbatman.github.io/project/seil/">https://saulbatman.github.io/project/seil/</a></p></blockquote><h2 id="5-1-目标问题">5.1 目标问题</h2><p>机器人模仿学习中，样本获取非常困难，因为需要与现实世界进行交互。为了解决这个问题，本文在图像数据增强的基础上进行模仿学习。</p><h2 id="5-2-方法">5.2 方法</h2><p><strong>（1）数据增强</strong></p><p>本文实现了一种专家数据增强方法Transition Simulation。通过将观察到的点云投影到模拟的机械臂姿态中，生成新的观察图像，从而模拟专家的state-action来增加数据多样性。</p><p><strong>（2）等变行为克隆</strong></p><p>利用机器人操作过程中的O(2)对称性（所有平面旋转和反射对称性），利用Steerable CNNs将策略自动泛化到不同的O(2)状态中。</p><h2 id="5-3-总结">5.3 总结</h2><p>专家数据增强+等变行为克隆</p><h1>6 Waypoint-Based Imitation Learning for Robotic Manipulation</h1><blockquote><p><strong>标题</strong>：基于路标点的机器人操作模仿学习<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/lucys0/awe">https://github.com/lucys0/awe</a></p></blockquote><h2 id="6-1-目标问题">6.1 目标问题</h2><p>模仿学习容易出现错误，特别是在执行复杂操作时。</p><p>使用路标点可以减少模仿学习中的错误，但是一般路标点需要认为监督，本文则是提出了一种自动生成路标点的方法。提高了模仿学习的成功率。</p><h2 id="6-2-方法">6.2 方法</h2><p>本文设计了一种自动路标点提取方法，这是一个预处理模块，因此很容易添加到其它行为克隆算法中。本文举例了两种先进的模仿学习算法：扩散策略和基于Transformer的动作。</p><p><strong>（1）重建损失</strong></p><p>定义了一种损失：给定路标点后重建轨迹的质量，通过最小化原始轨迹与根据路标点重建的轨迹之间的偏差，来使得路标点能尽可能代替真实轨迹。</p><p><strong>（2）路径点选择动态规划</strong></p><p>使用一种简单而动态规划算法，用于选择最小数量的路径点，并保证重建的误差满足要求。</p><h2 id="6-3-总结">6.3 总结</h2><p>一种自动路标点提取算法，用于对行为克隆数据进行预处理。</p><h1>7 Mobile ALOHA: Learning Bimanual Mobile Manipulation with Low-Cost Whole-Body Teleoperation</h1><blockquote><p><strong>标题</strong>：Mobile ALOHA：通过低成本全身远程操作学习双手移动操作<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：无<br><strong>时间</strong>：2024<br><strong>代码</strong>：<a href="https://mobile-aloha.github.io/">https://mobile-aloha.github.io/</a></p></blockquote><h2 id="7-1-目标问题">7.1 目标问题</h2><p>目前的大多数从人类演示中模仿学习的机器人技术集中在桌面操作，缺乏一般有用的任务所需的机动性和灵活性，本文主要是开发了一个移动机器人，实现移动+双手的模仿学习。</p><h2 id="7-2-论文中提到的学习方法">7.2 论文中提到的学习方法</h2><p><strong>（0）基础模仿学习算法</strong></p><ol><li>ACT: Learning fine-grained bimanual manipulation with low-cost hardware</li><li>扩散策略: Diffusion policy: Visuomotor policy learning via action diffusion</li><li>VINN: The surprising effectiveness of representation learning for visual imitation</li></ol><p><strong>（1）BC 的改进</strong></p><p>行为克隆 BC 与各种架构相结合</p><ol><li>Rt-1: Robotics transformer for real-world control at scale</li><li>Bc-z: Zero-shot task generalization with robotic imitation learning</li><li>What matters in learning from offline human demonstrations for robot manipulation</li><li>Behavior transformers: Cloning k modes with one stone</li></ol><p>使用新的训练目标</p><ol><li>Roboagent: Towards sample efficient robot manipulation with semantic augmentations and action chunking</li><li>Diffusion policy: Visuomotor policy learning via action diffusion</li><li>Implicit behavioral cloning</li><li>The surprising effectiveness of representation learning for visual imitation</li><li>Learning fine-grained bimanual manipulation with low-cost hardware</li></ol><p>正则化</p><ol><li>Vision-based multi-task manipulation for inexpensive robots using end-to-end learning from demonstration</li></ol><p>Motor Primitives</p><ol><li>Hierarchical neural dynamic policies</li><li>Dynamical movement primitives: learning attractor models for motor behaviors</li><li>Learning motor primitives for robotics</li><li>Using probabilistic movement primitives in robotics</li><li>Learning and generalization of motor skills by learning from demonstration</li><li>Learning periodic tasks from human demonstrations</li></ol><p>数据预处理</p><ol><li>Waypoint-based imitation learning for robotic manipulation</li></ol><p><strong>（2）多任务或少镜头模仿学习</strong></p><ol><li>Transformers for one-shot visual imitation</li><li>One-shot imitation learning</li><li>Learning manipulation skills from a single demonstration</li><li>One-shot visual imitation learning via meta-learning</li><li>Task-embedded control networks for few-shot imitation learning</li><li>Coarse-to-fine imitation learning: Robot manipulation from a single demonstration</li><li>Demonstrate once, imitate immediately (dome): Learning visual servoing for one-shot imitation learning</li><li>One-shot imitation from observing humans via domain-adaptive metalearning</li></ol><p><strong>（3）语言条件的模仿学习</strong></p><ol><li>Rt-1: Robotics transformer for real-world control at scale</li><li>Bc-z: Zero-shot task generalization with robotic imitation learning</li><li>Cliport: What and where pathways for robotic manipulation</li><li>Perceiver-actor: A multi-task transformer for robotic manipulation</li></ol><p><strong>（4）从演示数据模仿</strong></p><ol><li>From play to policy: Conditional behavior generation from uncurated robot data</li><li>Learning latent plans from play</li><li>Latent plans for task-agnostic offline reinforcement learning</li><li>Mimicplay: Longhorizon imitation learning by watching human play</li></ol><p><strong>（5）使用人类视频模仿</strong></p><ol><li>Learning generalizable robotic reward functions from&quot; in-the-wild&quot; human videos</li><li>Model-based inverse reinforcement learning from visual demonstrations</li><li>Perceptual values from observation</li><li>R3m: A universal visual representation for robot manipulation</li><li>Real-world robot learning with masked visual pre-training</li><li>Concept2robot: Learning manipulation concepts from instructions and human demonstrations</li><li>Avid: Learning multi-stage tasks via pixel-level translation of human videos</li><li>Learning by watching: Physical imitation of manipulation skills from human videos</li></ol><p><strong>（6）针对特定任务的模仿学习</strong></p><ol><li>Coarse-to-fine imitation learning: Robot manipulation from a single demonstration</li><li>Perceiver-actor: A multi-task transformer for robotic manipulation</li><li>Transporter networks: Rearranging the visual world for robotic manipulation</li></ol><p><strong>（7）针对模仿学习的通用化用于新的场景或对象</strong></p><ol><li>Rt-1: Robotics transformer for real-world control at scale</li><li>Rt-2: Vision-language-action models transfer web knowledge to robotic control</li><li>Bridge data: Boosting generalization of robotic skills with cross-domain datasets</li><li>Bc-z: Zero-shot task generalization with robotic imitation learning</li><li>Robot peels banana with goalconditioned dual-action deep imitation learning</li></ol><p><strong>（8）从不同但类似的机器人上收集数据模仿</strong></p><ol><li>Robocat: A self-improving foundation agent for robotic manipulation</li><li>Open X-Embodiment: Robotic learning datasets and RT-X models</li><li>In Towards Generalist Robots: Learning Paradigms for Scalable Skill Acquisition</li><li>Octo: An open-source generalist robot policy</li></ol><h2 id="7-3-总结">7.3 总结</h2>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 模仿学习 </tag>
            
            <tag> 机器人动作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【实验准备】MuJoCo导入自定义机器人</title>
      <link href="/post/f67206dd.html"/>
      <url>/post/f67206dd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本实验所配置的模型已开源至 <a href="https://github.com/HaofeiMa/E05_Robotiq-2f-85">Github: HaofeiMa/E05_Robotiq-2f-85</a></p></blockquote><h1>1 模型准备</h1><h2 id="1-1-机器人Solidworks模型转URDF">1.1 机器人Solidworks模型转URDF</h2><p>本仿真实验使用<a href="https://www.hansrobot.com/service/download/3dmoxing?pagenum=3">大族E05机器人</a>和<a href="https://robotiq.com/products/2f85-140-adaptive-robot-gripper">Robotiq 2f-85夹爪</a></p><p>该部分参考<a href="https://www.bilibili.com/video/BV1Tx411o7rH">以下视频</a></p><iframe src="//player.bilibili.com/player.html?aid=56651666&bvid=BV1Tx411o7rH&cid=98972250&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="height:100%;width:100%; aspect-ratio: 16 / 9;"> </iframe><p>首先下载机器人模型，并转换为URDF。</p><p><strong>（1）安装sw_urdf_exporter插件</strong></p><p>下载sw_urdf_exporter插件：<a href="http://wiki.ros.org/sw_urdf_exporter">http://wiki.ros.org/sw_urdf_exporter</a>，注意下载最新的就行，最新的也支持以前版本的Solidworks。</p><p>关闭 Solidworks。</p><p>运行 <a href="https://github.com/ros/solidworks_urdf_exporter/releases">sw2urdfSetup.exe</a>，自行安装即可。</p><p><strong>（2）为机器人添加基准轴（旋转轴）</strong></p><p><img src="https://img.mahaofei.com/img/202312041343070.png" alt="image.png"></p><p>以此选择六个圆柱面，确定六个旋转轴方向。</p><p><img src="https://img.mahaofei.com/img/202312041401387.png" alt="image.png"></p><p><strong>（3）导出URDF</strong></p><p>查看是否有【工具-最下面File-Export as URDF】，如果有的话，直接点击打开，如果没有，则打开【工具-插件】，在最下面打开Sw2URDF插件的两个√。</p><p>按照以下过程，创建base_link和link1-6</p><p><img src="https://img.mahaofei.com/img/202312041434677.png" alt="image.png"></p><p>然后点击Preview and Export</p><p><img src="https://img.mahaofei.com/img/202312041439265.png" alt="image.png"></p><p>然后点击Next和Export URDF and Mesh，它会将我们的URDF模型以功能包的形式保存到设置的位置。</p><p><strong>注意创建完成后，一定要检查最后一个坐标系是否是在机器人末端连接法兰的中心，因为后续添加夹爪需要这个坐标系，如果不是，需要自己手动调整坐标系的位置，重新生成URDF</strong></p><h2 id="1-2-ROS-中查看模型">1.2 ROS 中查看模型</h2><blockquote><p>不需要使用 Gazebo 的可直接跳到第 2 节（2 模型导入 Mujoco）</p></blockquote><p>创建一个工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p catkin_robot/src</span><br><span class="line">cd catkin_robot/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p>将功能包复制到<code>src</code>目录下</p><p>回到 <code>catkin_robot</code> 目录下，编译工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行测试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05 display.launch</span><br></pre></td></tr></table></figure><p>将 <code>Fixed Frame</code> 改为 <code>base_link</code>，点击左下角的 <code>Add</code>，添加一个 <code>Robot Model</code>，可以看到机器人正常显示在 Rviz 界面中，拖动进度条即可控制机械臂各关节运动。</p><p><img src="https://img.mahaofei.com/img/202312041606763.png" alt="image.png"></p><h2 id="1-3-添加-Robotiq-2f-85-夹爪">1.3 添加 Robotiq 2f-85 夹爪</h2><p><strong>（1）准备夹爪环境</strong></p><p>进入工作空间的src目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">git clone https://github.com/ros-industrial/robotiq.git</span><br></pre></td></tr></table></figure><p>在自己的机械臂的功能包的urdf文件夹中，新建一个<code>common.gazebo.xacro</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src/e05/urdf</span><br><span class="line">gedit common.gazebo.xacro</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;ros_control&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_control.so&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了方便表示，我在<code>e05.urdf</code>最后添加了一个<code>ee_link</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;ee_link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- You can use any simple geometry like a sphere for visualization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- Choose a color for visualization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;ee_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;ee_link&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再新建一个<code>xacro</code>文件，（例如我的机械臂功能包名字为e05）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit e05.xacro</span><br></pre></td></tr></table></figure><p>添加如下内容，注意修改<code>Gazebo支持</code>和<code>E05机械臂</code>部分自己的机械臂功能包名称，以及<code>夹爪与机械臂连接</code>部分的第一行的parent，我这里连接在了link6也就是末端上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;e05&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">&quot;transmission_hw_interface&quot;</span> <span class="attr">default</span>=<span class="string">&quot;hardware_interface/PositionJointInterface&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- E05机械臂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find e05)/urdf/e05.urdf&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Gazebo 支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find e05)/urdf/common.gazebo.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载gazebo中需要使用的模型 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- macros for transmission --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;transmission_block&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;motor1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Transmissions for ros control --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint6&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find e05)/urdf/e05.gazebo.xacro&quot; /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 机器人固定在世界坐标系下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;world_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;world&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span> = <span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Robotiq 2F-85夹爪 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find robotiq_2f_85_gripper_visualization)/urdf/robotiq_arg2f_85_macro.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find robotiq_85_description)/urdf/robotiq_85_gripper.urdf.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_grasp_fix&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_grasp_fix.so&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arm</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;arm_name&gt;应该是一个单独的名字，不能和别的任何关节同名 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arm_name</span>&gt;</span>ur5_gripper<span class="tag">&lt;/<span class="name">arm_name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;palm_link&gt;是和手指相连的关节 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">palm_link</span>&gt;</span>link6<span class="tag">&lt;/<span class="name">palm_link</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;gripper_link&gt;是会检测碰撞的关节 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_finger_tip_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_finger_tip_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_inner_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_inner_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">arm</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">forces_angle_tolerance</span>&gt;</span>150<span class="tag">&lt;/<span class="name">forces_angle_tolerance</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 检测频率 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>130<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 检测为抓取状态的接触次数阈值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">grip_count_threshold</span>&gt;</span>2<span class="tag">&lt;/<span class="name">grip_count_threshold</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_grip_count</span>&gt;</span>8<span class="tag">&lt;/<span class="name">max_grip_count</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 释放时的容忍度，超过这个就会把物体放下。数值越大，需要把夹爪打开更大才能释放物体 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">release_tolerance</span>&gt;</span>0.005<span class="tag">&lt;/<span class="name">release_tolerance</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">disable_collisions_on_attach</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disable_collisions_on_attach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contact_topic</span>&gt;</span>__default_topic__<span class="tag">&lt;/<span class="name">contact_topic</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将夹爪实例化，并设置夹爪和机械臂的关系（连接在tool0上） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:robotiq_85_gripper</span> <span class="attr">prefix</span>=<span class="string">&quot;&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;ee_link&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 $&#123;-pi/2&#125; 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:robotiq_85_gripper</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 相机实例化，然后设置仿真位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find realsense_ros_gazebo)/xacro/depthcam.xacro&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;xacro:realsense_d435 sensor_name=&quot;d435&quot; parent_link=&quot;tool0&quot; rate=&quot;10&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;origin rpy=&quot;0 $&#123;-pi/2&#125; 0 &quot; xyz=&quot;-0.1 0 0&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/xacro:realsense_d435&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改原来的launch文件，这里我为了后续方便，将原来的<code>display.launch</code>重命名了<code>display_e05_with_gripper.launch</code>，这里主要修改<code>&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro '$(find e05)/urdf/e05.xacro'&quot; /&gt;  </code>这一行，添加刚刚创建的xacro文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find e05)/urdf/e05.xacro&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro &#x27;$(find e05)/urdf/e05.xacro&#x27;&quot;</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find e05)/urdf.rviz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）Rviz中查看机器人</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_motion</span><br><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05 display_e05_with_gripper.launch</span><br></pre></td></tr></table></figure><p>左下角Add，添加机器人模型RobotModel。</p><p>左侧Fixed Frame选择base_link，即可看到机器人了。</p><p><img src="https://img.mahaofei.com/img/202312051357909.png" alt="image.png"></p><p><strong>（3）Gazebo中查看机器人</strong></p><p>创建一个<code>gazebo_e05_with_gripper.launch</code>文件，内容参考如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span> <span class="attr">doc</span>=<span class="string">&quot;Starts gazebo gui&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span> <span class="attr">doc</span>=<span class="string">&quot;Starts gazebo in paused mode&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 启动仿真环境 后续有环境修改，可以替换此处的worlds/empty.world，改为例如&quot;$(find ur_gazebo)/worlds/table_custom.world&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.world&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载TF --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;tf_footprint_base&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0 base_link base_footprint 40&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 启动机器人 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find e05)/launch/display_e05_with_gripper.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将 robot_description 发送到 gazebo 中生成机器人 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;node name=&quot;spawn_model&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; args=&quot;-file $(find e05)/urdf/e05.urdf -urdf -model e05&quot; output=&quot;screen&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;spawn_gazebo_model&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -param robot_description -model robot -z 0&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;fake_joint_calibration&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rostopic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rostopic&quot;</span> <span class="attr">args</span>=<span class="string">&quot;pub /calibrated std_msgs/Bool true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时启动<code>launch</code>文件，可以看到gazebo环境中机器人。</p><p><img src="https://img.mahaofei.com/img/202312051949512.png" alt="image.png"></p><hr><p><strong>下面的创建moveit驱动，在mujoco中不需要，请直接跳到 2 模型导入mujoco</strong></p><h2 id="1-4-创建MoveIt驱动">1.4 创建MoveIt驱动</h2><p>此部分参考<a href="https://blog.csdn.net/Tepmoe/article/details/119533792">该文章</a>。</p><p>启动moveit设置助手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun moveit_setup_assistant moveit_setup_assistant</span><br></pre></td></tr></table></figure><p>选择Create New Moveit Configuration Package，选择自己的<code>e05.xacro</code>文件，点击<code>Load Files</code></p><p><img src="https://img.mahaofei.com/img/202312051459862.png" alt="image.png"></p><p>左侧第二个的<code>Self-Collisions</code>是检查碰撞，一定将所有有可能发生碰撞的都勾选上，不然后续会出错。</p><p><img src="https://img.mahaofei.com/img/202312051948359.png" alt="image.png"></p><p>第三个<code>Virtual Joints</code>一般也不需要。</p><p>第四个<code>Planning Groups</code>是最重要的，我们需要设置，点击<code>Add Group</code>，分别配置机器人和末端夹爪。</p><p>机械臂：</p><ul><li>Group Name一般填manipulator就行</li><li>运动学求解器，选择kdl</li><li>路径规划算法，默认选择RRT Star就行</li><li>点击<code>Add Kin. Chain</code>，Baselink选择 base_link，Tiplink选择ee_link</li></ul><p><img src="https://img.mahaofei.com/img/202312051507765.png" alt="image.png"></p><p>末端夹爪的Group Name填上gripper，其它的都不用选。</p><p>第五个<code>Robot Poses</code>可以添加一些常用位置，便于我们快速使机器人运动到这些位置，例如</p><ul><li>up：机器人初始的竖直向上</li><li>pick：机器人准备夹取</li><li>open：夹爪打开</li><li>close：夹爪关闭</li></ul><p><img src="https://img.mahaofei.com/img/202312051513180.png" alt="image.png"></p><p>第六个<code>End Effectors</code>，按下图设置就行</p><p><img src="https://img.mahaofei.com/img/202312051533929.png" alt="image.png"></p><p>点击<code>Controllers</code>，点击左上角自动生成</p><p><img src="https://img.mahaofei.com/img/202312051534681.png" alt="image.png"></p><p>点击倒数第二个<code>Author Information</code>，填写名字和邮箱，不一定是真实的，但是不填无法生成功能包</p><p>最后<code>Generate Package</code>就可以了（在src目录下新建一个<code>e05_moveit</code>文件夹，选择此文件夹生成）</p><p>测试rviz是否能控制机器人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05_moveit demo.launch</span><br></pre></td></tr></table></figure><p>测试gazebo是否能联动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch e05_moveit demo_gazebo.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312052212812.png" alt="image.png"></p><p>测试时遇到了<strong>Rviz中的机械臂可以正常做规划和执行，但是Gazebo中机械臂没有反应</strong>的问题，解决方法参考<a href="https://blog.csdn.net/qq_50598558/article/details/114702163">此文章</a></p><h1>2 模型导入Mujoco</h1><h2 id="2-1-修改URDF">2.1 修改URDF</h2><p>在现有模型的xacro或urdf中的开头，添加下面的tag</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mujoco</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">compiler</span> </span></span><br><span class="line"><span class="tag"><span class="attr">meshdir</span>=<span class="string">&quot;../meshes_mujoco/&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">balanceinertia</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">discardvisual</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mujoco</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个文件夹<code>e05/meshes_mujoco</code>，将所有模型的stl文件放到这个文件夹下。</p><p>从xacro文件生成urdf文件的命令（如果有urdf文件则不需要此步）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro --inorder e05.xacro &gt; e05.urdf</span><br></pre></td></tr></table></figure><p>检查urdf文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf e05.urdf</span><br></pre></td></tr></table></figure><p>在RViz中可视化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch e05 display.launch model:=path/to/your/urdf/file</span><br></pre></td></tr></table></figure><h2 id="2-2-生成基本模型">2.2 生成基本模型</h2><p>在确认URDF模型没有问题后，进入MuJoCo的可执行文件夹内执行命令进行转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.mujoco/mujoco210/bin</span><br></pre></td></tr></table></figure><p>官方说明可以转换成三种模型<code>.mjb/.txt/.xml</code>，我们一般用xml的格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./compile /path/to/model.urdf /path/to/model.xml</span><br></pre></td></tr></table></figure><p>测试生成的基本模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./simulate /path/to/model.xml</span><br></pre></td></tr></table></figure><p>可以看到我们的机器人出现在了仿真环境中，虽然会发现我们的模型直接瘫倒，但是这是因为没有添加actuator等配置。</p><p><img src="https://img.mahaofei.com/img/202312060913373.png" alt="image.png"></p><p>由于夹爪出现问题，一直无法使用，因此替换了<a href="https://github.com/vikashplus/robotiq_sim">vikashplus/robotiq_sim</a>的夹爪。</p><p>添加完成后的<code>e05_mujoco.xml</code>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mujoco</span> <span class="attr">model</span>=<span class="string">&quot;e05&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">compiler</span> <span class="attr">angle</span>=<span class="string">&quot;radian&quot;</span> <span class="attr">meshdir</span>=<span class="string">&quot;../meshes_mujoco/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span> <span class="attr">njmax</span>=<span class="string">&quot;500&quot;</span> <span class="attr">nconmax</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载 E05 机械臂模型与基本配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">asset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/base_link.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link1.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link2&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link2.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link3&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link3.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link4&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link4.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link5&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link5.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mesh</span> <span class="attr">name</span>=<span class="string">&quot;link6&quot;</span> <span class="attr">file</span>=<span class="string">&quot;e05/link6.STL&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">texture</span> <span class="attr">type</span>=<span class="string">&quot;skybox&quot;</span> <span class="attr">builtin</span>=<span class="string">&quot;gradient&quot;</span> <span class="attr">rgb1</span>=<span class="string">&quot;0.3 0.5 0.7&quot;</span> <span class="attr">rgb2</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;512&quot;</span> <span class="attr">height</span>=<span class="string">&quot;3072&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;texture builtin=&quot;flat&quot; height=&quot;1278&quot; mark=&quot;cross&quot; markrgb=&quot;1 1 1&quot; name=&quot;texgeom&quot; random=&quot;0.01&quot; rgb1=&quot;0.8 0.6 0.4&quot; rgb2=&quot;0.8 0.6 0.4&quot; type=&quot;cube&quot; width=&quot;127&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;material name=&quot;geom&quot; texture=&quot;texgeom&quot; texuniform=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">texture</span> <span class="attr">type</span>=<span class="string">&quot;2d&quot;</span> <span class="attr">name</span>=<span class="string">&quot;groundplane&quot;</span> <span class="attr">builtin</span>=<span class="string">&quot;checker&quot;</span> <span class="attr">mark</span>=<span class="string">&quot;edge&quot;</span> <span class="attr">rgb1</span>=<span class="string">&quot;0.2 0.3 0.4&quot;</span> <span class="attr">rgb2</span>=<span class="string">&quot;0.1 0.2 0.3&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">markrgb</span>=<span class="string">&quot;0.8 0.8 0.8&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;groundplane&quot;</span> <span class="attr">texture</span>=<span class="string">&quot;groundplane&quot;</span> <span class="attr">texuniform</span>=<span class="string">&quot;true&quot;</span> <span class="attr">texrepeat</span>=<span class="string">&quot;5 5&quot;</span> <span class="attr">reflectance</span>=<span class="string">&quot;0.2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">asset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">damping</span>=<span class="string">&#x27;200&#x27;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">default</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">damping</span>=<span class="string">&#x27;100&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 加载 Robotiq-2f-85 夹爪与基本配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;robotiq-2f-85-assets.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 机器人本体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">worldbody</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 仿真环境设置定义 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;body pos=&quot;-0.16 0.90 0.02&quot; euler=&quot;4.71238898 0 3.14159265&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;body euler=&quot;0 -0.82 0&quot;&gt;</span></span><br><span class="line"><span class="comment">                &lt;camera name=&quot;workbench_camera&quot; euler=&quot;0 0 0&quot; fovy=&quot;60&quot; pos=&quot;0 0 0.5&quot; /&gt;</span></span><br><span class="line"><span class="comment">            &lt;/body&gt;</span></span><br><span class="line"><span class="comment">        &lt;/body&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">light</span> <span class="attr">diffuse</span>=<span class="string">&quot;0.6 0.6 0.6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">light</span> <span class="attr">diffuse</span>=<span class="string">&quot;0.6 0.6 0.6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 -0.3 3&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;0 0.2 -0.8&quot;</span> <span class="attr">directional</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;light cutoff=&quot;100&quot; diffuse=&quot;0.5 0.5 0.5&quot; dir=&quot;-0 0 -1.3&quot; directional=&quot;true&quot; exponent=&quot;1&quot; pos=&quot;0 0 1.3&quot; specular=&quot;.1 .1 .1&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">name</span>=<span class="string">&quot;floor&quot;</span> <span class="attr">size</span>=<span class="string">&quot;0 0 0.05&quot;</span> <span class="attr">type</span>=<span class="string">&quot;plane&quot;</span> <span class="attr">material</span>=<span class="string">&quot;groundplane&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 整个运动链 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.501961 0.501961 0.501961 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.501961 0.501961 0.501961 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link1&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0.0735&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;-0.0218175 -1.34618e-05 0.0953928&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.696024 -0.147787 -0.14991 0.686467&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;2.58559&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.0143616 0.0141793 0.00506835&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link1&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link2&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0.1465&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.5 -0.5 -0.5 0.5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;4.42659e-06 -0.15814 0.130501&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.491565 0.508215 -0.508335 0.491606&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;1.21311&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.0159807 0.0154676 0.00149746&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 -1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link3&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 -0.38 0&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.707107 0 0 0.707107&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;-0.0414786 1.14213e-05 0.0194164&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.601987 0.371892 0.373044 0.600122&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;1.53239&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00608826 0.00587729 0.00215529&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 -1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.866667 0.866667 0.890196 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link3&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.866667 0.866667 0.890196 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link3&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link4&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.5 -0.5 0.5 -0.5&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;3.8238e-05 -0.0589656 -0.257081&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.988248 -0.152858 -0.000415939 -0.000860755&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;0.475189&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00538322 0.0052745 0.000778119&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint4&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link4&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.772549 0.752941 0.733333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link4&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link5&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 -0.42&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.707105 -0.707108 0 0&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;1.42418e-06 0.0365906 -0.0159722&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.527641 0.849468 0.000113207 -7.90953e-05&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;0.811919&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00229898 0.00217056 0.000742684&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint5&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link5&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.792157 0.819608 0.933333 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link5&quot;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">body</span> <span class="attr">name</span>=<span class="string">&quot;link6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0.155 0&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.707105 -0.707108 0 0&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inertial</span> <span class="attr">pos</span>=<span class="string">&quot;-4.84703e-06 0.00109667 -0.0032406&quot;</span> <span class="attr">quat</span>=<span class="string">&quot;0.999926 0.0120786 2.3554e-05 -0.00120144&quot;</span> <span class="attr">mass</span>=<span class="string">&quot;0.75038&quot;</span> <span class="attr">diaginertia</span>=<span class="string">&quot;0.00129697 0.00122959 0.00051245&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">joint</span> <span class="attr">class</span>=<span class="string">&quot;E05e&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joint6&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 -1&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.776471 0.756863 0.737255 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">type</span>=<span class="string">&quot;mesh&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;0.776471 0.756863 0.737255 1&quot;</span> <span class="attr">mesh</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">geom</span> <span class="attr">size</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">contype</span>=<span class="string">&quot;0&quot;</span> <span class="attr">conaffinity</span>=<span class="string">&quot;0&quot;</span> <span class="attr">group</span>=<span class="string">&quot;1&quot;</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">&lt;!-- 导入 Robotiq 2f-85 运动链 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;robotiq-2f-85-chain.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">worldbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">actuator</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E05 机械臂驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;4000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-1.57 1.57&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint2&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint3&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;3000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint4&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint4&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint5&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint5&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">position</span> <span class="attr">name</span>=<span class="string">&quot;joint6&quot;</span> <span class="attr">ctrllimited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ctrlrange</span>=<span class="string">&quot;-3.14159 3.14159&quot;</span> <span class="attr">joint</span>=<span class="string">&quot;joint6&quot;</span> <span class="attr">kp</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mujoco</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加完成后效果如下：</p><blockquote><p>注意，需要在每个 joint 标签中加入 damping 属性，例如 <code>damping='200'</code> ，否则会出现模型持续抖动闪烁，无法控制的问题。</p></blockquote><p><img src="https://img.mahaofei.com/img/202312061457266.png" alt="image.png"></p><p>整理文件结构，添加桌子、小方块，移动机器人位置和相机视角，最后得到下面的仿真环境。具体代码已开源至<a href="https://github.com/HaofeiMa/E05_Robotiq-2f-85">Github</a>:</p><p><img src="https://img.mahaofei.com/img/202312062141059.png" alt="image.png"></p><h1>3 Mujoco 常用命令</h1><h2 id="3-1-模型加载与初始化配置">3.1 模型加载与初始化配置</h2><p>模型加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = mujoco_py.load_model_from_path(<span class="string">&quot;path/to/.xml&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建mujoco仿真实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim = mujoco_py.MjSim(model)</span><br></pre></td></tr></table></figure><p>渲染设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建渲染器</span></span><br><span class="line">viewer = mujoco_py.MjViewer(sim)</span><br><span class="line"><span class="comment"># 设置模拟环境视角</span></span><br><span class="line">lookat = [<span class="number">1.27998563</span>, <span class="number">0.68635066</span>, <span class="number">0.55350562</span>]</span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">viewer.cam.lookat[idx] = lookat[idx]</span><br><span class="line">viewer.cam.distance = <span class="number">1.4547035766991275</span></span><br><span class="line">viewer.cam.azimuth = <span class="number">134.95215311004816</span></span><br><span class="line">viewer.cam.elevation = -<span class="number">32.488038277512022</span></span><br></pre></td></tr></table></figure><p>初始姿态设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initial_qpos = &#123;</span><br><span class="line"><span class="string">&#x27;joint1&#x27;</span>: np.pi/<span class="number">2</span>,</span><br><span class="line"><span class="string">&#x27;joint2&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;joint3&#x27;</span>: np.pi/<span class="number">2</span>,</span><br><span class="line"><span class="string">&#x27;joint4&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;joint5&#x27;</span>: np.pi/<span class="number">2</span>,</span><br><span class="line"><span class="string">&#x27;joint6&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">&#x27;robotiq_2f_85_right_driver_joint&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;object0:joint&#x27;</span>: [<span class="number">1</span>, <span class="number">0.45</span>, <span class="number">0.425</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, value <span class="keyword">in</span> initial_qpos.items():</span><br><span class="line">sim.data.set_joint_qpos(name, value)</span><br><span class="line">sim.forward()</span><br></pre></td></tr></table></figure><p>主函数调用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">sim.step()</span><br><span class="line">viewer.render()</span><br></pre></td></tr></table></figure><h2 id="3-2-基本信息查询与设置">3.2 基本信息查询与设置</h2><p><strong>（1）body</strong></p><p>打印<code>body</code>位置与姿态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body_idx = sim.model.body_name2id(<span class="string">&quot;link6&quot;</span>)</span><br><span class="line"><span class="comment"># 打印 body 坐标</span></span><br><span class="line"><span class="built_in">print</span>(sim.data.body_xpos[body_idx])</span><br><span class="line"><span class="comment"># 打印 body 四元数</span></span><br><span class="line"><span class="built_in">print</span>(sim.data.body_xquat[body_idx])</span><br></pre></td></tr></table></figure><p><strong>（2）site</strong></p><p>打印<code>site</code>位置与姿态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.get_site_xpos(<span class="string">&#x27;site_name&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(sim.data.get_site_xquat(<span class="string">&#x27;site_name&#x27;</span>))</span><br></pre></td></tr></table></figure><p><strong>（3）joint</strong></p><p>打印<code>joint</code>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">joint_idx = model.joint_name2id(<span class="string">&quot;joint_name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sim.data.qpos[model.jnt_qposadr[joint_idx]])</span><br></pre></td></tr></table></figure><p>设置<code>joint</code>值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim.data.set_joint_qpos(<span class="string">&quot;joint_name&quot;</span>, value)</span><br></pre></td></tr></table></figure><p><strong>（4）actuator</strong></p><p>打印<code>actuator</code>状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.ctrl)</span><br></pre></td></tr></table></figure><p>设置<code>actuator</code>值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sim.data.ctrl[actuator_index] = value</span><br></pre></td></tr></table></figure><p><strong>（5）mocap</strong></p><p>打印<code>mocap</code>位置和姿态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.mocap_pos)</span><br><span class="line"><span class="built_in">print</span>(sim.data.mocap_quat)</span><br></pre></td></tr></table></figure><p>设置<code>mocap</code>位置和姿态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">sim.data.mocap_pos[:] = np.array([x, y, z])</span><br><span class="line">sim.data.mocap_quat[:] = np.array([quat_1, quat_2, quat_3, quat_4])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line">sim.data.set_mocap_pos(<span class="string">&#x27;mocap_name&#x27;</span>, np.array([x, y, z]))</span><br><span class="line">sim.data.set_mocap_quat(<span class="string">&#x27;mocap_name&#x27;</span>, np.array([quat_1, quat_2, quat_3, quat_4]))</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：</p><ol><li><a href="https://www.bilibili.com/video/BV1Tx411o7rH">SUES木鸢机甲工作室. SolidWorks模型导出urdf （古月居老师）. Bilibili</a></li><li><a href="https://zhuanlan.zhihu.com/p/99991106">Robot Learning. MuJoCo的机器人建模. 知乎</a></li><li><a href="https://roboti.us/forum/index.php?resources/">MuJoCo官方论坛</a></li><li><a href="http://www.mujoco.org/book/index.html">MoJoCo官方文档</a></li><li><a href="https://github.com/vikashplus/robotiq_sim">vikashplus/robotiq_sim.git</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> MuJoCo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记工具】Markdown语法与Obsidian编辑器</title>
      <link href="/post/37a3baf2.html"/>
      <url>/post/37a3baf2.html</url>
      
        <content type="html"><![CDATA[<h1>1 Markdown</h1><h2 id="1-1-什么是-Markdown">1.1 什么是 Markdown</h2><p>Markdown 是一种是目前互联网上最流行的写作语言，它使用一些简单的符号来标记文本格式，其简洁的语法、优美的格式以及强大的软件支持深受广大网友的喜爱。</p><p>Markdown 使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。它的学习门槛很低，你可能只需花几分钟就可以入门了。</p><p>目前基本上所有的博客网站、在线文档等都支持 markdown 格式，尤其广泛应用于程序员领域，例如 Github 中的所有说明文档一般都是 <code>.md</code> 格式。</p><h2 id="1-2-为什么使用-Markdown">1.2 为什么使用 Markdown</h2><p>Markdown 的出现主要是为了解决以下通点：</p><ul><li><strong>软件不兼容</strong>：例如不同版本的word、或者不同软件如office与wps，打开同一文档，可能有的正常，有的格式错误，有的乱码。</li><li><strong>排版浪费时间</strong>：功能越多，我们就容易想得越多，遇到的问题也会越多。对于专注于写作的场景，有时可能并不需要那么多选项格式，例如行高行距字体颜色等等。而是要关注内容。同时word中每次写完一段文字，都要再手动为它选择格式，多的这一步操作可能就会打断思路。而markdown可以让你仅通过键盘，在写文档的同时完成格式的设置。</li><li><strong>格式不兼容</strong>：复制同一段文字到另一个文档中，很有可能格式全乱了，同理复制到网页或从其他地方复制过来，格式也都是很麻烦的问题。</li></ul><p>为了解决这些问题，Markdown 实现了以下功能：</p><ul><li><strong>语法简单</strong>：只需要一些简单地标记符号，例如<code># * &gt; - [] () =</code></li><li><strong>兼容性强</strong>：所有的编辑器都可以打开 <code>.md</code> 文件，甚至记事本和vim都可以编辑</li><li><strong>导出方便</strong>：可以导出PDF、也可以嵌入HTML、Latex等格式</li><li><strong>专注内容</strong>：写作时双手无需脱离键盘，再也不用纠结排版问题</li></ul><h2 id="1-3-Markdown-怎么用">1.3 Markdown 怎么用</h2><p>虽然所有的编辑器都可以编辑 Markdown 文件，但是为了更加直观，并且让我们有更好地写作体验，这里推荐两款所见即所得的 Markdown 编辑神器：<a href="https://obsidian.md/">Obsidian</a>和<a href="https://typora.io/">Typora</a>。前者是我现在一直在用的笔记软件，作为我的知识库管理工具，后者在我写作初期使用过，编辑体验也非常不错。</p><p>下图为 Obsidian：</p><p><img src="https://img.mahaofei.com/img/202311292058718.png" alt="image.png"></p><p>下图为 Typora：</p><p><img src="https://img.mahaofei.com/img/202311292059046.png" alt="image.png"></p><p>打开自己的 Markdown 编辑器，新建一个文件，就可以开始自己的创作了。</p><h2 id="1-4-Markdown-基本语法">1.4 Markdown 基本语法</h2><p>以下是一些比较常用的 Markdown 语法，按照我的常用顺序排列：</p><h3 id="1-标题">1. 标题</h3><p>使用方式为：<code>#</code> + <code>空格</code> + <code>标题文字</code>，注意<code>#</code>号与<code>标题文字</code>之间的<code>空格</code>：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h1>一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6><h3 id="2-倾斜">2. 倾斜</h3><p>使用方式：<code>*被倾斜的文字*</code> 或者 <code>_被倾斜的文字_</code>，快捷键 <code>Ctrl+I</code>， 例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字，<span class="emphasis">*这里是被倾斜的文字*</span>，这里又是正常文字</span><br><span class="line"></span><br><span class="line"><span class="emphasis">_下划线在Obsidian中好像只能倾斜整行_</span></span><br></pre></td></tr></table></figure><p>这里是正常文字，<em>这里是被倾斜的文字</em>，这里又是正常文字</p><p><em>下划线在 Obsidian 中好像只能倾斜整行</em></p><h3 id="3-加粗">3. 加粗</h3><p>使用方式：<code>**被加粗的文字**</code> 或 <code>__被加粗的文字__</code>，快捷键 <code>Ctrl+B</code>， 例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字，<span class="strong">**这里是被加粗的文字**</span>，这里又是正常文字</span><br><span class="line"></span><br><span class="line"><span class="strong">__下划线在Obsidian中好像只能加粗整行__</span></span><br></pre></td></tr></table></figure><p>这里是正常文字，<strong>这里是被加粗的文字</strong>，这里又是正常文字</p><p><strong>下划线在 Obsidian 中好像只能加粗整行</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*当然倾斜和加粗可以一起使用，那样就是三个星号*</span>**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__<span class="emphasis">_也可以是三个下划线_</span>__</span></span><br></pre></td></tr></table></figure><p><em><strong>当然倾斜和加粗可以一起使用，那样就是三个星号</strong></em></p><p><em><strong>也可以是三个下划线</strong></em></p><h3 id="4-高亮">4. 高亮</h3><p>使用方式如下</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字，==这里是被高亮的文字，但是不能换行，如果要对多段高亮，需要每一段使用高亮标记==，这里又是正常文字</span><br></pre></td></tr></table></figure><p>这里是正常文字，==这里是被加粗的文字，但是不能换行，如果要对多段加粗，需要每一段使用加粗标记==，这里又是正常文字</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*==当然倾斜和加粗可以一起使用，就像这样==*</span>**</span></span><br><span class="line"></span><br><span class="line">==<span class="strong">**<span class="emphasis">*也可以是这样*</span>**</span>==</span><br><span class="line"></span><br><span class="line">==<span class="strong">__<span class="emphasis">_也可以是下划线_</span>__</span>==</span><br></pre></td></tr></table></figure><p>==<em><strong>当然倾斜和加粗可以一起使用，那样就是三个星号</strong></em>==</p><p>==<em><strong>也可以是这样</strong></em>==</p><p>==<em><strong>也可以是下划线</strong></em>==</p><h3 id="5-列表">5. 列表</h3><p><strong>无序列表</strong></p><p>使用<code>+ -</code>标记无序列表，使用方式为<code>+/-</code>+<code>空格</code>+<code>文字</code>，注意<code>+/-</code>号与<code>文字</code>之间的<code>空格</code>。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 这是无序列表的第一项</span><br><span class="line"><span class="bullet">-</span> 这是第二项</span><br><span class="line"><span class="bullet">-</span> 这是第三项</span><br></pre></td></tr></table></figure><ul><li>这是无序列表的第一项</li><li>这是第二项</li><li>这是第三项</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+</span> 这是无序列表的第一项</span><br><span class="line"><span class="bullet">+</span> 这是第二项</span><br><span class="line"><span class="bullet">+</span> 这是第三项</span><br></pre></td></tr></table></figure><ul><li>这是无序列表的第一项</li><li>这是第二项</li><li>这是第三项</li></ul><p><strong>有序列表</strong></p><p>使用方式为<code>数字</code>+<code>.</code>+<code>空格</code>+<code>文字</code>。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br><span class="line">3. 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="6-引用">6. 引用</h3><p>使用<code>&gt;</code>标记引用的内容，使用方式为<code>&gt;</code> + <code>空格</code> + <code>引用文字</code>，注意<code>&gt;</code>号与<code>文字</code>之间的<code>空格</code>。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是被引用的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>这是被引用的内容</p></blockquote><h3 id="7-代码">7. 代码</h3><p>代码分为行内代码和代码块。</p><p><strong>行内代码</strong>，使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是正常文字`code`文字继续</span><br></pre></td></tr></table></figure><p>这里是正常文字<code>code</code>文字继续</p><p><strong>代码块</strong>，使用方式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```代码格式（c, c++, python, html, java, css, yaml, shell ...)</span></span><br><span class="line"><span class="code">代码内容</span></span><br><span class="line"><span class="code">```</span>ㅤㅤ</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```python</span></span><br><span class="line"><span class="code">import numpy as np</span></span><br><span class="line"><span class="code">np.array([1, 2, 3])</span></span><br><span class="line"><span class="code">```</span>ㅤㅤ</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="8-链接">8. 链接</h3><p>链接的使用格式如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接显示文字</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">马浩飞丨博客</span>](<span class="link">https://www.mahaofei.com</span>)</span><br></pre></td></tr></table></figure><p><a href="https://www.mahaofei.com">马浩飞丨博客</a></p><h3 id="9-图片">9. 图片</h3><p>图片的使用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](图片地址)</span><br><span class="line">![](https://img.mahaofei.com/img/202311292058718.png)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202311292058718.png" alt=""></p><h3 id="10-分割线">10. 分割线</h3><p>分割线使用三个以上的<code>*</code>或<code>-</code>或<code>_</code>组成，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分割线之上</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">或者使用</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">再或者</span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br><span class="line">就这些</span><br></pre></td></tr></table></figure><p>分割线之上</p><hr><p>或者使用</p><hr><p>再或者</p><hr><p>就这些</p><h3 id="11-表格">11. 表格</h3><p>表格的使用可能稍微有些繁琐，如果是在Obsidian中，可以有些插件简化表格的创建方式。</p><p>常规使用方式如下，注意中间的<code>|-|-|-|</code>是不能删的，表格有几列就写几个<code>|-|</code>：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头1|表头2|表头3|</span><br><span class="line">|-|-|-|</span><br><span class="line">|表格内容1|表格内容2|表格内容3|</span><br><span class="line">|表格内容4|表格内容5|表格内容6|</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr><td>表格内容1</td><td>表格内容2</td><td>表格内容3</td></tr><tr><td>表格内容4</td><td>表格内容5</td><td>表格内容6</td></tr></tbody></table><blockquote><p>哦对，补充一下，为了表示直观，markdown使用空行分割两个段落</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一段</span><br><span class="line"></span><br><span class="line">第二段</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-callout">12.callout</h3><p>使用<code>&gt; [!note] </code>就可以创建一个callout模块，例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [!INFO]</span></span><br><span class="line"><span class="quote">&gt; 这里是callout模块</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202401031849885.png" alt="image.png"></p><p>默认有12种风格。每一种有不同的颜色和图标（标题中的单词可以替换 <code>&gt; ![替换]</code> 实现下面效果）。</p><p><img src="https://img.mahaofei.com/img/202401031850041.png" alt="image.png"></p><p>可以使用 <code>+</code> 默认展开或者 <code>-</code> 默认折叠正文部分。例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; [!FAQ]- 点击就可以展开了</span></span><br><span class="line"><span class="quote">&gt; 这里是callout的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>[!FAQ]- 点击就可以展开了<br>这里是callout的内容</p></blockquote><h1>2 Obsidian</h1><h2 id="2-1-为什么使用-Obsidian">2.1 为什么使用 Obsidian</h2><p><strong>Obsidian 很适合用来管理多层级多文件，因此很适合用来构建知识库</strong></p><p>最初我使用 Obsidian 是因为我写的文章越来越多，当时使用 Typora 管理起来感觉不是很方便，而且那时正逢 Typora 更新至1.0后开始收费，而 Obsidian 开始展露头角，因此我尝试使用了 Obsidian，从此在我的所有设备的dock栏上，一定会有一个 Obsidian，只要我在使用电脑，Obsidian一定是处于打开状态的。</p><p>下图是我现在的 Obsidian 图</p><ul><li>左边是文件列表、历史打开文件</li><li>右边是任务列表和日历（也可以切换为文档目录）</li></ul><p><img src="https://img.mahaofei.com/img/202311292140615.png" alt="image.png"></p><p>我自己的博客内容全部使用Obsidian存储，同时记录我的一些笔记和平时遇到的各种Bug，这样遇到相似问题时，直接使用全局搜索，就可以快速找到解决办法，亲测已经帮我解决了好多次问题，节约了大把时间。</p><p><strong>个人不放心云笔记，Obsidian 是纯本地化文件编辑与管理</strong></p><p>由于各种原因，我不想将我自己记录的一些内容全部放到云笔记上，一旦宕机或跑路，会是一件非常麻烦的问题，例如有道云笔记、印象笔记等等，OneNote等我也用过，但是迁移性太差，如果想换别的笔记软件，之前记录的东西根本不能导出。</p><p>而Obsidian则是使用的本地化文件管理，左侧的文件列表就是本地中真实存在的一个个文件夹和<code>.md</code>文件。在多设备同步方面，推荐坚果云或者OneDrive实现多设备的实时同步。</p><p><strong>Obsidian 的功能非常丰富，是一个笔记软件，又不止是一个笔记软件</strong></p><p>对于我来说，我使用 Obsidian 完成了很多功能，当然最主要的还是记笔记，包括学习笔记、Bug 笔记、组会记录等等。</p><p>同时使用<code>custom frames</code>插件能够将网页嵌入到 Obsidian 中，我将滴答清单加入了进来，这样就实现了上图右侧的任务管理功能。</p><p>此外我还写了一个自动化脚本，根据我的笔记库的内容修改，每天定时更新博客内容。</p><p><strong>Obsidian 颜值非常高，有各种各样主题，而且几乎所有的样式格式都可以自定义修改</strong></p><p>在外观这方面，我也折腾了一段时间，最终还是使用 <code>Blue Topaz</code>主题，辅以<code>Style Settings</code> 插件中的一些个性化设置。总的来说没有修改太多。</p><p>网上也有一些开源的高度修改的库模板，下载下来就可以直接用，但是我找了一圈，发现自己还是更喜欢简约直接的，各位可以根据自己的审美找找看。</p><h2 id="2-2-Obsidian-的特色功能">2.2 Obsidian 的特色功能</h2><p>这里只介绍大致功能，具体使用方法，请参考 <a href="https://publish.obsidian.md/help-zh/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B">Obsidian 官方教程</a>，或者下载Obsidian软件后，第一次打开会有示例库，我当时就是阅读那个学习的。</p><p><strong>双向链接</strong></p><p>不确定 Obsidian 是不是第一个双链笔记软件，但它也是最早的一批了。</p><p>双向链接，顾名思义就是双向引用的链接，例如我在A文章中使用<code>[[B文章的标题或者小标题]]</code>，就可以实现文章和文章之间的链接，有点类似于网页链接，但是它是在笔记软件内跳转的。</p><p>在被引用的笔记中，你也可以看到这篇笔记被哪些其它笔记引用了。例如可能某篇<code>[[Ubuntu系统Buglist]]</code>中的内容就可能被我在写其它实验笔记的时候引用很多次。</p><p>这样所有的笔记相互链接，就会形成一个庞大的关系图谱，Obsidian中也可以查看这个关系图谱。</p><p>此外，双向链接还可以使用<code>![[文件名]]</code>或<code>![[文件名#小节标题]]</code>这样的格式，在引用的同时，将那篇笔记的全部或某一节插入到当前文章中，例如：</p><p><img src="https://img.mahaofei.com/img/202311292210694.png" alt="image.png"></p><p><strong>模板</strong></p><p>Obsidian 提供了模板的功能。</p><p>我创建了一个文件夹保存所有的模板。当我新建笔记后，可以直接插入现有的模板，例如我经常使用的论文笔记模板</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># X 论文名称</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; <span class="strong">**标题**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**作者团队**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**期刊会议**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**时间**</span>：</span></span><br><span class="line"><span class="quote">&gt; <span class="strong">**代码**</span>：</span></span><br><span class="line"></span><br><span class="line"><span class="section">## X.1 目标问题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## X.2 方法</span></span><br><span class="line"></span><br><span class="line"><span class="section">## X.3 思考</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202311292215167.png" alt="image.png"></p><p><strong>工作区保存与快速恢复</strong></p><p>有的时候我可能会同时打开好几个笔记，比如实验笔记、论文笔记、Buglist等等，我会把他们分屏分开放在不同的位置，例如这样：</p><p><img src="https://img.mahaofei.com/img/202311292218056.png" alt="image.png"></p><p>但是此时如果我需要去做另一件事，比如开会，我就需要把当前的这些笔记都关掉，打开会议记录，但是下次想要在恢复这个布局又比较麻烦。</p><p>这时候就可以点击左侧的<code>管理工作空间布局按钮</code>，保存工作空间布局，然后就可以放心关闭了，下次使用点击加载工作空间布局就可以一键恢复之前的布局。</p><p><strong>丰富的插件系统</strong></p><p>Obsidian 提供了丰富的插件系统，有些可以增加 Obsidian 的功能，有些则是美化外观，有些可以提高编辑体验。</p><p>具体哪些插件我用过比较好用的，后续会持续在本文下面更新。</p><p><strong>录音</strong></p><p>写这篇文章，在查资料的时候突然发现Obsidian出了录音功能，在【设置-核心插件】里打开即可使用，打开后会在主页面最左侧添加一个图标，按下即可开始录音。</p><p>录音完成后，会保存在当前笔记文件中。</p><p><img src="https://img.mahaofei.com/img/202311292224701.png" alt="image.png"></p><h2 id="2-3-Obsidian-插件推荐">2.3 Obsidian 插件推荐</h2><p><strong>所有的插件都可以在插件市场中直接搜索下载</strong>，【设置-第三方插件-社区插件市场】</p><p>后续有时间再更新各个插件的介绍和使用详情</p><h3 id="1-提升编辑体验">1. 提升编辑体验</h3><p><a href="https://obsidian.md/plugins?id=media-extended"><strong>Media Extended</strong></a></p><p>Media Extended增强了媒体播放功能，包括链接到在线视频，速度控制，循环播放，字幕支持。</p><p>以及创建时间戳链接笔记，从在线视频、本地视频、录音中获取时间戳等等。</p><p>（目前测试似乎只能添加 Youtube 在线视频）</p><p><img src="https://www.youtube.com/watch?v=yBCD-Hfpd8U" alt=""></p><p><a href="https://obsidian.md/plugins?id=obsidian-outliner"><strong>Outliner</strong></a></p><p>增强列表样式</p><ul><li>可以上移下移缩进列表</li><li>增加列表垂直缩进线</li><li>增加折叠展开功能</li></ul><p><a href="https://obsidian.md/plugins?id=table-editor-obsidian"><strong>Advanced Tables</strong></a></p><p>优化创建表格的语法：输入一个<code>|</code>，然后输入第一个标题，接着按下<code>tab</code>，继续输入标题直到创建所有标题，然后按下<code>Enter</code>转到第一行输入内容，以此类推。</p><p>当光标位于表格中时：</p><table><thead><tr><th>快捷键</th><th>动作</th></tr></thead><tbody><tr><td><code>Tab</code></td><td>下一个单元格</td></tr><tr><td><code>Shift</code> + <code>Tab</code></td><td>上一个单元格</td></tr><tr><td><code>Enter</code></td><td>下一行</td></tr><tr><td><code>Ctrl</code> + <code>Shift</code> + <code>D</code></td><td>打开表格控件侧边栏</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/202311301613362.gif" alt=""></p><h3 id="2-增加功能">2. 增加功能</h3><p><a href="https://obsidian.md/plugins?id=calendar"><strong>Calendar</strong></a></p><p>日历插件，打开后会在右边侧栏出现日历。</p><p>点击日历上的日期，可以跳转到当天的每日笔记中（每日笔记也可以设置模板）</p><p><img src="https://img.mahaofei.com/img/202311301615320.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=obsidian-custom-frames"><strong>Custom Frames</strong></a></p><p>可以将任意的网页转换为obsidian窗格，非常不错。</p><p>例如我这里右侧的滴答清单：</p><p><img src="https://img.mahaofei.com/img/202311292140615.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=obsidian-image-auto-upload-plugin"><strong>Image auto upload Plugin</strong></a></p><p>image auto upload插件搭配PicGo使用，能自动将ob中插入的图片上传到图床中，优化图片插件体验。</p><p>在这里我使用的是阿里云OSS存储我的图片，具体可以参考：<a href="https://www.mahaofei.com/post/d05a7f72.html">阿里云图床搭建方法</a>或者[[01_阿里云图床搭建方法]]</p><p><a href="https://obsidian.md/plugins?id=recent-files-obsidian"><strong>Recent Files</strong></a></p><p>非常直观的功能，就是在左侧文件列表增加最近打开的文件列表。</p><p><img src="https://img.mahaofei.com/img/202311301701536.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=dataview"><strong>Dataview</strong></a></p><p>一个高效信息动态查询插件，当你拥有足够多的笔记后，可以用它来生成目录表格，并且支持各种查询限制条件。</p><p><a href="https://obsidian.md/plugins?id=templater-obsidian"><strong>Templater</strong></a></p><p>相比较与 obsidian 自带的模板工具，他能实现更复杂的模板，设置更多的变量和函数，生成一些功能强大的模板。</p><p><a href="https://obsidian.md/plugins?id=obsidian-admonition"><strong>Admonition</strong></a></p><p>能够在 Obsidian 中添加样式框的插件，能让笔记显得好看又有层次，可以配合着 Task、QuickAdd、Button 和 Dataview 等插件使用。</p><p><img src="https://img.mahaofei.com/img/202401071717704.png" alt="image.png"></p><p><a href="https://obsidian.md/plugins?id=quickadd"><strong>Quickadd</strong></a></p><p>可快速添加信息，捕捉想法，采用模板新建笔记和添加宏命令，快速执行多项操作的好用又强大的插件。</p><p><a href="https://obsidian.md/plugins?id=buttons"><strong>Buttons</strong></a></p><p>可以添加一些自定义按钮，用来执行一些特定人物，例如一些命令或者打开链接或者结合 quickadd 实现一些自动化流程。</p><p><a href="https://obsidian.md/plugins?id=obsidian-banners"><strong>Banners</strong></a></p><p>在笔记的开头添加和管理横幅图片，一般用于制作笔记主页时使用。</p><p><a href="https://obsidian.md/plugins?id=workspaces-plus"><strong>Workspaces plus</strong></a></p><p>快速切换管理工作区的布局。你可以按照你不同的习惯，规划工作区。</p><p><a href="https://obsidian.md/plugins?id=obsidian-hover-editor"><strong>Hover Editor</strong></a></p><p>通过将悬停弹窗变成一个功能齐全的编辑器，来增强核心的“页面预览”原有的功能。</p><h3 id="3-个性化设置">3. 个性化设置</h3><p><a href="https://obsidian.md/plugins?id=mysnippets-plugin"><strong>MySnippets</strong></a></p><p>css片段管理插件，在右下角生成css管理菜单，点击后可方便的开关css片段。</p><p><img src="https://img.mahaofei.com/img/202312010757678.gif" alt=""></p><p><a href="https://obsidian.md/plugins?id=obsidian42-brat"><strong>Obsidian42 - BRAT</strong></a></p><p>obsidian的插件下载大致可分为两种，第一种是从ob软件内的官方渠道下载，第二种则是通过Github等渠道下载后再手动安装。</p><p>Obsidian42 - BRAT 可以帮助你直接安装社区插件市场无法安装的插件。</p><p><a href="https://obsidian.md/plugins?id=obsidian-style-settings"><strong>Style Settings</strong></a></p><p>主题自定义设置插件，可以在现有主题的基础上，根据自己的需要进行魔改。</p><p><img src="https://img.mahaofei.com/img/202312010804210.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 科研利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】人机协作</title>
      <link href="/post/a9bacf05.html"/>
      <url>/post/a9bacf05.html</url>
      
        <content type="html"><![CDATA[<h1>1 Transfer Learning-enabled Action Recognition for Human-robot Collaborative Assembly</h1><blockquote><p><strong>标题</strong>：用于人机协作装配的迁移学习动作识别<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CIRP<br><strong>时间</strong>：2021<br><strong>代码</strong>：</p></blockquote><h2 id="1-1-背景">1.1 背景</h2><p>随着现代制造业从大规模生产转向大量的个性化应用，工业机器人对自适应控制以及在共享工作空间中与人类无缝协作的需求不断增加。在柔性自动化的背景下，人机协作旨在将机器人的准确性和强度在人类的认知能力和灵活性相结合。</p><blockquote><p>With modern manufacturing shifting from mass production to mass personalization, industrial robots have been of rising demands for adaptive control and seamless cooperation with human operators in a shared workspace. In the context of flexible automation, human-robot collaboration (HRC) aims to integrate the accuracy and strength of robots with cognitive ability and flexibility of humans in the execution loop.</p></blockquote><p>实现这一目标的一个重要基础，就是机器人动态规划对人类活动和意图的安全的响应。因此人类的动作识别作为先决条件，在高效HRC中起着至关重要的作用。</p><blockquote><p>One major pillar to achieve this is that robots dynamically plan safe reactions responded to human activities and intentions.</p></blockquote><p>这可以在面向个性化定制的制造中带来更高的效率。</p><blockquote><p>which can result in higher overall productivity in customization-oriented manufacturing.</p></blockquote><h2 id="1-2-目标问题">1.2 目标问题</h2><p>人机协作(Human-robot collaboration, HRC)对于当今制造业的高柔性装配趋势至关重要。人类动作识别作为HRC的先决条件，使工业机器人能够理解人类意图并自适应的执行规划。</p><blockquote><p>Human-robot collaboration (HRC) is critical to today’s tendency towards high-flexible assembly in manufacturing. Human action recognition, as one of the core prerequisites for HRC, enables industrial robots to understand human intentions and to execute planning adaptively.</p></blockquote><p>目前的基于深度学习的动作识别方法严重依赖大量的注释数据，这在实际中并不有效且不现实。</p><p>因此本文提出了一种基于迁移学习的动作识别方法，帮助HRC装配。并引入了机器人规划决策机制。</p><h2 id="1-3-方法">1.3 方法</h2><p>本文提出了一种基于迁移学习的动作预测方法，以实现高效的HRC装配。系统包括三部分：（1）数据感知和预处理；（2）从采样视频中提取知识和动作识别；（3）机器人根据学到的语义知识做出决策和反应。</p><p><strong>（1）基于迁移学习的人类动作识别</strong></p><p>使用Kinect获取机器人的动作，通过Openpose工具箱获得人体姿态（该工具箱可以在连续视频中预测操作者的身体关节）。</p><p>本文提出的基于迁移学习的ST-GCN框架，包括三个模块：特征提取器、动作分类器和域自适应模块。</p><p><strong>（2）面向任务的自适应HRC装配</strong></p><p>预测的人类活动通过语义图转换为HRC装配中的机器人规划决策。通过将人体轨迹和深度相机的手眼标定，机器人可以获得真实的物理世界坐标，从而使机器人能够移动到精确的位置。因此机器人可以动态的协调人类并根据人类的子任务自适应的改变动作，最终实现面向任务的HRC装配。</p><h1>2 Vision-based holistic scene understanding towards proactive human–robot collaboration</h1><blockquote><p><strong>标题</strong>：基于视觉的整体场景理解，实现主动的人机协作<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：Robotics and Computer-Integrated Manufacturing<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><p>近年来，人机协作因其潜在的生产效率提高和大规模自定义能力而在制造领域引起了许多关注。 HRC将机器人的力量和准确性与人类的灵活性和创造力相结合，使人类操作员和机器人能够在共享工作空间中无缝工作并执行共享任务。</p><blockquote><p>Human–robot collaboration (HRC) has attracted many interests in recent years in the field of manufacturing because of the potential production efficiency improvement and mass personalization capability. The strength and accuracy of robots along with the flexibility and creativity of humans are combined in an HRC team, allowing human operators and robots to work seamlessly in a shared workspace with shared tasks.</p></blockquote><p>近年来，由于能够充分利用人类的灵活性和机器人精度的优势，人机协作已经成为制造业大规模个性化的一个有前途的方法。</p><blockquote><p>Recently human–robot collaboration (HRC) has emerged as a promising paradigm for mass personalization in manufacturing owing to the potential to fully exploit the strength of human flexibility and robot precision.</p></blockquote><p>为了实现更好的协作，机器人应该能够实现整体感知和解析工作场景的信息，从而主动规划并采取相应行动。目前HRC的相关工作虽然关注了人类的认知，但是缺乏对工作场景的其它关键要素的整体考虑。</p><p>为了解决这个问题，本文考虑物体、人类和环境的认识以及视觉推理，以收集视觉信息，并将其编译为语义，用于后续机器人的决策与协作。</p><h1>3 Dynamic Scene Graph for Mutual-Cognition Generation in Proactive Human-Robot Collaboration</h1><blockquote><p><strong>标题</strong>：主动人机协作中相互认知生成的动态场景图<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CIRP Conference on Manufacturing Systems<br><strong>时间</strong>：<br><strong>代码</strong>：</p></blockquote><h2 id="3-1-背景">3.1 背景</h2><p>在先进制造业向工业5.0转型和在工业化过程中，人类在生产过程中发挥着核心作用。一方面，大规模个性化生产趋势对现代工厂的柔性制造提出了越来越高的要求，而这些要求目前还无法实现，只能依靠人的手动敏捷操作。此外，为了实现工业5.0的可持续性和弹性原则，产品的再利用和回收过程需要高水平的灵活性和自适应性的自动化技术。基于这种情况，人机协作引起了人们对灵活自动化任务的兴趣，该任务结合了人类和机器人的互补能力以提高生产力。</p><blockquote><p>Among the advanced manufacturing transition to Industry 5.0 and reindustrialization, human operators play a central role in the production process. For one side, the mass personalized production tendency raises ever-increasing flexible manufacturing requirements for modern factories, which remain unattained and rely on human manually agile operations. Besides, to achieve sustainability and resilience principles of Industry 5.0, the re-use, re-purpose and recycle processes of products demand high-level flexible and adaptable automation technologies. Motivated by this situation, human-robot collaboration (HRC) has elicited particular interest in flexiable automation tasks, which combines human and robotic complementing competencies for improved productivity.</p></blockquote><p>针对HRC系统，人们进行了大量的研究，以期在工业环境中实现人类技能和机器人操作的相互作用。例如，对人类的动作识别、工件的6-DOF位姿估计等。以及基于这些感知结果的机器人控制、 人类安全机制等等。</p><p>但是除了以上研究，HRC对于上下文感知的能力仍然停留在对周围环境的非语义感知。</p><h2 id="3-2-目标问题">3.2 目标问题</h2><p>人机协作在敏捷、灵活和以人为中心的制造向大规模个性化的转型中发挥着至关重要的作用。</p><p>现存问题：</p><ul><li>在当今的HRC任务中，无论是人类还是机器人都需要遵循命令和指示来进行协作活动，而不是主动、相互参与。</li><li>HRC的非语义感知阻碍了HRC系统中的主动规划和认知能力</li></ul><p>解决方法：<br>提出了一种基于动态场景图的方法，用于主动HRC应用中的相互认知生成。</p><ul><li>利用空间注意金字塔网络，检测工业环境中的对象（工件、机器人手臂、人手）。</li><li>利用链接预测模块构建HRC场景图，利用注意力图卷积网络来捕获工业零件、人类操作员和机器人操作之间的关系，并将人机协作处理结构连接推理为图嵌入，链接到人类操作和机器人主动指令的相互规划器。</li><li>在电池拆卸任务中进行了评估。</li></ul><h1>4 A visual reasoning-based approach for mutual-cognitive human-robot collaboration</h1><blockquote><p><strong>标题</strong>：基于视觉推理的人机交互认知协作方法<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CIRP Annals-Manufacturing Technology<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><h2 id="4-1-背景">4.1 背景</h2><p>在现代工厂中，许多复杂的机械产品的个性化生产，既依赖于机器人的精确操控，又依赖于人类的敏捷操作。在此背景下，人机协作HRC利用了人类的高灵活性和机器人的高效率和可靠性，引起了工业界和学术界的极大兴趣。人类和机器人具有互补的操作目标和能力，并在共享工作空间中协作执行制造任务，迄今为止，已经出现了大量的HRC解决方案。</p><blockquote><p>In modern factories, personalized production of many complicated mechanical products relies on both robots’ precision manipulation and human operators’ agile operations. In this context, human-robot collaboration (HRC) has attracted much interest from the industry and academia, which leverages humans’ high flexibility and robots’ high efficiency and reliability. Human and robotic agents have complementary operation goals and capabilities, and collaboratively conduct manufacturing tasks in a shared workspace. To date, numerous research efforts on HRC solutions have emerged.</p></blockquote><h2 id="4-2-目标问题">4.2 目标问题</h2><p>人机协作允许人类和机器人之间的无缝通信和协作，以在共享工作空间中完成灵活的制造任务。</p><p>现有的HRC系统缺乏机器人和人类认知的有效整合。</p><ul><li>现有的HRC系统上下文感知能力侧重于对环境的感知，而不是对任务过程的类人理解</li><li>现有的HRC系统直接将结果传递到反应控制中，很少考虑知识学习来进行主动路径规划</li><li>机器人执行和人类操作的规划器通常是预定义的，缺乏任务完成过程中的动态调整能力。</li></ul><p>本文提出了一种基于视觉推理的相互认知HRC方法：</p><ul><li>建立HRC知识图谱</li><li>视觉传感器将整体制造场景感知为时间图，通过图嵌入推断出具有相似指令的协作模式。</li><li>将相互认知决策融入到增强现实执行中。</li></ul><h1>5 Towards Mutual-Cognitive Human-Robot Collaboration: A Zero-shot Visual Reasoning Method</h1><blockquote><p><strong>标题</strong>：迈向相互认知的人机协作：零样本视觉推理方法<br><strong>作者团队</strong>：香港理工大学（郑湃）<br><strong>期刊会议</strong>：CASE<br><strong>时间</strong>：2023<br><strong>代码</strong>：</p></blockquote><h2 id="5-1-背景">5.1 背景</h2><p>工业5.0代表了制造业转型为以人为本、可持续和弹性的原则。迈向以人为本的智能制造，人机协作揭示了改善人类工作条件和确保一致质量的优势。HRC系统结合了人类灵活能力和机器人的自动化能力，对于制造任务，人类能够敏捷操作，而机器人同时执行重复且精确的操作，所有这些都朝着一个共同的目标努力。</p><blockquote><p>Industry 5.0 represents the principles of human-centricity, sustainability and resilience for manufacturing transformation. Towards human-centric smart manufacturing, Human-Robot Collaboration (HRC) sheds light on the benefits of improving human working conditions and ensuring consistent quality. HRC systems combine human’s flexible capabilities and robot automatic capabilities. For a manufacturing task, human operators take agile operations, while the robot concurrently executes repetitive and precise manipulation, all working towards a common goal.</p></blockquote><p>HRC的成功取决于多种因素，包括周围环境的感知、安全的机器人控制和双向通信。在此背景下，先进的计算机视觉技术促进了HRC系统在工业环境中的应用。例如，在HRC系统中跟踪人体运动以避免机器人碰撞并确保人体安全。与此同时，人们还探索了人类的行为、手势和声音，以实现无缝的人机通信。 HRC 场景中的感知信息在人类和机器人代理之间传输，以便在共享制造目标内进行有效协作。</p><blockquote><p>The success of HRC relies on various factors, including the perception of surrounding environments, safe robot control, and bidirectional communication. In this context, the advanced computer vision techniques facilitate applications of HRC systems in industrial settings. For example, human motions were tracked in HRC systems to avoid robot collision and ensure human safety. Meanwhile, human actions, gestures, and voices were explored to allow for seamless human-robot communication. The perceived information in HRC scenarios is transmitted among human and robotic agents for effective co-working within a shared manufacturing goal.</p></blockquote><p>然而，现有的HRC研究工作主要集中在感知层面，未能学习人机操作意图的语义知识并制定认知任务规划策略。在当前的 HRC 系统中，机器人可以跟随人类手势来反应性地规划运动并协助工人，而很少考虑 HRC 任务结构知识和随时间变化的团队合作目标。如果没有对任务的整体理解，HRC系统就无法减轻人类手动操作并增强机器人自适应辅助。此外，对于相似但不同的任务，HRC系统需要学习新的知识表示来规划合理的人类和机器人操作，这限制了HRC在实际情况中的应用。</p><blockquote><p>Nevertheless, existing research efforts on HRC focus on perception level, which fails to learn semantic knowledge of human-robot operation intentions and make cognitive task planning strategies. In current HRC systems, a robot can follow human gestures to reactively plan motions and assist the worker, while seldom considering HRC task structure knowledge and time-changing teamwork goals. Without a holistic understanding of tasks, the HRC system cannot relieve human manual operations and enhance robot adaptive assistance. Besides, for similar but different tasks, the HRC system needs to learn new knowledge representations to plan reasonable human and robotic operations, which limits the HRC applications in real cases.</p></blockquote><h2 id="5-2-目标问题">5.2 目标问题</h2><p>人机协作HRC在当今工业5.0所规定的以人为本的智能制造中显示出了广泛的应用潜力。</p><p>为了实现安全高效的协作，人们探索了多种视觉感知方法。使机器人能够感知周围环境并实现无碰撞的操作规划。</p><p>现存问题：</p><ul><li>目前的视觉感知方法只能传达机器人和人类之间的基本信息，缺乏语义知识（机器人遇到类似但未见过的情况，则无法顺利执行）</li></ul><p>解决方法：</p><ul><li>本文提出了一种基于相互认知的HRC架构，基于现场情况和任务结构的知识表示进行学习，规划人类和机器人的操作。</li><li>引入零样本视觉推理方法，从感知结果中得出机器人策略。</li><li>对老化电动汽车电池协同拆卸任务进行测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 人机协作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器人 </tag>
            
            <tag> 人机协作 </tag>
            
            <tag> HRC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】Reskill基于技能的适应性动作空间学习</title>
      <link href="/post/be8c51e1.html"/>
      <url>/post/be8c51e1.html</url>
      
        <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：剩余技能策略：学习基于技能的适应性行动空间，用于机器人强化学习<br><strong>作者团队</strong>：昆士兰科技大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://krishanrana.github.io/reskill">https://krishanrana.github.io/reskill</a></p></blockquote><h2 id="1-1-目标问题">1.1 目标问题</h2><p>基于技能的学习已经成为加速机器人学习的方法，技能从专家演示中提取，是短序列的单步操作（平移、抓取、抬起等动作），这些技能嵌入到潜在空间中，构成上层 RL 策略的行动空间。但是这种方式存在一些问题：</p><ul><li>对所有技能进行随机抽样探索，效率极低，因为其中只有一小部分技能与当前执行的任务相关，并且这些相关的技能通常不会聚集在技能空间的同一邻域内。</li><li>该方法假设技能是最优的，并且下层的任务来自于技能空间的相同分布，因此学习的通用性和变化适应性有限，例如从移动方块中学习技能，则无法应对障碍物、物体变化、不同摩擦等情况。</li></ul><p>为解决上述问题，本文提出了以下创新方法，称为残差技能策略（Residual Skill Policies，ReSkill）：</p><ul><li>状态条件技能先验：对相关技能进行采样来引导探索</li><li>底层残差策略：通过对技能进行细粒度的技能适应，实现任务变化的适应</li></ul><h2 id="1-2-方法">1.2 方法</h2><p>总的来说，该方法将经典控制器产生的演示轨迹分解为与任务无关的技能，并将其嵌入到连续到技能空间中，利用技能空间实现真正的通用学习，上层智能体能够从技能空间中访问但不动作，降低了对数据集详细程度的要求。</p><ul><li>从现有控制器中提取技能</li><li>学习技能嵌入和先验技能</li><li>训练一个分层强化学习策略，在技能空间中使用底层残差适应性策略。</li></ul><p><img src="https://img.mahaofei.com/img/202311161019261.png" alt="image.png"></p><p><strong>（1）数据收集</strong></p><p>本文通过手动控制收集演示数据（基本操作任务，如推物体、抓物体），虽然任务简单，但轨迹包含复杂的技能，可以重新组合解决复杂的任务。</p><p>轨迹是由 state-action 成对组成的，本文从中随机切片 $H$ 长度的片段进行无监督技能提取，利用提取的动作 a 和状态 s 学习下一小节中的 state-action。</p><p>其中状态 s 包括关节角度、关节速度、夹具位置、物体位置，动作是连续的 4D 向量，包括末端位置和速度。</p><p><strong>（2）学习强化学习的状态条件技能空间</strong></p><ul><li>将提取的技能嵌入到潜在空间中：使用变分自动编码器 VAE 将技能 $a$ 嵌入到潜在空间中，VAE 包括编码器和解码器，编码器将完整的 state-action 序列编码为 $z$，解码器根据当前状态 $s_t$ 和技能编码 $z$ 重建动作。</li><li>在探索过程中采样的技能状态条件先验：学习潜在技能空间上的条件概率密度。传统的高斯密度不能处理多模态信息，本文使用 real NVP 方法，实值非体积保留变换。学习从 $Z\times S-&gt;G$ 的映射，该映射就可以从简单分布 G 变换到技能空间 Z，因此 f 就是技能先验。</li></ul><p><img src="https://img.mahaofei.com/img/202311251603089.png" alt=""></p><blockquote><p><strong>变分自编码器</strong>，是一种深度生成模型<br><strong>传统</strong>：传统的自编码器包括编码器和解码器两部分，经过反复训练，输入数据被编码成一个编码向量，编码向量的每一个维度表示学习到的数据的特征，解码器尝试从编码向量中解码原始输入<br><strong>缺陷</strong>：传统的方法，使用单个值表示输入在某个潜在特征的表现。但实际上，将潜在特征表示为可能的取值范围会更合理。<br><strong>改进</strong>：因此变分自编码器就是使用取值的概率分布，代替原来的单值表示特征。<br><strong>优势</strong>：每个潜在特征表示为概率分布，解码时从潜在状态分布中随机采样，生成一个编码向量作为解码器的输入。实现了连续且平滑的潜在空间表示（潜在空间中彼此相邻的值重构出的结果相似）<br>参考理解:<a href="https://zhuanlan.zhihu.com/p/64485020">https://zhuanlan.zhihu.com/p/64485020</a></p></blockquote><p><strong>（3）状态条件技能空间中的强化学习</strong></p><p>一旦训练完成，解码器和技能先验权重就会被冻结，并合并到 RL 框架中。高级强化学习策略 $\pi$ 是一个神经网络，将状态映射到技能先验变化中的向量 g，在转换为潜在技能 Z。</p><p>然后解码器根据技能范围 H 的当前状态顺序重构动作。同时有一个底层残差策略，调整解码后的技能。</p><h2 id="1-3-总结">1.3 总结</h2><p>该方法是一种基于技能的强化学习方法。</p><ol><li>数据收集：使用最基本的控制器生成一些基本任务轨迹（移动、抓取），然后将这些轨迹分割成固定长度的序列，每一小段包括动作和对应的状态。</li><li>学习技能空间，使用变分自编码器将技能编码到潜在空间中；使用realNVP将技能潜在空间+机器人状态空间映射到简单分布空间（高斯分布），这样可以直接根据状态采样技能，称为技能先验。</li><li>强化学习：使用一个高层策略网络，根据当前的状态生成一个向量，根据技能先验（与当前状态有关的技能）中选择一个技能，利用技能解码器解码成机器人动作。</li></ol><h1>二、代码复现</h1><h2 id="2-1-环境搭建">2.1 环境搭建</h2><p><strong>（1）安装<code>mujoco</code>：</strong></p><p>下载<code>mujoco</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mujoco.org/download/mujoco210-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>创建一个隐藏文件夹，尽量不要修改此路经</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.mujoco</span><br></pre></td></tr></table></figure><p>将<code>mujoco</code>库解压到上面的文件夹中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf mujoco210-linux-x86_64.tar.gz -C ~/.mujoco</span><br></pre></td></tr></table></figure><p>编辑环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件最后添加下面的语句，注意修改自己的用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mujoco environment</span></span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/nvidia</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/用户名/.mujoco/mujoco210/bin</span><br><span class="line">export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so</span><br></pre></td></tr></table></figure><p>刷新环境变量，重启terminal或执行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>测试mujoco</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.mujoco/mujoco210/bin</span><br><span class="line">./simulate ../model/arm26.xml</span><br></pre></td></tr></table></figure><p>能看到一个mujoco界面启动，并看到一个二自由度机械臂，说明安装成功。<code>../model/</code>下也有很多其它的模型示例，感兴趣可以看看。</p><p><strong>（2）python环境构建</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/krishanrana/reskill.git</span><br><span class="line">cd reskill</span><br><span class="line">conda env create -f environment.yml</span><br><span class="line">conda activate reskill_new</span><br><span class="line">pip install -e .</span><br><span class="line">cd reskill</span><br></pre></td></tr></table></figure><h2 id="2-2-数据收集">2.2 数据收集</h2><p>使用下面的脚本收集数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python data/collect_demos.py --num_trajectories 40000 --subseq_len 10 --task block</span><br></pre></td></tr></table></figure><p>其中<code>task</code>可以设置为<code>block</code>或<code>hook</code>。</p><h2 id="2-3-训练">2.3 训练</h2><p>训练技能模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_skill_modules.py --config_file block/config.yaml --dataset_name fetch_block_40000</span><br></pre></td></tr></table></figure><p>可视化训练完成的技能模块的性能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python utils/test_skill_modules.py --dataset_name fetch_block_40000 --task block --use_skill_prior True</span><br></pre></td></tr></table></figure><p>训练reskill代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_reskill_agent.py --config_file block/config.yaml --dataset_name fetch_block_40000</span><br></pre></td></tr></table></figure><p>可视化训练完成的reskill代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python utils/test_reskill_agent.py --dataset_name fetch_block_40000 --env_name FetchSlipperyPush-v0</span><br></pre></td></tr></table></figure><h2 id="2-4-日志记录">2.4 日志记录</h2><p>使用<a href="https://wandb.ai/">W&amp;B</a>，第一次train时输入自己的api即可。</p><h1>三、代码理解</h1><h2 id="3-1-基本定义">3.1 基本定义</h2><p><strong>（1）机器人动作</strong></p><p>算法中机器人通过下面的方法进行定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_set_action</span>(<span class="params">self, action</span>):</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;设置动作，在模拟环境中执行动作&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 处理输入动作</span></span><br><span class="line"><span class="keyword">assert</span> action.shape == (<span class="number">4</span>,) <span class="comment"># 确保输入的动作形状是（4，）</span></span><br><span class="line">action = action.copy()      <span class="comment"># ensure that we don&#x27;t change the action outside of this scope</span></span><br><span class="line">pos_ctrl, gripper_ctrl = action[:<span class="number">3</span>], action[<span class="number">3</span>]  <span class="comment"># 将动作差分成位置控制[:3]和夹爪控制[3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输入动作值进行处理，末端位置进行缩放，旋转固定，夹爪根据条件是否设0</span></span><br><span class="line">pos_ctrl *= <span class="number">0.05</span>  <span class="comment"># 限制位置变化的最大值</span></span><br><span class="line">rot_ctrl = [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]  <span class="comment"># 固定末端执行器的旋转，使用四元数表示</span></span><br><span class="line"><span class="comment">#rot_ctrl = [ 0.5, -0.5, 0.5, 0.5 ]  # 90 deg rotation of the original end effector, expressed as a quaternion</span></span><br><span class="line">gripper_ctrl = np.array([gripper_ctrl, gripper_ctrl])   <span class="comment"># 夹爪复制成两个</span></span><br><span class="line"><span class="keyword">assert</span> gripper_ctrl.shape == (<span class="number">2</span>,)</span><br><span class="line"><span class="keyword">if</span> self.block_gripper:  <span class="comment"># 如果block_gripper，则将手指位置设置为0</span></span><br><span class="line">gripper_ctrl = np.zeros_like(gripper_ctrl)</span><br><span class="line"><span class="comment"># 将经过修改后的位置控制、固定的末端执行器旋转和处理后的夹爪控制连接成一个新的动作数组 action</span></span><br><span class="line">action = np.concatenate([pos_ctrl, rot_ctrl, gripper_ctrl])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply action to simulation. 将动作应用到仿真环境中</span></span><br><span class="line">utils.ctrl_set_action(self.sim, action)</span><br><span class="line">utils.mocap_set_action(self.sim, action)</span><br></pre></td></tr></table></figure><p>可以看出在本算法中，机器人的动作被定义为了长度为4的数组，四个值分别代表机器人末端的控制位置和夹爪开合大小。（这里旋转被忽略了，因为任务是抓取方块到指定位置，所以算法直接设置末端永远竖直向下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = [x, y, z, gripper]</span><br></pre></td></tr></table></figure><p>实际上gym中机器人的<code>action</code>使用长度为9的数组进行控制，分别代表末端的空间位置3个变量，末端的空间姿态四元数，夹爪两个平行板的动作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action = [x, y, z, quat1, quat2, quat3, quat4, gripper_l, gripper_r]</span><br></pre></td></tr></table></figure><p><strong>（2）观测状态</strong></p><p>观测状态通过如下代码获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_obs</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;获得环境的观察&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 位置</span></span><br><span class="line">    grip_pos = self.sim.data.get_site_xpos(<span class="string">&#x27;robot0:grip&#x27;</span>)   <span class="comment"># 获取机器人手爪的位置</span></span><br><span class="line">    dt = self.sim.nsubsteps * self.sim.model.opt.timestep</span><br><span class="line">    grip_velp = self.sim.data.get_site_xvelp(<span class="string">&#x27;robot0:grip&#x27;</span>) * dt    <span class="comment"># 计算手爪的线速度</span></span><br><span class="line">    robot_qpos, robot_qvel = utils.robot_get_obs(self.sim)  <span class="comment"># 使用辅助函数获取机器人的位置和速度</span></span><br><span class="line"></span><br><span class="line">    gripper_state = robot_qpos[-<span class="number">2</span>:]     <span class="comment"># 提取了夹爪的状态和速度</span></span><br><span class="line">    gripper_vel = robot_qvel[-<span class="number">2</span>:] * dt  <span class="comment"># change to a scalar if the gripper is made symmetric</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将夹爪的位置、状态、夹爪线速度、速度连接起来，形成初始观察</span></span><br><span class="line">    obs = np.concatenate([</span><br><span class="line">        grip_pos,</span><br><span class="line">        gripper_state,</span><br><span class="line">        grip_velp,</span><br><span class="line">        gripper_vel,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储已经到达的目标</span></span><br><span class="line">    achieved_goal = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有的方块</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.num_blocks):</span><br><span class="line">    <span class="comment"># for i in range(1):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取方块们的位置、姿态、速度、相对位置、相对速度</span></span><br><span class="line">        object_i_pos = self.sim.data.get_site_xpos(self.object_names[i])</span><br><span class="line">        <span class="comment"># rotations</span></span><br><span class="line">        object_i_rot = rotations.mat2euler(self.sim.data.get_site_xmat(self.object_names[i]))</span><br><span class="line">        <span class="comment"># velocities</span></span><br><span class="line">        object_i_velp = self.sim.data.get_site_xvelp(self.object_names[i]) * dt</span><br><span class="line">        object_i_velr = self.sim.data.get_site_xvelr(self.object_names[i]) * dt</span><br><span class="line">        <span class="comment"># gripper state</span></span><br><span class="line">        object_i_rel_pos = object_i_pos - grip_pos</span><br><span class="line">        object_i_velp -= grip_velp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接到观察值中</span></span><br><span class="line">        obs = np.concatenate([</span><br><span class="line">            obs,</span><br><span class="line">            object_i_pos.ravel(),</span><br><span class="line">            object_i_rel_pos.ravel(),</span><br><span class="line">            <span class="comment">#object_i_rot.ravel(),</span></span><br><span class="line">            object_i_velp.ravel(),</span><br><span class="line">            <span class="comment">#object_i_velr.ravel()</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># This is current location of the blocks</span></span><br><span class="line">        <span class="comment"># 方块们的当前位置</span></span><br><span class="line">        achieved_goal = np.concatenate([</span><br><span class="line">            achieved_goal, object_i_pos.copy()</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    achieved_goal = np.concatenate([achieved_goal, grip_pos.copy()])</span><br><span class="line"></span><br><span class="line">    achieved_goal = np.squeeze(achieved_goal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.use_force_sensor:</span><br><span class="line">        self.sim.data.get_sensor(<span class="string">&#x27;force_sensor&#x27;</span>) </span><br><span class="line">        force_reading = self.sim.data.sensordata <span class="comment"># Read force sensor reading from tray</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        force_reading = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;observation&#x27;</span>: obs.copy(),</span><br><span class="line">        <span class="string">&#x27;achieved_goal&#x27;</span>: achieved_goal.copy(),</span><br><span class="line">        <span class="string">&#x27;desired_goal&#x27;</span>: self.goal.copy(),</span><br><span class="line">        <span class="string">&#x27;force_sensor&#x27;</span>: force_reading.copy()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出观测状态是一个字典：</p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">observation</td><td style="text-align:left">[grip_x, grip_y, grip_z,</td><td style="text-align:left">grip_pos，末端位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">gripper_left, gripper_right,</td><td style="text-align:left">gripper_state，夹爪两侧状态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">grip_vx, grip_vy, grip_vz,</td><td style="text-align:left">grip_vel，末端速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">gripper_vl, gripper_vr,</td><td style="text-align:left">gripper_vel，夹爪两侧速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_x, obj1_y, obj1_z,</td><td style="text-align:left">obj_i_pos，方块i位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_rx, obj1_ry, obj1_rz,</td><td style="text-align:left">obj_i_rel_pos，方块i相对末端位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj1_vx, obj1_vy, obj1_vz,</td><td style="text-align:left">obj_i_velp, 方块i相对末端速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj2…</td><td style="text-align:left">方块2位置、相对位置、相对速度</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obji…]</td><td style="text-align:left">方块i位置、相对位置、相对速度</td></tr><tr><td style="text-align:left">achieved_goal</td><td style="text-align:left">[grip_x1, grip_y1, grip_z1,</br>grip_x2, grip_y2, grip_z2</br>…]</td><td style="text-align:left">每调用一次_get_obs()方法</br>将当前末端位置</br>添加到achieved_goal最后</td></tr><tr><td style="text-align:left">desired_goal</td><td style="text-align:left">[[x1, y1, z1], [x2, y2, z2], … ]</td><td style="text-align:left">多个目标位置</td></tr><tr><td style="text-align:left">force_sensor</td><td style="text-align:left">[f_x, f_y, f_z]</td><td style="text-align:left">force_reading，末端力，默认[0,0,0]</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><!--python data/collect_demos_reskill_6d.py --num_trajectories 40000 --subseq_len 10python train_skill_modules.py --config_file pickplace/config.yaml --dataset_name fetch_pickplace_40000python utils/test_skill_modules.py --dataset_name fetch_pickplace_40000 --use_skill_prior Truepython train_reskill_agent.py --config_file pickplace/config.yaml --dataset_name fetch_pickplace_40000python utils/test_reskill_agent.py --dataset_name fetch_pickplace_40000 --env_name FetchPourWater-v0--><p>💰</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 机器人动作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】Dex 演示引导强化学习与手术机器人任务自动化的高效探索</title>
      <link href="/post/90275938.html"/>
      <url>/post/90275938.html</url>
      
        <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：Demonstration-Guided Reinforcement Learning with Efficient Exploration for Task Automation of Surgical Robot<br><strong>标题</strong>：演示引导强化学习与手术机器人任务自动化的高效探索<br><strong>作者团队</strong>：香港中文大学（刘云辉团队）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/med-air/DEX">https://github.com/med-air/DEX</a></p></blockquote><h2 id="1-1-目标问题-5">1.1 目标问题</h2><p>虽然基于强化学习的方法为手术自动化提供了可能的方案，但是通常需要大量收集数据才能进行学习。因此本文目的是提高从演示中探索学习的效率，有效地利用专家演示数据。</p><p>具体而言，目前的问题如下：</p><ul><li>使用强化学习，如果不给出演示数据而仅通过探索学习，需要收集大量的数据来解决任务；</li><li>使用演示数据的方法，例如赋予演示数据相对于机器人探索数据更高的优先级，效率仍然低下，设置额外奖励函数的方法不仅只能针对特定环境，且容易引起局部最优；</li><li>使用 actor-critic 框架，通过正则化 actor 损失来衡量机器人与专家之间的行为差异，但是这种方式效率较低（尤其在初期机器人与演示差距较大情况下），且没有考虑 critic 的正则化，容易导致高估问题。</li></ul><p>本文贡献：</p><ul><li>提出一种 actor-critic 框架，降低 critic 的高估问题，提高强化学习过程中类似专家的行动进行探索。</li><li>使用非参数引导传播，实现未观测状态的探索</li><li>在 SurRoL 手术机器人上实验验证，效果优秀，同时部署在 dVRK 上，同样表示出强大的潜力。</li></ul><blockquote><p>dVRK(da Vinci Research Kit，达芬奇手术机器人系统)</p></blockquote><h2 id="1-2-方法-4">1.2 方法</h2><p>DEX(Demonstration-guided EXploration)，演示引导探索。</p><p><strong>（0）问题定义</strong></p><p>将手术机器人动作学习考虑为一个 off-policy 的智能体，在由马尔可夫决策过程构建的环境中进行交互。</p><blockquote><p>off-policy，指智能体不使用当前的策略来决定行动，而是使用不同的策略来生成行为数据，从过去的经历中学到最优的行为决策方法。</p></blockquote><p>在 $t$ 时刻，机器人根据当前状态 $s_t$ 以及确定性策略 $\pi$ 执行行动，环境用 $r_t=r(s_t,a_t)$ 奖励智能体，然后状态转移 $s_{t+1}$。</p><p>循环此过程，每次智能体将经验 $(s+t,a_t,r_t,s_{t+1})$ 存入重放缓冲区 $D_A$。</p><p>同时设置一个演示缓冲区 $D_E$，用于存放专家策略 $\pi$ 经验。</p><p><img src="https://img.mahaofei.com/img/202311151037433.png" alt="image.png"></p><p>如图，该方法由两部分组成：</p><ul><li>基于 actor-critic 的策略学习模块（右下角），用于从演示数据中指导探索；</li><li>基于最近邻匹配和局部加权回归的非参数模块（左上角），用于将与当前状态相差过大的演示传播到为当前状态。</li></ul><p><strong>（1）专家引导的 actor-critic 框架</strong></p><p>现有的 actor-critic 方法通过最大化预期回报来学习最优策略，但是如果 Q 值估计不准确，会阻碍探索。本文通过利用智能体和专家策略之间的动作差距来增强环境奖励。</p><p>$$<br>\max_{\pi}\mathbb{E}<em>{\pi}\left[\sum</em>{t=0}^{\infty}\gamma^{t}(r_{t}-\alpha d(a_{t},a_{t}^{e}))\right],a_{t}^{e}:=\pi^{e}(s_{t}),<br>$$</p><p>其中 $\alpha$ 是探索系数，$d()$ 衡量智能体动作和专家动作之间的相似性距离度量。</p><p>基于此奖励，本文设计了正则化 Q 函数（critic），并最小化动作价值和状态价值的差距。</p><p><strong>（2）有限演示情况下的引导的传播</strong></p><p>智能体在初始学习阶段很容易探索演示未覆盖的区域，无法实现监督 actor 探索。</p><p>常规的解决思路有行为克隆，但是当状态相差较大时，策略与专家行动仍会有较大的不同。因此本文使用非参数回归模型，从有限的演示中将经验传播实现更稳定的引导。</p><p>首先从演示缓冲区采样一小批状态和动作，然后给定一个当前状态，在一小批状态中搜索，利用 k 近邻方法找到最接近的状态，然后使用指数和函数的局部加权回归方法近似专家策略。</p><p>$$<br>\hat{\pi}^e(s)=\frac{\sum_{i=1}^k\exp\left(-|s-s^{(i)}|<em>2\right)\cdot a^{(i)}}{\sum</em>{i=1}^k\exp\left(-|s-s^{(i)}|_2)\right)}.<br>$$</p><h1>二、算法复现</h1><h2 id="2-1-环境配置">2.1 环境配置</h2><p>clone代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/med-air/DEX.git</span><br><span class="line">cd DEX</span><br></pre></td></tr></table></figure><p>创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n dex python=3.8</span><br><span class="line">conda activate dex</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -e SurRoL/# install surrol environments</span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line">pip3 install -e .</span><br></pre></td></tr></table></figure><p>在虚拟环境的<code>gym/envs/__init__.py</code>的第一行注册SurRoL任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">directory: anaconda3/envs/dex/lib/python3.8/site-packages/gym/envs/__init__.py</span></span><br><span class="line">import surrol.gym</span><br></pre></td></tr></table></figure><h2 id="2-2-数据采集">2.2 数据采集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir SurRoL/surrol/data/demo</span><br><span class="line">python SurRoL/surrol/data/data_generation.py --env NeedlePick-v0 </span><br></pre></td></tr></table></figure><h2 id="2-3-训练">2.3 训练</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 train.py task=NeedlePick-v0 agent=dex use_wb=True</span><br></pre></td></tr></table></figure><p>作者提供的程序中也包括了其它强化学习与模仿学习算法，例如：</p><ul><li>DDPG：深度确定性策略梯度的强化学习</li><li>DDPGBC：深度确定性策略梯度的强化学习+行为克隆</li><li>SAC：最大熵无模型深度强化学习</li><li>SQIL：正则化行为克隆的模仿学习</li><li>COL：行为克隆与强化学习</li><li>AWAC：离线强化学习</li><li>AMP：对抗模仿学习</li></ul><h1>三、代码理解</h1><h2 id="3-1-基本定义">3.1 基本定义</h2><p><strong>（1）机器人状态</strong></p><p>通过以下函数获取机器人状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SurRoL.surrol.tasks.psm_env.PsmEnv._get_robot_state</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_robot_state</span>(<span class="params">self, idx: <span class="built_in">int</span></span>) -&gt; np.ndarray:</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;获取机器人的状态，返回机器人当前位姿、夹爪角度，两者拼接成一个数组（3位置+3欧拉角+1开合角度）&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># robot state: tip pose in the world coordinate</span></span><br><span class="line">psm = self.psm1 <span class="keyword">if</span> idx == <span class="number">0</span> <span class="keyword">else</span> self.psm2</span><br><span class="line">pose_world = psm.pose_rcm2world(psm.get_current_position(), <span class="string">&#x27;tuple&#x27;</span>)    <span class="comment"># 机器人在世界坐标系下的位姿</span></span><br><span class="line">jaw_angle = psm.get_current_jaw_position()  <span class="comment"># 夹爪角度</span></span><br><span class="line"><span class="keyword">return</span> np.concatenate([</span><br><span class="line">np.array(pose_world[<span class="number">0</span>]), np.array(p.getEulerFromQuaternion(pose_world[<span class="number">1</span>])), np.array(jaw_angle).ravel()</span><br><span class="line">])  <span class="comment"># 3 + 3 + 1 = 7</span></span><br></pre></td></tr></table></figure><p>因此机器人的状态为一个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robot_state = [x, y, z, roll, pitch, yaw, gripper]</span><br></pre></td></tr></table></figure><p><strong>（2）观测状态</strong></p><p>观测状态通过以下方法进行获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SurRoL.surrol.tasks.psm_env.PsmEnv._get_obs</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_obs</span>(<span class="params">self</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;获取当前环境状态信息（机器人当前位置、目标物体位置、机器人与目标物体的相对位置）&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 获取机器人当前状态</span></span><br><span class="line">robot_state = self._get_robot_state(idx=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> may need to modify</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境中是否有物体，如果有则获取目标物体的位置、姿态、相对于机器人的位置</span></span><br><span class="line"><span class="keyword">if</span> self.has_object:</span><br><span class="line">pos, _ = get_link_pose(self.obj_id, -<span class="number">1</span>)     <span class="comment"># 目标物体位置</span></span><br><span class="line">object_pos = np.array(pos)</span><br><span class="line">pos, orn = get_link_pose(self.obj_id, self.obj_link1)   <span class="comment"># 获取目标物体的特定link的位置和方向</span></span><br><span class="line">waypoint_pos = np.array(pos)    <span class="comment"># 路径点位置为目标物体link位置</span></span><br><span class="line"><span class="comment"># rotations</span></span><br><span class="line">waypoint_rot = np.array(p.getEulerFromQuaternion(orn))  <span class="comment">#路径点姿态为目标物体link姿态</span></span><br><span class="line"><span class="comment"># relative position state</span></span><br><span class="line">object_rel_pos = object_pos - robot_state[<span class="number">0</span>: <span class="number">3</span>] <span class="comment"># 相对位置为目标位置与机器人末端位置之差</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> can have a same-length state representation</span></span><br><span class="line">object_pos = waypoint_pos = waypoint_rot = object_rel_pos = np.zeros(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定使用哪个位置作为目标位置</span></span><br><span class="line"><span class="keyword">if</span> self.has_object:</span><br><span class="line"><span class="comment"># object/waypoint position，使用物体位置object_pos，或物体link位置waypoint_pos</span></span><br><span class="line">achieved_goal = object_pos.copy() <span class="keyword">if</span> <span class="keyword">not</span> self._waypoint_goal <span class="keyword">else</span> waypoint_pos.copy()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># tip position，如果没有目标物体，则将机器人末端的位置作为目标位置</span></span><br><span class="line">achieved_goal = np.array(get_link_pose(self.psm1.body, self.psm1.TIP_LINK_INDEX)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">observation = np.concatenate([</span><br><span class="line">robot_state, object_pos.ravel(), object_rel_pos.ravel(),</span><br><span class="line">waypoint_pos.ravel(), waypoint_rot.ravel()  <span class="comment"># achieved_goal.copy(),</span></span><br><span class="line">])</span><br><span class="line">obs = &#123;</span><br><span class="line"><span class="string">&#x27;observation&#x27;</span>: observation.copy(),</span><br><span class="line"><span class="string">&#x27;achieved_goal&#x27;</span>: achieved_goal.copy(),</span><br><span class="line"><span class="string">&#x27;desired_goal&#x27;</span>: self.goal.copy()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obs</span><br></pre></td></tr></table></figure><p>可以看出观测状态是一个字典，包含三个键：<code>observation</code>, <code>achieved_goal</code>, <code>desired_goal</code>。</p><ul><li>observation: 由robot_state, object_pos.ravel(), object_rel_pos.ravel(), waypoint_pos.ravel(), waypoint_rot.ravel()组成，</li></ul><table><thead><tr><th style="text-align:left">obs</th><th style="text-align:left">键值（三个都是一维数组）</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">observation</td><td style="text-align:left">[robot_x, robot_y, robot_z, robot_roll, robot_pitch, robot_yaw, gripper,</td><td style="text-align:left">机器人末端位姿和夹爪状态</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_x, obj_y, obj_z,</td><td style="text-align:left">目标物体位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_rel_x, obj_rel_y, obj_rel_z,</td><td style="text-align:left">目标物体与当前机械臂相对位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_link1_x, obj_link1_y, obj_link1_z</td><td style="text-align:left">目标物体的link1位置作为waypoint位置</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">obj_link1_roll, obj_link1_pitch, obj_link1_yaw]</td><td style="text-align:left">目标物体的link1姿态作为waypoint姿态</td></tr><tr><td style="text-align:left">achieved_goal</td><td style="text-align:left">[x, y, z]</td><td style="text-align:left">waypoint作为实际位置，未设置link1则用目标物体位置作为实际位置，无物体则用机器人末端位置为实际位置</td></tr><tr><td style="text-align:left">desired_goal</td><td style="text-align:left">[x, y, z]</td><td style="text-align:left">机器人末端的目标位置</td></tr></tbody></table><p><strong>（3）机器人动作</strong></p><p>机器人动作通过以下方法进行执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SurRoL.surrol.tasks.psm_env.PsmEnv._set_action</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_set_action</span>(<span class="params">self, action: np.ndarray</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">delta_position (3), delta_theta (1) and open/close the gripper (1)</span></span><br><span class="line"><span class="string">in the world frame</span></span><br><span class="line"><span class="string">执行动作的过程（位置的变化，旋转变化，夹爪的开合）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(action) == self.ACTION_SIZE, <span class="string">&quot;The action should have the save dim with the ACTION_SIZE&quot;</span> <span class="comment"># ACTION_SIZE = 5</span></span><br><span class="line"><span class="comment"># time0 = time.time()</span></span><br><span class="line">action = action.copy()  <span class="comment"># ensure that we don&#x27;t change the action outside of this scope</span></span><br><span class="line">action[:<span class="number">3</span>] *= <span class="number">0.01</span> * self.SCALING  <span class="comment"># position, limit maximum change in position</span></span><br><span class="line">pose_world = self.psm1.pose_rcm2world(self.psm1.get_current_position())</span><br><span class="line">workspace_limits = self.workspace_limits1</span><br><span class="line">pose_world[:<span class="number">3</span>, <span class="number">3</span>] = np.clip(pose_world[:<span class="number">3</span>, <span class="number">3</span>] + action[:<span class="number">3</span>],</span><br><span class="line">workspace_limits[:, <span class="number">0</span>] - [<span class="number">0.02</span>, <span class="number">0.02</span>, <span class="number">0.</span>],</span><br><span class="line">workspace_limits[:, <span class="number">1</span>] + [<span class="number">0.02</span>, <span class="number">0.02</span>, <span class="number">0.08</span>])  <span class="comment"># clip to ensure convergence</span></span><br><span class="line">rot = get_euler_from_matrix(pose_world[:<span class="number">3</span>, :<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> self.ACTION_MODE == <span class="string">&#x27;yaw&#x27;</span>:</span><br><span class="line">action[<span class="number">3</span>] *= np.deg2rad(<span class="number">30</span>)  <span class="comment"># yaw, limit maximum change in rotation</span></span><br><span class="line">rot = (self.psm1_eul[<span class="number">0</span>], self.psm1_eul[<span class="number">1</span>], wrap_angle(rot[<span class="number">2</span>] + action[<span class="number">3</span>]))  <span class="comment"># only change yaw</span></span><br><span class="line"><span class="keyword">elif</span> self.ACTION_MODE == <span class="string">&#x27;pitch&#x27;</span>:</span><br><span class="line">action[<span class="number">3</span>] *= np.deg2rad(<span class="number">15</span>)  <span class="comment"># pitch, limit maximum change in rotation</span></span><br><span class="line">pitch = np.clip(wrap_angle(rot[<span class="number">1</span>] + action[<span class="number">3</span>]), np.deg2rad(-<span class="number">90</span>), np.deg2rad(<span class="number">90</span>))</span><br><span class="line">rot = (self.psm1_eul[<span class="number">0</span>], pitch, self.psm1_eul[<span class="number">2</span>])  <span class="comment"># only change pitch</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">raise</span> NotImplementedError</span><br><span class="line">pose_world[:<span class="number">3</span>, :<span class="number">3</span>] = get_matrix_from_euler(rot)</span><br><span class="line">action_rcm = self.psm1.pose_world2rcm(pose_world)</span><br><span class="line"><span class="comment"># time1 = time.time()</span></span><br><span class="line">self.psm1.move(action_rcm)</span><br><span class="line"><span class="comment"># time2 = time.time()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># jaw</span></span><br><span class="line"><span class="keyword">if</span> self.block_gripper:</span><br><span class="line">action[<span class="number">4</span>] = -<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> action[<span class="number">4</span>] &lt; <span class="number">0</span>:</span><br><span class="line">self.psm1.close_jaw()</span><br><span class="line">self._activate(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.psm1.move_jaw(np.deg2rad(<span class="number">40</span>))  <span class="comment"># open jaw angle; can tune</span></span><br><span class="line">self._release(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中机器人动作是一个长度为5的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action[<span class="number">5</span>] = [delta_x, delta_y, delta_z, yaw/pitch, gripper]</span><br></pre></td></tr></table></figure><ul><li>其中<code>delta_xyz</code>代表机器人末端在xyz轴上的位移量；</li><li>yaw/pitch根据类变量ACTION_MODE定义使用哪种旋转；</li><li>夹爪为负数则关闭，如果为非负数则根据数值大小确定打开大小。</li></ul><h1>四、代码修改</h1><h2 id="4-1-环境补充">4.1 环境补充</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install hydra-core colorlog termcolor opencv-python perlin_noise</span><br><span class="line">pip install <span class="string">&quot;cython&lt;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-测试">4.2 测试</h2><ul><li>AWAC：离线强化学习</li></ul><p><strong>（1）DDPGBC：深度确定性策略梯度的强化学习+行为克隆</strong></p><table><thead><tr><th style="text-align:left">DDPGBC</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（2）SAC：最大熵无模型深度强化学习</strong></p><table><thead><tr><th style="text-align:left">SAC</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left">平移物体到达位置，成功率高</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（3）SQIL：正则化行为克隆的模仿学习</strong></p><table><thead><tr><th style="text-align:left">SQIL</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（4）COL：行为克隆与强化学习</strong></p><table><thead><tr><th style="text-align:left">CoL</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（5）AWAC：离线强化学习</strong></p><table><thead><tr><th style="text-align:left">AWAC</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">平移物体到达位置，成功率低</td><td style="text-align:left">平移物体到达位置，成功率高</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（6）AMP：对抗模仿学习</strong></p><table><thead><tr><th style="text-align:left">AMP</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left">平移物体到达位置，成功率高</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">平移物体到达位置，成功率高</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><p><strong>（7）DEX：演示引导的强化学习</strong></p><table><thead><tr><th style="text-align:left">DEX</th><th style="text-align:left">Demo 1000</th><th style="text-align:left">Demo 10000</th></tr></thead><tbody><tr><td style="text-align:left">Success Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left">无法成功</td></tr><tr><td style="text-align:left">Trajectory Reward</td><td style="text-align:left">无法成功</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 机器人动作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习与模仿学习Buglist（不定时更新）</title>
      <link href="/post/1494b0dc.html"/>
      <url>/post/1494b0dc.html</url>
      
        <content type="html"><![CDATA[<h1>1 环境搭建问题</h1><h2 id="1-1-mujoco-相关">1.1 mujoco 相关</h2><h3 id="1-mujoco-py-安装后编译错误-Error-compiling-Cython-file">(1) mujoco-py 安装后编译错误 Error compiling Cython file</h3><p><strong>问题详情：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">performance hint: /home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/mujoco_py/cymj.pyx:67:5: Exception check on &#x27;c_warning_callback&#x27; will always require the GIL to be acquired.</span><br><span class="line">Possible solutions:</span><br><span class="line">1. Declare the function as &#x27;noexcept&#x27; if you control the definition and you&#x27;re sure you don&#x27;t want the function to raise exceptions.</span><br><span class="line">2. Use an &#x27;int&#x27; return type on the function to allow an error code to be returned.</span><br><span class="line">performance hint: /home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/mujoco_py/cymj.pyx:104:5: Exception check on &#x27;c_error_callback&#x27; will always require the GIL to be acquired.</span><br><span class="line">Possible solutions:</span><br><span class="line">1. Declare the function as &#x27;noexcept&#x27; if you control the definition and you&#x27;re sure you don&#x27;t want the function to raise exceptions.</span><br><span class="line">2. Use an &#x27;int&#x27; return type on the function to allow an error code to be returned.</span><br><span class="line"></span><br><span class="line">Error compiling Cython file:</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">...</span><br><span class="line">    See c_warning_callback, which is the C wrapper to the user defined function</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    global py_warning_callback</span><br><span class="line">    global mju_user_warning</span><br><span class="line">    py_warning_callback = warn</span><br><span class="line">    mju_user_warning = c_warning_callback</span><br><span class="line">                       ^</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">/home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/mujoco_py/cymj.pyx:92:23: Cannot assign type &#x27;void (const char *) except * nogil&#x27; to &#x27;void (*)(const char *) noexcept nogil&#x27;. Exception values are incompatible. Suggest adding &#x27;noexcept&#x27; to type &#x27;void (const char *) except * nogil&#x27;.</span><br><span class="line"></span><br><span class="line">Error compiling Cython file:</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">...</span><br><span class="line">    See c_warning_callback, which is the C wrapper to the user defined function</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    global py_error_callback</span><br><span class="line">    global mju_user_error</span><br><span class="line">    py_error_callback = err_callback</span><br><span class="line">    mju_user_error = c_error_callback</span><br><span class="line">                     ^</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/76985054/import-mujoco-py-is-giving-me-compiling-errors">stackoverflow</a> 与 <a href="https://github.com/openai/mujoco-py/issues/773#issuecomment-1639684035">github issue</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &quot;cython&lt;3&quot;</span><br></pre></td></tr></table></figure><h3 id="2-ERROR-GLEW-initalization-error-Missing-GL-version">(2) ERROR: GLEW initalization error: Missing GL version</h3><p><strong>问题详情：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/home/mahaofei/anaconda3/envs/reskill_new/lib/python3.7/site-packages/gym/envs/registration.py:64: UserWarning: register(timestep_limit=100) is deprecated. Use register(max_episode_steps=100) instead.</span><br><span class="line">  warnings.warn(&quot;register(timestep_limit=&#123;&#125;) is deprecated. Use register(max_episode_steps=&#123;&#125;) instead.&quot;.format(timestep_limit, timestep_limit))</span><br><span class="line">Creating window glfw</span><br><span class="line">ERROR: GLEW initalization error: Missing GL version</span><br><span class="line"></span><br><span class="line">Press Enter to exit ...Killed</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so</span><br></pre></td></tr></table></figure><blockquote><p>[!question] 配置好 gym 环境后再使用 opencv 出现 RuntimeError: Failed to initialize OpenGL<br>目前来看 gym 渲染和 opencv 显示不能同时使用。</p><ul><li>想要使用 opencv 则需要执行 <code>unset LD_PRELOAD</code>；</li><li>想要使用 gym 渲染需要执行 <code>export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libGLEW.so</code>。</li></ul></blockquote><h3 id="3-MujocoException-Got-MuJoCo-Warning-Nan-Inf-or-huge-value-in-QACC-at-DOF-X-The-simulation-is-unstable">(3) MujocoException: Got MuJoCo Warning: Nan, Inf or huge value in QACC at DOF X. The simulation is unstable.</h3><p><strong>问题原因：</strong></p><p>在使用<code>mujoco</code>进行强化学习训练的过程中，有可能会出先上面这种报错，从而导致训练提前终止。</p><p>这是因为在执行<code>env.step</code>过程中，环境中的模型（机器人自身或者机器人和其它物体）发生了模型穿透或者约束冲突，导致mujoco无法进行仿真。</p><p><strong>解决方法1：添加关节属性damping和armature（有效！）</strong></p><p>参考链接：<a href="https://github.com/google-deepmind/mujoco/issues/989">https://github.com/google-deepmind/mujoco/issues/989</a></p><p>在限制关节转角后，法线算法能训练的epoch数变多了，但是到后面还是会报错。</p><p>经过检查法线我的夹爪上的关节都没有设置阻尼，添加<code>damping</code>和<code>armature</code>，注意需要给所有的<code>joint</code>都添加这两个属性，包括机器人和各种物体。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;robotiq_2f_85_right_driver_joint&quot;</span> <span class="attr">range</span>=<span class="string">&quot;0 0.834&quot;</span> <span class="attr">damping</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">armature</span>=<span class="string">&#x27;0.01&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>之后再进行训练，再也没有出现过错误。</p><p>注意：<code>damping</code>和<code>armature</code>这两个参数可能需要调节，尤其是夹爪等比较小的部件，如果这里的阻尼设置的太大，会出现关节无法运动的情况。</p><p><strong>其它方法2：限制关节范围（有一定效果）</strong></p><p>对于我的机械臂模型而言，由于我的目标任务是抓取，机械臂原本的活动范围设置的很大，在调试过程中也能够发现在很多情况下机械臂会与自身碰撞、或与桌面碰撞。</p><p>我的方法是：手动控制机械臂在<code>mujoco</code>环境中运动，使其到达任务空间的极限位置，使用下面的命令，打印出各<code>joint</code>在极限位置的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sim.data.qpos[model.jnt_qposadr])</span><br></pre></td></tr></table></figure><p>根据所有极限位置，确定各个关节的取值范围。</p><p>然后在模型的<code>.xml</code>文件中，修改<code>&lt;wholebody&gt;</code>中各个<code>&lt;joint&gt;</code>的<code>range</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 初始 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;joint name=&quot;joint1&quot; pos=&quot;0 0 0&quot; axis=&quot;0 0 1&quot; armature=&quot;1.5708&quot; limited=&quot;true&quot; range=&quot;-3.14159 3.14159&quot; damping=&#x27;200&#x27; /&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 测试关节范围(抓取) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;joint1&quot;</span> <span class="attr">pos</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">axis</span>=<span class="string">&quot;0 0 1&quot;</span> <span class="attr">armature</span>=<span class="string">&quot;1.5708&quot;</span> <span class="attr">limited</span>=<span class="string">&quot;true&quot;</span> <span class="attr">range</span>=<span class="string">&quot;-1.57079 1.57079&quot;</span> <span class="attr">damping</span>=<span class="string">&#x27;200&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>经过测试，只改变<code>joint</code>的<code>range</code>后，能迭代的次数变多了，但是还是没有解决问题。</p><p><strong>其它方法3：修改奖励函数（有一定效果）</strong></p><p>因为报错的原因是机器人的动作超出了工作空间或者发生了碰撞，那么说明学习算法没有学习到合适的动作，让机器人产生了错误的运动。</p><p>因此考虑修改奖励函数，加入超出工作空间的惩罚，例如对于抓取，如果夹爪末端位置xyz超出一定坐标，则给予惩罚，以及夹爪距离物体过远，也给予惩罚。</p><p>这种方式有一定效果。</p><p><strong>其它方法4：减小solrel（未尝试）</strong></p><p>参考链接：<a href="https://github.com/google-deepmind/mujoco/discussions/63">https://github.com/google-deepmind/mujoco/discussions/63</a></p><p><strong>其它方法5：改用RK4积分器（无效）</strong></p><p>参考链接：<a href="https://github.com/google-deepmind/mujoco/issues/168">https://github.com/google-deepmind/mujoco/issues/168</a></p><p><strong>其它方法6：检查环境设置（有效）</strong></p><p>检查环境的<code>reset</code>函数是否设置正确，经过检查，我发现我的代码问题在于重置了环境和机械臂的各个关节，但是没有重置<code>mocap</code>，导致如果上一次仿真最后机械臂末端漂了，这一次一开始机械臂就会漂的很远，随着仿真的进行就容易出现上面的错误。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】基于强化学习的机器人动作模仿</title>
      <link href="/post/6fa4482c.html"/>
      <url>/post/6fa4482c.html</url>
      
        <content type="html"><![CDATA[<h1>1 Reinforcement Learning with Videos: Combining Offline Observations with Interaction</h1><blockquote><p><strong>标题</strong>：视频强化学习：将离线观察与互动相结合<br><strong>作者团队</strong>：宾夕法尼亚大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/kschmeckpeper/rl_with_videos">https://github.com/kschmeckpeper/rl_with_videos</a></p></blockquote><h2 id="1-1-目标问题-7">1.1 目标问题</h2><p>应用强化学习使机器人学习技能，通常需要大量的机器人在线数据，但是机器人的数据收集非常麻烦困难，难以获得足够多的数据。</p><p>人类视频广泛且多样，因此考虑从人类经验中进行强化学习。但因为人类视频没有动作的标注，并且人类视频和机器人相机图像，具有巨大的图像差异和视角差异。具体问题如下：</p><ul><li>机器人必须能通过观察来更新策略，不需要任何的行动或者奖励；</li><li>人手与末端执行器视觉差异较大，自由度也不同，因此需要考虑动作空间、形态、视角、环境差异带来的变化；</li></ul><p>为了解决这些问题，本文提出了视频强化学习框架（Reinforcement Learning with Videos，RLV），使用人类数据经验和机器人数据学习策略和价值函数。</p><h2 id="1-2-方法-6">1.2 方法</h2><p><strong>（1）问题定义</strong></p><p>该论文将问题公式化为马尔可夫决策过程 MDP，定义成元组 $(S_{int},A_{int},P,R)$，其中 $S_{int}$ 是状态空间，$A_{int}$ 是动作空间，$P$ 是环境的动力学，$R$ 是奖励函数。</p><p>机器人首先被提供了人类的观测 ${(s_{obs},s_{int}')_{1:t}}$，这些观察被建模成另一组马尔可夫决策链，其具有不同的状态和动作空间，但是两者的动力学和奖励函数是相同的。</p><p><strong>（2）方法概述</strong></p><p>该论文所提出的方法如下图所示，包含两个重放池，一个是无动作的观测数据 $(s_{obs},s_{obs}‘)\in D_{obj}$，另一个是包含动作条件的交互数据 $(s_{int},a_{int},s_{int}’,r_{int})\in D_{int}$，交互数据在训练期间会更新，而观测数据仅仅是初始的观测数据集。</p><blockquote><p><strong>重放池 (reply pool)</strong>：存储了智能体过去经历过的（状态，动作，奖励，新状态）的数据结构，通过采样这个池中的数据进行训练，可以从过去的经验中学习更多的规律，提高决策能力。</p></blockquote><p><img src="https://img.mahaofei.com/img/202311091616113.png" alt="image.png"></p><ul><li>左图：从动作条件重放池中采样数据 $(s_{int},a_{int},s_{int}‘,r_{int})$，将观测状态分别编码成特征 $h_{int},h_{int}’$，训练一个可逆的模型，来从特征中预测动作 $a_{int}$。</li><li>中图：将这个可逆模型用于根据观测状态特征 $h_{obs},h_{obs}'$，预测离线视频中的缺失的机器人动作 $\hat a_{int}$，将轨迹中最后一步设置为很大的奖励，前面其它步骤都设置为很小的奖励。</li><li>右图：使用 adversarial domain confusion(ADS)来对齐特征，最后使用离线策略强化学习算法，对于数据 $((h_{int},h_{obs}),(a_{int},\hat a_{int}),(h_{int}‘,h_{obs}’),(r_{int},\hat r_{obs}))$ 进行训练。</li></ul><blockquote><p><strong>Adversarial Domain Confusion (ADC)</strong>：通过最小化源域和目标域之间的特征分布距离来实现跨域的迁移学习。</p></blockquote><p><strong>（3）动作预测</strong></p><p>本文通过监督学习训练了一个参数为 $\theta$ 的逆模型，根据一对不变的特征编码 $(h,h’)$ 计算机器人动作。由于机器人与人类视频环境相同，我们应该能够预测任一马尔可夫决策过程的数据的操作。</p><p>损失使用预测动作 $\hat a_{int}=f_{inv}(h_{int},h_{int}';\theta)$ 和真实动作的均方误差 $a_{int}$：</p><p>$$<br>L_a(a_{int},h_{int},h_{int}‘,\theta)=||a_{int}-f_{inv}(h_{int},h_{int}’;\theta)||^2<br>$$</p><p>本文使用逆模型预测人手视频中的动作数据，并用它们来训练强化学习算法。</p><p><strong>（4）奖励生成</strong></p><p>由于强化学习使用观测数据的一个障碍就是缺乏奖励，虽然可以通过上面训练的逆模型预测奖励和动作，但实际上效果可能不会很好。</p><p>本文使用了替代方案，将观测数据轨迹的最后一个时间步长分配一个大的恒定奖励，之前的每一个时间步长分配一个小的恒定奖励。</p><p>这种方式目的是保证观测数据在轨迹结束时达到目标状态。至于其中的不准确之处，可以通过机器人收集的交互数据训练来消除。</p><p><strong>（5）域自适应</strong></p><p>要使用观测数据 $(s_{obs},s_{obs})'$，需要将其映射到一个不变的量 $h$。</p><p>为了实现这个目的，本文训练了一种特征编码器 $f_{enc}$，来从观测状态 $s$ 中学习编码表示 $h=f_{enc}(s;\psi)$，这种编码器应该包含所有相关的信息，并对与观测的域来说是不变的。</p><p>本文还训练了一个鉴别器，用于区分观测数据中提取的特征 $h_{obs}$ 和机器人交互数据中提取的特征 $h_{int}$。</p><p>将特征编码器和鉴别器使用对抗性学习方法进行训练，过程中编码器试图最小化鉴别器对编码特征的域的正确分类能力，鉴别器试图最大化分类能力。</p><p>最终获得的编码器就是我们需要的，将观测数据和机器人交互数据映射到不变量 $h$ 的编码器。</p><p><strong>（6）联合优化</strong></p><p>将领域自适应损失和逆模型的损失进行联合优化。</p><h1>2 Learning Generalizable Robotic Reward Functions from “In-The-Wild” Human Videos</h1><blockquote><p><strong>标题</strong>：从“野外”人类视频中学习可推广的机器人奖励函数<br><strong>作者团队</strong>：斯坦福大学<br><strong>期刊会议</strong>：Robotics: Science and Systems (RSS)<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://sites.google.com/view/dvd-human-videos">https://sites.google.com/view/dvd-human-videos</a></p></blockquote><h2 id="2-1-目标问题-3">2.1 目标问题</h2><p>要实现通用型机器人完成各类任务，关键是机器人能够知道任务成功和奖励的能力，该奖励函数还必须能够在不同环境、任务、对象中推广。</p><p>由于收集大规模机器人交互数据是一件十分复杂困难的问题，而人类视频中则包含了大量的不同环境中的任务信息。</p><p>本文提出了一种不可知域视频鉴别器(Domain-agnostic Video Discriminator, DVD)，通过训练鉴别器来分类两个视频是否执行相同的任务学习多任务奖励函数。并通过少量的机器人训练数据学习人类视频的广泛数据集进行推广。</p><p>要解决的问题：</p><ul><li>人类的 wild data 和机器人的观测空间有着巨大的域变换，不管是 agent 的形态、还是场景的外观。</li><li>人类的动作空间和机器人的动作空间不同，可能不能很好的实现动作的映射</li><li>人类视频很多情况下是低质量的、有噪声的，还有着复杂的背景或视角</li></ul><p>解决思路：</p><ul><li>训练一个分类器预测两个视频是否完成的是同一个任务，也就是不可知域视频鉴别器（DVD）</li><li>训练完成后，DVD 能够将人类视频作为演示，机器人的行为作为另一个视频，输出一个分数，衡量任务成功的奖励。</li></ul><h2 id="2-2-方法-3">2.2 方法</h2><p><strong>（1）Domain-Agnostic Video Discriminators</strong></p><ul><li>一个预训练视频编码器将视频 $d_i$ 编码为特征 $h_i$</li><li>一个全连接神经网络，预测两个视频是否完成同样的任务<ul><li>损失函数设置见原文</li><li>奖励函数通过训练分类器来获得</li></ul></li></ul><p>本文的关键是训练一个分类器来学习 $R_\theta$，该分类器两个视频作为输入，判断两个视频是否属于同一个任务。视频可以来自于人类数据集或机器人数据集。</p><p>首先对视频进行采样，设两个视频为 $d_i$ 和 $d_j$，采样一批视频 $(d_i,d_i’,d_j)$ 其中 $d_i$ 和 $d_i’$ 是完成相同的任务，$d_j$ 是完成不同的个任务，最小化平均交叉熵损失训练 $R_\theta$，损失函数见原文，最终得到奖励函数如下：</p><p>$$<br>R_\theta(d_i,d_j)=f_{sin}(f_{enc}(d_i),f_{enc}(d_j);\theta)<br>$$</p><p>其中 $h=f_{enc}$ 是一个预训练的视频编码器，$f_{sin}(h_i,h_j;\theta)$ 是一个参数为 $\theta$ 的全连接神经网络，用来预测两个视频编码特征 $h_i,h_j$ 是否完成同样的任务。</p><p><strong>（2）使用 DVD 执行任务</strong></p><p>使用视觉模型预测控制(Visual Model Predictive Control, VMPC)实现。</p><p><img src="https://img.mahaofei.com/img/202311101115799.png" alt="image.png"></p><ol><li>使用 SV2P 模型训练动作条件视频预测模型 $\rho$</li><li>使用交叉熵和该动作模型 $\rho$ 选择与人类演示最相似的动作<ol><li>对输入图像，从动作分布中采样多个动作序列，并使用动作模型 $\rho$ 预测相应的未来轨迹</li><li>将每个预测轨迹和人类演示视频，输入DVD，得到任务相似性分数</li><li>执行与演示图象具有最高相似性的动作轨迹</li></ol></li></ol><h1>3 PLAS: Latent Action Space for Offline Reinforcement Learning</h1><blockquote><p><strong>标题</strong>：PLAS：离线强化学习的潜在行动空间<br><strong>作者团队</strong>：卡耐基梅隆大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2021<br><strong>代码</strong>： <a href="https://github.com/sfujim/BCQ">https://github.com/sfujim/BCQ</a></p></blockquote><h2 id="3-1-目标问题-2">3.1 目标问题</h2><p>离线强化学习可以从固定的数据集中学习策略。</p><p>在机器人中，数据收集十分麻烦且有一定的危险性，现有的方法从离线数据集中进行学习，性能十分受限。</p><p>本文提出了潜在动作空间中的策略(Policy in the Latent Action Space, PLAS)。</p><h2 id="3-2-方法-2">3.2 方法</h2><p><strong>（0）原理基础-离线 RL</strong></p><p>给定一个固定的离线数据集 $D={(s_t,a_t,r_t,s_{t+1})_i}$，难点在于该数据集没有覆盖马尔科夫决策过程 MDP 的整个状态空间和动作空间。</p><p>离线 RL 目的就是学习能使奖励最大化的策略，而策略受到我们对马尔可夫决策过程的了解，马尔可夫决策过程则是从有限的数据集中推理得到的。</p><p>但如果考虑离线 RL 的目标是最大化 MDP 在有限数据集下的累计回报，也能作为近似替代。并且在近似 Q 函数的时候会存在推理误差，</p><p><img src="https://img.mahaofei.com/img/202311122207187.png" alt="image.png"></p><p>给定一个状态，潜在策略输出一个潜在动作，使用解码器将其解码为动作空间输出。（可以添加扰动层来增加泛化能力）</p><p><strong>（1）潜在动作空间中的策略（Policy in Latent Action Space, PLAS）</strong></p><p>给定离线数据集，本文使用条件变分自动编码器（Conditional Variational Autoencoder, CVAE）对策略进行建模。为了使策略约束在数据集的范围内，考虑使用确定性策略，从状态映射到潜在动作，再用解码器得到实际动作。</p><p><strong>（2）泛化</strong></p><p>潜在策略再数据集范围内能够提供约束，但是在训练的时候，本文允许了从分布外的行为的发生，即添加了一个扰动层，设置了一个超参数限制扰动层的动作输出残差。</p><p>当然，如果数据集再状态-动作空间中有着非常高的覆盖率，那么这个扰动层就是不必要的。</p><h1>4 Demonstration-Guided Reinforcement Learning with Efficient Exploration for Task Automation of Surgical Robot</h1><blockquote><p><strong>标题</strong>：演示引导强化学习与手术机器人任务自动化的高效探索<br><strong>作者团队</strong>：香港中文大学（刘云辉团队）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/med-air/DEX">https://github.com/med-air/DEX</a></p></blockquote><h2 id="4-1-目标问题">4.1 目标问题</h2><p>虽然基于强化学习的方法为手术自动化提供了可能的方案，但是通常需要大量收集数据才能进行学习。因此本文目的是提高从演示中探索学习的效率，有效地利用专家演示数据。</p><p>具体而言，目前的问题如下：</p><ul><li>使用强化学习，如果不给出演示数据而仅通过探索学习，需要收集大量的数据来解决任务；</li><li>使用演示数据的方法，例如赋予演示数据相对于机器人探索数据更高的优先级，效率仍然低下，设置额外奖励函数的方法不仅只能针对特定环境，且容易引起局部最优；</li><li>使用 actor-critic 框架，通过正则化 actor 损失来衡量机器人与专家之间的行为差异，但是这种方式效率较低（尤其在初期机器人与演示差距较大情况下），且没有考虑 critic 的正则化，容易导致高估问题。</li></ul><p>本文贡献：</p><ul><li>提出一种 actor-critic 框架，降低 critic 的高估问题，提高强化学习过程中类似专家的行动进行探索。</li><li>使用非参数引导传播，实现未观测状态的探索</li><li>在 SurRoL 手术机器人上实验验证，效果优秀，同时部署在 dVRK 上，同样表示出强大的潜力。</li></ul><blockquote><p>dVRK(da Vinci Research Kit，达芬奇手术机器人系统)</p></blockquote><h2 id="4-2-方法-2">4.2 方法</h2><p>DEX(Demonstration-guided EXploration)，演示引导探索。</p><p><strong>（0）问题定义</strong></p><p>将手术机器人动作学习考虑为一个 off-policy 的智能体，在由马尔可夫决策过程构建的环境中进行交互。</p><blockquote><p>off-policy，指智能体不使用当前的策略来决定行动，而是使用不同的策略来生成行为数据，从过去的经历中学到最优的行为决策方法。</p></blockquote><p>在 $t$ 时刻，机器人根据当前状态 $s_t$ 以及确定性策略 $\pi$ 执行行动，环境用 $r_t=r(s_t,a_t)$ 奖励智能体，然后状态转移 $s_{t+1}$。</p><p>循环此过程，每次智能体将经验 $(s+t,a_t,r_t,s_{t+1})$ 存入重放缓冲区 $D_A$。</p><p>同时设置一个演示缓冲区 $D_E$，用于存放专家策略 $\pi$ 经验。</p><p><img src="https://img.mahaofei.com/img/202311151037433.png" alt="image.png"></p><p>如图，该方法由两部分组成：</p><ul><li>基于 actor-critic 的策略学习模块（右下角），用于从演示数据中指导探索；</li><li>基于最近邻匹配和局部加权回归的非参数模块（左上角），用于将与当前状态相差过大的演示传播到为当前状态。</li></ul><p><strong>（1）专家引导的 actor-critic 框架</strong></p><p>现有的 actor-critic 方法通过最大化预期回报来学习最优策略，但是如果 Q 值估计不准确，会阻碍探索。本文通过利用智能体和专家策略之间的动作差距来增强环境奖励。</p><p>$$<br>\max_{\pi}\mathbb{E}<em>{\pi}\left[\sum</em>{t=0}^{\infty}\gamma^{t}(r_{t}-\alpha d(a_{t},a_{t}^{e}))\right],a_{t}^{e}:=\pi^{e}(s_{t}),<br>$$</p><p>其中 $\alpha$ 是探索系数，$d()$ 衡量智能体动作和专家动作之间的相似性距离度量。</p><p>基于此奖励，本文设计了正则化 Q 函数（critic），并最小化动作价值和状态价值的差距。</p><p><strong>（2）有限演示情况下的引导的传播</strong></p><p>智能体在初始学习阶段很容易探索演示未覆盖的区域，无法实现监督 actor 探索。</p><p>常规的解决思路有行为克隆，但是当状态相差较大时，策略与专家行动仍会有较大的不同。因此本文使用非参数回归模型，从有限的演示中将经验传播实现更稳定的引导。</p><p>首先从演示缓冲区采样一小批状态和动作，然后给定一个当前状态，在一小批状态中搜索，利用 k 近邻方法找到最接近的状态，然后使用指数和函数的局部加权回归方法近似专家策略。</p><p>$$<br>\hat{\pi}^e(s)=\frac{\sum_{i=1}^k\exp\left(-|s-s^{(i)}|<em>2\right)\cdot a^{(i)}}{\sum</em>{i=1}^k\exp\left(-|s-s^{(i)}|_2)\right)}.<br>$$</p><h1>5 Residual Skill Policies: Learning an Adaptable Skill-based Action Space for Reinforcement Learning for Robotics</h1><blockquote><p><strong>标题</strong>：剩余技能策略：学习基于技能的适应性行动空间，用于机器人强化学习<br><strong>作者团队</strong>：昆士兰科技大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://krishanrana.github.io/reskill">https://krishanrana.github.io/reskill</a></p></blockquote><h2 id="5-1-目标问题-2">5.1 目标问题</h2><p>基于技能的学习已经成为加速机器人学习的方法，技能从专家演示中提取，是短序列的单步操作（平移、抓取、抬起等动作），这些技能嵌入到潜在空间中，构成上层 RL 策略的行动空间。但是这种方式存在一些问题：</p><ul><li>对所有技能进行随机抽样探索，效率极低，因为其中只有一小部分技能与当前执行的任务相关，并且这些相关的技能通常不会聚集在技能空间的同一邻域内。</li><li>该方法假设技能是最优的，并且下层的任务来自于技能空间的相同分布，因此学习的通用性和变化适应性有限，例如从移动方块中学习技能，则无法应对障碍物、物体变化、不同摩擦等情况。</li></ul><p>为解决上述问题，本文提出了以下创新方法，称为残差技能策略（Residual Skill Policies，ReSkill）：</p><ul><li>状态条件技能先验：对相关技能进行采样来引导探索</li><li>底层残差策略：通过对技能进行细粒度的技能适应，实现任务变化的适应</li></ul><h2 id="5-2-方法">5.2 方法</h2><p>总的来说，该方法将经典控制器产生的演示轨迹分解为与任务无关的技能，并将其嵌入到连续到技能空间中，利用技能空间实现真正的通用学习，上层智能体能够从技能空间中访问但不动作，降低了对数据集详细程度的要求。</p><ul><li>从现有控制器中提取技能</li><li>学习技能嵌入和先验技能</li><li>训练一个分层强化学习策略，在技能空间中使用底层残差适应性策略。</li></ul><p><img src="https://img.mahaofei.com/img/202311161019261.png" alt="image.png"></p><p><strong>（1）数据收集</strong></p><p>本文通过手动控制收集演示数据（基本操作任务，如推物体、抓物体），虽然任务简单，但轨迹包含复杂的技能，可以重新组合解决复杂的任务。</p><p>轨迹是由 state-action 成对组成的，本文从中随机切片 $H$ 长度的片段进行无监督技能提取，利用提取的动作 a 和状态 s 学习下一小节中的 state-action。</p><p>其中状态 s 包括关节角度、关节速度、夹具位置、物体位置，动作是连续的 4D 向量，包括末端位置和速度。</p><p><strong>（2）学习强化学习的状态条件技能空间</strong></p><ul><li>将提取的技能嵌入到潜在空间中：使用变分自动编码器 VAE 将技能 $a$ 嵌入到潜在空间中，VAE 包括编码器和解码器，编码器将完整的 state-action 序列编码为 $z$，解码器根据当前状态 $s_t$ 和技能编码 $z$ 重建动作。</li><li>在探索过程中采样的技能状态条件先验：学习潜在技能空间上的条件概率密度。传统的高斯密度不能处理多模态信息，本文使用 real NVP 方法，实值非体积保留变换。学习从 $Z\times S-&gt;G$ 的映射，该映射就可以从简单分布 G 变换到技能空间 Z，因此 f 就是技能先验。</li></ul><blockquote><p><strong>变分自编码器</strong>，是一种深度生成模型<br><strong>传统</strong>：传统的自编码器包括编码器和解码器两部分，经过反复训练，输入数据被编码成一个编码向量，编码向量的每一个维度表示学习到的数据的特征，解码器尝试从编码向量中解码原始输入<br><strong>缺陷</strong>：传统的方法，使用单个值表示输入在某个潜在特征的表现。但实际上，将潜在特征表示为可能的取值范围会更合理。<br><strong>改进</strong>：因此变分自编码器就是使用取值的概率分布，代替原来的单值表示特征。<br><strong>优势</strong>：每个潜在特征表示为概率分布，解码时从潜在状态分布中随机采样，生成一个编码向量作为解码器的输入。实现了连续且平滑的潜在空间表示（潜在空间中彼此相邻的值重构出的结果相似）<br>参考理解:<a href="https://zhuanlan.zhihu.com/p/64485020">https://zhuanlan.zhihu.com/p/64485020</a></p></blockquote><p><strong>（3）状态条件技能空间中的强化学习</strong></p><p>一旦训练完成，解码器和技能先验权重就会被冻结，并合并到 RL 框架中。高级强化学习策略 $\pi$ 是一个神经网络，将状态映射到技能先验变化中的向量 g，在转换为潜在技能 Z。</p><p>然后解码器根据技能范围 H 的当前状态顺序重构动作。同时有一个底层残差策略，调整解码后的技能。</p><h2 id="5-3-总结">5.3 总结</h2><p>该方法是一种基于技能的强化学习方法。</p><ol><li>数据收集：使用最基本的控制器生成一些基本任务轨迹（移动、抓取），然后将这些轨迹分割成固定长度的序列，每一小段包括动作和对应的状态。</li><li>学习技能空间，使用变分自编码器将技能编码到潜在空间中；使用realNVP将技能潜在空间+机器人状态空间映射到简单分布空间（高斯分布），这样可以直接根据状态采样技能，称为技能先验。</li><li>强化学习：使用一个高层策略网络，根据当前的状态生成一个向量，根据技能先验（与当前状态有关的技能）中选择一个技能，利用技能解码器解码成机器人动作。</li></ol><h1>6 Watch and Match: Supercharging Imitation with Regularized Optimal Transport</h1><blockquote><p><strong>标题</strong>：观看与匹配：通过正则化最优传输增强模仿<br><strong>作者团队</strong>：纽约大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://rot-robot.github.io/">https://rot-robot.github.io/</a></p></blockquote><h2 id="6-1-目标问题-2">6.1 目标问题</h2><p>目前模仿学习通常使用逆强化学习，给出演示的情况下，交替推理奖励函数和策略。但是这种方式需要大量的在线交互来解决复杂的控制问题。</p><p>本文提出了正则化最佳传输（Regularized Optimal Transport，ROT）方法，即使只有少量的演示，也能自适应的匹配轨迹奖励与行为克隆，加速模仿。</p><blockquote><p>基于最佳传输的模仿学习（Optimal Transport，OT）：模仿学习实在给定专家策略或轨迹的情况下学习行为行为策略 $\pi^b$，逆强化学习根据专家轨迹 $T^e$ 推断奖励函数 $r^e$，然后利用奖励优化策略来得到行为策略 $\pi^b$。为了计算 $r^e$，基于 OT 的逆学习方法就是一种思路。专家轨迹和行为轨迹的接近程度可以通过测量两个轨迹之间的最佳传输来计算。</p></blockquote><h2 id="6-2-方法-2">6.2 方法</h2><p><strong>（1）BC 预训练</strong></p><p>使用 BC 对专家演示的数据进行随机初始化策略的训练。</p><p>BC 对应求解公式中的最大似然问题，这里的专家轨迹 $T^e$ 指的是专家演示，训练后，它能够使 $\pi^{BC}$ 模仿与演示中想对应的动作，但是如果出现未见过的状态，那么很容易会导致推理失败。</p><p><strong>（2）在线 IRL 微调</strong></p><p>在 BC 训练的模型基础上，进行在线微调策略。由于本文操作没有明确的任务奖励，因此使用基于 OT 的轨迹匹配获得奖励。（本文使用了 n 步 DDPG 方法实现连续控制）</p><ol><li>正则化微调：由于在线部署期间很容易因为错误累计导致分布偏移，本文通过基于引导 RL 和离线 RL 将 $\pi^{ROT}$ 与 BC 损失相结合来规范 $\pi^{ROT}$ 的训练，此处设置了一个 $\lambda(\pi)$ 自适应权重来控制两个损失项的贡献。</li><li>柔性 Q 滤波的自适应正则化：自适应权重调整 $\lambda(\pi)$，通过比较当前策略 $\pi^{ROT}$ 和与训练策略 $\pi^{BC}$ 在一段重放缓冲区采样的一批数据的性能表现来完成。</li><li>基于图像观测的考虑：对视觉观测进行数据增强，将图像输入 CNN 编码器，获得 OT 奖励的计算，减少 ROT 模仿过程中的非平稳性。</li></ol><h2 id="6-3-实验">6.3 实验</h2><p>本文的模型包括三个神经网络：encoder、actor、critic，三者均使用均方误差进行训练。</p><p>使用 n 步 DDPG 作为 RL 主干，actor 使用确定性策略梯度进行训练。critic 使用 clipped double Q-learning 进行训练，主要时为了减少高估问题，因此使用两个 Q 函数实现 critic 的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 强化学习 </tag>
            
            <tag> 模仿 </tag>
            
            <tag> 机器人动作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模仿学习笔记】行为克隆 Behavior Cloning</title>
      <link href="/post/1d3a3b82.html"/>
      <url>/post/1d3a3b82.html</url>
      
        <content type="html"><![CDATA[<h1>一、行为克隆概念</h1><p>行为克隆属于模仿学习中的方法，不是强化学习。</p><blockquote><p>强化学习：从环境给出的奖励中进行监督；<br>模仿学习：从人类动作经验中监督<br>区分两者主要在于，模仿学习没有奖励回报，知识模仿专家动作。</p></blockquote><h1>二、行为克隆过程</h1><ol><li>观测当前状态 $s_t$</li><li>策略网络做出预测 $p_t$</li><li>专家的动作是 $a_t^*$，向量化从而得到 $y_t$</li><li>计算损失 CrossEntropy($y_t,p_t$)</li><li>使用梯度下降来更新策略网络</li></ol><h1>三、行为克隆的优势与不足</h1><p>如果当前的状态出现在训练数据中，则可以根据行为克隆训练得到的策略网络，执行类似于人类专家的动作。</p><p>但是如果当前状态没有出现在训练数据中，那么策略网络输出的动作可能不会很好，而且错误会累加。这种情况尤其出现在状态极为复杂的情况下。</p><h1>一、模仿学习简介</h1><p>模仿学习是让智能体从专家示例中学习，从而像人类专家一样能够智能决策。</p><ul><li>不同于传统的监督学习算法，监督学习需要考虑大量的约束条件，根据约束设计特定的监督方法来引导智能体；</li><li>而模仿学习旨在让人类为之恩能够提提供大量的示例行为，利用这些专家示例来教会智能体进行决策。</li></ul><p>目前模仿学习主要分为两类：</p><ul><li>行为克隆：尝试最小化智能体策略和专家策略的动作差异，把模仿学习作为回归或分类任务学习；</li><li>对抗式模仿学习：通过逆强化学习来构建对抗的奖励函数，最大化这个奖励函数来模仿专家行为。</li></ul><h1>二、数学基础（马尔可夫决策过程）</h1><p>考察一个有限状态的马尔可夫链，状态空间$S={1,2,3,\cdots,|S|}$，由于马尔可夫性，状态转移与历史状态无关，因此对于有限状态的马尔可夫链，状态转移矩阵 $P$ 如下：</p><p>$$<br>P=\begin{bmatrix}{}<br>p_{1,1} &amp; p_{1,2} &amp; \cdots &amp; p_{1,|S|}\<br>p_{2,1} &amp; p_{2,2} &amp; \cdots &amp; p_{2,|S|}\<br>\cdots &amp; \cdots &amp; \cdots &amp; \cdots\<br>p_{|S|,1} &amp; p_{|S|,2} &amp; \cdots &amp; p_{|S|,|S|}<br>\end{bmatrix}<br>$$</p><p>其中每一个元素 $p_{i,j}$ 表示由状态 $i$ 转移到 $j$ 的概率，满足：</p><p>$$<br>\sum^{|S|}<em>{i=1}P</em>{i,j}=1, \sum^{|S|}<em>{j=1}P</em>{i,j}=1<br>$$</p><p>为了完整表示状态转移过程，需要指定初始状态分布 $\rho$ ，便于递归计算某个状态 $i$ 在 $t$ 时刻出现的概率（上一时刻为 $j$ 状态的概率 $\times$ $j$ 状态到 $i$ 状态的状态转移概率）：</p><p>$$<br>\mathbb{P}(s_t=i)=\sum_{j\in S}\mathbb{P}(s_{t-1}=j)p_{j,i}<br>$$</p><p>对于一个马尔可夫决策过程，状态转移不仅受到上移时刻状态的影响，还取决于当前动作，因此不仅要考虑状态，还要额外考虑动作和奖励，即一个马尔可夫决策过程可以表示为 $M=(S,A,\rho,P,r)$ ，数学上表示为 $P(s_{t+1}|s_t, a_t)$。</p><p>为了表示动作产生的过程，引入了策略 $\pi(a|s)$ ，代表在状态 $s$ 处选择动作 $a$ 的概率，因为我们最多有 $|S|$ 个状态和 $|A|$ 个动作，$\pi$ 也可以用一个 $|S| \times |A|$ 的矩阵来表示。</p><p>据马尔可夫决策过程的交互规则以及累计回报计算，实际需要考虑回报折扣，定义一个折扣因子 $\gamma \in(0,1)$，则马尔可夫决策过程变成了由6元组表示 $M=(S, A, \rho, P, r, \gamma)$，在 $M$ 下的累计回报为：</p><p>$$<br>V(\pi)=\mathbb{E}\left[\sum^\infty_{t=0}\gamma^t r(s_t, a_t)\right]<br>$$</p><p>这里的 $V(\pi)$ 代表了策略 $\pi$ 所能获得的累计奖励的期望，每一步奖励都会被乘以系数 $\gamma^t$，以此来保证无限求和时正确的。</p><p>当策略 $\pi$ 确定时，我们可以对任意的起始状态 $s$ 来定义其状态价值函数</p><p>$$<br>V^{\pi}(s)=\mathbb{E}\left[\sum_{t=0}^{\infty}\gamma^{t}r(s_{t},a_{t})\bigg|s_{0}=s,a_{t}\sim\pi(\cdot|s_{t}),s_{t+1}\sim P(s_{t+1}|s_{t},a_{t})\right].<br>$$</p><p>同样可以定义状态-动作价值函数</p><p>$$<br>Q^{\pi}(s,a)=\mathbb{E}\left[\sum_{t=0}^{\infty}\gamma^{t}r(s_{t},a_{t})\bigg|s_{0}=s,a_0=a,a_{t}\sim\pi(\cdot|s_{t}),s_{t+1}\sim P(s_{t+1}|s_{t},a_{t})\right].<br>$$</p><h1>三、模仿学习算法</h1><h2 id="3-1-行为克隆算法">3.1 行为克隆算法</h2><p>行为克隆的想法就是从数据中估计专家测类 $\pi^E$，具体到一个状态 $s$ ，$\pi(\cdot|s)$ 就是动作空间 $A$ 上的概率分布。一个经典的估计方法就是最大似然估计。</p><p>$$<br>\max_{\theta}\sum_{(s,a)\in\mathcal{D}}\log(\hat \pi_{\theta}(a|s))<br>$$</p><p>可以证明该最大似然模型对应的问题是一个凸优化问题。</p><ul><li>如果动作空间是离散的，可以使用 $A$ 维的向量定义 softmax 函数，这时要解决的问题就变成了常见的分类问题中的交叉熵优化问题。</li><li>如果哦当作空间是连续的，可以使用高斯分布表示一个策略，$\hat \pi_\theta(\cdot|s)=N(\mu_\theta(s),\sigma^2_\theta(s))$，因此问题被转换为基于均方差的回归问题。</li></ul><p>行为克隆算法可以直接从专家数据中估计出策略 $\pi$ ，但也会带来问题，即训练数据集</p><blockquote><p>参考链接：</p><ol><li><a href="https://www.lamda.nju.edu.cn/xut/docs/Imitation_Learning.pdf">许天, 李子牛, 俞扬. 模仿学习简洁教程. 2021</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 模仿学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 模仿学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【强化学习笔记】强化学习基础</title>
      <link href="/post/cfa8c737.html"/>
      <url>/post/cfa8c737.html</url>
      
        <content type="html"><![CDATA[<h1>一、基本概念</h1><h2 id="1-1-专业术语">1.1 专业术语</h2><p><strong>（1）状态（State）</strong>：状态可以被理解为当前环境的情况。</p><p><strong>（2）动作（Action）</strong>：动作是智能体（agent）采取的行为。</p><p><strong>（3）策略（Policy）</strong>：策略是用于在给定观测状态下做出决策的函数，通常表示为 $\pi(a|s)$，其中 $a$ 是动作，$s$ 是状态。强化学习的目标是学习策略函数，通常以概率密度函数的形式表示。</p><p><strong>（4）奖励（Reward）</strong>：奖励定义了奖励的方式，对强化学习的结果产生重要影响。</p><p><strong>（5）状态转移（State Transition）</strong>：状态转移表示在当前状态下，当智能体执行一个动作后，环境可能随机转移到的下一个状态的概率，通常表示为 $P(S’|S, A)$。</p><p><strong>（6）回报（Return）</strong>：回报又被称为未来奖励的累积，通常表示为 $U_t = R_t + R_{t+1} + R_{t+2} + \ldots$。</p><p><strong>（7）折扣回报（Discounted Return）</strong>：折扣回报考虑未来奖励的折扣效应，用折扣率 $\gamma$ 表示，通常表示为 $U_t = R_t + \gamma R_{t+1} + \gamma^2 R_{t+2} + \ldots$。</p><p><strong>（8）动作价值函数（Action-Value Function）</strong>：动作价值函数表示在给定状态和动作下，智能体可以获得的期望回报，通常表示为 $Q_\pi(s_t, a_t) = E[U_t | S_t=s_t, A_t=a_t]$。最优策略下的动作价值函数被表示为 $Q^*(s_t, a_t) = \max_\pi Q_\pi(s_t, a_t)$，使用动作价值函数可以评估当前动作的质量。</p><p><strong>（9）状态价值函数（State-Value Function）</strong>：状态价值函数表示在给定状态下，按照策略函数的预期回报，通常表示为 $V_\pi(s_t) = E_A[Q_\pi(s_t, A)]$。状态价值函数可以告诉我们当前状态的好坏程度。</p><p><strong>（10）交叉熵（Cross Entropy）</strong>：交叉熵用于度量两个概率分布之间的差异，通常表示为 $H(\textbf p, \textbf q) = -\sum^m_{j=1}p_j\cdot \log(q_j)$。当两个概率分布相同时，交叉熵达到最小值。</p><h2 id="1-2-强化学习的随机性">1.2 强化学习的随机性</h2><p><strong>（1）Action动作的随机性</strong></p><p>因为动作是根据策略函数随机抽样得到的，因此agent有可能做策略中的任何一种动作，虽然这些动作的概率有大有小，但是动作本身是随机的。</p><p><strong>（2）State transitions状态转移的随机性</strong></p><p>假定agent作出了一个动作，环境会用概率随机抽样，给出下一个状态。</p><h2 id="1-3-强化学习如何控制agent">1.3 强化学习如何控制agent</h2><p><strong>（1）如果有策略函数 $\pi(a|s)$</strong></p><ol><li>给定一个观测状态 $s_t$</li><li>利用策略函数从所有可能的动作中随机采样 $a_t~\pi(\cdot|s_t)$</li></ol><p><strong>（2）如果有最优的动作价值函数 $Q^<em>(s,a)</em>$</strong></p><ol><li>给定一个观测状态 $s_t$</li><li>最大化 $a_t=argmax_a Q^*(s_t,a)$ 来选择动作</li></ol><h1>二、价值学习 Deep Q-Network(DQN)</h1><p>$U_t$ 反映未来奖励的总和，因此我们要知道 $U_t$ 的大小，由于其是一个随机变量，我们可以对 $U_t$ 求期望，只留下 $s_t$ 和 $a_t$ 两个变量。</p><p>$$Q_\pi(s_t,a_t)=E[U_t|S_t=s_t,A_t=a_t]$$</p><p>要想进一步消除策略函数 $\pi$，可以对 $Q_\pi$ 关于 $\pi$ 球最大化，记为 $Q^*$</p><p>$$Q^*(s_t,a_t)=max_\pi Q_\pi(s_t,a_t)$$</p><p>这个参数告诉我们不管在什么情况 $s_t$ 下做动作 $a_t$，那么期望顶多就是 $Q^*(s_t,a_t)$。</p><blockquote><p>目标：完成任务（最大化总回报）<br>问题：如果已知 $Q^<em>(s,a)$，那么最好的动作就是 $a^</em>=argmax_a Q^<em>(s,a)$，因为 $Q^</em>$ 指示了该agent在s状态下选择a动作的好坏程度<br>挑战：我们不知道 $Q^*(s,a)$</p></blockquote><p><strong>（1）什么是 DQN</strong></p><p>我们使用神经网络 $Q(s,a;w)$ 来近似 $Q^*(s,a)$，其中 w 是要近似的参数，s 是输入，a 是输出是对所有动作的打分。</p><p><img src="https://img.mahaofei.com/img/202311030917032.png" alt="image.png"></p><p>当前观测到状态 $s_t$，用DQN把 $s_t$ 作为输入，为所有动作打分，选出分数最高的动作作为 $a_t$。</p><p>agent 作出动作 $a_t$ 后，环境会改变，用状态转移函数 $p$ 随机抽取一个新的状态 $s_{t+1}$，环境还会告诉我们一个回报 $r_t$，这个 $r_t$ 就是训练DQN的关键。</p><p><strong>（2）如何训练 DQN</strong></p><p>常规的网络训练过程如下：</p><ol><li>首先对任务结果做一个预测 $q=Q(w)$</li><li>完成任务后获得目标 $y$</li><li>计算损失 $L=\frac{1}{2}(q-y)^2$</li><li>计算梯度 $\frac{\partial L}{\partial w}=\frac{\partial L}{\partial q}\cdot \frac{\partial q}{\partial w}$</li><li>更新参数 $w_{t+1}=w_t-\alpha \cdot\frac{\partial L}{\partial w}|_{w=w_t}$</li></ol><p>但这种方式需要完整完成一次任务后才能更新参数，而能否执行一部分任务后就开始更新参数，因此有了 Temporal Difference Learning （TD算法），过程如下：</p><ol><li>首先对任务结果做一个预测 $q=Q(w)$</li><li>执行一部分任务后，对任务结果再进行预测 $y$，此时的 $y$ 包括已经完成的部分和对剩下部分的预测，因此比 $q$ 更可靠</li><li>计算损失 $L=\frac{1}{2}(q-y)^2$</li><li>计算梯度 $\frac{\partial L}{\partial w}=\frac{\partial L}{\partial q}\cdot \frac{\partial q}{\partial w}$</li><li>更新参数 $w_{t+1}=w_t-\alpha \cdot\frac{\partial L}{\partial w}|_{w=w_t}$</li></ol><p>在深度强化学习中，也就是下面这个公式</p><p>$$Q(s_t,a_t;w)\approx r_t+\gamma\cdot Q(s_{t+1},a_{t+1};w)$$</p><p>对未来奖励总和的期望，就是真实已经观测到的奖励，加在t+1时刻对未来奖励的期望。</p><ol><li>首先进行预测 $Q(s_t,a_t;w_t)$</li><li>获得TD目标 $y_t=r_t+\gamma\cdot Q(s_{t+1},a_{t+1};w_t)=r_t+\gamma\cdot max_a Q(s_{t+1},a;w_t)$</li><li>计算损失 $L_t=\frac{1}{2}[Q(s_t,a_t;w)-y_t]^2$</li><li>进行剃度下降 $w_{t+q}=w_t-\alpha\cdot\frac{\partial L_t}{\partial w}|_{w=w_t}$</li></ol><p><img src="https://img.mahaofei.com/img/202311031636429.png" alt="image.png"></p><p><strong>（3）经验回放</strong></p><p>之前我们使用在线梯度下降来更新 $w$，以此来减小TD errer $\delta_t=q_t-t_t$。</p><p>我们定义一个经验transition为$(s_t,a_t,r_t,s_{t+1})$，传统的方法再每使用一个transition后就会丢弃它，这回造成经验的浪费。此外传统的方法还忽略了不同经验之间的相关性。</p><p>将最近的n个transition存储进一个replay buffer，当有新的经验进来后，就删除老的transition。</p><ol><li>每次从buffer中随机抽取一个transition</li><li>计算TD error</li><li>极端梯度</li><li>进行随机梯度下降（实际一般使用minibatch SGD，一次取多个transition）</li></ol><p><strong>优先经验回放</strong>：为了解决数据的不均匀性，可以使用重要性抽样代替平均采样。可以根据TD error抽样，误差越大的，transition被抽样的概率越大。</p><p><strong>学习率比例设置</strong>：如果一个transition有较大的抽样概率，那么其学习率应该设置的比较小。</p><p><strong>更新TD error</strong>：如果一个transition没有被用过，那么就设置它的TD error为最大值，在训练DQN的同时，对TD error进行更新。</p><h1>三、策略学习</h1><p>策略函数 $\pi(a|s)$是一个概率密度函数，对每一个给定的状态 $s$，策略函数会抽取一个最优的动作 $a$ 作为将要执行的动作。</p><p>理想情况下，列出所有的状态和动作，计算所有状态和动作之间的概率即可。</p><p>但是实际情况下有无数个状态，不可能记录所有的状态对应的动作，因此需要函数近似。一般使用神经网络进行近似，即policy network $\pi(a|s;\theta)$</p><p>状态价值函数$V_\pi(s_t)=E_A[Q_\pi(s_t,A)]$，状态价值函数可以告诉我们当前的局势好不好。在状态已知时，还可以判断策略好不好，策略越好，$V_\pi$ 越大，任务完成成功率越高，$V_\pi$ 可以表示为：</p><p>$$V_\pi(s_t)=E_A[Q_\pi(s_t,A)]=\sum_a\pi(a|s_t)\cdot Q_\pi(s_t,a)$$</p><p>使用神经网络替换策略函数，因此得到：</p><p>$$V_\pi(s_t;\theta)=\sum_a\pi(a|s_t;\theta)\cdot Q_\pi(s_t,a)$$</p><p>给定状态 $s$，策略函数函数越好，价值函数越大。因此可以考虑通过改变神经网络参数 $\theta$，让 $V(s;\theta)$ 变大，基于这个思想，可以求期望：</p><p>$$J(\theta)=E_s[V(S;\theta)]$$</p><p>策略网络越好，$J(\theta)$ 就越大，为了改变 $\theta$，我们使用策略梯度算法。</p><ol><li>观测状态 $s$</li><li>更新策略 $\theta=\theta+\beta\cdot\frac{\partial V(s;\theta)}{\partial \theta}$，做梯度上升，因为我们希望价值函数越大越好。</li></ol><p>对于离散的动作，使用$\frac{\partial V(s;\theta)}{\partial \theta}=\sum_a \frac{\partial \pi(a|s;\theta)}{\partial \theta}\cdot Q_\pi(s,a)$</p><p>对于连续的动作，使用$\frac{\partial V(s;\theta)}{\partial \theta}=E_{A~\pi(\cdot|s;\theta)} [\frac{\partial \pi(a|s;\theta)}{\partial \theta}\cdot Q_\pi(s,a)]$</p><p><img src="https://img.mahaofei.com/img/202311031636316.png" alt="image.png"></p><h1>四、Actor-Crictic</h1><p>状态价值函数的定义如下：</p><p>$$V_\pi(s_t)=\sum_a\pi(a|s_t)\cdot Q_\pi(s_t,a)$$</p><p>策略网络（产生动作）：</p><ul><li>使用神经网络 $\pi(a|s;\theta)$ 来近似策略函数 $\pi(a|s)$</li><li>其中 $\theta$ 是训练的参数</li></ul><p>价值网络（产生评判标准）：</p><ul><li>使用神经网络 $q(s,a;w)$ 来近似价值函数 $Q_\pi(s,a)$</li><li>其中 $w$ 是训练的参数</li></ul><p>因此状态价值函数可以写成</p><p>$$V_\pi(s_t)=\sum_a\pi(a|s_t;\theta)\cdot Q_\pi(s_t,a;w)$$</p><p>同时训练策略网络和价值网络，就称为 Actor-Critic Method，大致步骤如下：</p><ol><li>观测当前状态 $s_t$</li><li>根据策略函数 $\pi(\cdot|s_t;\theta_t)$ 随机采样获得动作 $a_t$</li><li>执行动作 $a_t$，并观测新的状态 $s_{t+1}$ 和回报 $r_t$</li><li>更新价值网络的参数 $w$，使用TD算法</li><li>更新策略网络的参数 $\theta$，使用策略梯度算法</li></ol><p>训练过程中需要同时训练策略网络和价值网络，利用价值网络对策略网络进行评分。训练完成后就不需要价值网络了，只需要策略网络生成动作。</p><h1>五、蒙特卡洛树搜索（Monte Carlo Tree Search）</h1><h2 id="5-1-基本思想">5.1 基本思想</h2><p>蒙特卡洛树搜索的思想是人们必须要向前看很多步，看到未来时间内所有可能的情况，挑选最优的执行动作。</p><ol><li>如果我在此时选择执行动作 $a_t$</li><li>那么未来一段时间环境的反馈是怎么变化的 $s_{t+1}$</li><li>基于这种环境变化，我又会执行动作 $a_{t+1}$</li><li>此时环境又会如何变化</li></ol><p>如果一个agent能够穷举所有的可能性直到任务完成，那么这个任务一定有很高的成功率。</p><h2 id="5-2-过程">5.2 过程</h2><p><strong>（1）选择</strong></p><p>根据分数选择一个动作（假想的动作，实际上并不会执行）；</p><p>首先对所有可能的动作 $a$，计算得分：</p><p>$$score(a)=Q(a)+\eta\cdot\frac{\pi(a|s_t;\theta)}{1+N(a)}$$</p><p>其中 $Q(a)$ 是蒙特卡洛树搜索计算的动作价值<br>$\pi(a|s_t;\theta)$ 是学习好的策略网络，动作越好，策略分数越高<br>$N(a)$ 是给定环境状态 $s_t$ 情况下，目前为止选择动作 $a$ 的次数，如果同一个动作被探索太多次，该项分母就会变大。</p><p><strong>（2）扩展</strong></p><p>假想环境更新；</p><p><strong>（3）评估</strong></p><p>评价状态价值得分 $v$ 和回报 $r$，将动作的分数设为 $\frac{v+r}{22}$；</p><p><strong>（4）备份</strong></p><p>用动作的分数 $\frac{v+r}{2}$ 更新动作价值：</p><p>$$Q(a_t)=mean(the recorded V’s)$$</p><p>将以后所有步的状态价值进行平均。</p><h1>六、连续控制</h1><p>在实际进行强化学习时，可能有离散动作空间（例如上下左右控制游戏人物），也可能是连续动作（机械臂关节控制）。</p><p>在进行离散控制时，可以直接使用分类的思想，得到一个onehot向量，每个向量元素代表执行该动作的得分，以此来获得应该执行那种动作。而连续控制中动作空间是有无穷维的，因此不能直接使用这种思想实现连续控制。</p><p>比较常规的一种解决思路是将动作空间离散化，但这种方式也有问题，例如机械臂的6个自由度，就算每个自由度离散为360个点，那么整个动作空间也有 $360^6$ 个点，这会造成维度灾难，在训练时非常困难。</p><p>因此有两种方式实现连续控制：</p><ul><li>确定性策略网络</li><li>随机策略网络</li></ul><h2 id="6-1-确定策略梯度（Deterministic-Policy-Gradient-DPG）">6.1 确定策略梯度（Deterministic Policy Gradient DPG）</h2><p>考虑一个只有2自由度的机械臂，基座运动范围为(0,180)，机械臂运动范围为(0,360)，因此机械臂的动作空间是 $A=[0,180]\times[0,360]$ 的连续集合，动作就是一个二维向量。</p><p>DPG 是一种 Actor-Critic 方法</p><ul><li>有一个<strong>策略网络</strong>，控制 agent 运动，它根据状态 s 做出决策 a；<br>使用策略网络 $a=\pi(s;\theta)$ 根据输入状态 s，输出一个<strong>确定</strong>的动作 a，这里的动作 a 就是机器人的二维动作向量。</li><li>有一个<strong>价值网络</strong>，不控制 agent，它根据状态 s，给动作 a 打分，从而指导策略网络做出改进。<br>使用价值网络 $q(s,a;w)$，输入状态 s 和动作 a，输出一个实数 value 是对动作的评价，动作越好，value 越大。</li></ul><p>因此 DPG 的原理就是训练这两个网络。</p><p><img src="https://img.mahaofei.com/img/202311041607515.png" alt="image.png"></p><p><strong>（1）价值网络训练</strong></p><ol><li>每次得到一个训练数据 transition $(s_t,a_t,r_t,s_{t+1})$</li><li>用价值网络预测当前时刻 t 下的动作价值 $q_t=q(s_t,a_t;w)$</li><li>用价值网络预测下一时刻 t+1 的动作价值 $q_{t+1}=q(s_{t+1},a_{t+1}‘;w)$ ，其中 $a_{t+1}’=\pi(s_{t+1};\theta)$，这个动作并不是 agent 真正执行的动作，$a_{t+1}'$ 只用于更新价值网络。</li><li>计算 TD error：$\delta_t=q_t-(r_t+\gamma\cdot q_{t+1})$，其中第二项是 TD Target，它一部分是真实观测到的奖励，另一部分是价值网络自己做出的预测。因为我们认为第二项中由于包含本步真实奖励，比单纯的 $q_t$ 更接近真实情况，因此要让 $q_t$ 与 TD Target 接近，也就是让 TD error 尽可能小。</li><li>进行梯度下降更新 w：$w=w-\alpha\cdot\gamma_t\cdot\frac{\partial q(s_t,a_t;w)}{\partial w}$</li></ol><p>但这其中有一个问题，就是计算 TD error $\delta_t=q_t-(r_t+\gamma\cdot q_{t+1})$ 这一步时，会出现 bootstrapping 问题，也就是如果初始值高估或者低估，那么 TD target 就会有高估或低估，并传播回价值网络自身，导致高估或低估一直存在，解决方案就是用不同的神经网络计算 TD Target，也就是用 Target Networks。</p><ol><li>每次得到一个训练数据 transition $(s_t,a_t,r_t,s_{t+1})$</li><li>用价值网络预测当前时刻 t 下的动作价值 $q_t=q(s_t,a_t;w)$</li><li>用价值网络预测下一时刻 t+1 的动作价值 $q_{t+1}=q(s_{t+1},a_{t+1}‘;w^-)$ ，其中 $a_{t+1}’=\pi(s_{t+1};\theta^-)$<br>$\pi(s_{t+1};\theta^-)$ 是 Target policy network 用来代替策略网络，它的网络结构和策略网络一模一样，但是参数不一样。<br>$q(s_{t+1},a_{t+1}';w^-)$ 是 Target value network，它与价值网络结构一样，参数不同。</li></ol><p><strong>（2）策略网络训练</strong></p><p>训练策略网络，需要靠价值网络评价动作的好坏，从而指导策略网络进行改进。</p><p>也就是更新策略网络的参数 $\theta$ 让价值网络认为动作 $a=\pi(s;\theta)$ 更好，也就是改进 $\theta$ 让价值 $q(s,a;w)=q(s,\pi(s;\theta);w)$ 尽可能大。</p><p>由于给定状态 s，策略网络会输出一个确定的动作 a，而如果价值网络也是确定的，那么输出的价值就是确定的。</p><p>因此问题中只需要改变 $\theta$，使得价值 q 变大，也就是计算 $q(s,a;w)$ 对 $\theta$ 的梯度，然后用梯度上升更新 $\theta$，就可以让 $q$ 变大，这个梯度就叫<strong>确定策略梯度 DPG</strong>。</p><p>$$<br>g=\frac{\partial q(s,\pi(s;\theta);w)}{\partial\theta}=\frac{\partial a}{\partial \theta}\cdot\frac{\partial q(s,a;w)}{\partial a}<br>$$</p><p>其中 $a=\pi(s;\theta)$，然后进行梯度上升 $\theta=\theta+\beta\cdot g$</p><p><strong>策略网络和价值网络联合具体步骤如下：</strong></p><ol><li>策略网络做一个决策：$a=\pi(s;\theta)$</li><li>计算价值网络的输出：$q_t=q(s,a;w)$</li><li>用 DPG 更新策略网络： $\theta=\theta+\beta\cdot \frac{\partial a}{\partial \theta}\cdot\frac{\partial q(s,a;w)}{\partial a}$</li><li>利用 Target networks $\pi(s;\theta^-)$ 和 $q(s,a;w^-)$ 计算 $q_{t+1}$</li><li>计算 TD error：$\delta_t=q_t-(r_t+\gamma\cdot q_{t+1})$</li><li>更新价值网络：$w=w-\alpha\cdot\gamma_t\cdot\frac{\partial q(s_t,a_t;w)}{\partial w}$</li><li>更新 Target networks 的参数：$w^-=\tau\cdot w+(1-\tau)\cdot w^-$，$\theta^-=\tau\cdot \theta+(1-\tau)\cdot \theta^-$，其中 $\tau$ 是超参数</li></ol><h2 id="6-2-随机策略用于连续控制">6.2 随机策略用于连续控制</h2><p>首先考虑自由度等于 1 的随机策略连续控制，也就是动作都是实数。</p><p>设 $\mu$ 代表均值，和 $\sigma$ 代表标准差，都是状态 s 的函数。</p><p>用正态分布的概率密度函数作为策略函数：</p><p>$$<br>\pi(a|s)=\frac{1}{\sqrt{6.28}\sigma}\cdot exp(-\frac{(a-\mu)^2}{2\sigma^2})<br>$$</p><p>对于 d 维情况一样，动作是 d 维向量。</p><p>设向量 $\mu$ 代表均值，和向量 $\sigma$ 代表标准差，都是状态 s 的函数。</p><p>使用特殊正态分布作为策略函数：</p><p>$$<br>\pi(a|s)=\prod_{i=1}^d\frac{1}{\sqrt{6.28}\sigma_i}\cdot exp(-\frac{(a_i-\mu_i)^2}{2\sigma^2_i})<br>$$</p><p>但这里我们不知道 $\mu$ 和 $\sigma$，也就不知道策略函数。</p><p>因此可以用神经网络来近似 $\mu(s;\theta^{\mu})$ 和 $\rho(s;\theta{\rho})$，其中 $\rho_i=ln\sigma_i^2$</p><p>将策略函数进行取对数，将连乘变成连加，得到辅助神经网络 $f(s,a;\theta)=\sum^d_{i=1}[-\frac{\rho_i}{2}-\frac{(a_i-\mu_i)^2}{2\cdot exp(\rho_i)}]$，计算 f 关于其中卷积层和全连接层的参数的梯度，进而实现反向传播更新参数。</p><p><img src="https://img.mahaofei.com/img/202311041725827.png" alt="image.png"></p><blockquote><p>参考：</p><ol><li>王树森.  <a href="https://www.youtube.com/channel/UC9qKcEgXHPFP2-ywYoA-E0Q/playlists?view=50&amp;sort=dd&amp;shelf_id=2">强化学习课程(Youtube)</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文复现】MimicPlay从人类演示中学习机器人技能</title>
      <link href="/post/21b38b7b.html"/>
      <url>/post/21b38b7b.html</url>
      
        <content type="html"><![CDATA[<h1>论文笔记</h1><h2 id="1-目标问题-23">1 目标问题</h2><p>从人类演示中学习，是教授机器人操作技能的一种很有前途的方法。</p><p>目前大多数模仿学习算法仍然局限于学习短期的操作，例如开门或抓取特定物品。</p><p>而关于长期任务的研究，目前有两个方向：分层模仿学习和从演示数据中学习。分层学习旨在通过端到端实现高级规划到低级运动控制的学习。从演示数据中学习是指人类通过遥控机器人于环境互动来收集数据。</p><p>本文提出了一个分层学习框架，从大量人类演示数据中学习潜在的计划，来指导机器人在少量演示中实现视觉运动控制。</p><h2 id="2-主要方法">2 主要方法</h2><p><img src="https://img.mahaofei.com/img/202310231710757.png" alt="image.png"></p><h3 id="2-1-收集人类数据">2.1 收集人类数据</h3><p>人类在用手与环境互动的过程中，创造了一个手的轨迹。本文使用两台经过校准的相机来跟踪人类演示数据中的3D手轨迹，手部位置检测使用现有的库。</p><h3 id="2-2-从人类数据中学习3D潜在规划">2.2 从人类数据中学习3D潜在规划</h3><p>问题：给定一个由目标图像表示的长期任务，策略产生以目标为条件的行动。</p><p>将该问题转化为分层学习策略，其中高级规划器从目标图像中提取关键特征，并转化成低维的规划，利用这些规划引导运动控制器动作。为了训练高级规划器，本文使用廉价的数据源（人类演示数据）</p><p><strong>（1）多模式潜在计划学习</strong></p><p>利用收集的人类演示数据和对应的3D手部轨迹，将学习规程转化为目标条件的3D轨迹生成任务。即将人类演示图像，目标图像处理为低维特征，利用MLP编码为潜在计划向量，利用潜在计划向量和手的位置，利用MLP解码为3D手部轨迹的预测。</p><p>为了解决不同人演示同一任务的差异，使用基于MLP的高斯混合模型来对潜在计划的轨迹分布进行建模。</p><p><strong>（2）处理人类演示数据和机器人之间的视觉差异</strong></p><p>本文考虑人与机器人在同一环境中，需要解决机器人与人类外观不同导致的视觉差异。通过计算人类和机器人的视觉编码器的特征嵌入的分布，最小化两者距离（此步骤机器人与人类视频不需要是对应的）</p><h3 id="2-3-多任务模仿学习">2.3 多任务模仿学习</h3><p><strong>（1）用于潜在计划生成的视频提示</strong></p><p>使用单镜头视频作为目标指定提示，发送给训练好的潜在规划器，生成机器人可执行的潜在计划。</p><p>规划器将视频分成多个帧，每个时间步长，规划器从序列中取一个图像帧作为目标图像，生成潜在规划引导机器人动作。</p><p><strong>（2）基于Transformer的计划引导与模仿</strong></p><p>在执行复杂任务时，仅使用高层规划是不够的，还需要考虑底层的细节。因此考虑将机器人腕部相机和本体感觉都转换成低维特征向量，与潜在计划进行结合，利用Trasformer架构（因为其擅长管理长期运动生成）进行处理。</p><p><strong>（3）多任务</strong></p><p>在同一环境中的所有任务中共享相同的规划器和策略模型。</p><h1>算法复现</h1><h2 id="1-环境搭建">1 环境搭建</h2><p><strong>（1）进入所下载代码环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd MimicPlay</span><br></pre></td></tr></table></figure><p><strong>（2）创建 conda 环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n mimicplay python=3.8 -y</span><br><span class="line">conda activate mimicplay</span><br></pre></td></tr></table></figure><p><strong>（3）安装 MuJoCo</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mujoco==2.3.0</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果出现问题</strong>：<code>imgaug 0.4.0 requires XXXXXX, which is not installed.</code><br><strong>解决方法如下</strong>：</p><ol><li>安装报错提示的imgaug所需的依赖项：<code>pip install imageio matplotlib Pillow scikit-image six opencv-python</code></li><li>重新安装mujoco：<code>pip install mujoco</code></li></ol></blockquote><p><strong>（4）安装robosuite</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ARISE-Initiative/robosuite.git</span><br><span class="line">cd robosuite</span><br><span class="line">git checkout v1.4.1_libero</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install -r requirements-extra.txt</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><blockquote><p>第一次安装失败，然后<code>git checkout v1.4.1_libero</code>之后才安装成功</p></blockquote><p><strong>（5）安装BDDL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git clone https://github.com/StanfordVL/bddl.git</span><br><span class="line">cd bddl</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p><strong>（6）安装LIBERO</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git clone https://github.com/Lifelong-Robot-Learning/LIBERO.git</span><br><span class="line">cd LIBERO</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><p><strong>（7）安装robomimic</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git clone https://github.com/ARISE-Initiative/robomimic</span><br><span class="line">cd robomimic</span><br><span class="line">git checkout mimicplay-libero</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><blockquote><p>第一次安装失败，然后<code>git checkout mimicplay-libero</code>之后才安装成功</p></blockquote><p><strong>（8）安装MimicPlay</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git clone https://github.com/j96w/MimicPlay.git</span><br><span class="line">cd MimicPlay</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure><h2 id="2-数据准备（从虚拟机器人动作数据中学习机器人动作）">2 数据准备（从虚拟机器人动作数据中学习机器人动作）</h2><h3 id="2-1-官方数据集">2.1 官方数据集</h3><p>训练集和测试视频在<a href="https://drive.google.com/drive/folders/1FUKd3vr-KBiYRnKIymNmGClmVx9U45XG">此处</a>下载。训练集是一系列没有指定特定任务（没有标签）的人类演示视频。</p><p>作者推荐下载原始数据<code>demo.hdf5</code>，然后在本地电脑上将其处理为具有图像观察的训练数据集<code>demo_image.hdf5</code>，因为这样可以很好的检查环境库是否安装正确，具体步骤如下：</p><p><strong>（1）将下载的数据集移动到<code>mimicplay/datasets</code></strong></p><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd MimicPlay/mimicplay</span><br><span class="line">mkdir -p datasets/playdata</span><br><span class="line">mv ~/Downloads/demo.hdf5 ./datasets/playdata/</span><br></pre></td></tr></table></figure><p><strong>（2）将原始数据转换为图像数据集</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">示例</span></span><br><span class="line">cd MimicPlay/mimicplay</span><br><span class="line">python scripts/preprocess_hdf5.py -i ./datasets/playdata/demo.hdf5 -o ./datasets/playdata/demo_modified.hdf5</span><br><span class="line">python scripts/dataset_states_to_obs.py --dataset &#x27;datasets/playdata/demo_modified.hdf5&#x27; --done_mode 0 --camera_names agentview robot0_eye_in_hand --camera_height 84 --camera_width 84 --output_name image_demo_local.hdf5 --exclude-next-obs</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果出现问题</strong>：<code>ileNotFoundError: [Errno 2] No such file or directory: 'patchelf'</code><br><strong>解决方法如下</strong>：<code>sudo apt-get install patchelf</code></p></blockquote><p><strong>（3）提取末端轨迹用于上层规划器的训练</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts/dataset_extract_traj_plans.py --dataset &#x27;datasets/playdata/image_demo_local.hdf5&#x27;</span><br></pre></td></tr></table></figure><p><strong>（4）检查数据：重新播放数据集中的图像，保存成视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts/playback_robomimic_dataset.py --dataset &#x27;datasets/playdata/image_demo_local.hdf5&#x27; --use-obs --render_image_names agentview_image --video_path image_demo_local_replay.mp4</span><br></pre></td></tr></table></figure><h3 id="2-2-自制数据集">2.2 自制数据集</h3><p><strong>（1）使用BDDL文件收集数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts/collect_playdata.py --bddl-file &#x27;scripts/bddl_files/KITCHEN_SCENE9_playdata.bddl&#x27; --device &#x27;keyboard&#x27;</span><br></pre></td></tr></table></figure><p>收集的原始数据可以在<code>robosuite/robosuite/models/assets/demonstrations/</code>路径下找到。</p><p><strong>（2）将原始数据转换成robomimic格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts/convert_playdata_to_robomimic_dataset.py --dataset &#x27;path_to_your_data&#x27;</span><br></pre></td></tr></table></figure><p><strong>（3）现在有了robomimic格式的数据，按照#1.3 公共数据集中的步骤生成特定任务的视频提示</strong></p><h2 id="3-数据准备（从人类演示中学习机器人动作）">3 数据准备（从人类演示中学习机器人动作）</h2><h3 id="3-1-配置人手检测模型">3.1 配置人手检测模型</h3><p><strong>（1）配置开源的 hand_object_detector</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conda create --name handobj python=3.6</span><br><span class="line">conda activate handobj</span><br><span class="line">conda install pytorch=1.0.1 torchvision cudatoolkit=10.0 -c pytorch</span><br><span class="line">cd mimicplay/scripts/human_playdata_process</span><br><span class="line">git clone https://github.com/ddshan/hand_object_detector &amp;&amp; cd hand_object_detector</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">cd lib</span><br><span class="line">python setup.py build develop</span><br></pre></td></tr></table></figure><p><strong>（2）下载fast_rcnn模型，并放置在指定位置</strong></p><p>从Google Drive中下载<a href="https://drive.google.com/file/d/1H2tWsZkS7tDF8q1-jdjx6V9XrK25EDbE/view">faster_rcnn_1_8_132028.pth (361M)</a>，移动到下面的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hand_object_detector</span><br><span class="line">mkdir -p models/res101_handobj_100K/pascal_voc</span><br><span class="line">mv faster_rcnn_1_8_132028.pth models/res101_handobj_100K/pascal_voc/.</span><br></pre></td></tr></table></figure><p><strong>（3）将mimicplay的python脚本放入人手检测器的目录下</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd mimicplay/scripts/human_playdata_process/</span><br><span class="line">cp demo_mp4.py hand_object_detector/</span><br></pre></td></tr></table></figure><h3 id="3-2-从人类演示生成数据集">3.2 从人类演示生成数据集</h3><p><strong>（1）复制两个示例视频</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp vis_1.mp4 hand_object_detector/</span><br><span class="line">cp vis_2.mp4 hand_object_detector/</span><br></pre></td></tr></table></figure><p><strong>（2）生成hdf5数据文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hand_object_detector/</span><br><span class="line">python demo_mp4.py</span><br></pre></td></tr></table></figure><p><strong>（3）可视化数据集</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd scripts/human_playdata_process/</span><br><span class="line">python vis_processed_human_play_data.py</span><br></pre></td></tr></table></figure><h2 id="4-训练">4 训练</h2><h3 id="4-1-训练高级规划器">4.1 训练高级规划器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd MimicPlay/mimicplay</span><br><span class="line">python scripts/train.py --config configs/highlevel.json --dataset &#x27;datasets/playdata/image_demo_local.hdf5&#x27;</span><br></pre></td></tr></table></figure><p>训练结束后，选择评估分数最高的checkpoint，将其路径作为</p><h3 id="4-2-训练低级机器人控制器">4.2 训练低级机器人控制器</h3><blockquote><p>参考：</p><ol><li>Mimicplay: Long-horizon imitation learning by watching human play. [Project](<a href="https://mimic-play.github.io/">MimicPlay | Long-Horizon Imitation Learning by Watching Human Play (mimic-play.github.io)</a>) <a href="https://github.com/j96w/MimicPlay">Code</a>, <a href="https://arxiv.org/abs/2302.12422">arXiv</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
            <tag> 模仿 </tag>
            
            <tag> 机器人动作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCL库的安装与基本使用</title>
      <link href="/post/8ea92350.html"/>
      <url>/post/8ea92350.html</url>
      
        <content type="html"><![CDATA[<h1>Ubuntu 20.04 安装 PCL 库</h1><p><strong>推荐安装方法</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libpcl*</span><br></pre></td></tr></table></figure><p>如果不用最新的PCL功能的话，正常点云处理显示等使用还是没问题的。</p><p><strong>源码安装（建议使用cmake-gui）</strong>：</p><p>下载<a href="https://github.com/PointCloudLibrary/pcl/releases/tag/pcl-1.10.0">PCL-1.10</a>，一定要下载1.10，因为ROS安装的过程中会安装pcl-1.10的库，正常使用没问题，但是缺少一些新功能例如<code>pcl/surface/on_nurbs</code>，我想要使用这个库，因此能够从源码编译，如果使用其它版本安装，会出现冲突例如<code>error: redefinition of</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd pcl-pcl-1.10</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake-gui</span><br></pre></td></tr></table></figure><p>选择source code为下载解压的文件夹pcl-pcl-1.10，第二个选择刚创建的build文件夹</p><p>点击<code>Configure</code>，点击<code>Finish</code>，出现一些初始化配置。</p><p>注意要选<code>BUILD_surface_on_nurbs</code>，不然会报错<code>pcl/surface/on_nurbs/fitting_surface_tdm.h: 没有那个文件或目录</code>，当然最好把能选的都选了，我这里除了默认的，还额外勾选了</p><ul><li>BUILD_CUDA</li><li>BUILD_GPU</li><li>BUILD_examples</li><li>BUILD_simulation</li><li>BUILD_surface_on_nurbs</li><li>BUILD_kinfu_tools</li></ul><p><img src="https://img.mahaofei.com/img/202312221852931.png" alt="image.png"></p><p>直到没有红色区域之后，点击<code>configure</code>，配置完成后点击<code>generate</code>按钮，会在build文件夹下生成工程文件，然后关闭cmake-gui界面就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用make -j4，make -j8，后面的数字为同时使用的线程数，量力而行，线程过多可能会系统直接卡死</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p><strong>源码卸载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo updatedb</span><br><span class="line">locate pcl-1.13 #查看pcl-1.13的位置 </span><br><span class="line">sudo rm -r /usr/local/include/pcl-1.13 /usr/local/share/pcl-1.13</span><br><span class="line">sudo updatedb</span><br><span class="line">locate pcl-1.13 #检查是否全部删除</span><br></pre></td></tr></table></figure><h1>PCL基本使用</h1><h2 id="1-基本数据类型">1. 基本数据类型</h2><ul><li>点：<code>pcl::PointXYZ</code>、<code>pcl::PointXYZRGB</code>、<code>pcl::PointXYZI</code></li><li>点云：<code>pcl::PointCloud</code><ul><li>宽高：<code>PointCloud::width</code>与<code>PointCloud::height</code>，都为<code>int</code>类型，如果是规律排列的，则分别代表点云的长宽，如果是无序的则高为1，宽为点数量</li><li>点：<code>PointCloud::points</code>存放点的vector变量</li><li>指针：<code>PointCloud::Ptr</code>：只想<code>PointCloud</code>的智能指针</li></ul></li></ul><h2 id="2-读写点云数据">2. 读写点云数据</h2><p><strong>读取点云</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::PCDReader pcd_reader;</span><br><span class="line">pcd_reader.<span class="built_in">read</span>(<span class="string">&quot;xxx.pcd&quot;</span>, *cloud);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">pcl::io::<span class="built_in">loadPCDFile</span>&lt;pcl::PointXYZ&gt;(<span class="string">&quot;xxx.pcd&quot;</span>, *cloud);</span><br></pre></td></tr></table></figure><p><strong>保存点云</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pcd_writer.<span class="built_in">write</span>&lt;pcl::PointXYZ&gt;(<span class="string">&quot;xxx.pcd&quot;</span>, *cloud, <span class="literal">false</span>);  <span class="comment">//false表示保存为ASCII文件</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">pcl::io::<span class="built_in">savePCDFileASCII</span>(<span class="string">&quot;xxx.pcd&quot;</span>, *cloud);</span><br></pre></td></tr></table></figure><h2 id="3-点云滤波">3. 点云滤波</h2><p><strong>直通滤波</strong>：直接对x,y,z三个方向上设置要保留的点的距离范围，滤除距离范围外的点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::passThrough&lt;pcl::PointXYZ&gt; pass;</span><br><span class="line">pass.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">pass.<span class="built_in">setFilterFieldName</span>(<span class="string">&quot;x\y\z&quot;</span>);</span><br><span class="line">pass.<span class="built_in">setFileterLimits</span>(<span class="number">0.0</span>, <span class="number">3.0</span>);</span><br><span class="line">pass.<span class="built_in">filter</span>(*output_cloud);</span><br></pre></td></tr></table></figure><p><strong>体素滤波</strong>：将空间划分为一定体积的网格，用每个网格内所有的点的质心来代替所有的点，将每个网格内的点云压缩为一个质心点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::VoxelGrid&lt;pcl::PointXYZ&gt; vg;</span><br><span class="line">vg.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">vg.<span class="built_in">setLeafSize</span>(<span class="number">0.01f</span>, <span class="number">0.01f</span>, <span class="number">0.01f</span>);  <span class="comment">// 网格的长宽高</span></span><br><span class="line">vg.<span class="built_in">filter</span>(*output_cloud)</span><br></pre></td></tr></table></figure><p><strong>离群点滤波</strong>：统计每个点与周围最临近的若干个点的平均距离，若平均距离大于设定的阈值则判定为离群点而滤除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;</span><br><span class="line">sor.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">sor.<span class="built_in">setMeanK</span>(<span class="number">50</span>);  <span class="comment">//设置参与计算平均距离的点数</span></span><br><span class="line">sor.<span class="built_in">setStddevMulThresh</span>(<span class="number">0.1</span>);  <span class="comment">//设置平均距离的阈值（米）</span></span><br><span class="line">sor.<span class="built_in">filter</span>(*cloud_filtered);</span><br></pre></td></tr></table></figure><p><strong>半径滤波</strong>：对一定半径范围内点数少于设定值的点进行滤波。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pcl::RadiusOutlierRemoval&lt;pcl::PointXYZ&gt; outrem;</span><br><span class="line">outrem.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">outrem.<span class="built_in">setRadiusSearch</span>(<span class="number">0.8</span>)  <span class="comment">//设置半径大小</span></span><br><span class="line">outrem.<span class="built_in">setMinNeighborsInRadius</span>(<span class="number">2</span>);  <span class="comment">//设置点数阈值</span></span><br><span class="line">outrem.<span class="built_in">filter</span>(*output_cloud)</span><br></pre></td></tr></table></figure><h2 id="4-点云聚类与分割">4. 点云聚类与分割</h2><p><strong>RANSAC</strong>：随机抽样一致性算法，解决了传统最小二乘法全数据参与不能排除错误数据干扰的问题，可以拟合出更精确的模型，算法思路如下：</p><ol><li>在原本数据集中随机抽取最少可以拟合出模型的数据量进行拟合。最少数据量一般由模型位置的参数来确定（例如直线就是两个），假设拟合得到的模型为M。</li><li>利用M，对数据集中剩余数据计算各个数据与模型M的误差值p，若p&lt;给定阈值n，则认为该数据为内点；若大于阈值，则认为是外点。计算所有内点和外点，得到内点的集合S。</li><li>判断集合S的点数是否大于给定的点数阈值K，若大于K，则认为该次拟合的模型适合离得。若小于K，则认为不合理，直接丢弃。</li><li>若模型合理，则在用得到的内点集合S与之前随机得到的点再拟合依次模型，得到新的模型M’</li><li>重新随机采样，重复1-4过程，得到多个模型M’。</li><li>若采样次数达到给定阈值，则停止采样，就在得到的M’模型中，选择最优的作为最终结果。或者当某一模型M’的误差在给定精度阈值内，则停止采样，以该模型为最终结果。</li></ol><p><strong>平面分割</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pcl::PointIndices::Ptr inliers_plane;</span><br><span class="line">pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;</span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_PLANE);  <span class="comment">//设置平面模型</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);  <span class="comment">//使用RANSAC算法</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.01</span>)  <span class="comment">//容差范围0.01m</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers_planc, *coefficients);  <span class="comment">//得到模型中点的索引，模型参数</span></span><br></pre></td></tr></table></figure><p><strong>法线估计</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pcl::PointCloud&lt;pcl::Normal&gt;::<span class="function">Ptr <span class="title">cloud_normals</span> <span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::Normal&gt;)</span></span>;  <span class="comment">//保存法线信息的点云</span></span><br><span class="line">pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; ne;</span><br><span class="line">ne.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">pcl::search::KdTree&lt;pcl::PointXYZ&gt;::<span class="function">Ptr <span class="title">tree</span> <span class="params">(<span class="keyword">new</span> pcl::search::KdTree&lt;pcl::PointXYZ&gt; ())</span></span>;</span><br><span class="line">ne.<span class="built_in">setSearchMethod</span>(tree)  <span class="comment">//设置搜索方法</span></span><br><span class="line">ne.<span class="built_in">setRadiusSearch</span>(<span class="number">0.03</span>);  <span class="comment">//搜索半径，利用0.03米范围内的点计算法线</span></span><br><span class="line">ne.<span class="built_in">compute</span>(*cloud_normals)</span><br></pre></td></tr></table></figure><p><strong>圆柱分割</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pcl::PointIndices::Ptr inliers_cylinder;</span><br><span class="line">pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;</span><br><span class="line">seg.<span class="built_in">setOptimizeCoefficients</span>(<span class="literal">true</span>);</span><br><span class="line">seg.<span class="built_in">setModelType</span>(pcl::SACMODEL_CYLINDER);  <span class="comment">//设置圆柱模型</span></span><br><span class="line">seg.<span class="built_in">setMethodType</span>(pcl::SAC_RANSAC);  <span class="comment">//使用RANSAC算法</span></span><br><span class="line">seg.<span class="built_in">setNormalDistanceWeight</span>(<span class="number">0.1</span>)  <span class="comment">//法线在估计的权重</span></span><br><span class="line">seg.<span class="built_in">setMaxIterations</span>(<span class="number">10000</span>);  <span class="comment">//迭代次数</span></span><br><span class="line">seg.<span class="built_in">setDistanceThreshold</span>(<span class="number">0.05</span>);  <span class="comment">//距离容差</span></span><br><span class="line">seg.<span class="built_in">setRadiusLimits</span>(<span class="number">0</span>, <span class="number">0.1</span>);  <span class="comment">//半径范围</span></span><br><span class="line">seg.<span class="built_in">setInputCloud</span>(cloud);  <span class="comment">//输入点云</span></span><br><span class="line">seg.<span class="built_in">setInputNormals</span>(cloud_normals);  <span class="comment">//输入法线点云</span></span><br><span class="line">seg.<span class="built_in">segment</span>(*inliers_cylinder, *coefficients_cylinder); <span class="comment">//得到圆柱的点，模型参数</span></span><br></pre></td></tr></table></figure><p><strong>索引提取</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pcl::PointIndices::Ptr inliers;</span><br><span class="line">pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;</span><br><span class="line">extract.<span class="built_in">setInputCloud</span>(cloud);</span><br><span class="line">extract.<span class="built_in">setIndices</span>(inliers);</span><br><span class="line">extract.<span class="built_in">setNegative</span>(<span class="literal">false</span>);</span><br><span class="line">extract.<span class="built_in">filter</span>(*cloud_p);</span><br></pre></td></tr></table></figure><h2 id="5-可视化">5. 可视化</h2><p><strong>程序中可视化</strong></p><p>第一种方式，会造成程序暂停，需要先在点云窗口中按<code>w</code>，调整到一个比较好的视角，退出时按<code>q</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;Simple Cloud Viewer&quot;</span>)</span></span>; <span class="comment">//括号内是窗口名称</span></span><br><span class="line">viewer.<span class="built_in">showCloud</span>(cloud);</span><br><span class="line"><span class="keyword">while</span>(!viewer.<span class="built_in">wasStopped</span>())&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式，将显示放在了循环内，不会造成程序中断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;Simple Cloud Viewer&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>()</span><br></pre></td></tr></table></figure><p><strong>命令行可视化</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcl_viewer xxx.pcd</span><br></pre></td></tr></table></figure><blockquote><p>参考链接：</p><ol><li><a href="https://www.bilibili.com/video/BV1N24y1R7v8">哈工大竞技机器人队. 【视觉组竞培营】第四讲 PCL点云库. Bilibili. 2022.09.30</a></li><li><a href="https://blog.mangoeffect.net/tools/vcpkg-install-pcl-visualization-module">芒果的技术博客. vcpkg安装pcl-visualization模块. 2021.10.28</a></li><li><a href="https://pcl.readthedocs.io/projects/tutorials/en/master/#">Point Cloud Library. Tutorials</a></li><li><a href="https://blog.csdn.net/qq_42731705/article/details/129380907">Cc1924. Ubuntu18安装新版本PCL-1.13，并和ROS自带PCL-1.8共存. CSDN. 2023.03.07</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 3D点云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCL </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nerf(instant-ngp)快速实现三维重建</title>
      <link href="/post/ce3c8324.html"/>
      <url>/post/ce3c8324.html</url>
      
        <content type="html"><![CDATA[<h1>Windows 版</h1><h2 id="搭建环境">搭建环境</h2><p><strong>（1）创建conda环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n nerf-ngp python=3.8</span><br><span class="line">conda activate nerf-ngp</span><br><span class="line">pip install commentjson imageio numpy opencv-python-headless pybind11 pyquaternion scipy tqdm</span><br></pre></td></tr></table></figure><p><strong>（2）下载instant-ngp应用</strong></p><blockquote><p>项目地址：<a href="https://github.com/NVlabs/instant-ngp">https://github.com/NVlabs/instant-ngp</a></p></blockquote><p>快速使用可以下载官方提供的<code>instant-ngp.exe</code>应用，根据自己的显卡版本下载即可：</p><ul><li><a href="https://github.com/NVlabs/instant-ngp/releases/download/continuous/Instant-NGP-for-RTX-3000-and-4000.zip"><strong>RTX 3000 &amp; 4000 series, RTX A4000–A6000</strong>, and other Ampere &amp; Ada cards</a></li><li><a href="https://github.com/NVlabs/instant-ngp/releases/download/continuous/Instant-NGP-for-RTX-2000.zip"><strong>RTX 2000 series, Titan RTX, Quadro RTX 4000–8000</strong>, and other Turing cards</a></li><li><a href="https://github.com/NVlabs/instant-ngp/releases/download/continuous/Instant-NGP-for-GTX-1000.zip"><strong>GTX 1000 series, Titan Xp, Quadro P1000–P6000</strong>, and other Pascal cards</a></li></ul><p>（如果链接失效请参考源项目中Installation部分，如果在ubuntu下使用，需要下载源码构建。）</p><p>根据自己的情况，下载完成后解压即可：</p><p><img src="https://img.mahaofei.com/img/202310102108837.png" alt="image.png"></p><p><strong>（3）测试</strong></p><p>打开<code>instant-ngp.exe</code>，将<code>data\nerf\</code>下的<code>fox</code>文件直接拖到窗口中即可</p><p><img src="https://img.mahaofei.com/img/202310102110957.png" alt="image.png"></p><h2 id="Colmap-计算相机位姿">Colmap 计算相机位姿</h2><p><strong>（1）录制视频</strong></p><p>对于要三维重建的物体或场景，使用手机录制一段视频。</p><p>尽量均匀扫描，手机不要移动太快或抖动。</p><p><strong>（2）使用Colmap计算相机位姿</strong></p><p>在项目文件夹内新建一个文件夹，将录制的视频放进去。</p><p><img src="https://img.mahaofei.com/img/202310102113654.png" alt="image.png"></p><p><code>cd</code>到视频所在的目录下。在命令行内执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate nerf-ngp</span><br><span class="line">python ..\..\scripts\colmap2nerf.py --video_in desk.mp4 --run_colmap --overwrite</span><br></pre></td></tr></table></figure><p>需要等待较长的一段时间</p><p>完成后会出现分割好的image文件夹</p><p>再继续执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ..\..\scripts\colmap2nerf.py --colmap_matcher exhaustive --run_colmap --aabb_scale 16 --overwrite</span><br></pre></td></tr></table></figure><p>在等待比较长的一段时间，完成。</p><h2 id="instant-ngp-三维重建">instant-ngp 三维重建</h2><p>打开<code>instant-ngp.exe</code>，将desk文件夹整体拖进去就ok了</p><p><img src="https://img.mahaofei.com/img/202310102127121.png" alt="image.png"></p><p>视觉效果还是相当可以的，不过导出 mesh 模型效果比较差</p><h1>Ubuntu 版</h1><p>该方法在 Ubuntu 20.04 +RTX 3090Ti 机器上进行过测试。</p><h2 id="环境配置">环境配置</h2><p>首先安装以下依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential git python3-dev python3-pip libopenexr-dev libxi-dev libglfw3-dev libglew-dev libomp-dev libxinerama-dev libxcursor-dev</span><br></pre></td></tr></table></figure><p>安装 CUDA，参考 <a href="https://www.mahaofei.com/post/cdee659e.html">记录 Ubuntu 安装后的系统配置、常用软件安装过程/4.5 CUDA</a>。</p><p>下载代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/nvlabs/instant-ngp</span><br><span class="line">cd instant-ngp</span><br></pre></td></tr></table></figure><p>进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake . -B build -DCMAKE_BUILD_TYPE=RelWithDebInfo</span><br><span class="line">cmake --build build --config RelWithDebInfo -j</span><br></pre></td></tr></table></figure><h2 id="Demo-测试">Demo 测试</h2><p>运行下面的可执行文件，启动 nerf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./instant-ngp</span><br></pre></td></tr></table></figure><p>将 <code>data/nerf/fox</code> 中的 <code>transform.json</code> 文件直接拖进 gui 界面即可进行训练</p><h2 id="自建数据集">自建数据集</h2><p>创建 conda 环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n nerf-ngp python=3.8</span><br><span class="line">conda activate nerf-ngp</span><br><span class="line">pip install commentjson imageio numpy opencv-python-headless pybind11 pyquaternion scipy tqdm</span><br></pre></td></tr></table></figure><p>将自己录制的视频放置在 <code>instant-ngp/script</code> 目录下。</p><p>执行以下程序生成 <code>transform.json</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd scripts</span><br><span class="line">colmap2nerf.py --video_in 文件名.mp4 --video_fps 1 --run_colmap --aabb_scale 16</span><br></pre></td></tr></table></figure><p>直接把生成的 transform.json 文件拖到 instant-ngp 的 gui 界面就可以渲染。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 3D点云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
            <tag> 三维重建 </tag>
            
            <tag> Nerf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google_Mediapipe关节检测框架</title>
      <link href="/post/5090460e.html"/>
      <url>/post/5090460e.html</url>
      
        <content type="html"><![CDATA[<h1>1 准备工作</h1><h2 id="1-1-安装Baze">1.1 安装Baze</h2><p><strong>（1）下载Bazelisk</strong></p><p>MediaPipe使用bazel进行构建的，安装bazellisk主要是为了更新bazel</p><p>进入bazel的项目<a href="https://github.com/bazelbuild/bazelisk/releases">https://github.com/bazelbuild/bazelisk/releases</a>，下载二进制文件<a href="https://github.com/bazelbuild/bazelisk/releases/download/v1.18.0/bazelisk-linux-amd64">bazelisk-linux-amd64</a>。</p><p>然后将文件移动到<code>/usr/local/bin/bazel/</code>，并修改其可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv bazelisk-linux-amd64 /usr/local/bin/bazel</span><br><span class="line">sudo chmod u+x /usr/local/bin/bazel</span><br></pre></td></tr></table></figure><p>检查bazel是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel version</span><br></pre></td></tr></table></figure><p>可以查看到bazel的版本就算成功。</p><p><strong>（2）安装Bazel</strong></p><p>从 <a href="https://github.com/bazelbuild/bazel/releases">GitHub 上的 Bazel 版本页面</a>下载名为 bazel-version-installer-linux-x86_64.sh的shell脚本文件。</p><p>例如我本次安装的就是<code>bazel-6.3.2-installer-linux-x86_64.sh</code></p><p>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给bazel-6.3.2-installer-linux-x86_64.sh脚本可执行权限</span></span><br><span class="line">chmod +x bazel-6.3.2-installer-linux-x86_64.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载bazel</span></span><br><span class="line">./bazel-6.3.2-installer-linux-x86_64.sh --user</span><br></pre></td></tr></table></figure><p>根据提示，将 <code>source /home/mahaofei/bin/bazel/bin/bazel-complete.bash</code> 添加到 <code>~/.bashrc</code> 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;source /home/mahaofei/.bazel/bin/bazel-complete.bash&#x27; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>重启终端，使用<code>bazel --version</code>命令检查是否安装成功。</p><h2 id="1-2-下载Mediapipe">1.2 下载Mediapipe</h2><p><strong>（1）克隆项目</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:google/mediapipe.git</span><br></pre></td></tr></table></figure><p><strong>（2）安装opencv和ffmpeg</strong></p><p>进入克隆的项目中，为<code>setup_opencv.sh</code>添加可执行权限，并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x setup_opencv.sh</span><br><span class="line">./setup_opencv.sh</span><br></pre></td></tr></table></figure><h1>2 使用</h1><p><strong>（1）python环境</strong></p><p>创建虚拟环境，并安装必要的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda create -n mediapipe python=3.8</span><br><span class="line">conda activate mediapipe</span><br><span class="line">pip install opencv-python</span><br><span class="line">pip install opencv-contrib-python</span><br><span class="line">pip install mediapipe</span><br></pre></td></tr></table></figure><p><strong>（2）使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> mediapipe <span class="keyword">as</span> mp</span><br><span class="line">mp_drawing = mp.solutions.drawing_utils</span><br><span class="line">mp_drawing_styles = mp.solutions.drawing_styles</span><br><span class="line">mp_holistic = mp.solutions.holistic</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">with</span> mp_holistic.Holistic(</span><br><span class="line">    min_detection_confidence=<span class="number">0.5</span>,</span><br><span class="line">    min_tracking_confidence=<span class="number">0.5</span>) <span class="keyword">as</span> holistic:</span><br><span class="line">  <span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    success, image = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;Ignoring empty camera frame.&quot;</span>)</span><br><span class="line">      <span class="comment"># If loading a video, use &#x27;break&#x27; instead of &#x27;continue&#x27;.</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    image.flags.writeable = <span class="literal">False</span></span><br><span class="line">    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span><br><span class="line">    results = holistic.process(image)</span><br><span class="line"><span class="comment">#画图</span></span><br><span class="line">    image.flags.writeable = <span class="literal">True</span></span><br><span class="line">    image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)</span><br><span class="line">    mp_drawing.draw_landmarks(</span><br><span class="line">        image,</span><br><span class="line">        results.face_landmarks,</span><br><span class="line">        mp_holistic.FACEMESH_CONTOURS,</span><br><span class="line">        landmark_drawing_spec=<span class="literal">None</span>,</span><br><span class="line">        connection_drawing_spec=mp_drawing_styles</span><br><span class="line">        .get_default_face_mesh_contours_style())</span><br><span class="line">    mp_drawing.draw_landmarks(</span><br><span class="line">        image,</span><br><span class="line">        results.pose_landmarks,</span><br><span class="line">        mp_holistic.POSE_CONNECTIONS,</span><br><span class="line">        landmark_drawing_spec=mp_drawing_styles</span><br><span class="line">        .get_default_pose_landmarks_style())</span><br><span class="line"></span><br><span class="line">    mp_drawing.draw_landmarks(image, results.left_hand_landmarks, mp_holistic.HAND_CONNECTIONS)</span><br><span class="line">    mp_drawing.draw_landmarks(image, results.right_hand_landmarks, mp_holistic.HAND_CONNECTIONS)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#右手21个节点坐标</span></span><br><span class="line">    <span class="keyword">if</span> results.right_hand_landmarks:</span><br><span class="line">        <span class="keyword">for</span> index, landmarks  <span class="keyword">in</span> <span class="built_in">enumerate</span>(results.right_hand_landmarks.landmark):</span><br><span class="line">            <span class="built_in">print</span>(index,landmarks )</span><br><span class="line"><span class="comment">#鼻子坐标</span></span><br><span class="line">    <span class="comment">#print(results.pose_landmarks.landmark[mp_holistic.PoseLandmark.NOSE])</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;MediaPipe Holistic&#x27;</span>, cv2.flip(image, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312050848155.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 实例分割 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 模仿 </tag>
            
            <tag> 关节检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模仿动作】从人类演示中学习机器人动作规划方法</title>
      <link href="/post/d76756ed.html"/>
      <url>/post/d76756ed.html</url>
      
        <content type="html"><![CDATA[<h1>1 MimicPlay: Long-Horizon Imitation Learning by Watching Human Play</h1><blockquote><p><strong>标题</strong>：模拟游戏：通过观看人类游戏进行的长期模拟学习<br><strong>作者团队</strong>：斯坦福大学<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://mimic-play.github.io/">https://mimic-play.github.io/</a>(code is coming soon)</p></blockquote><h2 id="1-1-目标问题-6">1.1 目标问题</h2><p>由于人类比遥控机器人能更快的完成长时间任务，因此启发从人类演示中学习机器人规划策略。</p><p>为了减少数据需求，采用人类与环境的交互视频作为数据。开发一个分层学习框架，从人类数据中学习潜在的规划控制方法。</p><h2 id="1-2-方法-5">1.2 方法</h2><p><img src="https://img.mahaofei.com/img/202309071622980.png" alt="image.png"></p><p><strong>（1）从人类数据中学习潜在规划</strong></p><p>给定输入：视觉观察$o_t$，未来的目标图像$g_t$，当前手部位置$l_t$<br>训练过程中，$g_t$被视为执行动作后的未来帧<br>规划期的目标是根据视频提示V生成目标图像的动作规划。</p><ol><li>人类演示数据收集</li><li>跟踪人手三维轨迹：使用双目相机获取人手的3D轨迹，利用现成的<a href="https://github.com/ddshan/hand_object_detector">手部检测器</a>确定2维图像中的手部位置，然后利用双目视图重建手的3D轨迹。</li><li>学习潜在规划：使用两个卷积网络分别将当前图像和目标图像处理为低维特征，再与手部位置连接在一起，使用MLP处理为潜在规划特征。生成3D手部运动轨迹。为了处理同一个任务的不同方式的实现，使用高斯混合模型对潜在规划的轨迹分布进行建模。</li></ol><p><strong>（2）计划引导的多任务模仿学习</strong></p><p>机器人的底层策略使用行为克隆算法进行训练，使用通过遥操作收集的机器人演示数据。</p><ol><li>视频条件下的潜在规划生成：使用遥操作机器人任务视频来提示训练时潜在规划器生成相应的规划。</li><li>基于Transformer的规划引导模仿：将机器人手上相机观察和本体姿态信息处理为低维向量，再与潜在计划连接起来，通过Transformer架构来计算最终的机器人控制命令。</li><li>多任务学习</li></ol><h2 id="1-3-思考-4">1.3 思考</h2><p>李飞飞团队的作品，从视频中学习人手的运动轨迹，code is coming soon，等待后续再细看。</p><h1>2 One-Shot Imitation from Observing Humans via Domain-Adaptive Meta-Learning</h1><blockquote><p><strong>标题</strong>：通过领域自适应元学习观察人类的一次性模仿<br><strong>作者团队</strong>：加州大学伯克利分校<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2018<br><strong>代码</strong>：<br><a href="https://github.com/tianheyu927/mil">官方版: https://github.com/tianheyu927/mil</a><br><a href="https://github.com/daiyk/daml_pytorch">Pytorch版: https://github.com/daiyk/daml_pytorch</a></p></blockquote><h2 id="2-1-目标问题-2">2.1 目标问题</h2><p>提出一种从人类视频中进行学习的方法，通过使用各种先前任务的人类和机器人演示数据，使机器人执行人类演示的任务。</p><h2 id="2-2-方法-2">2.2 方法</h2><p><strong>（1）问题描述</strong></p><p>将先验知识和少量证据组合起来，形成一个人类演示的形式。从中推断出完成任务的机器人的策略参数。</p><p><strong>（2）领域自适应元学习</strong></p><p>能够处理从人类的视频演示中学习，学习一组参数，以便在人类演示的基础上进行梯度下降后，模型可以有效地执行新任务。</p><p>由于人类和机器人的动作无法直接对应，因此考虑学习只对策略激活起作用。</p><p><strong>（3）学习时间适应目标</strong></p><p>要从人类的视频中进行学习，需要捕获视频中的相关信息，例如人类的意图和任务的相关对象。要确定哪些行为正在被演示，哪些对象是相关的，通常需要同时检查多个帧来确定人类的运动。因此本文的学习适应目标将多个时间步长耦合，从多个时间步骤对策略进行操作。</p><p>此处使用卷积网络来表示自适应目标，使用递归神经网络LSTM进行时间卷积。</p><p><strong>（4）概率解释</strong></p><p>将学习到的自适应目标纳入到概率图模型的框架中，推断特定任务的策略参数。</p><h2 id="2-3-思考">2.3 思考</h2><p>思路看起来很可以，就是数学推理比较复杂，很难看得懂。</p><h1>3 Waypoint-Based Imitation Learning for Robotic Manipulation</h1><blockquote><p><strong>标题</strong>：基于航路点的机器人操纵模拟学习<br><strong>作者团队</strong>：斯坦福大学<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/lucys0/awe">https://github.com/lucys0/awe</a></p></blockquote><p>行为克隆BC目前有很多问题，路径点可以通过减少BC的范围来解决这个问题，但是传统路径点需要人工监督标注。</p><p>本文提出了线性运动近似的，模仿学习的自动轨迹点提取模块，将演示分解为一组轨迹点，进行线性插值，近似实现演示动作。</p><p>并且该方法可以与任务BC算法相结合，提高其成功率。</p><h1>4 Building Robot Intelligence by Scaling Human Supervision</h1><blockquote><p><strong>标题</strong>：通过扩展人类监督构建机器人智能<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：Thesis<br><strong>时间</strong>：2021</p></blockquote><h2 id="4-1-研究背景">4.1 研究背景</h2><p><strong>几十年来，我们一直在想象一个机器人可以充当个人助理的世界，能够完成我们每天做的各种任务和家务，比如做饭、打扫卫生、洗衣，甚至组装橱柜。机器人领域的研究人员一直致力于实现这一梦想。然而，不幸的是，今天的自主机器人远未达到操纵能力的水平。尽管研究在使机器人能够完全自主地完成特定任务的方面取得了令人印象深刻的进展，包括拾取物体，或将它们堆叠在一起。但机器人和人类的操作能力之间存在很大差距。人类智能地使用物体，并在日常生活中以丰富的方式与它们互动，比如当我们用刀切菜做饭时，或者用螺丝刀拧紧螺丝组装橱柜时。这种有目的的与物体的互动对机器人来说是十分困难的。</strong></p><p><strong>作为人类，我们在一生中积累了一系列不同的先前经验，这些经验我们可以在日常生活中借鉴。此外，即使我们不知道如何做某事，我们也可以通过观看其他人的视频来快速学习，例如通过观看YouTube上其他人组装橱柜的视频来学习如何组装橱柜。这就提出了一个问题——我们是否可以类似地为机器人提供丰富多样的先前经验，并使他们能够从这些数据集中学习操作技能？</strong></p><p><strong>这激发了数据驱动的机器人，这是一种有用的范式，让机器人从大型数据集中学习操作。但是这种方法通常有两种变体，第一种是机器人自行收集数据，数据一开始是随机的，但会随着时间推移慢慢变好。由于机器人必须自己学习，限制了可以学习的人物的复杂性。第二种则是人类控制机器人并引导它完成任务，然是这通常是不可扩展的，因此可以收集的数据量很小，这再次限制了任务的复杂性。</strong></p><p><strong>相比之下，计算机数据和自然语言处理等领域已经通过大规模高质量数据集开创了前所未有的成就，我们希望在机器人技术方面看到类似的突破。</strong></p><p><strong>为了复制这一成功经验，并解决数据驱动机器人中任务复杂性有限的问题，我们需要解决两个关键挑战。首先，收集大规模的人类数据具有挑战性。在计算机视觉领域，注释可以由人类直接标注，很容易实现并行标注和大规模人员标注。相比之下，在机器人技术中，人类必须与机器人实时互动，引导机器人完成任务。这使得提供直观和可扩展的方法来收集来自多个人的数据变得很困难。其次，从大规模数据集中学习可能并不简单。在其他领域，我们可以训练网络预测注释，这些注释对应的都是真实的标签。然而在机器人技术中，没有一种真正的方法来执行任务，不同的人可能会收集不同的轨迹，不同的策略，我们需要确定如何从这些数据集中学习。</strong></p><h2 id="4-2-研究目标">4.2 研究目标</h2><p>第一部分，讨论了如何通过充满丰富交互的人类监督来收集大规模数据，这些数据体现了机器人的类人操作能力。包括一个为解决机器人操作中对大规模人类数据集需求构建的平台，和现实世界的数据收集。</p><p>第二部分，讨论了如何使用丰富的数据集来学习机器人操作技能。</p><p>第三部分，讨论了该方法可能的进一步拓展和应用。</p><h2 id="4-3-收集人类操作数据">4.3 收集人类操作数据</h2><p><strong>为了使数据能够捕捉人类的操作，首先数据应该在所展示的解决问题的策略的种类上是多样化的。作为人类，我们很清楚什么时候应该尝试不同的方法类实现目标，而机器人应该从所有这些策略中学习，因为在特定的情况下可能需要其中的一种。其次，数据应该包含灵巧的操作，我们希望我们的机器人了解它们如何通过武力方式操作物体来实现预期的结果。最后，数据应该是大规模的，人类非常擅长在无数情况下解决问题，但机器人还不能做到这一点。我们向他们展示的数据越多，他们也就越有可能获得这种能力。</strong></p><p>在这一部分，我们提出了RoboTurk平台，一个数据收集平台，允许人类实时远程操作机器人。操作员在他们的网络浏览器中看到机器人的工作空间的视频流，用他们的智能手机控制机械臂，他们手机的运动与机器人的运动相耦合，可以自然地控制手臂，这使得人们可以轻松的提供任务演示，连接的过程快速而简单。实验表明，这些数据能够在多步骤操作任务上进行策略学习，并且在策略学习的过程中使用大量的演示可以在学习一致性和最终性能方面带来好处。</p><h2 id="4-4-从大规模人类数据集中学习操作">4.4 从大规模人类数据集中学习操作</h2><p><strong>在这一部分，我们讨论了机器人如何才能够大规模人类数据集中学习操作技能。此类数据集可能表现出巨大的多样性，并由次优解决方案组成，因此从中学习具有挑战性。我们提出了一种从大规模演示数据集中学习的新算法，即无规模交互的内隐强化IRIS算法。IRIS将控制问题分解为目标条件的低级控制器和高级目标选择机制，前者模仿短演示序列，后者为低级控制器设置目标，并选择性的组合部分次优解决方案，从而更成功的完成任务。</strong></p><p>尽管最近在模仿学习和强化学习方面缺乏开源的人类数据集和可重复的学习方法，使得评估该领域的状态变得困难。我们对六个离线学习机器人操作算法，在五个仿真和三个不同复杂度的真实环境中进行多阶段操作任务测试。我们得到了一系列经验，包括对不同算法设计选择的敏感性，对演示质量的依赖性，以及由于训练不同的目标而导致的不同停止标准。我们还强调了从人类数据集学习的可能性，例如在当前强化学习方法范围之外的具有挑战性的多阶段任务中学习熟练策略的能力，以及轻松扩展到只有原始感官信号可用的自然、真实世界操作场景的能力。我们已经开源了我们的数据集和所有算法实现，以促进未来的研究和从人类演示数据中学习的公平比较。</p><h2 id="4-5-使用人类数据集构建能力更强的机器人">4.5 使用人类数据集构建能力更强的机器人</h2><p>这一部分探讨了几个不同的应用程序，使我们更接近于我们希望的机器人能够在未来能够处理的任务。主要探讨了多任务领域（如厨房），高精度操作，和需要协作的多臂操作任务。</p><p><strong>模仿学习方法的一个常见的局限是由于训练集中的数据有限，在所展示的行为之外进行泛化是一个开放的挑战。例如在厨房场景中，我们可能希望机器人实现多种可能的配置，具有多个要操作和交互的对象，如食物、出轨、微波炉、水槽等。本章我们介绍了通过模仿进行任务泛化，这是一种新颖的模仿学习框架，使机器人能够从少量的人类演示中有效的学习复杂的现实世界操作任务。合成收集的演示中未包含的新行为。多任务领域通常呈现出一种潜在的结构，不同的任务轨迹在状态空间的公共区域相交。GTI是一个两阶段在线模仿学习算法，该算法利用交叉结构来训练目标导向的策略，这些测类推广到看不见的开始和目标状态组合。在GTI的第一阶段，我们训练了一个随机策略，该策略利用轨迹交叉点来有能力从不同的演示轨迹中组合行为在一起。在GTI的第二阶段，我们从第一阶段的无条件随机策略中收集了一小组推理，并训练一个目标导向的agent来推广到新的启动和目标配置。我们在模拟领域和现实世界中具有挑战性的长期机器人操作领域中验证了GTI。</strong></p><p><strong>模仿学习方法通常也很难完成高精度的操作任务，因为它们需要一系列精确的动作才能取得有意义的进展，比如机器人将pod插入咖啡机制作咖啡。经过培训的策略可能会在这些场景失败，因为行动上的微小偏差可能会导致策略进入未被演示覆盖的区域。基于干预的策略学习是解决这一问题的一种替代方案——它允许操作员监控经过训练的策略，并在遇到故障时接管控制权。</strong> 我们扩展了RoboTurk，使远程操作员能够监控和干预经过培训的政策。我们开发了一个简单的在系统收集的新数据上迭代训练策略的有效算法。我们证明，根据我们基于干预的系统和算法收集的数据训练的代理优于根据非干预演示者收集的同等数量样本训练的代理，并进一步证明，我们的方法在从具有挑战性的机器人线程任务和咖啡制作任务。</p><p><strong>最后，虽然通过远程操作收集的人类演示中的模仿学习（IL）是教授机器人操作技能的强大范式，但它大多局限于单臂操作。然而，许多现实世界中的任务需要多个手臂，例如举起重物或组装桌子。不幸的是，将IL应用于多臂操作任务一直具有挑战性</strong>——要求人类控制多个机械臂可能会带来巨大的认知负担，而且通常最多只能控制两个机械臂。为了应对这些挑战，我们介绍了多臂RoboTurk（MART），这是一个多用户数据收集平台，允许多个远程用户同时远程操作一组机械臂，并收集多臂任务的演示。使用MART，我们从几个地理位置不同的用户那里收集了五个新的双臂和三臂任务的演示。我们表明，从这些数据中学习因此给集中式代理带来了挑战，这些代理直接尝试同时对所有机器人动作进行建模，并对数据进行全面不同的策略架构，对我们的任务具有不同的集中程度。最后，<strong>我们提出并评估了一个基本残差策略框架，该框架允许经过训练的策略更好地适应多臂操作中常见的混合协调设置，并表明用去中心化残差模型增强的集中式策略在我们的基准任务集上优于所有其他模型。</strong></p><h1>5 Understanding and Learning Robotic Manipulation Skills From Humans</h1><blockquote><p><strong>标题</strong>：从人类身上理解和学习机器人操作技能<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：Thesis<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><h2 id="5-1-背景和动机">5.1 背景和动机</h2><p>制造机器人的性能是通过它们的精度、准确性和速度来衡量的。这导致了刚性和笨重的机器人的设计，这些机器人与人类一起工作是不安全的。他们的控制器在不使用力传感的情况下执行预先编程的轨迹，使其对位置误差高度敏感。通过使用夹具和夹具，例如装配线上的夹具，可以减少环境中的不确定性。</p><p>现实世界的环境需要低重量、人类安全、扭矩控制的机器人。<strong>如果机器人要在环境不断变化、感知能力有限的日常环境中真正发挥作用，就必须找到通过预编程轨迹控制机器人的替代方案。一种很有前途的方法是将复杂的任务划分为健壮且可重用的动作或基元。</strong> 在本文中，我们通过使用可推广的顺应原语，为在更高抽象级别上编程机器人奠定了理论和实践基础。</p><p><strong>方法的第一步是从人类演示中收集数据。然后，我们将数据分割成在任务期间执行的动作序列——基元。接下来，我们将数据投影到一个低维和物理意义的空间中，使我们能够理解人类的策略。最后，我们将这些行为编码到能够执行任务的机器人控制器上。</strong> 此外，我们的框架利用视觉和触觉反馈，让人类处于故障恢复和持续学习的循环中。</p><h2 id="5-2-从人类演示中学习">5.2 从人类演示中学习</h2><p><strong>本文的工作属于示范学习LfD的范畴。人类在操作方面非常有能力，因此从人类演示中收集数据使学习机器人新行为的一种流行方式。事实上，我们不仅可以学习单臂行为，还可以学习双臂行为，我们的系统已经证明了这一点，并在其它工作中进行了探索。</strong> 大多数先前的工作侧重于从视觉数据中学习。而我们的工作强调在执行富含接触的任务时里和数据的重要性。</p><p>近年来，互动学习是一个不断发展的研究领域，它使人类保持在循环学习的过程中。为了实现类似的工作方式，我们的框架通过使用触觉接口使人类处于循环中，我们系统手机故障恢复数据可以与从故障中学习的工作相结合，易产生更稳健的自主行为。</p><h2 id="5-3-机器人基本单元">5.3 机器人基本单元</h2><p>在这项研究中，基元是有一个兼容的框架和一组所需的任务参数定义的。顺应性框架是一个原点和空间中的三个方向，我们沿着它们控制运动和顺应性。柔顺框架附着到要操纵的对象上。任务参数包括所需的力、力矩、位置和方向。这种与机器人无关的任务规范提供了一种有物理意义的低维表示。</p><p><strong>基元库。生成一个由n个基元组成的库，对基本的操作技能进行编码，通过组合这些基元，可以以一种方式解决新的复杂任务，即所需基元的数量不会随着任务数量的增加而增加。广义上讲，关于运动基元的文献主要解决了三个主要的研究问题，生成运动基元，参数化基元以及将基元组合在一起以成功完成任务。</strong></p><p><strong>基元生成。基元的生成可以通过手动编码所需策略或者从数据中自动提取策略来实现。先前的研究已经转向人类寻求灵感，并试图提取策略。</strong></p><p><strong>基元参数化。参数化基元处理定义动作的方式。基元通常使用轨迹段进行参数化。用轨迹定义运动基元已经被证明是成功的，但该方法假设环境不确定性较低。</strong></p><p>兼容基元。我们使用框架的概念来参数化我们的原始控制器。先前的研究使用了以对象为中心的任务控制器的相同概念。然而，与本文中的工作相反，仅从视觉数据中提取控制器参数，我们认为，在处理复杂任务是，考虑序列数据是有利的。在存在位置不确定性的情况下，顺从性在任务中也起着重要作用，对于接触丰富的任务，比如抓获或本文中研究的任务。例如，基元的概念，其中柔顺基元就是用于实现对小物体的鲁棒抓取。</p><p><strong>使用基元进行规划。组合运动基元的概率方法利用了决策过程的固有不确定性，这些方法可以是完全自动化的，也可以是使用混合的方法，将自动决策算法与用户指定的图像相结合。</strong> 最近的其他方法使用语义模型来学习基于是觉得操纵任务计划，或者一些方法使用接触而不是视觉来指导决策过程。</p><h2 id="5-4-多层控制体系结构">5.4 多层控制体系结构</h2><p>该体系结构由三层感知-动作反馈回路组成。每个层都以不同的抽象级别运行，并以不同的频率运行。</p><p>在最底层，完全依赖于控制器，并有助于高速率感官反馈和控制的集成，以实现安全和可预测的机器人运动。该级别向机器人电机发送命令，因此，感知动作回路必须以非常高的频率闭环。下一层向全身控制器提供输入，从而以较慢的速率运行。最后，执行计算成本高昂的感知和规划的最高抽象级别以最低的速率运行。</p><p>全身控制级别使用任务优先级。基于优先级的控制使我们在设计原始动作时能够专注于对象及其几何约束。完整的机器人行为可以被视为由具有不同优先级的不同任务组成。例如，高优先级任务可以是避免奇异配置，另一个任务可以处理障碍或摩擦约束。以类似的方式，有一项任务专门负责实现操纵对象之间所需的几何关系。此任务被编码为基元。换句话说，基本动作只涉及对象，因为任务的所有其他方面，包括非几何约束和机器人运动学，都由控制器的其他组件处理。</p><p>基于优先级的全身控制使用零空间投影来确保满足所有不同的约束。此外，操作空间公式——使用Jacobian的动态解耦逆来计算递归零空间投影——确保具有不同优先级的任务动态解耦。先前的工作也在操作原语的上下文中使用了这种分层框架。</p><h1>6 Scaling Deep Robotic Learning to Broad Real-World Data</h1><blockquote><p><strong>标题</strong>：将深度机器人学习扩展到广泛的真实世界数据<br><strong>作者团队</strong>：Stanford University<br><strong>期刊会议</strong>：Thesis<br><strong>时间</strong>：2023<br><strong>代码</strong>：</p></blockquote><h2 id="6-1-背景">6.1 背景</h2><p>机器人的一个长期梦想是一种通用的家用机器人，它可以被放置在家庭环境中，也许是它以前从未见过的，并执行一系列有用的任务，如煮咖啡、清洁和烹饪。这样一个机器人无疑将在经济上和通过他们的帮助提高人类生活质量方面产生巨大影响。当然，这个梦想仍然是这样，在实现这个目标方面存在着无数的挑战，包括更好的机器人硬件、电池技术和传感。然而，核心挑战之一在于泛化，即机器人在新的物体、环境和任务中取得成功的能力。事实上，人类有这种能力，正是这种能力使我们能够完成像煮一杯咖啡这样的任务，即使在有新厨房和新物体的情况下也是如此。因此，相关的问题仍然存在——我们如何训练我们的机器人，使其能够广泛推广。</p><p>解决这个问题的一种方法是利用人类的直觉，以及用于机器人规划和控制的手部设计系统和表示。在这种方式中，人类定义了相关的对象类及其属性和关系（例如，颜色、形状、姿势、上方与下方等），然后可以使用状态估计技术从传感器观测中测量这些量，并且可以使用经典的搜索和运动规划方法来执行任务。然而，至关重要的是，这种方法是基于人类对相关对象、特性的规范，在某些情况下，甚至是每个环境和任务的对象的3D模型，这阻碍了这种方法在存在新对象和环境的情况下容易使用。</p><p>有一项工作研究了机器人如何在制造通用机器人时不依赖人类的直觉和手部设计，而是纯粹通过数据和自己的试错来学习行为。具体来说，深度强化学习研究了学习深度神经网络策略的问题，该策略在给定传感器观测的情况下采取行动，从而使策略通过从交互中学习来最大化一些定义的奖励。原则上，这种方法可以让机器人完全靠自己学习技能，而只有少量的成功指标。然而，在实践中，在机器人上运行深度强化学习带来了许多挑战，例如在重置和奖励方面需要人工监督。然而，最关键的是，深度强化学习通常需要在目标环境中进行数百万次在线环境交互才能进行学习，并且一旦完成，所学习的策略只对所训练的环境和数据有效。因此，标准的深度强化学习在消除了人手设计的大部分需求的同时，仍然没有立即让我们更接近能够在新环境和任务中操作的机器人。</p><p>退一步看，人们可能会从机器学习的其他领域寻找灵感，特别是过去几年里，自然语言处理和计算机视觉的研究领域取得了巨大进展。主要基于一个简单的配方：：（1）大量、多样化的离线数据集，（2）自监督或廉价监督的训练目标，以及（3）表达性的端到端训练的神经网络模型。这种基础模型的范例特别令人兴奋，因为这些模型表现出了令人印象深刻的泛化——例如，来自ImageNet的视觉模型可以适应癌症检测这样的全新任务，而像BERT这样的预训练语言模型的应用范围从医学编码到视觉问答。事实上，这种概括水平正是我们希望在一个通用机器人中看到的，它可以被放入一个新的环境中，并快速地学会解决新的任务。</p><p>所以为什么这个配方还没有在机器人中实现呢？现实世界中的机器人操作带来了许多独特的挑战，这使得直接复制这一配方变得困难——我们既没有足够大和多样化的机器人交互数据集，也不清楚什么类型的学习算法或监督来源可以使我们从这些数据集中大规模学习有用的技能。本文的目标在于解决这些挑战，并在机器人操作的背景下复制大规模数据和学习的配方。具体来说，我的研究集中在回答三个广泛的问题上。首先，我们如何可伸缩地收集在物理世界中交互的机器人的大型和多样化的数据集？其次，我们如何设计能够消耗如此广泛的离线数据的自我监督强化学习算法，这些数据可能来自非专家，缺乏奖励标签，并从中学习达到看不见的目标？第三，我们如何解锁网络上存在的广泛数据来源，如人类视频和自然语言，以便在我们的机器人中进行更有效的学习？</p><h1>7 Learning Perceptual Prediction: Learning From Humans and Reasoning About Objects</h1><blockquote><p><strong>标题</strong>：学习感知预测：向人类学习和对物体的推理<br><strong>作者团队</strong>：University of Pennsylvania<br><strong>期刊会议</strong>：Thesis<br><strong>时间</strong>：2023<br><strong>代码</strong>：</p></blockquote><h2 id="7-1-目标问题-2">7.1 目标问题</h2><p>人类在使用各种各样的感知模式进行预测时，主要关注从视觉学习。人类的视觉似乎经过了高度的优化，可以用于预测未来的视觉观测。</p><p>研究使用视觉传感器的预测也提供了许多实际优势。首先，高质量的相机很容易获得，并且尺寸、重量和功率要求都很低，这使得它们可以被包括在大多数机器人平台上，由于相机在非机器人应用中的普及，它们已经被商品化了。其次，视觉观察提供了关于环境的丰富信息，包括姿势、纹理和语义，这些信息是其他传感器无法轻易匹配的。获取大量丰富的世界信息对于使代理人能够与世界互动非常重要。</p><p>当前学习动作条件视觉预测模型的方法依赖于访问大量的具体数据，这是昂贵且耗时的，从而阻止了基于视觉预测的方法在许多应用中使用。对于机器人来说尤其如此，因为收集大量机器人数据既昂贵又耗时，而且可能不安全。现有工作表明，基于视觉预测的方法随着数据量的增加而扩展良好，因此找到新的数据来源对于使这些模型能够广泛使用至关重要。</p><p>在这篇论文中，我提出了三种不同的方法来利用非机器人数据来改进视觉预测和机器人控制。在前两项工作中，我使用人类数据来提高机器人的性能，而在第三项工作中我使用现有的非机器人数据集来实现以对象为中心的预测框架。</p><h2 id="7-2-从人类学习">7.2 从人类学习</h2><p>大型和多样化的真实世界数据集对于广泛的泛化和高性能至关重要。大型数据集可以通过自动化管道或人类远程操作进行收集。自动化数据收集过程可以收集非常大的数据集，但在到达环境中感兴趣的部分以及需要与环境进行大量交互方面存在问题。习得的探索策略可以提高代理达到有趣配置的能力，但这些方法仍然需要大量的探索。第二种方法是收集人类演示的远程操作轨迹。这种方法允许数据集轻松地达到有趣的和任务相关的配置。然而，它受到了影响，因为它依赖于人类来操作机器人，这需要训练有素的操作员，而且很快变得非常昂贵。通过从人类学习中汲取灵感，可以找到一种避免这两种方法困难的替代方法。</p><p>人类不仅有能力从自己与世界的互动中学习技能，也有能力通过观察他人来学习技能。考虑一个婴儿学习使用工具。为了成功地使用一个工具，它需要学习该工具如何与其他对象交互，以及如何移动工具来触发这种交互。这种直观的物理概念可以通过观察成年人如何使用工具来学习。更普遍地说，观察是关于世界以及行动如何导致结果的强大信息来源。然而，在存在身体差异的情况下（例如成人身体和婴儿身体之间），利用观察是具有挑战性的，因为演示者和观察者的行为之间没有直接对应关系。来自神经科学的证据表明，人类可以有效地推断出这种对应关系，并利用它们从观察中学习。</p><p>利用对人类的观察提供了大幅增加可用数据的规模和有用性的机会。与自主收集的数据不同，人类数据可以只关注配置空间中有趣的部分，避免危险或无聊的交互。与通过远程操作收集的数据集不同，人类数据集可以具有更大的规模。公开可用的人类数据集，如Ego4D或SomethingSomething，包含数十万个视频和数千小时的镜头，分布在数百个任务和数十个地点。这些数据集与自主收集的数据集的大小相当]，并比通过远程操作收集的数据集中的大小高出一到两个数量级。更重要的是，从人类的无行动观察中学习，开启了从互联网上公开生成的视频中学习的可能性，比如YouTube上的视频，这些视频提供了更多数量级的数据。目前的方法只能将这些数据的有限子集用于特定任务，但我们的工作为更广泛的利用提供了一步。</p><p>在这篇论文中，我们考虑了这样一个问题：主体能否学会利用自己的互动和其他主体的被动观察来解决任务？我们在两个环境中探讨了这个问题，第一个是学习动作条件视觉预测模型，第二个是端到端强化学习策略。</p><p>在第3章中，我们提出了一种使用人类的无动作数据和主体自己的探索来执行强化学习的方法。我们提出了克服野外人类数据和模拟机器人数据之间的域转换的方法，将动作添加到无动作的人类数据中，以及估计人类数据的奖励的方法。通过利用在现实世界中收集的人类视频，我们能够加快模拟机器人代理的学习速度。</p><h2 id="7-3-对象推理">7.3 对象推理</h2><p>虽然从人类观察中学习可以获得大量数据，但它并不能回答应该学习什么的问题。我们重点学习端到端模型，这些模型直接从传感器输入映射到预测的未来帧或内部结构很少的期望动作。通过为任务选择正确的归纳偏差集，并利用在非机器人数据上预训练的现有模型，我们应该能够用更少的数据训练我们的模型，并实现更高的性能。正确设计学习问题的结构也可以使模型更容易地用于下游任务。我们关注的是假设世界是由物体组成的简单归纳偏见。</p><p>大多数用于操纵的动态交互可以通过将场景分解为对象来建模。虽然有些材料，如液体或颗粒介质，不容易被表示为对象，但大多数操作任务都涉及操作离散对象。分拣箱子、重组房间，甚至喝杯咖啡，这些任务主要由与离散对象的交互控制。</p><p>以对象为中心的预测模型在预测和困难任务方面表现出了成功的性能。通过将场景分解为离散对象，这些预测模型可以在更长的时间范围内保持每个对象的内聚性。此外，通过将世界状态内部表示为对象集合，以对象为中心的预测模型可以轻松地与规划者对接，并提供一个非常可解释的界面，有助于调试和验证。</p><h1>8 Affordances from Human Videos as a Versatile Representation for Robotics</h1><blockquote><p><strong>标题</strong>：人类视频作为机器人的通用表示<br><strong>作者团队</strong>：CMU, Meta AI<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://robo-affordances.github.io/">https://robo-affordances.github.io/</a></p></blockquote><h2 id="8-1-目标问题-2">8.1 目标问题</h2><p>从人类视频中学习可操作的动作表示，该模型在未来帧的监督下预测接触点和轨迹路径点。</p><p>论文主要关注三个问题：</p><ol><li>如何表示可操作性？</li><li>如何以数据驱动和可扩展的方式学习这种表示？</li><li>如何实现跨机器人的视觉启发的方法部署？</li></ol><p>对应这三个问题，本文提出了以下三种观点：</p><ol><li>接触点和接触之后的轨迹是比较好的机器人操作的表示方法；</li><li>利用了自我中心的数据集，聚焦于所有有人类的帧，来预测接触点和接触之后的轨迹，通过使用现成的工具来估计自我运动、人体姿势和手-物体交互；</li><li>实现了一种称为Vision-Robotics Bridge(VRB)的方法，实现这些功能与不同类型机器人的无缝集成。</li></ol><h2 id="8-2-方法-2">8.2 方法</h2><p><strong>（1）可操作性表示</strong></p><p>提取人类启示的最自然的方式是观察人们如何与世界互动。常规的思路是从视频中准确模拟人类的运动，但这导致了一个以人为中心的模型，很不容易推广，因为人类的形态和机器人完全不同。</p><p>因此本文采用机器人需求驱动的第一性原理，机器人的本体的信息通常是已知的，因此使用运动规划达到3D空间中的点是很容易实现的，关键难点在于与环境的互动位置在哪里，以及接触之后如何移动。</p><p>受此启发，采用接触点 $c$ 和接触之后的轨迹 $\tau$ 作为视觉启发的简单操作表示，可以很容易的传递给机器人。其中 $\tau=f(I_t,h_t)$，$I_t$ 是时间步长 $t$ 的图像，$h_t$ 是像素空间中人手位置。</p><p><strong>（2）从自我中心的视频中学习操作</strong></p><p>接下来的问题是如何处理视觉输入的人体或手，从人类视频中提取接触点 $c$ 和轨迹 $\tau$。</p><ol><li>从人类视频中提取操作</li></ol><p>对于给定的视频 $V$，例如人开门，使用现有的手部对象检测模型，对每一帧图像 $I_t$ 生成手的2D边界框和离散接触变量 $o_t$，使用这些信息，我们可以过滤每个图像中 $o_t$ 表示接触的帧，从而找到发生<strong>接触的第一个时间步长</strong> $t_{contanct}$。</p><p><strong>手的像素空间位置构成了接触之后的轨迹</strong> $\tau$，为了提取接触点，我们使用手边界框以及颜色分割来找到手与其他物体边界框相交的点，利用高斯混合模型拟合这些接触点。</p><p>同时要考虑，一个人打开门的时候，人手不仅会移动，<strong>相机也会移动</strong>，需要补偿相机的运动，使用但应矩阵来解决这一问题，通过匹配连续帧之间的特征来获得单应性矩阵，产生变换后的轨迹。</p><p>需要完成<strong>视觉的转移</strong>，即训练视频中包含人手，但机器人任务中的视角不会有，因此考虑将所有的可操作性映射回第一帧，即人类还没有进入场景时。如果人总在视频中，要么将人裁剪出去，要么丢弃。</p><ol start="2"><li>训练模型</li></ol><p>以输入图像为条件，训练模型预测接触点和接触后的轨迹。然而由于学习的任务是多模态的，比如人从桌子上拿起杯子可能是要喝水或者倒到其他地方，因此考虑建立空间概率分布，预测多个heatmap处理这一问题。</p><p>输入图像使用ResNet进行编码，给出潜在空间表示，然后使用卷积层将这个潜在表示投影到K个概率分割中，得到GMM均值的标签的估计。</p><p><img src="https://img.mahaofei.com/img/202311011426427.png" alt="image.png"></p><p>为了估计接触后的轨迹，本文使用基于Transformer的预测。给定场景中，人类可能与许多对象进行交互，这些对象可能不存在在训练数据中，因此我们通过对接触点周围进行采样来解决，实现更好的泛化。</p><p><strong>（3）机器人学习</strong></p><p>本文用于引导现有的机器人学习方法，考虑了四种不同的机器人模式。</p><p><img src="https://img.mahaofei.com/img/202311011430303.png" alt="image.png"></p><ol><li>离线数据采集中的模仿学习</li></ol><p>给定一个图像输入，模型产生接触点和轨迹，我们将这一组数据存储在数据集中。收集到足够的数据后，我们使用模仿学习来控制策略，实现特定的任务。</p><ol start="2"><li>自由奖励的探索</li></ol><p>目标是发现尽可能多的不同技能，然而现实中从头开始探索效率太低了，因为机器人可能会花费大量时间尝试探索，但仍然无法学习有意义的技能来解决人类想要的任务。</p><p>我们考虑先收集数据，然后对所有轨迹进行排序。对于后续的数据采集从高度探索性的轨迹开始进行引导，进一步探索。</p><ol start="3"><li>目标条件的学习</li></ol><p>利用已知的知识，例如打开的门的图像，监督其进行探索学习。</p><ol start="4"><li>可操作性作为动作空间</li></ol><p>将机器人在连续空间中的操作，以空间的方式进行参数化，为每个位置分配一个基元。通过学习获得大量预测，利用GMM拟合到这些轨迹点上，获得离散的接触点和轨迹，机器人只需要在这个空间上进行搜索。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 模仿 </tag>
            
            <tag> 机器人动作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模仿抓取】从人类演示中学习机械臂抓取</title>
      <link href="/post/f9be0f4e.html"/>
      <url>/post/f9be0f4e.html</url>
      
        <content type="html"><![CDATA[<h1>1 DemoGrasp: Few-Shot Learning for Robotic Grasping with Human Demonstration</h1><blockquote><p><strong>标题</strong>：DemoGrasp: 机器人抓握的少镜头学习与人体演示<br><strong>作者团队</strong>：慕尼黑工业大学<br><strong>期刊会议</strong>：IROS<br><strong>时间</strong>：2021<br><strong>代码</strong>：</p></blockquote><h2 id="1-1-目标问题-4">1.1 目标问题</h2><h3 id="1-1-1-现存问题">1.1.1 现存问题</h3><p>现有的位姿估计方法要么需要计算目标物体的6D位姿，要么需要学习一组抓取点。前者的方法不能很好的扩展到多个对象实例或类，后者需要大型注释数据集，并且由于其对新几何图形的泛化能力交叉而受到阻碍。</p><h3 id="1-1-2-解决思路">1.1.2 解决思路</h3><p>通过简单简短的人类演示教机器人如何抓取物体，不需要许多带注释的图像，也不局限于特定的几何形状。</p><h3 id="1-1-3-大致方法">1.1.3 大致方法</h3><p>首先构建一个人机交互的RGB-D图像序列。利用该序列来构建表示交互的手和对象网格。完成重建对象形状的缺失部分，并估计重建模型与场景中可见对象之间的相对变换。最后将物体和人手之间的相对姿态的先验知识以及对场景中当前物体姿态的估计转化为机器人必要的抓取指令。</p><h3 id="1-1-4-引言总结">1.1.4 引言总结</h3><p><strong>为什么要做这个研究：</strong><br>当前的机器人抓取缺乏泛化能力，因为它们要么专注于估计物体姿态，要么学习抓取点，这需要物体的详细先验信息或大量注释。就像人手一样，机器人的抓取器和手臂的运动范围也有自然的限制，自由度也有限，这限制了它们可能的抓取姿势。虽然机器人抓取器和人手的运动模型可能有很大差异，但应该可以从人类操作中提取信息，并从中推断出目标机器人的足够抓取命令。通过有限的人类演示，机器人可以模仿人类行为，从而无缝抓取物体。</p><p><strong>本文主要做了什么：</strong><br>我们专注于这种模仿，机器人反映了人类的互动，如图1。该任务可以分为视觉感知和解释部分，其中人类教员演示先验操纵（Demo），机器人从中推断出操纵当前场景所需的抓握信息（抓握）。如果从人手到机器人抓取器有足够的映射，将任务分解为这两个阶段可以使我们的方法扩展到大量不同的抓取器。最终，这为通过自然人类演示来教授机器人铺平了道路，从而实现更高水平的自动化，尤其是在结构较少的环境中。</p><p><strong>本文大致是如何实现的：</strong><br>在从各种不同的角度向机器人演示物体（Demo）的过程中，我们的方法不断跟踪手和物体，这些手和物体被融合到截断有符号距离场（TSDF）中，用于3D重建。使用手和对象的语义分割，可以分离并进一步处理重建，以检索对象和手的完整3D表示。然后，我们利用MANO手部模型提取相关的3D手部网格，并将其与重建对象紧密对齐。在推理过程中，我们使用PPF FoldNet来预测对象是否存在，以及它从对象到相机空间的相对变换。然后，应用所估计的姿势从所估计的手网格导出最终抓握指令。</p><h2 id="1-2-方法-3">1.2 方法</h2><p><strong>总体流程：</strong></p><ol><li>在一组人类演示RGB-D图像上分割手和物体，并使用记录的深度图重建它们的形状</li><li>补全物体形状</li><li>提取手部姿态</li><li>估计对象的6D姿态，转换手部模型，推理抓取指令</li></ol><p><img src="https://img.mahaofei.com/img/202308131124867.png" alt="image.png"></p><h3 id="1-2-1-人-物交互的三维重建">1.2.1 人-物交互的三维重建</h3><p>使用MaskRCNN对手和物体进行分割，并且应用了二进制交叉熵来防止类间竞争。</p><p>利用分割后的深度图像，通过KinectFusion创建相应的TSDF体素，并通过输入帧与TSDF之间的ICP配准实现无漂移跟踪。<br>（因为家用物体几何形状简单，因此同时跟踪手和物体，手的结构复杂稳定了跟踪结果）</p><p>利用分割结果，通过两个单独的TSDF重建将手和物体分离开。</p><h3 id="1-2-2-物体形状补全">1.2.2 物体形状补全</h3><p>由于自遮挡和部分可见性，重建的模型还不完整。</p><p>使用3D CNN直接矫正TSDF体积，然后通过行进立方体进行形状提取。<br>（这里使用了UNet的3D变体，输入是64x64x64的体素，输出每个体素的预测分数表示体素是否被占用。</p><h3 id="1-2-3-手部姿态估计">1.2.3 手部姿态估计</h3><p>从重建的手形状中估计手部参数模型。</p><p>使用MANO手部模型，将手部姿态和形状参数映射到网格中。由于手部也受到了部分遮挡，因此使用辅助接触和碰撞损失联合训练CNN进行手部网格和物体网格估计。</p><p>为了进一步改进抓握位置，使用ICP将手部网格与手部TSDF体素对齐。</p><h3 id="1-2-4-抓取指令生成">1.2.4 抓取指令生成</h3><p>首先检索物体姿态，然后用它来变换手部网格，并用手部模型的拇指和食指计算抓握点。</p><h2 id="1-3-思考-3">1.3 思考</h2><ol><li>物体的三维重建可以采用其他方式，或者结合CAD模型补全的方式，相比于使用3D CNN预测效果会更好。</li><li>手部姿态的提取也可以考虑采用更新的算法，例如识别手部关键点，而不是预测手部网格的方式。</li><li>抓取姿态生成是直接使用拇指食指作为二指抓取姿态，是否可以考虑其他方式，提高抓取的可靠性。</li></ol><h1>2 Learning to Grasp Familiar Objects Based on Experience and Objects’ Shape Affordance</h1><blockquote><p><strong>标题</strong>：基于经验和物体形状的相似目标抓取<br><strong>作者团队</strong>：慕尼黑工业大学<br><strong>期刊会议</strong>：IEEE TRANSACTIONS ON SYSTEMS MAN CYBERNETICS-SYSTEMS<br><strong>时间</strong>：2019<br><strong>代码</strong>：</p></blockquote><h2 id="2-1-目标问题">2.1 目标问题</h2><h3 id="2-1-1-现存问题">2.1.1 现存问题</h3><p>对于已知物体的抓取方法，物体具有抓取数据库，机器人通过估计物体姿态，然后利用国旅行假设找到合适抓取姿态，但是这些方法的缺点是不可能将所有对象的模型都放入机器人的数据库。</p><p>需要一种从以前的经验推广到新对象的模型的能力。</p><h3 id="2-1-2-解决思路">2.1.2 解决思路</h3><p>整合人类抓握经验中的关键线索（拇指指尖和手腕的位置方向），提出了一种有效的抓握方法。</p><h2 id="2-2-方法">2.2 方法</h2><h3 id="2-2-1-从不完整点云上生成抓取点">2.2.1 从不完整点云上生成抓取点</h3><p>在抓取时，熟悉对象上的抓取点在对象上具有相似的相对位置。</p><p>基于这个原理，使用3D SHOT形状描述符描述物体，能够精确的描述兴趣点相对于整个对象和表面的位置。具体学习抓取点的过程如下：</p><ol><li>收集从部分点云中选择的兴趣点的SHOT特征、LR特征、RGB特征</li><li>通过计算简单的统计数据，如范围、均值、标准差、熵等，降低沿点维度的特征维度</li><li>将特征输入到用于对象分类的极限学习机中。</li></ol><h3 id="2-2-2-构建抓取模型">2.2.2 构建抓取模型</h3><p>没看懂。</p><p>大概是建立大拇指和物体之间的坐标变换关系，然后将其转换为三指夹爪与物体之间的坐标变换。</p><h3 id="2-2-3-腕关节约束估计">2.2.3 腕关节约束估计</h3><p>主要是解决受外在单一视角下点云被遮挡，无法精确确定手腕方向的问题。</p><h1>3 R3M: A Universal Visual Representation for Robot Manipulation</h1><blockquote><p><strong>标题</strong>：R3M:机器人操纵的通用视觉表示<br><strong>作者团队</strong>：斯坦福大学，Meta AI<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://tinyurl.com/robotr3m">https://tinyurl.com/robotr3m</a></p></blockquote><h2 id="3-1-目标问题">3.1 目标问题</h2><p>训练机器人根据图像完成操作任务。<strong>给定一段文字，例如“将铲子放到锅里”，机器人根据视觉执行相应的动作</strong>。</p><p><strong>（1）传统方法的局限性</strong></p><p>传统且广泛使用的方法是使用同构数据从头开始训练端到端的模型，但是由于训练数据难以获取，限制了这种方法的泛化。而我们还有没合适的机器人数据集，最近的数据集都是由少数不同环境有限任务组成，因此泛用性受到限制。</p><p><strong>（2）本文的突破思想</strong></p><p>参考<code>ImageNet</code>等通用有效的模型，机器人领域目前还没有类似的模型出现，但是思想可以借鉴，就是使用丰富的<code>in-the-wild data</code>（野生数据？），也就是使用人类与环境交互的视频，这些数据庞大且多样化，包含全球各种场景与任务。</p><p><strong>（3）本文方法简述</strong></p><p>训练了一种机器人操纵表示方法R3M。R3M能够学习具有挑战性的任务，例如将菜放入锅中，折叠毛巾等。</p><h2 id="3-2-方法">3.2 方法</h2><p>本文认为，机器人操作的良好表现由以下三个方面组成</p><ul><li>机器人应该捕获时间动态，因为机器人在环境中要按时间顺序完成任务</li><li>机器人应该捕获于一相关的特征</li><li>机器人应该是紧凑的</li></ul><p><strong>（1）时间对比学习</strong></p><p>训练编码器生成一个表示，是的时间上较近的图像之间的距离小于时间上较远的图像或来自不同视频的图像。</p><p><strong>（2）视频语言对齐</strong></p><p>捕获语言的特征，学习视频场景中的语义部分。</p><p><strong>（3）正则化</strong></p><p>降低状态空间的维度来保证克隆训练的策略符合专家状态分布。</p><h2 id="3-3-思考">3.3 思考</h2><p>与本人方向有差别，本文更偏向于语义，视觉只是作为一个感知手段。</p><h1>4 Adversarial Skill Networks: Unsupervised Robot Skill Learning from Video</h1><blockquote><p><strong>标题</strong>：对抗性技能网络：来自视频的无监督机器人技能学习<br><strong>作者团队</strong>：德国弗赖堡大学<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2019<br><strong>代码</strong>：<a href="http://robotskills.cs.uni-freiburg.de/">http://robotskills.cs.uni-freiburg.de/</a></p></blockquote><h2 id="4-1-目标任务">4.1 目标任务</h2><p>从未标记的多视角视频中学习机器人操作任务。</p><p><strong>（1）传统方法的局限性</strong></p><p>现有的强化学习方法尽管有一些进展，但是这些方法都是学习每项任务的解决方案，并且依赖于手动的、面向任务设置的奖励函数，所获得的策略也是针对于特定任务的，无法转移到新任务上。</p><p><strong>（2）本文的创新点</strong></p><p>提出一种无监督的技能学习方法，称为对抗性技能网络ASN，通过观看视频来发现和学习可转移的技能。学习到的技能被用于RL，以便通过组合以前的技能来解决更广泛的任务。</p><p>该方法不需要帧和任务ID的对应关系，不需要任何额外的监督。</p><h2 id="4-2-方法">4.2 方法</h2><p><strong>Adversarial Skill Networks对抗性技能网络</strong></p><p>我们在对抗性框架中学习技能度量空间。网络的编码部分试图最大化熵以增强通用性。鉴别器在测试时不使用，它试图最小化其预测的熵，以提高对技能的识别。最后，最大化所有技能的边际类熵会导致所有任务类的统一使用。请注意，不需要关于框架和它们所源自的任务之间关系的信息。<br>（没看懂）</p><h2 id="4-3-思考">4.3 思考</h2><p>似乎可以从无标签的视频中学习任务。但是过于理论化。</p><h1>5 BC-Z: Zero-Shot Task Generalization with Robotic Imitation Learning</h1><blockquote><p><strong>标题</strong>：BC-Z:利用机器人模仿学习实现零样本任务泛化<br><strong>作者团队</strong>：谷歌、加州大学伯克利分校、斯坦福<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://sites.google.com/view/bc-z/home">https://sites.google.com/view/bc-z/home</a></p></blockquote><h2 id="5-1-目标问题">5.1 目标问题</h2><p>使基于视觉的机器人操作系统能推广到新任务。</p><p>为此，开发了一个交互式模仿学习系统，可以传达人物的不同信息作为条件，包括自然语言或者人类演示视频，该系统可以从演示中进行学习。并且发现学习到100个任务之后，可以执行24个未训练的任务且不需要演示。</p><p><strong>（1）现存问题</strong></p><p>机器人技术的一大挑战就是创造一种能够在非结构化环境中基于任意的用户命令执行大量任务。这一工作的关键挑战是泛化。机器人必须要能处理新的环境，识别和操纵以前从未见过的物体，并且理解从未被要求执行过的命令的意图。</p><p>传统的方法是在像素级进行端到端的学习，然后由足够的真实世界的数据，这些方法原则上能够使机器人在新的任务、对象、场景中进行泛化。但实际上这一目标还是遥不可及。</p><p>本文要解决的问题就是通过零样本或者少样本推广基于视觉的机器人操纵任务的问题。</p><p><img src="https://img.mahaofei.com/img/202308151409631.png" alt="image.png"></p><h2 id="5-2-数据收集">5.2 数据收集</h2><p>为100个预先指定的任务手机了人类演示的视频，这些视频包含了推物体、拿取放置物体等9项基本任务。</p><p>搭建一套远程操作系统，远程操作设备通过USB连接到机器人上，通过两个手持控制器遥控操作站在机器人后面，使用控制器以第三人称视角操作机器人，机器人实时响应跟随操作员演示各种任务。</p><h2 id="5-3-方法">5.3 方法</h2><h3 id="5-3-1-语言和视频编码">5.3.1 语言和视频编码</h3><p>编码器以语言命令或人类视频作为输入，并生成任务。</p><ul><li>如果是语言命令，使用预训练的多语言语句编码器为每个任务生成512维语言向量</li><li>如果是视频，使用基于ResNet18的卷积网络</li></ul><h3 id="5-3-2-训练策略">5.3.2 训练策略</h3><p>给定固定的任务，我们通过XYZ和轴角预测的Huber损失和抓取器角度的对数损失来训练。</p><p>开环辅助检测，如果以开环的方式运行，将采取是个行动的开环轨迹。开环预测提供了一个辅助训练目标，并可以离线检查闭环规划质量。</p><p>将状态差异作为操作，标准的模仿学习会将演示动作直接作为目标标签，而本文的专家克隆行为会导致一些小动作或抖动，因此考虑将动作定义为未来目标和下一步的差异，使用自适应算法确定手臂和夹爪的移动量。</p><h3 id="5-3-3-网络架构">5.3.3 网络架构</h3><p>使用ResNet18作为主干，从主干最后一个平均池化层分出多个head，每个head是一个多层感知机，对末端执行器动作的一部分进行建模，具体见原文。</p><h2 id="5-3-思考">5.3 思考</h2><p>首先提供演示视频和文字，然后手动控制机器人执行任务收集数据。似乎仍然较为繁琐。</p><h1>VIP: Towards Universal Visual Reward and Representation via Value-Implicit Pre-Training</h1><blockquote><p><strong>标题</strong>：VIP：通过价值内隐预训练实现普遍的视觉奖励和表现<br><strong>作者团队</strong>：Meta AI，宾夕法尼亚大学<br><strong>期刊会议</strong>：ICLR<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://sites.google.com/view/vip-rl">https://sites.google.com/view/vip-rl</a></p></blockquote><h2 id="6-1-目标问题">6.1 目标问题</h2><p>特定任务的机器人数据的成本较高且稀缺。从大型、多样化的离线人类视频中学习已经成为获得普遍有效的途径。然而如何将这些<strong>人类视频</strong>用于通用的<strong>奖励学习</strong>仍然是一个未解决的问题。</p><p>与模拟环境中的机器人控制不同，真实世界中的机器人任务无法获得很好的环境状态信息或者定义良好的奖励函数。现有的方法学习每一项任务都需要大量的准备工作。相反，一个简单的方法来指定真实世界操作任务就是提供一个目标图像，图像捕捉环境所需要的视觉变化。然而现有的方法不能产生有效的奖励函数。</p><p>本文提出了一种隐含价值预训练方法（Value-Implicit Pre-training, VIP），一种自监督的预训练视觉表示，为机器人任务生成奖励函数。</p><p>本文的关键在于，将强化学习本身作为强化学习的预训练机制，但是由于人类视频中没有可以用于策略学习的动作信息，因此我们使用这种双价值函数，在没有动作的情况下以完全自我监督的方式进行预训练。</p><h2 id="6-2-方法">6.2 方法</h2><p><strong>（1）从人类视频中自我监督的价值学习</strong></p><p>虽然人类视频不是机器人域的数据，但是它们是学习人类行动的目标条件策略的领域中的数据。因此考虑使用离线人类视频进行学习的一个合理方法是在人类的策略空间上解决目标条件的强化学习问题，提取视觉表示（本文考虑使用 KL 方法进行离线强化学习）。</p><p>由于动作不出现在这个强化学习的目标中，并且所有数据都可以用离线数据集采样，因此可以通过适当选择奖励函数来对双价值函数进行自监督。</p><p><strong>（2）隐含的时间对比学习</strong></p><p>当有意义的指示任务的开始和结束的两个帧在嵌入空间中接近时，初始帧和目标帧之间能够捕获长程语义时间依赖性。</p><p><strong>（3）基于隐含价值的预训练</strong></p><p>具体算法见原文。</p><h2 id="6-3-代码实验">6.3 代码实验</h2><p>VIP 算法使用 ResNet50 作为视觉 backbone，并在 Ego4D 数据集上进行训练。</p><p>算法与 R3M 进行了比较</p><h2 id="6-3-思考">6.3 思考</h2><h1>7 Graph-Structured Visual Imitation</h1><blockquote><p><strong>标题</strong>：图形结构的视觉模仿<br><strong>作者团队</strong>：索尼<br><strong>期刊会议</strong>：CoRL<br><strong>时间</strong>：2019<br><strong>代码</strong>：无</p></blockquote><h2 id="7-1-目标问题">7.1 目标问题</h2><p>当机器人动作使工作空间中检测到的相应视觉实体的相对空间配置与演示更好的匹配时，会得到奖励。</p><p>本文使用人类手指关键点检测器、使用合成增强进行离线训练的对象检测器、由视点变化监督的点检测器。在没有人类注释数据或机器人交互的情况下为每次演示学习多个视觉实体检测器。</p><h2 id="7-2-方法">7.2 方法</h2><p><img src="https://img.mahaofei.com/img/202308151609226.png" alt="image.png"></p><p><strong>（1）检测视觉实体</strong></p><p>人手关键点检测：使用现有的手部检测器，并使用D435i获取3D位置。将机器人平行钳口夹持器映射到演示者的拇指和食指指尖。通过在两个指尖设置距离阈值来检测抓取和释放动作。</p><p>点特征检测器：训练后，在模仿者和演示者的环境中匹配点特征，建立对应关系。</p><p>合成数据扩充：使用背景移除来提取出2D掩模，并使用合成数据增强来训练视觉检测器。</p><p><strong>（2）动态图构造的运动显著性</strong></p><p><strong>（3）基于可视化实体图的策略学习</strong></p><p>目标是当机器人从单个人类演示中模仿物体操纵任务。具体的成本代价函数参考原文。</p><h2 id="7-3-思考">7.3 思考</h2><p>提取手部关键点映射到机器人夹爪，同时使用物体关键点检测来实现运动策略的生成。思路上不如DemoGrasp更直观。</p><p>可行的方法</p><ol><li>提取演示视频中物体位姿</li><li>模仿执行动作<ol><li>将当前视角下物体位姿与演示视频中每一帧位姿计算误差损失</li><li>根据误差实时计算末端位姿调整姿态</li><li>将当前帧手臂关键点加入，获取机械臂各关节应到的位姿</li><li>执行机械臂动作（期间加入机械臂避障与轨迹平滑）</li></ol></li></ol><h1>8 Learning by Watching: Physical Imitation of Manipulation Skills from Human Videos</h1><blockquote><p><strong>标题</strong>：通过观看学习：人体视频中操纵技能的物理模拟<br><strong>作者团队</strong>：多伦多大学<br><strong>期刊会议</strong>：IROS<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="http://www.pair.toronto.edu/lbw-kp/">http://www.pair.toronto.edu/lbw-kp/</a></p></blockquote><h2 id="8-1-目标问题">8.1 目标问题</h2><p>通过观看学习，通过模仿指定任务的单个视频来进行策略学习的算法框架。</p><ul><li>由于人类手臂与机器人手臂形态不同，我们的框架学习无监督的人-机器人的翻译来克服形态不匹配问题。</li><li>为了捕捉对学习状态至关重要的显著区域的细节，我们的模型采取了无监督关键点检测。检测到的关键点形成包含语义上有意义的信息的结构化表示，并可以直接用于计算奖励和策略学习。</li></ul><h2 id="8-2-方法">8.2 方法</h2><p>本文所提出的LbW框架由三个部分组成</p><ul><li>图像到图像的翻译网络：逐帧翻译输入的人类演示视频，生成机器人演示视频</li><li>关键点检测器：将生成的机器人演示视频作为输入，提取每帧的关键点，形成关键点轨迹</li><li>策略网络：将当前的基于关键点的观察表示传递给策略网络，用于预测与环境交互的动作</li></ul><p><img src="https://img.mahaofei.com/img/202308151841683.png" alt="image.png"></p><h2 id="8-3-思考">8.3 思考</h2><p>与其说是模仿学习网络，不如说是一个图像翻译网络，基于CycleGAN的图像翻译，将人手演示翻译成机器人动作视频，然后提取视频中机器人的关键点轨迹，通过策略函数实现实物机器人的动作。</p><h1>9 Learning Periodic Tasks from Human Demonstrations</h1><blockquote><p><strong>标题</strong>：从人类演示中学习周期性任务<br><strong>作者团队</strong>：卡内基梅隆大学<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><h2 id="9-1-目标问题">9.1 目标问题</h2><p>使用主动学习来优化参数，提出了一个目标最大限度的提高机器人操纵物体的运动与演示视频中物体运动之间的相似性。重点在于可变形物体和颗粒物体。（用布擦拭表面，缠绕电缆，用勺子搅拌颗粒物质等）</p><h2 id="9-2-方法">9.2 方法</h2><p>本文提出的框架由两部分组成</p><ul><li>表示学习模块：关键点检测模型从独立收集的非特定任务的人类和机器人数据中提取一致的关键点</li><li>姿态优化模块：将产生在检测的关键点方面与人类演示相匹配的机器人视频</li></ul><h2 id="9-3-思考">9.3 思考</h2><p>给定人类演示动作和手动操控机器人演示动作，机器人学习两者的相似性，然后重复演示动作使其更接近人类演示效果。</p><h1>10 One-Shot Hierarchical Imitation Learning of Compound Visuomotor Tasks</h1><blockquote><p><strong>标题</strong>：复合视觉运动任务的一次性层次模拟学习<br><strong>作者团队</strong>：加州大学伯克利分校<br><strong>期刊会议</strong>：arXiv<br><strong>时间</strong>：2018<br><strong>代码</strong>：<a href="https://sites.google.com/view/one-shot-hil">https://sites.google.com/view/one-shot-hil</a></p></blockquote><h2 id="10-1-目标问题">10.1 目标问题</h2><p>真实机器人上从人类执行任务的视频中学习多阶段任务。</p><h2 id="10-2-方法">10.2 方法</h2><p>对于每个子任务，我们提供多个人类演示和多个机器人演示（需要对象和执行的任务对应，但是不用相同的对象位置、执行速度）</p><p><strong>（1）基元的合成</strong>：训练了一个人类相位预测器和机器人相位预测器，从人类执行视频中学习特定的机器人策略</p><p><strong>（2）原始相位预测</strong>：学习如何分割复合任务的人类演示；何时学习策略过度到下一个。</p><h2 id="10-3-思考">10.3 思考</h2><p>提供人的演示视频，机器人的演示视频，然后训练策略。最后利用训练的策略，提供一段人类演示视频，机器人执行对应的操作。</p><h1>11 Third-Person Visual Imitation Learning via Decoupled Hierarchical Controller</h1><blockquote><p><strong>标题</strong>：基于解耦层次控制器的第三人称视觉模仿学习<br><strong>作者团队</strong>：MIT<br><strong>期刊会议</strong>：NeurIPS<br><strong>时间</strong>：2019<br><strong>代码</strong>：<a href="https://pathak22.github.io/hierarchical-imitation/">https://pathak22.github.io/hierarchical-imitation/</a></p></blockquote><h2 id="11-1-目标问题">11.1 目标问题</h2><p>通过从第三人称视角观看人类演示视频，可以在未知场景中操纵新物体。</p><h2 id="11-2-方法">11.2 方法</h2><p><img src="https://img.mahaofei.com/img/202308152040902.png" alt="image.png"></p><p><strong>（1）目标生成器</strong></p><p>从人类演示视频中推断像素空间中的目标，并以像素级的表示形式将其转化为机器人环境中的目标。</p><p>也是使用图像翻译的方法，将人类演示图像翻译为机器人演示图象。</p><p><strong>（2）反向控制器</strong></p><p>跟踪视觉目标推理模型中生成的线索，并生成机器人要执行的动作。</p><p>使用ResNet18模型。</p><p><strong>（3）第三人称模仿</strong></p><p>以交替方式运行目标生成器和反向控制器。目标生成器生成子目标，低级控制器生成机器人关节角度，直到人类演示结束。</p><h2 id="11-3-思考">11.3 思考</h2><p>还是使用图像翻译的思路，把人手操作图像翻译成机械臂操作图像，再由控制器生成机器人关节角度。</p><h1>12 You Only Demonstrate Once: Category-Level Manipulation from Single Visual Demonstration</h1><blockquote><p><strong>标题</strong>：Yodo：单一视觉演示的类别级操作<br><strong>作者团队</strong>：罗格斯大学<br><strong>期刊会议</strong>：RSS<br><strong>时间</strong>：2022<br><strong>代码</strong>：</p></blockquote><h2 id="12-1-目标问题">12.1 目标问题</h2><p>由于最近的跨对象类别级操作虽然有很好的结果，但通常需要昂贵的真实数据收集和为每个对象类别和任务手动指定语义关键点。并且粗略的关键点预测和忽略中间动作序列阻止了在抓取和防止之外的复杂任务的应用。</p><p>本工作提出了一种新的操作框架。该框架利用了无模型6D跟踪技术，解析单个演示视频中的类别级任务轨迹，整个执行过程被分解为远程、无碰撞运动和最后一英寸操作三个步骤。</p><h2 id="12-2-方法">12.2 方法</h2><p>对于每个演示视频帧，通过无模型6D位姿估计跟踪目标位姿，对象位姿在容器的坐标系中表示，这样允许泛化到新的场景。</p><p><strong>（1）类别级表示的离线学习</strong></p><p>建立了一个9D物体表示方法，6D位姿+3D缩放</p><p><strong>（2）无模型的物体6D跟踪</strong></p><p>物体运动跟踪要实现两个目的</p><ul><li>演示阶段，解析录制的视频，提取容器坐标系中被操纵的对象的6D运动轨迹</li><li>在线执行期间，为闭环控制器提供视觉反馈</li></ul><p><strong>（3）类别级行为克隆作为最后一步策略</strong></p><p>产生密集的离散轨迹，以便机器人能沿轨迹到达下一个目标</p><p><strong>（4）基于局部注意的动态类别级框架</strong></p><p>自动动态地规范坐标系原点。</p><p><strong>（5）抓取物体并使其沿关键点移动</strong></p><p>常规的抓取方法</p><h2 id="12-3-思考">12.3 思考</h2><p>将目标位姿表示为相对于另一个物体的相对位姿，这样有助于场景的泛化。</p><p>整体思想就是使用6D位姿估计获得目标的运动轨迹，然后重复这条轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 模仿动作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 抓取 </tag>
            
            <tag> 模仿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu截图与录屏工具</title>
      <link href="/post/9c4a6943.html"/>
      <url>/post/9c4a6943.html</url>
      
        <content type="html"><![CDATA[<h1>1 截屏软件：Shutter</h1><h2 id="1-1-介绍">1.1 介绍</h2><p><a href="http://shutter-project.org/">Shutter</a> 是一个对所有主流 Linux 发行版都适用的屏幕截图工具，功能十分强大，且近几年已知保持更新，功能稳定。</p><p>可以实现以下功能：</p><ul><li>截屏特定区域、整个桌面、整个框口、某个网站</li><li>倒计时截屏</li><li>截屏后标注（文本、箭头、举行、椭圆、马赛克、自动编号）</li></ul><h2 id="1-2-安装">1.2 安装</h2><p>添加软件库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:linuxuprising/shutter</span><br></pre></td></tr></table></figure><p>安装shutter与gnome-web-photo增强</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install shutter gnome-web-photo</span><br></pre></td></tr></table></figure><h2 id="1-3-使用">1.3 使用</h2><p>开始栏找到shutter，打开即可使用。</p><p><img src="https://img.mahaofei.com/img/202311261548285.png" alt="image.png"></p><p>设置快捷键：打开系统设置-Keyboard Shortcuts，添加自定义快捷键，设置如下</p><p><img src="https://img.mahaofei.com/img/202311261552664.png" alt="image.png"></p><p>设置完成后就可以直接【Ctrl + Alt + A】截屏了。</p><h1>2 录屏工具 Obs-Studio</h1><h2 id="2-1-介绍">2.1 介绍</h2><p>OBS Studio 是一款用于视频录制和直播的免费、轻量级开源软件。 它可用于捕获、录制、流式传输和编码视频内容。 它可以同时录制来自多个来源的视频，组合并将它们流式传输到流媒体平台。</p><p>简单来说，他可以把屏幕、摄像头等放在一个画面里进行录制，或者直播推流，这里我只用它来录屏。</p><h2 id="2-2-安装">2.2 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:obsproject/obs-studio</span><br><span class="line">sudo apt install obs-studio</span><br></pre></td></tr></table></figure><h2 id="2-3-使用">2.3 使用</h2><p><img src="https://img.mahaofei.com/img/202311261602791.png" alt="image.png"></p><p>通过Sources的小加号可以添加屏幕、摄像头等。</p><p>添加屏幕后，在obs主界面按住alt，拖动画面边框可以实现裁剪。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS系统Buglist（不定时更新）</title>
      <link href="/post/4add66b0.html"/>
      <url>/post/4add66b0.html</url>
      
        <content type="html"><![CDATA[<h1>一、安装问题</h1><h2 id="ROS安装时rosdep-init与rosdep-update问题解决方法">ROS安装时rosdep_init与rosdep_update问题解决方法</h2><p><strong>解决方法</strong></p><p>使用下面的命令替代上面两行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo pip3 install rosdepc</span><br><span class="line">sudo rosdepc init</span><br><span class="line">rosdepc update</span><br></pre></td></tr></table></figure><h1>二、环境问题</h1><h2 id="Unable-to-find-either-executable-‘empy’-or-Python-module-‘em’…-try-installing-the-package-‘python3-empy’">Unable to find either executable ‘empy’ or Python module ‘em’…  try  installing the package ‘python3-empy’</h2><p><strong>（1）问题原因</strong></p><p>Anaconda使用的是Python3版本，但是ROS使用的Python2</p><p><strong>（2）解决方法 1：不使用 conda 环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><strong>（3）解决方法 2：如果需要使用 conda 环境</strong></p><p>通过下面命令查看自己的 python 路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin/python*</span><br><span class="line">ls /usr/include/python*</span><br></pre></td></tr></table></figure><pre><code>在工作空间目录下，设置 python 路径，告诉 ros 使用 python3 进行编译。`</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make -DPYTHON_EXECUTABLE=/usr/bin/python3 -DPYTHON_INCLUDE_DIR=/usr/include/python3.7m</span><br></pre></td></tr></table></figure><h2 id="Could-not-find-a-package-configuration-file-provided-by-“某某包”-with-any-of-the-following-names">Could not find a package configuration file provided by “某某包” with any of  the following names</h2><p><strong>（1）问题原因</strong></p><p>缺少<code>某某包</code></p><p><strong>（2）解决方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-某某包</span><br></pre></td></tr></table></figure><h1>三、配置问题</h1><h2 id="ERROR-cannot-launch-node-of-type-robot-state-publisher-state-publisher-Cannot-locate-node-of-type-state-publisher-in-package-robot-state-publisher-Make-sure-file-exists-in-package-path-and-permission-is-set-to-executable-chmod-x）">ERROR: cannot launch node of type [robot_state_publisher/state_publisher]: Cannot locate node of type [state_publisher] in package [robot_state_publisher]. Make sure file exists in package path and permission is set to executable (chmod +x）</h2><p><strong>（1）问题原因</strong></p><p>使用launch文件启动某个节点时出现这个问题，是因为launch文件中name、pkg、type不统一导致的。</p><p><strong>（2）解决方法</strong></p><p>检查launch文件，确保name、pkg、type一样，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;robot_state_publisher&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="joint-state-publisher-gui没有显示">joint state publisher gui没有显示</h2><p><strong>（1）问题描述</strong></p><p>使用ROS进行仿真，想用joint state publisher进行机械臂控制，但是启动launch文件后没有报错信息，但也没有joint state publisher gui。</p><p><strong>（2）解决方法</strong></p><p>2020年开始，gui已经移出了 joint state publisher, 并且成为了一个新的package：joint state publisher gui. 之前那种使用gui参数的方式调用joint state publisher 是仍然可行的，但是不会调用gui。</p><p>在launch文件中，将joint state publisher 替换成joint__state__publisher_gui。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ros </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS Gazebo 6D机械臂抓取仿真实验</title>
      <link href="/post/7fec171b.html"/>
      <url>/post/7fec171b.html</url>
      
        <content type="html"><![CDATA[<h1>〇、基础知识</h1><h2 id="1-1-URDF">1.1 URDF</h2><p>URDF是ROS中机器人模型的描述格式，包括机器人的外观、物理属性、关节类型等方面。</p><ul><li><code>&lt;robot&gt;</code>：最顶层标签</li><li><code>&lt;link&gt;</code>：描述刚提的外观形状、碰撞几何、颜色、惯性矩阵等</li><li><code>&lt;joint&gt;</code>：描述两个link之间的关系，有6种类型，最常用的是<code>revolute</code>类型，有关节位置限制的旋转关节</li></ul><p>xacro模型可以将部分URDF打包成一个&quot;类&quot;，在其他模型中调用。</p><p>功能包中一般包括以下四个部分</p><ol><li><code>cfg</code>：配置文件</li><li><code>launch</code>：加载urdf模型，并在rviz中展示</li><li><code>meshes</code>：urdf用到的外观模型</li><li><code>urdf</code>：urdf模型定义</li></ol><h2 id="1-2-Moveit控制">1.2 Moveit控制</h2><p><strong>（1）Moveit!大致功能</strong></p><ul><li>运动学计算</li><li>运动规划</li><li>碰撞检测</li></ul><p>最重要的节点是<code>move_group</code>，输入可以是RVIZ中的数据或点云和深度图。路径规划一般使用的OMPL库，碰撞检测使用FCL库。最后发送个机械臂让机械臂执行轨迹。</p><h1>一、实验环境搭建</h1><h2 id="1-0-安装-ROS">1.0 安装 ROS</h2><p>参考<a href="https://www.mahaofei.com/post/b278544f.html">Ubuntu20.04安装ROS Noetic</a>文章</p><p>![[01-Ubuntu20.04安装ROS Noetic#二、安装ROS]]</p><h2 id="1-1-机器人Solidworks模型转URDF">1.1 机器人Solidworks模型转URDF</h2><p>本仿真实验使用<a href="https://www.hansrobot.com/service/download/3dmoxing?pagenum=3">大族E05机器人</a>和<a href="https://robotiq.com/products/2f85-140-adaptive-robot-gripper">Robotiq 2f-85夹爪</a></p><p>该部分参考<a href="https://www.bilibili.com/video/BV1Tx411o7rH">以下视频</a></p><iframe src="//player.bilibili.com/player.html?aid=56651666&bvid=BV1Tx411o7rH&cid=98972250&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="height:100%;width:100%; aspect-ratio: 16 / 9;"> </iframe><p>首先下载机器人模型，并转换为URDF。</p><p><strong>（1）安装sw_urdf_exporter插件</strong></p><p>下载sw_urdf_exporter插件：<a href="http://wiki.ros.org/sw_urdf_exporter">http://wiki.ros.org/sw_urdf_exporter</a>，注意下载最新的就行，最新的也支持以前版本的Solidworks。</p><p>关闭 Solidworks。</p><p>运行 <a href="https://github.com/ros/solidworks_urdf_exporter/releases">sw2urdfSetup.exe</a>，自行安装即可。</p><p><strong>（2）为机器人添加基准轴（旋转轴）</strong></p><p><img src="https://img.mahaofei.com/img/202312041343070.png" alt="image.png"></p><p>以此选择六个圆柱面，确定六个旋转轴方向。</p><p><img src="https://img.mahaofei.com/img/202312041401387.png" alt="image.png"></p><p><strong>（3）导出URDF</strong></p><p>查看是否有【工具-最下面File-Export as URDF】，如果有的话，直接点击打开，如果没有，则打开【工具-插件】，在最下面打开Sw2URDF插件的两个√。</p><p>按照以下过程，创建base_link和link1-6</p><p><img src="https://img.mahaofei.com/img/202312041434677.png" alt="image.png"></p><p>然后点击Preview and Export</p><p><img src="https://img.mahaofei.com/img/202312041439265.png" alt="image.png"></p><p>然后点击Next和Export URDF and Mesh，它会将我们的URDF模型以功能包的形式保存到设置的位置。</p><p><strong>注意创建完成后，一定要检查最后一个坐标系是否是在机器人末端连接法兰的中心，因为后续添加夹爪需要这个坐标系，如果不是，需要自己手动调整坐标系的位置，重新生成URDF</strong></p><h2 id="1-2-ROS中查看模型">1.2 ROS中查看模型</h2><p>创建一个工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p catkin_robot/src</span><br><span class="line">cd catkin_robot/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p>将功能包复制到<code>src</code>目录下</p><p>编译工作空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行测试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05 display.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312041606763.png" alt="image.png"></p><h2 id="1-3-添加-Robotiq-2f-85-夹爪">1.3 添加 Robotiq 2f-85 夹爪</h2><p><strong>（1）准备夹爪环境</strong></p><p>进入工作空间的src目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">git clone https://github.com/ros-industrial/robotiq.git</span><br></pre></td></tr></table></figure><p>在自己的机械臂的功能包的urdf文件夹中，新建一个<code>common.gazebo.xacro</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src/e05/urdf</span><br><span class="line">gedit common.gazebo.xacro</span><br></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;ros_control&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_control.so&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了方便表示，我在<code>e05.urdf</code>最后添加了一个<code>ee_link</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;ee_link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span> <span class="comment">&lt;!-- You can use any simple geometry like a sphere for visualization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- Choose a color for visualization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;ee_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link6&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;ee_link&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再新建一个<code>xacro</code>文件，（例如我的机械臂功能包名字为e05）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit e05.xacro</span><br></pre></td></tr></table></figure><p>添加如下内容，注意修改<code>Gazebo支持</code>和<code>E05机械臂</code>部分自己的机械臂功能包名称，以及<code>夹爪与机械臂连接</code>部分的第一行的parent，我这里连接在了link6也就是末端上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://www.ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;e05&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:arg</span> <span class="attr">name</span>=<span class="string">&quot;transmission_hw_interface&quot;</span> <span class="attr">default</span>=<span class="string">&quot;hardware_interface/PositionJointInterface&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- E05机械臂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find e05)/urdf/e05.urdf&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Gazebo 支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find e05)/urdf/common.gazebo.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载gazebo中需要使用的模型 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- macros for transmission --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;transmission_block&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;motor1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Transmissions for ros control --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:transmission_block</span> <span class="attr">joint_name</span>=<span class="string">&quot;joint6&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find e05)/urdf/e05.gazebo.xacro&quot; /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 机器人固定在世界坐标系下 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;world_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;world&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span> = <span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Robotiq 2F-85夹爪 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find robotiq_2f_85_gripper_visualization)/urdf/robotiq_arg2f_85_macro.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find robotiq_85_description)/urdf/robotiq_85_gripper.urdf.xacro&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_grasp_fix&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_grasp_fix.so&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arm</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;arm_name&gt;应该是一个单独的名字，不能和别的任何关节同名 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arm_name</span>&gt;</span>ur5_gripper<span class="tag">&lt;/<span class="name">arm_name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;palm_link&gt;是和手指相连的关节 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">palm_link</span>&gt;</span>link6<span class="tag">&lt;/<span class="name">palm_link</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- &lt;gripper_link&gt;是会检测碰撞的关节 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_finger_tip_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_finger_tip_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger1_inner_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">gripper_link</span>&gt;</span>gripper_finger2_inner_knuckle_link<span class="tag">&lt;/<span class="name">gripper_link</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">arm</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">forces_angle_tolerance</span>&gt;</span>150<span class="tag">&lt;/<span class="name">forces_angle_tolerance</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 检测频率 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">update_rate</span>&gt;</span>130<span class="tag">&lt;/<span class="name">update_rate</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 检测为抓取状态的接触次数阈值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">grip_count_threshold</span>&gt;</span>2<span class="tag">&lt;/<span class="name">grip_count_threshold</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">max_grip_count</span>&gt;</span>8<span class="tag">&lt;/<span class="name">max_grip_count</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 释放时的容忍度，超过这个就会把物体放下。数值越大，需要把夹爪打开更大才能释放物体 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">release_tolerance</span>&gt;</span>0.005<span class="tag">&lt;/<span class="name">release_tolerance</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">disable_collisions_on_attach</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disable_collisions_on_attach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">contact_topic</span>&gt;</span>__default_topic__<span class="tag">&lt;/<span class="name">contact_topic</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将夹爪实例化，并设置夹爪和机械臂的关系（连接在tool0上） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:robotiq_85_gripper</span> <span class="attr">prefix</span>=<span class="string">&quot;&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;ee_link&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 $&#123;-pi/2&#125; 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:robotiq_85_gripper</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 相机实例化，然后设置仿真位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;xacro:include filename=&quot;$(find realsense_ros_gazebo)/xacro/depthcam.xacro&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;xacro:realsense_d435 sensor_name=&quot;d435&quot; parent_link=&quot;tool0&quot; rate=&quot;10&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;origin rpy=&quot;0 $&#123;-pi/2&#125; 0 &quot; xyz=&quot;-0.1 0 0&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/xacro:realsense_d435&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改原来的launch文件，这里我为了后续方便，将原来的<code>display.launch</code>重命名了<code>display_e05_with_gripper.launch</code>，这里主要修改<code>&lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro '$(find e05)/urdf/e05.xacro'&quot; /&gt;  </code>这一行，添加刚刚创建的xacro文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find e05)/urdf/e05.xacro&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro &#x27;$(find e05)/urdf/e05.xacro&#x27;&quot;</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find e05)/urdf.rviz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）Rviz中查看机器人</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_motion</span><br><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05 display_e05_with_gripper.launch</span><br></pre></td></tr></table></figure><p>左下角Add，添加机器人模型RobotModel。</p><p>左侧Fixed Frame选择base_link，即可看到机器人了。</p><p><img src="https://img.mahaofei.com/img/202312051357909.png" alt="image.png"></p><p><strong>（3）Gazebo中查看机器人</strong></p><p>创建一个<code>gazebo_e05_with_gripper.launch</code>文件，内容参考如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span> <span class="attr">doc</span>=<span class="string">&quot;Starts gazebo gui&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span> <span class="attr">doc</span>=<span class="string">&quot;Starts gazebo in paused mode&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 启动仿真环境 后续有环境修改，可以替换此处的worlds/empty.world，改为例如&quot;$(find ur_gazebo)/worlds/table_custom.world&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.world&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载TF --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;tf_footprint_base&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0 base_link base_footprint 40&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 启动机器人 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find e05)/launch/display_e05_with_gripper.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将 robot_description 发送到 gazebo 中生成机器人 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;node name=&quot;spawn_model&quot; pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; args=&quot;-file $(find e05)/urdf/e05.urdf -urdf -model e05&quot; output=&quot;screen&quot; /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;spawn_gazebo_model&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -param robot_description -model robot -z 0&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;fake_joint_calibration&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rostopic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rostopic&quot;</span> <span class="attr">args</span>=<span class="string">&quot;pub /calibrated std_msgs/Bool true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时启动<code>launch</code>文件，可以看到gazebo环境中机器人。</p><p><img src="https://img.mahaofei.com/img/202312051949512.png" alt="image.png"></p><h2 id="1-4-创建MoveIt驱动">1.4 创建MoveIt驱动</h2><p>此部分参考<a href="https://blog.csdn.net/Tepmoe/article/details/119533792">该文章</a>。</p><p>安装<code>moveit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-moveit</span><br><span class="line">sudo apt install ros-noetic-object-recognition-msgs ros-noetic-soem* ros-noetic-socketcan-* </span><br><span class="line">sudo apt install ros-noetic-moveit*</span><br></pre></td></tr></table></figure><p>启动moveit设置助手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun moveit_setup_assistant moveit_setup_assistant</span><br></pre></td></tr></table></figure><p>选择Create New Moveit Configuration Package，选择自己的<code>e05.xacro</code>文件，点击<code>Load Files</code></p><p><img src="https://img.mahaofei.com/img/202312051459862.png" alt="image.png"></p><p>左侧第二个的<code>Self-Collisions</code>是检查碰撞，一定将所有有可能发生碰撞的都勾选上，不然后续会出错。</p><p><img src="https://img.mahaofei.com/img/202312051948359.png" alt="image.png"></p><p>第三个<code>Virtual Joints</code>一般也不需要。</p><p>第四个<code>Planning Groups</code>是最重要的，我们需要设置，点击<code>Add Group</code>，分别配置机器人和末端夹爪。</p><p>机械臂：</p><ul><li>Group Name一般填manipulator就行</li><li>运动学求解器，选择kdl</li><li>路径规划算法，默认选择RRT Star就行</li><li>点击<code>Add Kin. Chain</code>，Baselink选择 base_link，Tiplink选择ee_link</li></ul><p><img src="https://img.mahaofei.com/img/202312051507765.png" alt="image.png"></p><p>末端夹爪的Group Name填上gripper，其它的都不用选。</p><p>第五个<code>Robot Poses</code>可以添加一些常用位置，便于我们快速使机器人运动到这些位置，例如</p><ul><li>up：机器人初始的竖直向上</li><li>pick：机器人准备夹取</li><li>open：夹爪打开</li><li>close：夹爪关闭</li></ul><p><img src="https://img.mahaofei.com/img/202312051513180.png" alt="image.png"></p><p>第六个<code>End Effectors</code>，按下图设置就行</p><p><img src="https://img.mahaofei.com/img/202312051533929.png" alt="image.png"></p><p>点击<code>Controllers</code>，点击左上角自动生成</p><p><img src="https://img.mahaofei.com/img/202312051534681.png" alt="image.png"></p><p>点击倒数第二个<code>Author Information</code>，填写名字和邮箱，不一定是真实的，但是不填无法生成功能包</p><p>最后<code>Generate Package</code>就可以了（在src目录下新建一个<code>e05_moveit</code>文件夹，选择此文件夹生成）</p><p>测试rviz是否能控制机器人</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash</span><br><span class="line">roslaunch e05_moveit demo.launch</span><br></pre></td></tr></table></figure><p>测试gazebo是否能联动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch e05_moveit demo_gazebo.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312052212812.png" alt="image.png"></p><p>测试时遇到了<strong>Rviz中的机械臂可以正常做规划和执行，但是Gazebo中机械臂没有反应</strong>的问题，解决方法参考<a href="https://blog.csdn.net/qq_50598558/article/details/114702163">此文章</a></p><h1>二、实验环境搭建</h1><blockquote><p>以下为之前使用的 UR5 + Robotiq 2f-85 测试</p></blockquote><h2 id="2-1-安装UR机器人及驱动">2.1 安装UR机器人及驱动</h2><p>复制代码后，修改下面的内容，使其能在noetic版本的ros上运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/catkin_ws/src/universal_robot/ur_msgs/srv/SetPayload.srv</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float32 payload</span><br><span class="line">geometry_msgs/Vector3 center_of_gravity</span><br><span class="line">-----------------------</span><br><span class="line">bool success</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/catkin_ws/src/universal_robot/ur_msgs/CMakeLists.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8.3)</span><br><span class="line">project(ur_msgs)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Find catkin macros and libraries</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># is used, also find other catkin packages</span></span></span><br><span class="line">find_package(catkin REQUIRED COMPONENTS message_generation std_msgs geometry_msgs)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate messages in the &#x27;msg&#x27; folder</span></span></span><br><span class="line">add_message_files(</span><br><span class="line">   FILES</span><br><span class="line">   Analog.msg</span><br><span class="line">   Digital.msg</span><br><span class="line">   IOStates.msg</span><br><span class="line">   RobotStateRTMsg.msg</span><br><span class="line">   MasterboardDataMsg.msg</span><br><span class="line">   RobotModeDataMsg.msg</span><br><span class="line">   ToolDataMsg.msg</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate services in the &#x27;srv&#x27; folder</span></span></span><br><span class="line">add_service_files(</span><br><span class="line">   FILES</span><br><span class="line">   SetPayload.srv</span><br><span class="line">   SetSpeedSliderFraction.srv</span><br><span class="line">   SetIO.srv</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Generate added messages and services with any dependencies listed here</span></span></span><br><span class="line">generate_messages(</span><br><span class="line">   DEPENDENCIES</span><br><span class="line">   std_msgs</span><br><span class="line">   geometry_msgs</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># catkin specific configuration ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##################################</span></span></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> INCLUDE_DIRS include</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> LIBRARIES ur_msgs</span></span><br><span class="line">   CATKIN_DEPENDS message_runtime std_msgs geometry_msgs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Build ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Install ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Testing ##</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/catkin_ws/src/universal_robot/ur_msgs/package.xml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;package format=&quot;2&quot;&gt;</span><br><span class="line">  &lt;name&gt;ur_msgs&lt;/name&gt;</span><br><span class="line">  &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">  &lt;description&gt;The ur_msgs package&lt;/description&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;author&gt;Andrew Glusiec&lt;/author&gt;</span><br><span class="line">  &lt;author&gt;Felix Messmer&lt;/author&gt;</span><br><span class="line">  &lt;maintainer email=&quot;g.a.vanderhoorn@tudelft.nl&quot;&gt;G.A. vd. Hoorn&lt;/maintainer&gt;</span><br><span class="line">  &lt;maintainer email=&quot;miguel.prada@tecnalia.com&quot;&gt;Miguel Prada Sarasola&lt;/maintainer&gt;</span><br><span class="line">  &lt;maintainer email=&quot;nhg@ipa.fhg.de&quot;&gt;Nadia Hammoudeh Garcia&lt;/maintainer&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;license&gt;BSD&lt;/license&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line">  &lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">  &lt;depend&gt;std_msgs&lt;/depend&gt;</span><br><span class="line">  &lt;depend&gt;geometry_msgs&lt;/depend&gt;</span><br><span class="line">  &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br><span class="line"></span><br><span class="line">  &lt;export&gt;</span><br><span class="line">  &lt;/export&gt;</span><br><span class="line">&lt;/package&gt;</span><br></pre></td></tr></table></figure><p>完成之后，就可以编译了。<code>source</code>之后使用<code>roslaunch ur5_moveit_config demo.launch</code></p><h2 id="2-2-简单测试">2.2 简单测试</h2><p><strong>（1）Rviz打开UR5模型</strong></p><p>机械臂夹爪模型路径为<code>universal_robot/urdf/ur5_gripper_joint_limited_robot.urdf.xacro</code>。</p><p>可以通过<code>universal_robot/ur_description/launch/view_ur5_with_gripper.launch</code>启动，从Rviz中查看模型情况，并使用<code>joint_state_publisher_gui</code>对机械臂模型拖动控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无夹爪</span></span><br><span class="line">roslaunch ur_description view_ur5.launch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有夹爪</span></span><br><span class="line">roslaunch ur_description view_ur5_with_gripper.launch</span><br></pre></td></tr></table></figure><p><strong>（2）Rviz中Moveit测试</strong></p><p>使用下面的程序可以在 Rviz 中进行 Moveit 轨迹规划测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无夹爪</span></span><br><span class="line">roslaunch ur5_moveit_config demo.launch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有夹爪</span></span><br><span class="line">roslaunch ur5_gripper_moveit_config demo.launch</span><br></pre></td></tr></table></figure><p><strong>（3）Gazebo中Moveit测试</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">无夹爪</span></span><br><span class="line">roslaunch ur_gazebo ur5.launch</span><br><span class="line">roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch sim:=true</span><br><span class="line">roslaunch ur5_moveit_config moveit_rviz.launch config:=true</span><br></pre></td></tr></table></figure><p><code>ur5.launch</code>：用于启动 gazebo 仿真环境。具体包括以下几个部分，启动空环境、定义 robot_description 参数服务器、发送到gazebo中生成机器人、启动并加载控制器。</p><p><code>ur5_moveit_planning_execution.launch</code>：用于启动 MoveIt 相关组件。具体包括以下几个部分：设置 sim参数， 根据 sim 参数重映射 follow_joint_trajectory 话题，启动MoveIt。</p><p><code>moveit_rviz.launch</code>：用于启动 Rviz 相关组件。具体包括以下几个部分：加载配置参数，启动Rviz。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有夹爪</span></span><br><span class="line">roslaunch ur_gazebo ur5_with_gripper.launch</span><br><span class="line">roslaunch ur5_single_arm_moveit_config ur5_moveit_planning_execution.launch</span><br><span class="line">roslaunch ur5_gripper_moveit_config moveit_rviz.launch config:=true</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202308041008966.png" alt=""></p><h2 id="2-3-导入自定义物体">2.3 导入自定义物体</h2><p><strong>（1）网络方法</strong></p><p>使用 MeshLab 加载自己的物体模型。</p><p>点击【Filters -&gt; Normals … -&gt; Compute normals for points sets】，按照默认设置确定即可。</p><p>点击【Filters -&gt; Remeshing -&gt; Surface Reconstruction: Screened Poisson】，按照默认设置确定即可。</p><p>点击【Filters -&gt; Texture -&gt; Parametrization: Trivial Per-Triangle】，按照如下设置，重要的是Method。</p><p><img src="https://img.mahaofei.com/img/202305242228283.png" alt="image.png"></p><p>点击【Filters -&gt; Texture -&gt; Transfer Vertex Attributes to Textur(1 or 2 meshes)】，按照如下设置，重要的是Source Mesh和Target Mesh。</p><p><img src="https://img.mahaofei.com/img/202305242231021.png" alt="image.png"></p><p><strong>（2）摸索方法</strong></p><p>点击【Filters -&gt; Texture -&gt; Parametrization: Flat Plane】</p><p>点击【Filters -&gt; Texture -&gt; Transfer Vertex Attributes to Textur(1 or 2 meshes)】</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 机器人抓取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 实验 </tag>
            
            <tag> 抓取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【目标检测算法】YOLOV8代码复现</title>
      <link href="/post/16b5f6b3.html"/>
      <url>/post/16b5f6b3.html</url>
      
        <content type="html"><![CDATA[<h1>一、算法笔记</h1><h1>二、代码复现</h1><h2 id="2-1-搭建环境">2.1 搭建环境</h2><p>创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov8 python=3.7</span><br><span class="line">conda activate yolov8</span><br></pre></td></tr></table></figure><p>安装PyTorch1.8.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><p>下载作者开源的程序，并安装其他依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/ultralytics</span><br><span class="line">cd ultralytics</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="2-2-命令行使用教程">2.2 命令行使用教程</h2><p><strong>（1）语法规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yolo TASK MODE ARGS</span><br><span class="line"></span><br><span class="line">Where   TASK (optional) is one of [detect, segment, classify]</span><br><span class="line">        MODE (required) is one of [train, val, predict, export, track]</span><br><span class="line">        ARGS (optional) are any number of custom &#x27;arg=value&#x27; pairs like &#x27;imgsz=320&#x27; that override defaults.</span><br></pre></td></tr></table></figure><p><strong>（2）训练</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolo train data=coco128.yaml model=yolov8n.pt epochs=10 lr0=0.01</span><br></pre></td></tr></table></figure><p><strong>（3）预测</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolo predict model=yolov8n-seg.pt source=&#x27;https://youtu.be/Zgi9g1ksQHc&#x27; imgsz=320</span><br></pre></td></tr></table></figure><p><strong>（4）评价</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolo val model=yolov8n.pt data=coco128.yaml batch=1 imgsz=640</span><br></pre></td></tr></table></figure><h2 id="2-3-Python使用教程">2.3 Python使用教程</h2><p><strong>（1）训练</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line">model = YOLO(<span class="string">&#x27;yolov8n.pt&#x27;</span>) <span class="comment"># 从预训练模型开始</span></span><br><span class="line">model.train(epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）评价</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line">model = YOLO(<span class="string">&quot;model.pt&quot;</span>)</span><br><span class="line">model.val()  <span class="comment"># 使用model.pt的data yaml进行评价</span></span><br><span class="line">model.val(data=<span class="string">&#x27;coco128.yaml&#x27;</span>)  <span class="comment"># 或指定数据进行评价</span></span><br></pre></td></tr></table></figure><p><strong>（3）预测</strong></p><p>获取预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">model = YOLO(<span class="string">&quot;model.pt&quot;</span>)</span><br><span class="line"><span class="comment"># 接受所有类型 - image/dir/Path/URL/video/PIL/ndarray. 0 for webcam</span></span><br><span class="line"><span class="comment"># 从摄像头</span></span><br><span class="line">results = model.predict(source=<span class="string">&quot;0&quot;</span>)</span><br><span class="line"><span class="comment"># 从文件夹</span></span><br><span class="line">results = model.predict(source=<span class="string">&quot;folder&quot;</span>, show=<span class="literal">True</span>) <span class="comment"># Display preds. Accepts all YOLO predict arguments</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从PIL图像</span></span><br><span class="line">im1 = Image.<span class="built_in">open</span>(<span class="string">&quot;bus.jpg&quot;</span>)</span><br><span class="line">results = model.predict(source=im1, save=<span class="literal">True</span>)  <span class="comment"># save plotted images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从ndarray</span></span><br><span class="line">im2 = cv2.imread(<span class="string">&quot;bus.jpg&quot;</span>)</span><br><span class="line">results = model.predict(source=im2, save=<span class="literal">True</span>, save_txt=<span class="literal">True</span>)  <span class="comment"># save predictions as labels</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从PIL/ndarray的列表</span></span><br><span class="line">results = model.predict(source=[im1, im2])</span><br></pre></td></tr></table></figure><p>预测结果分析（results会包含预测所有结果的列表，当有很多图像的时候要注意避免内存溢出，特别是在实例分割时）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. return as a list</span></span><br><span class="line">results = model.predict(source=<span class="string">&quot;folder&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.  return as a generator (stream=True)</span></span><br><span class="line">results = model.predict(source=<span class="number">0</span>, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    <span class="comment"># Detection</span></span><br><span class="line">    result.boxes.xyxy   <span class="comment"># box with xyxy format, (N, 4)</span></span><br><span class="line">    result.boxes.xywh   <span class="comment"># box with xywh format, (N, 4)</span></span><br><span class="line">    result.boxes.xyxyn  <span class="comment"># box with xyxy format but normalized, (N, 4)</span></span><br><span class="line">    result.boxes.xywhn  <span class="comment"># box with xywh format but normalized, (N, 4)</span></span><br><span class="line">    result.boxes.conf   <span class="comment"># confidence score, (N, 1)</span></span><br><span class="line">    result.boxes.cls    <span class="comment"># cls, (N, 1)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Segmentation</span></span><br><span class="line">    result.masks.data      <span class="comment"># masks, (N, H, W)</span></span><br><span class="line">    result.masks.xy        <span class="comment"># x,y segments (pixels), List[segment] * N</span></span><br><span class="line">    result.masks.xyn       <span class="comment"># x,y segments (normalized), List[segment] * N</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Classification</span></span><br><span class="line">    result.probs     <span class="comment"># cls prob, (num_class, )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Each result is composed of torch.Tensor by default, </span></span><br><span class="line"><span class="comment"># in which you can easily use following functionality:</span></span><br><span class="line">result = result.cuda()</span><br><span class="line">result = result.cpu()</span><br><span class="line">result = result.to(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">result = result.numpy()</span><br></pre></td></tr></table></figure><h2 id="2-3-数据集制作（实例分割）">2.3 数据集制作（实例分割）</h2><p><strong>（1）使用Labelme创建实例分割数据集</strong></p><p>安装labelme</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme</span><br></pre></td></tr></table></figure><p>安装完成后直接在命令行输入<code>labelme</code>即可打开。</p><p>使用label进行标注，将生成的json文件和原始图像jpg，放入同一个文件夹中。</p><p><strong>（2）Labelme格式转COCO格式</strong></p><p>参考<a href="https://pypi.org/project/labelme2coco/">pypi的labelme2coco包</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme2coco</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用清华源</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple labelme2coco</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelme2coco path/to/labelme/dir --train_split_rate 0.85</span><br></pre></td></tr></table></figure><p><strong>（3）COCO格式转YOLO格式</strong></p><p>使用<code>labelme</code>制作实例分割的coco格式数据集，然后使用<a href="https://github.com/ultralytics/JSON2YOLO">ultralytics/JSON2YOLO</a>项目将json文件转换成yolo的训练格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/JSON2YOLO.git</span><br><span class="line">cd JSON2YOLO</span><br></pre></td></tr></table></figure><p>创建一个虚拟环境，然后使用下面的命令安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>修改<code>general_json2yolo.py</code>的第387行，设置为刚才得到的COCO注释的位置，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> source == <span class="string">&#x27;COCO&#x27;</span>:</span><br><span class="line">convert_coco_json(<span class="string">&#x27;datasets/20230223_Phone_4Obj_Coco/annotations&#x27;</span>,  <span class="comment"># directory with *.json</span></span><br><span class="line">  use_segments=<span class="literal">True</span>,</span><br><span class="line">  cls91to80=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>修改<code>general_json2yolo.py</code>的第289行，因为不是coco80中的物体类型，是自己设置的，因此需要修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cls = coco80[ann[&#x27;category_id&#x27;] - 1] if cls91to80 else ann[&#x27;category_id&#x27;] - 1  # class</span></span><br><span class="line">cls = ann[<span class="string">&#x27;category_id&#x27;</span>]  <span class="comment"># class</span></span><br></pre></td></tr></table></figure><p>运行程序将COCO格式json文件转换为YOLO格式txt。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python general_json2yolo.py</span><br></pre></td></tr></table></figure><p>结果保存在new_dir中，需要手动把images复制过去。最后得到的数据集如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data_root</span><br><span class="line">├── images</span><br><span class="line">├── train2017</span><br><span class="line">├── youimagename.jpg</span><br><span class="line">└── ...</span><br><span class="line">    └── val2017</span><br><span class="line">├── youimagename.jpg</span><br><span class="line">└── ...</span><br><span class="line">└── labels</span><br><span class="line">├── train2017</span><br><span class="line">├── youimagename.txt</span><br><span class="line">└── ...</span><br><span class="line">    └── val2017</span><br><span class="line">├── youimagename.txt</span><br><span class="line">└── ...</span><br></pre></td></tr></table></figure><p><strong>（4）创建数据集的YAML文件</strong></p><p>打开目录<code>ultralytics/datasets</code>，复制一份其中的<code>coco128-seg.yaml</code>，重命名为<code>custom-seg.yaml</code>，然后根据自己的数据集进行修改。</p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Train/val/test sets as 1) dir: path/to/imgs, 2) file: path/to/imgs.txt, or 3) list: [path/to/imgs1, path/to/imgs2, ..]</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/media/mahaofei/OneTouch/Dataset/Program_data/image_processing/ultralytics/20230223_Phone_4Obj_YOLO</span>  <span class="comment"># dataset root dir</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train2017</span>  <span class="comment"># train images (relative to &#x27;path&#x27;) 128 images</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/train2017</span>  <span class="comment"># val images (relative to &#x27;path&#x27;) 128 images</span></span><br><span class="line"><span class="attr">test:</span>  <span class="comment"># test images (optional)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Classes</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line">  <span class="attr">0:</span> <span class="string">ammeter</span></span><br><span class="line">  <span class="attr">1:</span> <span class="string">coffeebox</span></span><br><span class="line">  <span class="attr">2:</span> <span class="string">realsensebox</span></span><br><span class="line">  <span class="attr">3:</span> <span class="string">sucker</span></span><br></pre></td></tr></table></figure><h2 id="2-4-开始训练">2.4 开始训练</h2><p>新建一个python文件如<code>train.py</code>，添加内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load a model</span></span><br><span class="line"><span class="comment"># model = YOLO(&#x27;yolov8n-seg.yaml&#x27;)  # build a new model from YAML</span></span><br><span class="line">model = YOLO(<span class="string">&#x27;yolov8n-seg.pt&#x27;</span>)  <span class="comment"># load a pretrained model (recommended for training)</span></span><br><span class="line"><span class="comment"># model = YOLO(&#x27;yolov8n-seg.yaml&#x27;).load(&#x27;yolov8n.pt&#x27;)  # build from YAML and transfer weights</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Train the model</span></span><br><span class="line">model.train(data=<span class="string">&#x27;custom-seg.yaml&#x27;</span>, epochs=<span class="number">100</span>, imgsz=<span class="number">3904</span>, batch=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="2-5-结果预测">2.5 结果预测</h2>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【抓取姿态估计算法】RGB Matters论文笔记与复现</title>
      <link href="/post/a1b0a01b.html"/>
      <url>/post/a1b0a01b.html</url>
      
        <content type="html"><![CDATA[<h1>一、论文笔记</h1><p><strong>RGB Matters: Learning 7-DoF Grasp Poses on Monocular RGBD Images</strong></p><blockquote><p><strong>标题</strong>：RGB Matters：单RGBD图像学习学习7D抓取姿态<br><strong>作者团队</strong>：上海交通大学（卢策吾）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/GouMinghao/RGB_Matters">https://github.com/GouMinghao/RGB_Matters</a></p></blockquote><h2 id="1-1-目标问题-3">1.1 目标问题</h2><p>现有方法要么生成自由度很少的抓取姿态，要么只将不稳定的深度点云输入。</p><h2 id="1-2-方法-2">1.2 方法</h2><p>大致流程为：</p><ol><li>使用Angle View Net网络生成图像不同位置的抓取器方向 $P_{img}=(u,v,r_x,r_y,r_z,c)$，即图像中坐标的位置，其对应的夹爪旋转姿态，以及置信度。</li><li>对置信度高的预测，结合深度图计算距离和夹爪宽度$P_{cam}=x,y,z,rx,ry,rz,w$</li></ol><p><strong>（0）定义</strong></p><p>抓握姿势定义为 (x, y, z, rx, ry, rz, w)，其中(x, y, z)代表夹持器的位置，(rx, ry, rz)代表夹持器的旋转，w代表夹持器的宽度。</p><p>夹持器本文仅考虑平行夹爪，使用 (h, l, wmax) 定义，三个参数分别代表夹具的 高度、长度和最大宽度。</p><p><img src="https://img.mahaofei.com/img/202304241634347.png" alt=""></p><p><strong>（1）Angle-View Net</strong></p><p>预测像素级的夹持器旋转配置。直接回归四元数不太现实，而且不鲁棒（因为同一个位置进行抓取有不止一个可行的旋转）。</p><p>可以使用下面的模型，将方向解耦为接近方向和绕平面的旋转，将夹持器旋转预测作为一个分类问题进行预测，共有VxA类方向。</p><p><img src="https://img.mahaofei.com/img/202304231549478.png" alt=""></p><p>网络通过将RGB图像栅格化，对于每一个网格，AVN预测一个1维VxA个元素的向量，包含每个方向的置信度。最终得到(VxA)xGHxGW的tensor。AVN最终的输出表示为每个角度的heatmap。</p><p>作者在代码中给出的是V=60,A=6的测试。</p><p><strong>（2）快速分析搜索</strong></p><p>AVN识别了7个自由度的其中五个，但是夹持器的宽度和夹持器沿轴方向的自由度还没有确定。</p><p>本文提出了基于碰撞和空抓取检测的快速分析搜索来计算宽度和距离。</p><p>通过对从0到Wmax采样，假设抓取器靠近由深度图重建的点云的对应点。过滤掉夹持器占用的空间中存在点、抓取空间没有点的两种情况。</p><p><img src="https://img.mahaofei.com/img/202304231549054.png" alt=""></p><h2 id="1-3-思考-2">1.3 思考</h2><p>本文使用了尽可能简单的思路解决抓取预测问题</p><p>将末端夹持器的旋转方向通过分类器进行回归计算。</p><p>将夹持器位置和宽度通过采样测试逐一排除得到最优解。</p><p>思路直观简单，可以尝试。</p><h1>二、复现过程</h1><h2 id="2-1-环境搭建-2">2.1 环境搭建</h2><p>创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n rgb_matters python=3.7</span><br><span class="line">conda activate rgb_matters</span><br></pre></td></tr></table></figure><p>下载程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/GouMinghao/rgb_matters</span><br><span class="line">cd rgb_matters</span><br></pre></td></tr></table></figure><p>安装PyTorch1.8.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="2-2-测试Demo">2.2 测试Demo</h2><p>下载作者训练好的模型：<a href="https://drive.google.com/drive/folders/1upW4gvQk5ftXfpLHtvCogudpP4kNyoGq?usp=sharing">Google Drive</a></p><p>在代码目录创建一个<code>weights</code>的目录，然后将下载的模型放入其中，完成后文件夹结构如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rgbd_graspnet/</span><br><span class="line">├── check_label_integrity.py</span><br><span class="line">├── train.py</span><br><span class="line">├── train.sh</span><br><span class="line">├── vis_label.py</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">└── weights</span><br><span class="line">    ├── kn_jitter_79200.pth</span><br><span class="line">    ├── kn_no_norm_76800.pth</span><br><span class="line">    ├── kn_norm_63200.pth</span><br><span class="line">    ├── kn_norm_only_73600.pth</span><br><span class="line">    └── rs_norm_56400.pth</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20230424162408.png" alt=""></p><h1>三、代码分析</h1><h2 id="3-1-输出结果分析">3.1 输出结果分析</h2><p><strong>（1）热力图获取</strong></p><p>使用下面的代码进行预测热力图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net = RGBNormalNet(num_layers=args.num_layers, use_normal=args.use_normal, normal_only=args.normal_only)</span><br><span class="line">state_dict = torch.load(weights_path)</span><br><span class="line">net.load_state_dict(state_dict[&quot;net&quot;], strict=False)</span><br><span class="line">net = net.to(device)</span><br><span class="line">net.eval()</span><br><span class="line"></span><br><span class="line">rgb, _ = load_data(rgb_path, depth_path)</span><br><span class="line"></span><br><span class="line">rgb = rgb.unsqueeze(0).to(device)</span><br><span class="line"></span><br><span class="line">prob_map = net(rgb)</span><br></pre></td></tr></table></figure><p>其中的<code>prob_mat</code>是预测的热力图<code>shape=(batch_size, 360, h, w)</code>一共360张热力图（360张包括接近方向v=60和平面内旋转A=6）</p><p><strong>（2）夹爪姿态获取</strong></p><p>使用<code>convert_grasp()</code>函数从360张热力图中提取夹爪姿态。</p><p>夹爪姿态为<code>Grasp</code>实例，包括以下几个参数：</p><ul><li><code>score</code>：float类型，抓取得分</li><li><code>width</code>：float类型，夹爪宽度</li><li><code>height</code>：float类型，夹爪高度</li><li><code>depth</code>：float类型，夹爪深度</li><li><code>rotation_matrix</code>：shape(3, 3)数组，旋转矩阵</li><li><code>translation</code>：shape(3)数组，平移向量</li><li><code>object_id</code>：int类型，抓取物体类别</li></ul><p>具体参考下面两张图：</p><p><img src="https://img.mahaofei.com/img/202305142107952.png" alt="image.png"></p><p><img src="https://img.mahaofei.com/img/202304241634347.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 机器人抓取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 抓取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓取姿态估计算法调研</title>
      <link href="/post/791dd0f5.html"/>
      <url>/post/791dd0f5.html</url>
      
        <content type="html"><![CDATA[<h1>Hybrid Physical Metric For 6-DoF Grasp Pose Detection</h1><blockquote><p><strong>标题</strong>：用于6D抓取检测的混合物理度量<br><strong>作者团队</strong>：清华大学（王生进）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/luyh20/FGC-GraspNet">https://github.com/luyh20/FGC-GraspNet</a></p></blockquote><h2 id="一、目标问题">一、目标问题</h2><p>单个物理指标会导致离散的抓取置信度分数，在百万抓取数据训练时会导致预测结果不准确。</p><p>本文定义了一种新的度量方式，基于力封闭度量、物体平面度、重力和碰撞测量。</p><p>本文设计了平面重力碰撞FGC-GraspNet，适用于多任务多分辨率学习体系。</p><h2 id="二、混合物理度量">二、混合物理度量</h2><p><img src="https://img.mahaofei.com/img/202304231518654.png" alt="image.png"></p><p><strong>（1）平面度</strong></p><p>平面度越高的抓的越稳。利用点的局部法向量的相似性计算平坦度得分。</p><p><strong>（2）重心度量</strong></p><p>夹持力更接近物体重心的更稳定。计算物体重心到两个接触点的连线的距离作为重力得分。</p><p><strong>（3）碰撞扰动度量</strong></p><p>当夹爪接近物体时容易发生碰撞，因此取夹爪两个最大行程端点与物体接触点的欧氏距离最小值作为碰撞扰动得分。</p><p><strong>（4）混合物理度量</strong></p><p>混合物理度量是上面度量的加权组合。</p><h2 id="三、-FGC-GraspNet">三、 FGC-GraspNet</h2><p>通过最远点采样FPS得到20000x3对点云输入，网络由PointNet++，FA分支、RD分支组成。</p><p><img src="https://img.mahaofei.com/img/202304231530817.png" alt=""></p><ul><li>PointNEt++用于提取点特征</li><li>低分辨率的特征进入FA分支进行前景分割和逐点逼近方向得分回归</li><li>高分辨率的特征用于RD旋转分支。</li></ul><h2 id="四、思考">四、思考</h2><p>将混合物理度量纳入LOSS的计算过程确实有意义。而且具有一定的复用性，其它算法也可借鉴此设计。</p><h1>Volumetric Grasping Network: Real-time 6 DOF Grasp Detection in Clutter</h1><blockquote><p><strong>标题</strong>：基于体素的抓取网络：杂乱场景中实时6D抓取检测<br><strong>作者团队</strong>：ETH Zurich（苏黎世联邦理工学院）<br><strong>期刊会议</strong>：CoRL2020<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/ethz-asl/vgn">https://github.com/ethz-asl/vgn</a></p></blockquote><h2 id="一、目标问题-2">一、目标问题</h2><p>本文提出了一种网络从深度相机中获得场景信息，预测6D抓取的网络。</p><h2 id="二、论文方法">二、论文方法</h2><p><strong>（1）网络架构</strong></p><p>由滤波器、卷积层组成的感知模块将输入体素映射为特征图，然后进行卷积、上采样操作，最后是三个独立的分支用于预测抓取质量、旋转和夹爪宽度。</p><p><strong>（2）抓取检测</strong></p><p>使用一些方法去除不可能的抓取姿势，然后应用非极大抑制来获得候选的抓取列表。</p><h2 id="三、思考">三、思考</h2><p>非常基础的方法，已经有人在此基础上进行了扩展并发表了顶会。</p><h1>Efficient Learning of Goal-Oriented Push-Grasping Synergy in Clutter</h1><blockquote><p><strong>标题</strong>：杂乱场景中面向目标的的推/抓协同有效学习<br><strong>作者团队</strong>：浙江大学（熊蓉）<br><strong>期刊会议</strong>：RAL<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/xukechun/Efficient_goal-oriented_push-grasping_synergy">https://github.com/xukechun/Efficient_goal-oriented_push-grasping_synergy</a></p></blockquote><h2 id="一、目标问题-3">一、目标问题</h2><p>在混乱场景中抓取物体时，有时需要一些预抓取动作，例如推动。使机械臂能够分离目标对象并稳定的实现抓取。</p><h2 id="二、方法">二、方法</h2><p><img src="https://img.mahaofei.com/img/202304231536100.png" alt=""></p><p>环境准备：固定的RGBD相机拍摄工作空间，将RGBD投影到重力方向，使用颜色高度图和深度高度图表示每个状态。</p><p><strong>（1）有目标的抓取训练</strong></p><p>训练一个有目标条件下的抓取网络，当有足够的训练之后，成功抓取的Q值稳定。</p><p><strong>（2）有目标的推动训练</strong></p><p>训练一个有目标条件下的推动网络，推动的奖励函数是基于抓取网络反向训练设计的。</p><p><strong>（3）交替训练</strong></p><p>利用交替训练来解决物体分布不匹配的问题，进一步提高混乱环境中抓取策略性能。</p><h2 id="三、思考-2">三、思考</h2><p>推物体再抓取物体相当于一个两阶段方法，可以不用在底层进行训练，而是在高层的规划决策层来进行判断，发布任务是推物体还是抓物体。</p><h1>TransGrasp: Grasp Pose Estimation ofaCategory ofObjects byTransferring Grasps fromOnlyOne Labeled Instance</h1><blockquote><p><strong>标题</strong>：杂乱场景中面向目标的的推/抓协同有效学习<br><strong>作者团队</strong>：大连理工大学（孙怡）<br><strong>期刊会议</strong>：ECCV<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/yanjh97/TransGrasp">https://github.com/yanjh97/TransGrasp</a></p></blockquote><h2 id="一、目标问题-4">一、目标问题</h2><p>现有大多数方法需要大量的抓取数据来训练，为了解决这个问题，本文实现只标记一个对象预测一类对象的抓取姿态。</p><h2 id="二、方法-2">二、方法</h2><p><strong>（1）学习类别的对应关系</strong></p><ol><li>Shape Encoder和DIFDecoder组成神经网络，训练得到对象变形到模板的密集对应关系</li></ol><p><strong>（2）抓取姿态估计</strong></p><ol><li>点云首先从相机坐标系转换到对象坐标系</li><li>生成对象实例的变形到模板</li><li>将带有抓取注释的模型输入到DeformNet中获得模型的变形</li><li>由两者的共同模板见你对应关系，通过对准物体表面上的抓握点来引导抓握姿势的变换</li><li>通过refine模块进行优化</li><li>将优化后的抓握知识转换为相机坐标进行抓取</li></ol><h2 id="三、思考-3">三、思考</h2><p>这种算法只能实现与模板形状相似的物体进行抓取，而且每个类别要先手工标记1000个抓握姿势。</p><h1>Contact-GraspNet: Efficient 6-DoF Grasp Generation in Cluttered Scenes</h1><blockquote><p><strong>标题</strong>：ContactGraspNet：在杂乱场景中高效生成6-DoF抓取<br><strong>作者团队</strong>：NVIDIA<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/NVlabs/contact_graspnet">https://github.com/NVlabs/contact_graspnet</a></p></blockquote><h2 id="1-目标问题">1 目标问题</h2><p>提出了一种端到端的网络，从图像的深度数据中生成6D抓取分布。</p><h2 id="2-方法">2 方法</h2><p>使用原始的深度图，以及（可选使用对象掩码），生成6D抓取建议以及抓取宽度。</p><p><strong>（1）抓取表示方法</strong></p><p>可以发现，大多是可以预测的两手指抓取，在抓取前至少可以看到两个接触点的一个。因此可以将抓取问题简化为估计平行板抓取器的3D抓取旋转和抓取宽度。</p><p><img src="https://img.mahaofei.com/img/202304231545643.png" alt=""></p><p>其中a是接近向量，b是抓取基线向量，d是从抓取基线到抓取基座的距离。使用这种表示方法可以加速学习过程，提高预测精度，且没有歧义和间断区域。</p><p><strong>（2）数据生成</strong></p><p>使用了ACRONYM数据集。在场景中以随机稳定的姿态放置具有密集抓取注释的对象网格。其中会导致夹爪与模型碰撞的抓取姿态将被删除。</p><p><strong>（3）网络</strong></p><p>使用PointNet++中提出的集合概要和特征传播层来构建非对称的U形网络。</p><p>网络有四个检测头，每个检测头包括两个1D卷积层，每个点输出s∈R，z1∈R3，z2∈R3、o∈R10，从中我们形成了我们的抓取表示。</p><p>将抓取的宽度划分为10个等距的抓取宽度，来抵消数据不平衡问题，然后选择置信度最高的抓取宽度表示。由于接近方向和基线方向是正交的，通过进行正交归一化预测，将这一性质加入到训练过程，有助于3D旋转的回归。</p><p><img src="https://img.mahaofei.com/img/202304231546650.png" alt=""></p><h2 id="3-思考">3 思考</h2><p>在数据集中预先定义好了抓取姿态，然后进行监督训练。使用时根据深度图首先确定物体所在区域，然后利用其点云预测抓取分布。</p><p>自定义物体的数据集不易制作。</p><h1>RGB Matters: Learning 7-DoF Grasp Poses on Monocular RGBD Images</h1><blockquote><p><strong>标题</strong>：RGB Matters：单RGBD图像学习学习7D抓取姿态<br><strong>作者团队</strong>：上海交通大学（卢策吾）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/GouMinghao/RGB_Matters">https://github.com/GouMinghao/RGB_Matters</a></p></blockquote><h2 id="一、目标问题-5">一、目标问题</h2><p>现有方法要么生成自由度很少的抓取姿态，要么只将不稳定的深度点云输入。</p><h2 id="二、方法-3">二、方法</h2><p><strong>（1）Angle-View Net</strong></p><p>预测像素级的夹持器旋转配置。直接回归四元数不太现实，而且不鲁棒。可以使用下面的模型，将夹持器旋转预测作为一个分类问题进行预测。</p><p><img src="https://img.mahaofei.com/img/202304231549478.png" alt=""></p><p>AVN最终的输出表示为角视图热图。</p><p><strong>（2）快速分析搜索</strong></p><p>AVN识别了7个自由度的其中五个，但是夹持器的宽度和夹持器沿轴方向的自由度还没有确定。</p><p>本文提出了基于碰撞和空抓取检测的快速分析搜索来计算宽度和距离。</p><p>通过对从0到Wmax采样，假设抓取器靠近由深度图重建的点云的对应点。过滤掉夹持器占用的空间中存在点、抓取空间没有点的两种情况。</p><p><img src="https://img.mahaofei.com/img/202304231549054.png" alt=""></p><h2 id="三、思考-4">三、思考</h2><p>本文使用了尽可能简单的思路解决抓取预测问题</p><p>将末端夹持器的旋转方向通过分类器进行回归计算。</p><p>将夹持器位置和宽度通过采样测试逐一排除得到最优解。</p><p>思路直观简单，可以尝试。</p><h1>CaTGrasp: Learning Category-Level Task-Relevant Grasping in Clutter from Simulation</h1><blockquote><p><strong>标题</strong>：CaTGrasp：从仿真中学习杂乱场景的类别级抓取<br><strong>作者团队</strong>：Rutgers University（美国罗格斯大学）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/wenbowen123/catgrasp">https://github.com/wenbowen123/catgrasp</a></p></blockquote><h2 id="一、目标问题-6">一、目标问题</h2><p>提出了一个框架学习工业对象的抓取，不需要真实的数据或手动注释</p><h2 id="二、方法-4">二、方法</h2><p>给定同一类别的3D模型的数据库，该方法学习</p><ul><li>以对象为中心的NUNOCS表示</li><li>hotmap：抓握过程中手-对象接触区域的任务实现成功的可能性</li><li>抓取姿势的编码本</li></ul><p><strong>（1）类别级标准NUNOCS表示</strong></p><p>将同一个类别的不同实例对象转换到标准空间，并缩放为标准大小。</p><p><strong>（2）稳定抓取学习</strong></p><p>首先给定从当前实例到规范模型的9D变换，将相同的变换应用于抓取来得到抓取建议。</p><p>将生成的抓取用于训练基于PointNet构建的网络，预测抓取质量。</p><p><strong>（3）实例分割</strong></p><p>使用了3D U-Net，将整个场景的点云作为输入，预测每点偏移到物体中心，将偏移点聚类为实例段。</p><p><strong>（4）仿真中生成训练数据</strong></p><p>利用PyBullet模拟生成合成数据。</p><h2 id="三、思考-5">三、思考</h2><p>该方法提出了一种使用仿真数据进行训练，减少人工标注的方法。抓取的方法没有太多创新，仍然需要每个类别提供多个预先的实例以及抓取姿态用于训练。</p><h1>Closed-Loop Next-Best-View Planning for Target-Driven Grasping</h1><blockquote><p><strong>标题</strong>：闭环次优视图规划用于目标驱动的抓取<br><strong>作者团队</strong>：ETH Zurich（苏黎世联邦理工学院）<br><strong>期刊会议</strong>：IROS<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/ethz-asl/active_grasp">https://github.com/ethz-asl/active_grasp</a></p></blockquote><h2 id="一、目标问题-7">一、目标问题</h2><p>从密集遮挡环境中抓取物体</p><h2 id="二、方法-5">二、方法</h2><p>该方法具有以下前提条件</p><ul><li>机械臂末端连接深度相机</li><li>相机光学中心和手抓中心已经校准</li><li>已知物体的部分视图和3D边界框</li></ul><p><img src="https://img.mahaofei.com/img/202304231603042.png" alt=""></p><p>首先将点云观测yt和相机姿态xt继承，重建为体素图。计算体素的可抓取性，以及可能的抓取姿态。如果可抓取性不满足要求，就调整机械臂位置计算下一张图</p><p><strong>（1）抓取检测</strong></p><p>使用体积抓取网络VGN进行抓取。该网络将体素网格M映射到抓握质量分数Q、平行抓握方向R、开口宽度W。</p><p>过滤掉指尖不在目标边界框的抓取姿态、无法找到反向运动学解的抓取姿态。</p><p><strong>（2）次优视图规划器</strong></p><p><strong>世界表示</strong>：使用TSDF（截断有符号距离函数）表示大小为 l 的立方体体素。</p><p><strong>视图生成</strong>：将候选视图生成在目标边界上半球内。</p><p><strong>信息增益</strong>：TSDF 重建的完整性对于抓取的检测和预测准确性有很大影响。因此使用了后侧体素 IG 公式的变体，对被遮挡具有负距离的体素使用光线投影来计算隐藏对象体素的数量。</p><ol><li>在策略更新的最大数量中加入时间预算</li><li>如果抓取分数低于给定的阈值，就会停止算法，因为获取不到有用信息</li><li>如果VGN在几帧内保持稳定的抓取配置，就停止</li></ol><h2 id="三、思考-6">三、思考</h2><p>该方法是在位姿估计的基础上进行的抓取预测，可以将该方法与Gen6D结合起来，获得物体的6D抓取位姿。</p><h1>Edge Grasp Network: A Graph-Based SE(3)-invariant Approach to Grasp Detection</h1><blockquote><p><strong>标题</strong>：边缘抓取网络：一种基于图的SE(3)不变的抓取检测方法<br><strong>作者团队</strong>：Northeastern University（美国东北大学）<br><strong>期刊会议</strong>：ICRA<br><strong>时间</strong>：2023<br><strong>代码</strong>：<a href="https://github.com/HaojHuang/Edge-Grasp-Network">https://github.com/HaojHuang/Edge-Grasp-Network</a></p></blockquote><h2 id="一、目标问题-8">一、目标问题</h2><p>以单个视角观察到的点云为输入，得到一组抓取姿态</p><h2 id="二、方法-6">二、方法</h2><p><strong>（1）裁剪点云</strong></p><p>给定一个点云p和接近点pa，只有接近点pa的相邻点会影响抓取，因此以pa为中心裁剪一个球。</p><p><strong>（2）PointNet卷积</strong></p><p>使用PointNet计算接近点与最近邻点，每个点的特征。</p><p><strong>（3）计算全局特征</strong></p><p>将逐点特征传递给MLP，用最大池化层生成一级全局特征。这些全局特征再与点特征相连传递到第二个MLP计算全局特征。</p><p>对于每个抓取，通过将全局特征与点特征连接来计算边缘特征，用分类器表示边缘抓取。</p><p><strong>（4）抓取评估</strong></p><p>使用sigmoid函数的四层MLP来预测抓取成功率，以边缘特征为输入计算抓取是否成功。</p><h2 id="三、思考-7">三、思考</h2><p>该方法类似于DenseFusion的思想，即提取逐点特征和全局特征，进行特征融合，本文得到的融合特征即边缘特征，利用该特征再使用分类器得到抓取位姿。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 机器人抓取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 抓取姿态估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVPR2022高被引论文笔记</title>
      <link href="/post/6ec34466.html"/>
      <url>/post/6ec34466.html</url>
      
        <content type="html"><![CDATA[<h1>一、目标检测</h1><h2 id="1-1-视频目标检测">1.1 视频目标检测</h2><h3 id="Video-Swin-Transformer">Video Swin Transformer</h3><blockquote><p><strong>标题</strong>：视频 Swin Transformer<br><strong>作者团队</strong>：Microsoft Research Asia<br><strong>期刊会议</strong>：CVPR<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/CompVis/latent-diffusion">https://github.com/CompVis/latent-diffusion</a></p></blockquote><p><strong>（1）目标问题</strong></p><p>现今大多数的视觉识别模型都是基于Transformer建立的，本文在此基础上进行调整，得到更好的速度和精度。</p><p><strong>（2）方法</strong></p><ol><li>总体架构</li></ol><p>视频定义为TxHxWx3，patch为2x4x4x3的块，每个patch有96个特征维度。该架构的主要组件是Video Swin Transformer模块，通过将标准的Transformer的Multihead self-attention(MSA)模块替换为基于3D Shift Window的MSA模块，来实现。</p><p><img src="https://img.mahaofei.com/img/202305071021361.png" alt="image.png"></p><ol start="2"><li>3D MSA模块</li></ol><p>由于视频有时间维度，全局自注意模块会导致巨大的计算和内存成本。MSA模块就比传统的全局自注意模块要高效。</p><p>更进一步，基于Swin Transformer的2D移位窗口扩展到3D，实现了跨窗口链接，保证了体系结构的表达能力。</p><p><img src="https://img.mahaofei.com/img/202305071033856.png" alt="image.png"></p><h1>二、图像分割</h1><h1>三、图像处理</h1><h2 id="3-1-图像合成">3.1 图像合成</h2><h3 id="High-Resolution-Image-Synthesis-with-Latent-Diffusion-Models">High-Resolution Image Synthesis with Latent Diffusion Models</h3><blockquote><p><strong>标题</strong>：具有潜在扩散模型的高分辨率图像合成<br><strong>作者团队</strong>：海德堡大学；Runway ML<br><strong>期刊会议</strong>：CVPR<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/CompVis/latent-diffusion">https://github.com/CompVis/latent-diffusion</a></p></blockquote><p><strong>（1）目标问题</strong></p><p>扩散模型已经在包括图像数据在内的很多数据上，实现了很好的数据合成效果。但这些模型由于直接操作像素，需要昂贵的GPU资源。</p><p>本文提出的潜在扩散模型，达到了降低复杂性和保留细节的平衡点。</p><p><strong>（2）方法</strong></p><p>主要方法是：使用自动编码模型，学习一个在感知上与图像空间等效的空间，压缩学习阶段和生成学习阶段来减少资源需求。</p><ol><li>感知压缩模型<br>利用了结合perceptual loss, patch-based, adversarial objective的自动编码器。</li><li>潜在扩散模型<br>扩散模型是概率模型，通过逐渐对正态分布变量去噪来学习数据分布。<br>通过由自动编码器得到的高效、低维的空间，与高维像素空间相比更适合生成模型。</li><li>调节机制<br>通过使用交叉注意力机制增强基础网络UNet，能够处理各种模态的输入。</li></ol><p><strong>（3）思考</strong></p><p>将需要高运算量的像素操作，通过自动编码转换为了低维空间的操作，节省了计算量。</p><h1>四、三维视觉</h1><h1>五、位姿估计</h1><h1>六、机器人</h1><h1>七、神经网络</h1><h2 id="7-1-神经网络结构设计">7.1 神经网络结构设计</h2><h3 id="A-ConvNet-for-the-2020s">A ConvNet for the 2020s</h3><blockquote><p><strong>标题</strong>：2020s的ConvNet<br><strong>作者团队</strong>：Facebook AI<br><strong>期刊会议</strong>：CVPR<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/facebookresearch/ConvNeXt">https://github.com/facebookresearch/ConvNeXt</a></p></blockquote><p><strong>（1）目标问题</strong></p><p>20年以来，由于Vision Transformers的引入，它开始快速取代卷积神经网络。但只使用Transformers也有些问题，因此后来又出现了hierarchical Transformers，其中加入了几个卷积神经网络作为先验。但这些方法都可以归结为Transformers的优势。</p><p>本文想要探讨纯卷积神经网络所能实现的极限。</p><p><strong>（2）最佳方法</strong></p><ol><li><strong>训练技术</strong>：使用AdamW优化器、数据增强、随机擦除、正则化等方法可以显著提高训练模型的性能</li><li><strong>宏观设计</strong>：<ul><li>阶段比例：ResNet中各阶段的比例很大程度是经验获得的，SwinTransformer的比例是1:1:3:1，传统的ResNet比例是(3,4,6,3)，此处调整为(3,3,9,3)与SwinT相同，发现也提高了模型准确率</li><li>模块设计：标准的ResNet模块包括一个7x7步长2的卷积层，然后是一个最大池化层。此处模仿SwinT，设计为4x4步长为4的卷积层作为基础模块。</li></ul></li><li><strong>使用分组卷积技术</strong>，可以有效提高网络性能</li><li><strong>反向瓶颈</strong>：使MLP的隐藏维度比输入维度宽4倍，这在几个ConvNet中以及Transformer中设计思路相同。</li><li><strong>更大的卷积核</strong>：尽管堆叠小卷积核可以有效利用硬件，但测试证明，总体上大卷积核能够提高模型性能</li><li><strong>微观设计</strong>：<ul><li>更少的归一化层</li><li>使用层归一化LN代替批归一化BatchNorm</li><li>分离下采样层：ResNet中，下采样是通过每个阶段开始的残差块实现的，在层和层之间加入单独的下采样层发现可以提高准确率</li></ul></li></ol><p><strong>（3）总结</strong></p><ol><li>尽可能丰富数据，增大随机化程度：使用AdamW优化器、数据增强、随机擦除、正则化等方法</li><li>使用更优化的网络结构：调整各阶段卷积比例、使用反向瓶颈设计、更少的归一化层、更大的卷积核、在每个阶段之间加入下采样层。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CVPR </tag>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用Git管理项目代码</title>
      <link href="/post/dd16f220.html"/>
      <url>/post/dd16f220.html</url>
      
        <content type="html"><![CDATA[<h1>一、注册Github并创建仓库</h1><p>这一步不细说了，需要科学上网，参考<a href="https://www.mahaofei.com/post/96c83ac9.html">这篇文章</a>，[[03_科学上网方法（如何访问Google, ChatGPT）|Google学术访问方法]]。</p><h1>二、下载Git并配置</h1><h2 id="2-1-Git安装">2.1 Git安装</h2><p>下载安装<a href="https://link.zhihu.com/?target=http%3A//git-scm.com/downloads">Git</a>。</p><p>在资源管理器内右键，选择 <code>Git bash here</code> 打开 Git 界面。</p><h2 id="2-2-Git配置">2.2 Git配置</h2><p>输入下面的代码，按下回车，生成ssh密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>出现要求设置密码，可以不用设置，连续回车两次就可以。</p><p>打开<code>C:\Users\用户名\.ssh</code>，可以看到有一个<code>id_rsa.pub</code>文件，这就是刚才生成的密钥。</p><p>使用记事本打开此文件，复制里面的密钥内容。</p><h2 id="2-3-Github添加ssh-key">2.3 Github添加ssh key</h2><p>进入<a href="https://github.com/">Github官网</a>，点击右上角【setting --&gt; SSH and GPG keys --&gt; New SSH key】，在这里添加密钥，其中</p><ul><li>Title：自己写一个ssh key的名字，用于区分多个ssh key</li><li>Key：刚刚复制的密钥<br>填写完成后点击Add SSH key添加。</li></ul><p>然后在git bash中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果连接成功，会让你输入<code>yes/no</code>，输入yes即可。</p><h2 id="2-4-配置用户名和邮箱">2.4 配置用户名和邮箱</h2><p>输入下面的代码配置自己的用户名和邮箱，两个信息都要和Github账号的信息一致</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><h1>三、代码管理</h1><h2 id="3-1-代码上传">3.1 代码上传</h2><p><strong>（1）初始化</strong></p><p>创建一个文件夹，在这个文件夹内，右键<code>git bash here</code>，然后输入<code>git init</code>完成初始化。</p><p>可以看到目录中出现了一个<code>.git</code>隐藏文件夹，这说明已经完成了初始化。</p><p><strong>（2）链接远程仓库</strong></p><p>在刚刚的<code>git bash</code>窗口，输入下面的命令同步到远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p>如果出现fatal: remote origin already exists.可按以下步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@github.com:用户名/仓库名.git</span><br><span class="line">git pull git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p><strong>（3）上传本地文件</strong></p><p>添加本地文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add.</span><br></pre></td></tr></table></figure><p>提交本地文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;说明信息，一般说明本次提交更新了什么&quot;</span><br></pre></td></tr></table></figure><p>推送到远端仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push git@github.com:用户名/仓库名.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="3-2-拉取代码">3.2 拉取代码</h2><p>从项目中拉取代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>如果出现<code>fatal: refusing to merge unrelated histories</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h2 id="3-3-分支管理">3.3 分支管理</h2><p><strong>（1）查看分支</strong></p><p>在命令行窗口的光标处，输入git branch命令，查看 Git 仓库的分支情况。分支前有*表示是当前所在的分支。</p><p><strong>（2）创建分支</strong></p><p>使用下面的命令创建一个名为a的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch a</span><br></pre></td></tr></table></figure><p><strong>（3）分支切换</strong></p><p>在命令行窗口的光标处，输入git checkout a命令，切换到a分支。</p><p><strong>（4）合并分支</strong></p><p>切换到master分支，然后输入git merge a命令，将a分支合并到master分支。</p><p><strong>（5）删除分支</strong></p><p>在命令行窗口的光标处，输入git branch -d a命令，删除a分支。</p><p><strong>（6）为分支添加标签</strong></p><p>在命令行窗口的光标处，输入git tag test_tag命令，为当前分支添加标签test_tag</p><h2 id="3-4-修改分支名称">3.4 修改分支名称</h2><p>假设分支名称为oldName，想要修改为 newName</p><ol><li>本地分支重命名(还没有推送到远程)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><ol start="2"><li>远程分支重命名 (已经推送远程-假设本地分支和远程对应分支名称相同)</li></ol><p>重命名远程分支对应的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m oldName newName</span><br></pre></td></tr></table></figure><p>到github修改默认分支的分支名。</p><p>上传新命名的本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin newName</span><br></pre></td></tr></table></figure><p>把修改后的本地分支与远程分支关联</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to origin/newName</span><br></pre></td></tr></table></figure><p>注意：如果本地分支已经关联了远程分支，需要先解除原先的关联关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --unset-upstream </span><br></pre></td></tr></table></figure><h2 id="3-5-报错信息">3.5 报错信息</h2><p><strong>（1）error: src refspec master does not match any. error: failed to push some refs to</strong></p><p>仔细检查push的是<code>master</code>分支还是<code>main</code>分支。</p><h1>附：Github Profile 美化</h1><blockquote><p>参考链接:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/416759197">知乎: Github Profile Readme美化效果汇总</a></li><li><a href="https://github.com/rzashakeri/beautify-github-profile">Github: beautify-github-profile</a></li></ol></blockquote><p><strong>（1）准备工作</strong></p><p>需要新建一个和 Github 用户名相同的仓库，新建时下面会有绿框提示。</p><p>注意设置为Public并添加Readme。</p><p><strong>（2）打字特效</strong></p><p>打字特效生成网站：<a href="https://readme-typing-svg.herokuapp.com/demo/">Readme Typing SVG - Demo Site</a></p><p>然后把生成的代码粘贴进去 Readme</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://readme-typing-svg.herokuapp.com?font=Monospace&amp;pause=1000&amp;color=000000&amp;random=false&amp;width=435&amp;lines=Haofei+Ma+-+Infinite+Advancing&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Typing SVG&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://readme-typing-svg.herokuapp.com?font=Monospace&amp;pause=1000&amp;color=000000&amp;random=false&amp;width=435&amp;lines=Haofei+Ma+-+Infinite+Advancing" alt=""></p><p><strong>（3）Github Badge</strong></p><p>网站：<a href="https://shields.io/">https://shields.io/</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=&quot;center&quot;&gt;</span><br><span class="line"></span><br><span class="line">[![](https://img.shields.io/badge/dynamic/json?url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dgithub%26queryKey%3DHaofeiMa&amp;query=%24.data.totalSubs&amp;suffix=%20followers&amp;logo=github&amp;label=Github&amp;color=black)](https://github.com/HaofeiMa)</span><br><span class="line"></span><br><span class="line">[![](https://img.shields.io/badge/dynamic/xml?url=https%3A%2F%2Fblog.csdn.net%2Fweixin_44543463&amp;query=%2F%2Fli%5B3%5D%2Fdiv%2Fspan%5B1%5D%2Ftext()%5B1%5D&amp;suffix=%20stars&amp;logo=csdn&amp;label=CSDN&amp;color=red)](https://blog.csdn.net/weixin_44543463)</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img.shields.io/badge/dynamic/json?url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dgithub%26queryKey%3DHaofeiMa&amp;query=%24.data.totalSubs&amp;suffix=%20followers&amp;logo=github&amp;label=Github&amp;color=black" alt=""></p><p><img src="https://img.shields.io/badge/dynamic/xml?url=https%3A%2F%2Fblog.csdn.net%2Fweixin_44543463&amp;query=%2F%2Fli%5B3%5D%2Fdiv%2Fspan%5B1%5D%2Ftext()%5B1%5D&amp;suffix=%20stars&amp;logo=csdn&amp;label=CSDN&amp;color=red" alt=""></p><p><strong>（4）Github统计信息</strong></p><p>替换自己的用户名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://github-readme-stats.vercel.app/api?username=HaofeiMa&amp;show_icons=true&amp;icon_color=CE1D2D&amp;text_color=718096&amp;bg_color=ffffff&amp;hide_title=true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://github-readme-stats.vercel.app/api?username=HaofeiMa&amp;show_icons=true&amp;icon_color=CE1D2D&amp;text_color=718096&amp;bg_color=ffffff&amp;hide_title=true" alt=""></p><p><strong>（4）GitHub 连续打卡</strong></p><p>Github 地址：<a href="https://github.com/DenverCoder1/github-readme-streak-stats">DenverCoder1/github-readme-streak-stats</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span>  <span class="attr">src</span>=<span class="string">&quot;https://github-readme-streak-stats.herokuapp.com/?user=HaofeiMa&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://github-readme-streak-stats.herokuapp.com/?user=HaofeiMa" alt=""></p><p><strong>（5）Github统计图</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=&quot;center&quot;&gt;</span><br><span class="line">    &lt;img  src=&quot;https://github-readme-activity-graph.vercel.app/graph?username=HaofeiMa&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github-readme-activity-graph.vercel.app/graph?username=HaofeiMa&amp;bg_color=ffffff&amp;theme=github-compact&amp;color=666666&amp;hide_title=true" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 科研利器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 科研利器 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu系统资源占用情况查看</title>
      <link href="/post/80e5e15a.html"/>
      <url>/post/80e5e15a.html</url>
      
        <content type="html"><![CDATA[<h1>显卡使用情况</h1><p><strong>使用命令</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>或每隔5s更新一次显卡信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 5 nvidia-smi</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312161609340.png" alt="image.png"></p><p><strong>第一部分</strong>：</p><p><code>| NVIDIA-SMI 525.125.06  Driver Version: 525.125.06  CUDA Version: 12.0 |</code></p><ul><li>Driver Version: 显卡驱动版本</li><li>CUDA Version: CUDA版本</li></ul><p><strong>第二部分</strong>：</p><p><code>| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC |</code></p><ul><li>GPU: 显卡序号，0, 1, …</li><li>Name: 显卡型号，例如 NVIDIA GeForce RTX 3090 Ti</li></ul><p><code>| Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. |</code></p><ul><li>Fan: 风扇转速，0到100%，如果风扇损坏则显示N/A</li><li>Temp: 显卡温度，摄氏度</li><li>Perf: 性能状态，P0到P12，P0表示最大性能，P12表示最小性能状态</li><li>Pwr: 显卡功率</li><li>Memory Usage: 显存使用情况</li><li>Volatile GPU-Util: 浮动的GPU利用率</li><li>Compute: 计算模式</li></ul><p><strong>第三部分</strong>：</p><p>每个进程的显卡显存使用情况</p><h1>CPU、内存、网络</h1><h2 id="可视化界面">可视化界面</h2><p>一下命令仅用于图形化界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnome-system-monitor</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312161627161.png" alt=""></p><h2 id="查看内存占用">查看内存占用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h -w</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312161628621.png" alt="image.png"></p><ul><li>total: 总计内存大小</li><li>used: 已使用内存</li><li>free: 空闲内存</li><li>shared: 共享内存</li><li>buffers: 缓冲区</li><li>cache: 缓存</li><li>available: 可用内存</li></ul><h2 id="CPU">CPU</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312161631024.png" alt="image.png"></p><p><strong>第一行（系统状态）</strong>：</p><p><code>top - 16:31:54 up 15 days, 41 min,  0 users,  load average: 14.45, 14.82, 15.31</code></p><ul><li>16:31:54: 当前系统时间</li><li>15 days, 41 min: 当前系统已经连续开机运行了15天41分钟</li><li>15 days, 41 min: 有0个用户登录系统（可能远程桌面没被计算）</li><li>load average: 14.45, 14.82, 15.31: 显示最近1分钟、5分钟、15分钟的负载情况（特定算法计算的值）</li></ul><p><strong>第二行（任务进程状态）</strong>：</p><p><code>Tasks: 771 total,  17 running, 748 sleeping,   0 stopped,   6 zombie</code></p><ul><li>Tasks: 771 total: 一共有771个进程</li><li>17 running: 有17个进程正在运行</li><li>748 sleeping: 有748个进程处于休眠状态</li><li>0 stopped: 有0个任务处于被停止状态</li><li>6 zombie: 有6个任务处于zombie状态</li></ul><p><strong>第三行（CPU状态）</strong>：</p><p><code>%Cpu(s): 67.4 us,  1.0 sy,  0.0 ni, 31.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</code></p><ul><li>67.4 us: 用户空间占用CPU的百分比为67.4%</li><li>1.0 sy: 内核空间占用CPU的百分比为1.0%</li><li>0.0 ni: 该变过优先级的任务占用系统CPU的百分比为0%</li><li>31.6 id: 空闲CPU百分比为31.6%</li><li>0.0 wa: IO等待占用CPU的百分比为0%</li><li>0.0 hi: 硬中断占用CPU的百分比为0%</li><li>0.0 si: 软中断占用CPU的百分比为0%</li></ul><p><strong>第四行（内存状态）</strong>：</p><p><code>MiB Mem :  64090.2 total,    596.0 free,  15622.8 used,  47871.4 buff/cache</code></p><ul><li>64090.2 total: 物理内存总量 64G</li><li>596.0 free: 空闲内存总量 596Mb</li><li>15622.8 used: 使用中的内存总量 15622.8Mb</li><li>47871.4 buff/cache: 缓存的内存量 47871.4 Mb</li></ul><p><strong>第五行（交换分区状态）</strong>：</p><p><code>MiB Swap:   2048.0 total,   1993.0 free,     55.0 used.  47513.7 avail Mem</code></p><ul><li>2048.0 total: 交换分区总量</li><li>1993.0 free: 空闲的交换分区容量</li><li>55.0 used: 使用中的交换分区容量</li><li>47513.7 avail Mem: 缓冲的交换分区容量</li></ul><p><strong>第六行及以下（进程信息）</strong>：</p><p><code>PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</code></p><ul><li>PID: 进程id</li><li>USER: 进程所有者的用户名</li><li>PR: 优先级</li><li>NI: nice值，负值表示高优先级，正值表示低优先级</li><li>VIRT: 进程使用的虚拟内存总量，单位kb</li><li>RES: 进程使用的、未被换出的物理内存大小，单位kb</li><li>SHR: 共享内存大小，单位kb</li><li>S: 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li>%CPU: 上次更新到现在的CPU时间占用百分比</li><li>%MEM: 进程使用的物理内存百分比</li><li>TIME+: 进程使用的CPU时间总计，单位1/100秒</li><li>COMMAND: 命令名/命令行</li></ul><blockquote><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/k_ilig/article/details/133769072">kilig ＿. ubuntu查看GPU信息和使用情况. CSDN</a></li><li><a href="https://blog.csdn.net/weixin_40277264/article/details/118328456">我有一个魔盒. Ubuntu 查看系统资源占用(CPU、内存、网络). CSDN</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【抓取算法】Contact GraspNet</title>
      <link href="/post/c18d351e.html"/>
      <url>/post/c18d351e.html</url>
      
        <content type="html"><![CDATA[<h1>一、论文笔记</h1><blockquote><p><strong>标题</strong>：Contact-GraspNet: 在杂乱场景中高效生成6-DoF抓取<br><strong>期刊会议</strong>：ICRA2021<br><strong>作者团队</strong>：Martin Sundermeyer（NVIDIA）<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/NVlabs/contact_graspnet">https://github.com/NVlabs/contact_graspnet</a><br><strong>数据集</strong>：</p></blockquote><h2 id="1-1-目标问题-2">1.1 目标问题</h2><p>提出了一种端到端的网络，从图像的深度数据中生成6D抓取分布。</p><h2 id="1-2-方法">1.2 方法</h2><p>使用原始的深度图，以及（可选使用对象掩码），生成6D抓取建议以及抓取宽度。</p><p><strong>（1）抓取表示方法</strong></p><p>可以发现，大多是可以预测的两手指抓取，在抓取前至少可以看到两个接触点的一个。因此可以将抓取问题简化为估计平行板抓取器的3D抓取旋转和抓取宽度。</p><p><img src="https://img.mahaofei.com/img/20230404152359.png" alt="image.png"></p><p>其中a是接近向量，b是抓取基线向量，d是从抓取基线到抓取基座的距离。使用这种表示方法可以加速学习过程，提高预测精度，且没有歧义和间断区域。</p><p><strong>（2）数据生成</strong></p><p>使用了ACRONYM数据集。在场景中以随机稳定的姿态放置具有密集抓取注释的对象网格。其中会导致夹爪与模型碰撞的抓取姿态将被删除。</p><p><strong>（3）网络</strong></p><p>使用PointNet++中提出的集合概要和特征传播层来构建非对称的U形网络。</p><p>网络有四个检测头，每个检测头包括两个1D卷积层，每个点输出s∈R，z1∈R3，z2∈R3、o∈R10，从中我们形成了我们的抓取表示。</p><p>将抓取的宽度划分为10个等距的抓取宽度，来抵消数据不平衡问题，然后选择置信度最高的抓取宽度表示。由于接近方向和基线方向是正交的，通过进行正交归一化预测，将这一性质加入到训练过程，有助于3D旋转的回归。</p><p><img src="https://img.mahaofei.com/img/20230404153946.png" alt="image.png"></p><h2 id="1-3-思考">1.3 思考</h2><p>在数据集中预先定义好了抓取姿态，然后进行监督训练。使用时根据深度图首先确定物体所在区域，然后利用其点云预测抓取分布。</p><p>自定义物体的数据集不易制作。</p><h1>二、算法复现</h1><h2 id="2-1-准备工作">2.1 准备工作</h2><p><strong>（1）环境搭建</strong></p><p>下载代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NVlabs/contact_graspnet.git</span><br></pre></td></tr></table></figure><p>创建虚拟环境<br>（这个环境是没问题的，如果出现依赖不满足要求的情况，可以先删掉那项，创建完环境后再手动安装）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f contact_graspnet_env.yml</span><br><span class="line">conda activate contact_graspnet_env</span><br></pre></td></tr></table></figure><p>重新编译<code>pointnet_tfops</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh compile_pointnet_tfops.sh</span><br></pre></td></tr></table></figure><p><strong>（2）模型和数据准备</strong></p><p>从作者给出的连接下载<a href="https://drive.google.com/drive/folders/1tBHKf60K8DLM5arm-Chyf7jxkzOr5zGl?usp=sharing">trained models</a>，并将它们放到<code>./checkpoints/</code>，下载<a href="https://drive.google.com/drive/folders/1v0_QMTUIEOcu09Int5V6N2Nuq7UCtuAA?usp=sharing">test data</a>，并将它们放到<code>./test_data</code></p><h2 id="2-2-预测抓取">2.2 预测抓取</h2><p>给定一个深度图(.npy文件/单位m)，相机内参，2D实例分割图，运行下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python contact_graspnet/inference.py \</span><br><span class="line">       --np_path=test_data/0.npy \</span><br><span class="line">       --local_regions --filter_grasps</span><br></pre></td></tr></table></figure><p><code>--np_path</code>：输入的.npz/.npy文件，带有深度、内参、实力分割图、RGB信息<br><code>--ckpt_dir</code>：checkpoint目录，默认为<code>checkpoint/scene_test_2048_bs3_hor_sigma_001</code>，非常干净的深度数据使用<code>scene_2048_bs3_rad2_32</code>，非常混乱的深度数据使用<code>scene_test_2048_bs3_hor_sigma_0025</code><br><code>--local_regions</code>：裁剪的3D实例分割<br><code>--filter_grasps</code>：筛选抓取点，使他们只为于对象的表面<br><code>--skip_border_objects</code>：忽略碰到深度图边缘的实例分割<br><code>--forward_passes</code>：前向计算的次数，增加可以提高抓取的采样点<br><code>--z_range</code>：[min, max]的z值来裁剪输入点云<br><code>--arg_configs TEST.second_thres:0.19 TEST.first_thres:0.23</code>：覆盖抓取的配置置信度来获得更多或更少的抓取候选</p><h2 id="2-3-训练网络">2.3 训练网络</h2><p><strong>（1）下载数据集</strong></p><ul><li>下载<a href="https://drive.google.com/file/d/1zcPARTCQx2oeiKk7a-wdN_CN-RUVX56c/view?usp=sharing">Acronym</a>数据集</li><li>从<a href="https://www.shapenet.org/">https://www.shapenet.org/</a>下载ShapeNet meshe</li><li>创建watertiget<ul><li>下载并构建<a href="https://github.com/hjwdzh/Manifold">https://github.com/hjwdzh/Manifold</a></li><li>创建watertight mesh，假设物体路径为model.obj：<code>manifold model.obj temp.watertight.obj -s</code></li><li>简化：<code>simplify -i temp.watertight.obj -o model.obj -m -r 0.02</code></li></ul></li></ul><p>下载10000个带有Contact抓取信息的桌面训练场景<a href="https://drive.google.com/drive/folders/1eeEXAISPaStZyjMX8BHR08cdQY4HF4s0">Google Drive</a>，解压为下面的格式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">acronym</span><br><span class="line">├── grasps</span><br><span class="line">├── meshes</span><br><span class="line">├── scene_contacts</span><br><span class="line">└── splits</span><br></pre></td></tr></table></figure><p><strong>（2）训练Contact-GraspNet</strong></p><p>如果在没有外设的服务器上训练，设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYOPENGL_PLATFORM=&#x27;egl&#x27;</span><br></pre></td></tr></table></figure><p>使用配置文件<code>contact_graspnet/config.yaml</code>开始训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python contact_graspnet/train.py --ckpt_dir checkpoints/your_model_name \</span><br><span class="line">                                 --data_path /path/to/acronym/data</span><br></pre></td></tr></table></figure><p><strong>（3）生成自己的Contact Grasps和场景</strong></p><p>所下载的<code>scene_contacts</code>是从Acronym数据集生成的，要生成自己的数据集，下载安装<a href="https://github.com/NVlabs/acronym">acronym_tools</a>。</p><p>第一步，对象的6D抓取被映射到保存在<code>mesh_contacts</code>的接触点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/create_contact_infos.py /path/to/acronym</span><br></pre></td></tr></table></figure><p>根据生成的<code>mesh_contacts</code>，可以创建桌面场景保存到<code>scene_contacts</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python tools/create_table_top_scenes.py /path/to/acronym</span><br></pre></td></tr></table></figure><p>一个线程大约花费3天，可以多次运行命令在多个核上并行处理。</p><p>可视化显示创建的桌面场景和抓取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python tools/create_table_top_scenes.py /path/to/acronym \</span><br><span class="line">       --load_existing scene_contacts/000000.npz -vis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 机器人抓取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 抓取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6D位姿估计算法】Gen6D算法</title>
      <link href="/post/76335f84.html"/>
      <url>/post/76335f84.html</url>
      
        <content type="html"><![CDATA[<h1>论文笔记</h1><blockquote><p><strong>标题</strong>：Gen6D: Generalizable Model-Free 6-DoF Object Pose Estimation from RGB Images<br><strong>作者团队</strong>：The University of Hong Kong<br><strong>期刊会议</strong>：ECCV<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/liuyuan-pal/Gen6D">https://github.com/liuyuan-pal/Gen6D</a></p></blockquote><h2 id="1-介绍">1. 介绍</h2><h3 id="1-1-目标问题">1.1 目标问题</h3><p>现有的位姿估计算法要么需要高质量的物体模型，要么需要提供额外的深度图或物体掩码图，这对于位姿估计的实际应用有很大的限制。本文提出的方法只需要一些物体的姿态图像，就能够在任意环境中预测物体位姿。</p><p>作者认为一个位姿估计器应该具有以下特点：</p><ul><li>通用性：可以应用于任意物体，而无需对对象或类别进行训练</li><li>无模型：用于一个未见过的物体时，只需要一些已知姿态的参考图像来定义物体参考坐标系即可</li><li>输入简单：仅输入RGB图像来估计位姿，而不需要深度图或物体掩码图</li></ul><p><strong>（1）如何设计视角选择器，从参考图像中找到与查询图像视角最接近的</strong></p><p>本文使用神经网络对查询图像和参考图像进行逐像素比较，产生相似性得分，并选择具有最高相似性得分的参考图像。并添加了全局归一化层和自注意层来共享不同参考图像之间的相似性信息，为选择最相似的参考图像提供了上下文信息。</p><p><strong>（2）实现没有模型的姿态优化</strong></p><p>本文提出了一种新的基于三维空间的姿态优化方法，给定一个查询图像和一个输入姿态，找到几个接近输入姿态的参考图像，将这些参考图像投影回3D空间中，构建特征空间，通过3D的CNN将构建的特征空间与查询图像的特征相匹配，来优化姿态。</p><h3 id="1-2-现有工作">1.2 现有工作</h3><p>现有位姿估计方法大都是基于特定实例的，不能推广到未见过的物体，通常都需要根据物体3D模型来渲染大量图像进行训练。有一些方法可以推广到类别级，也不需要对象的模型，但仍然无法预测没见过的类别的物体。</p><h2 id="2-实现方法">2. 实现方法</h2><p><strong>数据规范化</strong>：对于每个物体，通过对参考图像中的点进行三角测量等方法估计物体的大致大小，然后对物体坐标系进行归一化，使物体中心位于原点，大小为1，此时物体位于原点的单位球体内。</p><p>Gen6D包括一个物体检测器，一个视角选择器，一个姿态优化器。</p><p><img src="https://img.mahaofei.com/img/20230403203020.png" alt="image.png"></p><p>物体检测其首先利用查询图像和参考图像来检测物体所在区域。然后视角选择器将查询图像于参考图像相匹配，产生粗略的初始姿态。最后由姿态优化器进一步细化以得到精确的对象姿态。</p><h3 id="2-1-物体检测">2.1 物体检测</h3><p>将检测问题分解成两部分</p><ol><li>找到对象中心的2D投影点q</li><li>估计包围单位球体的正方形边界框。</li></ol><p><img src="https://img.mahaofei.com/img/20230403204751.png" alt="image.png"></p><p>物体中心的深度可以使用$d=2f/S_q$求得，其中2是单位球体的直径，f是虚拟焦距（将主点设为投影点q），$S_q$是边界框边长。这就是物体的初始平移。</p><blockquote><p>问题：这里将物体归一化之后求出的深度d还是真实深度吗？虚拟焦距又是如何确定的？</p></blockquote><p>检测器使用了VGG网络提取参考图像和查询图像的特征图，然后将所有参考图像的特征图作为卷积核与查询图像的特征图卷积，得到分数图。考虑尺度差异，设置再多个预定义尺度上进行卷积，最后得到热力图和比例图。选择热力图上的最大值位置作为对象中心2D投影，使用比例图上相同比例的比例作为边界框的大小$S_q=S_r*s$。</p><blockquote><p>问题：这里将所有参考图像的特征图都进行卷积，那么参考图像上物体特征和背景特征是如何区分的？</p></blockquote><h3 id="2-2-视角选择">2.2 视角选择</h3><p>将查询图像与每个参考图像比较，计算相似性得分。计算每个参考图像和查询图像的元素乘积，获得得分图，并计算相似性参数。</p><p><img src="https://img.mahaofei.com/img/20230404192903.png" alt="image.png"></p><p><strong>（1）平面内旋转</strong><br>为了考虑平面内旋转，本文将参考图像旋转Na个预定义角度，查询时使用所有旋转版本进行逐元素乘积。</p><p><strong>（2）全局归一化</strong><br>使用参考图像的所有特征图计算的均值和方差，对相似度网络生成的特征图进行归一化。这样做可以用特征图的分布来编码上下文相似性，并放大不同图像之间的相似性差异。</p><p><strong>（3）参考视角变换</strong><br>在所有参考图像的相似性特征向量上应用变换，包括它们的视角、注意力层。这样的变换器使得特征向量相互通信以编码上下文信息，有助于确定最相似的参考图像。</p><h3 id="2-3-姿态优化">2.3 姿态优化</h3><p>经过上面两个步骤，我们已经有了粗略的物体位姿。本步骤对位姿进行优化。</p><p>选择接近输入姿态的6个参考图像，通过CNN提取特征图，然后将特征图投影到3D空间中，并计算特征的均值和方差作为空间顶点的特征。<br>对于查询图像，使用同样的CNN提取特征图，将特征图投影到3D空间中，并将查询特征与参考图像特征的均值和方差连接起来。</p><p>最后在空间特征上使用3DCNN预测残差来更新输入姿态。</p><p><img src="https://img.mahaofei.com/img/20230404195340.png" alt="image.png"></p><h1>3. 实验分析</h1><h1>二、算法复现</h1><h2 id="2-1-环境搭建">2.1 环境搭建</h2><h3 id="2-1-1-Python环境">2.1.1 Python环境</h3><p>创建[[02_Anaconda的基本使用与在Pycharm中调用|Anaconda虚拟环境]]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n gen6d python=3.7</span><br><span class="line">conda activate gen6d</span><br></pre></td></tr></table></figure><p>安装pytorch环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 -c pytorch</span><br></pre></td></tr></table></figure><p>安装依赖，打开<code>requirements.txt</code>，删除其中的pytorch, torchvision, cudatoolkit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="2-1-2-自制数据集工具">2.1.2 自制数据集工具</h3><p><strong>（1）COLMAP</strong></p><p>参考官网教程：<a href="https://colmap.github.io/install.html">https://colmap.github.io/install.html</a></p><p>安装依赖库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    git \</span><br><span class="line">    cmake \</span><br><span class="line">    build-essential \</span><br><span class="line">    libboost-program-options-dev \</span><br><span class="line">    libboost-filesystem-dev \</span><br><span class="line">    libboost-graph-dev \</span><br><span class="line">    libboost-regex-dev \</span><br><span class="line">    libboost-system-dev \</span><br><span class="line">    libboost-test-dev \</span><br><span class="line">    libeigen3-dev \</span><br><span class="line">    libsuitesparse-dev \</span><br><span class="line">    libfreeimage-dev \</span><br><span class="line">    libgoogle-glog-dev \</span><br><span class="line">    libgflags-dev \</span><br><span class="line">    libglew-dev \</span><br><span class="line">    qtbase5-dev \</span><br><span class="line">    libqt5opengl5-dev \</span><br><span class="line">    libcgal-dev \</span><br><span class="line">    libcgal-qt5-dev\</span><br><span class="line">    libceres-dev\</span><br><span class="line">    ninja-build\</span><br><span class="line">    libmetis-dev</span><br></pre></td></tr></table></figure><p>下载COLMAP源代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/colmap/colmap</span><br><span class="line">cd colmap</span><br></pre></td></tr></table></figure><p>修改<code>CMakeLists.txt</code>文件，添加下面的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CUDA_ARCHITECTURES 86)</span><br></pre></td></tr></table></figure><p>开始编译、安装（注意一定要退出conda环境再编译安装）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake .. -GNinja</span><br><span class="line">ninja</span><br><span class="line">sudo ninja install</span><br></pre></td></tr></table></figure><p><strong>（2）CloudCompare</strong></p><p><strong>方式1：snap（推荐）</strong></p><p>安装snap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install snap</span><br></pre></td></tr></table></figure><p>安装cloudcompare</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap install cloudcompare</span><br></pre></td></tr></table></figure><p>启动cloudcompare</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudcompare.CloudCompare</span><br></pre></td></tr></table></figure><p><strong>方式2：Flatpak</strong></p><p>安装Flatpak</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install flatpak</span><br></pre></td></tr></table></figure><p>安装Software Flatpak plugin</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnome-software-plugin-flatpak</span><br></pre></td></tr></table></figure><p>添加Flathub repository</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo</span><br></pre></td></tr></table></figure><p>安装CloudCompare</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak install flathub org.cloudcompare.CloudCompare</span><br></pre></td></tr></table></figure><p>运行CloudCompare</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak run org.cloudcompare.CloudCompare</span><br></pre></td></tr></table></figure><p><strong>（3）安装ffmpeg</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ffmpeg</span><br></pre></td></tr></table></figure><h2 id="2-2-数据集准备">2.2 数据集准备</h2><h3 id="2-2-1-官方数据集">2.2.1 官方数据集</h3><p><strong>（1）下载数据集</strong></p><p>从<a href="https://connecthkuhk-my.sharepoint.com/:f:/g/personal/yuanly_connect_hku_hk/EkWESLayIVdEov4YlVrRShQBkOVTJwgK0bjF7chFg2GrBg?e=Y8UpXu">原作者给出的链接</a>中下载预训练模型，GenMOP数据集和processed LINEMOD数据集。</p><p><strong>（2）组织数据集</strong></p><p>将下载的文件按照下面的格式进行整理。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Gen6D</span><br><span class="line">|-- data</span><br><span class="line">    |-- model</span><br><span class="line">        |-- detector_pretrain</span><br><span class="line">            |-- model_best.pth</span><br><span class="line">        |-- selector_pretrain</span><br><span class="line">            |-- model_best.pth</span><br><span class="line">        |-- refiner_pretrain</span><br><span class="line">            |-- model_best.pth</span><br><span class="line">    |-- GenMOP</span><br><span class="line">        |-- chair </span><br><span class="line">            ...</span><br><span class="line">    |-- LINEMOD</span><br><span class="line">        |-- cat </span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><h3 id="2-2-2-自制数据集">2.2.2 自制数据集</h3><p><strong>（1）视频录制</strong></p><p>使用手机录制目标物体的参考视频和测试视频。注意：参考视频需要满足以下条件</p><ul><li>参考视频中对象是静态的</li><li>参考视频中背景尽可能纹理丰富且平整，摄像角度要尽可能覆盖每个角度，以便COLMAP恢复相机姿态</li></ul><p><strong>（2）组织文件</strong></p><p>将视频按照下面的路径进行组织</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Gen6D</span><br><span class="line">|-- data</span><br><span class="line">    |-- custom</span><br><span class="line">       |-- video</span><br><span class="line">           |-- mouse-ref.mp4</span><br><span class="line">           |-- mouse-test.mp4</span><br></pre></td></tr></table></figure><p><strong>（3）将参考视频拆分为图像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 每10帧保存一张图像，最大图像边长为960</span></span></span><br><span class="line">python prepare.py --action video2image \</span><br><span class="line">                  --input data/custom/video/ref/coffeebox-ref.mp4 \</span><br><span class="line">                  --output data/custom/coffeebox/images \</span><br><span class="line">                  --frame_inter 10 \</span><br><span class="line">                  --image_size 960 \</span><br><span class="line">                  --transpose</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 或者</span></span></span><br><span class="line">python prepare.py --action video2image --input data/custom/video/ammeter-ref.mp4 --output data/custom/ammeter/images --frame_inter 10 --image_size 960 --transpose</span><br></pre></td></tr></table></figure><p>拆分后的视频保存在<code>data/custom/coffeebox/images</code>中。</p><p><strong>（4）运行COLMAP SfM恢复相机姿态</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python prepare.py --action sfm --database_name custom/coffeebox --colmap &lt;path-to-your-colmap-exe&gt;</span><br></pre></td></tr></table></figure><p>注：<code>&lt;path-to-your-colmap-exe&gt;</code>可以通过命令<code>which colmap</code>来查找，一般ubuntu路径为<code>/usr/local/bin/colmap</code>，windows路径为<code>E:/Programming/COLMAP-3.8-windows-cuda/COLMAP.bat</code></p><p><strong>（5）手动处理点云</strong></p><p>通过裁减对象点云来手动确定对象所在区域。例如使用<a href="https://www.cloudcompare.org/">CloudCompare</a>来可视化处理COLMAP重建的点云，重建的点云位于<code>data/custom/mouse/colmap/pointcloud.ply</code>中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatpak run org.cloudcompare.CloudCompare</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20230327215520.png" alt=""></p><p>导出裁剪后的点云为<code>data/custom/mouse/object_point_cloud.ply</code>。</p><p><img src="https://img.mahaofei.com/img/20230327220042.png" alt=""></p><p><strong>（6）手动确定对象的X轴正方向和Z轴正方向</strong></p><p><img src="https://img.mahaofei.com/img/20230327220221.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20230327220225.png" alt=""></p><p>编辑一个<code>data/custom/mouse/meta_info.txt</code>文件来保存你的X+和Z+信息，例如</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.297052 0.350839 -0.000593</span><br><span class="line">0.973488 0.054352 -0.222188</span><br></pre></td></tr></table></figure><p><strong>（7）确保您具有以下文件，这些文件由上述步骤生成</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gen6D</span><br><span class="line">|-- data</span><br><span class="line">    |-- custom</span><br><span class="line">       |-- mouse</span><br><span class="line">           |-- object_point_cloud.ply  ## object point cloud</span><br><span class="line">           |-- meta_info.txt           ## meta information about z+/x+ directions</span><br><span class="line">           |-- images                  ## images</span><br><span class="line">           |-- colmap                  ## colmap project</span><br></pre></td></tr></table></figure><p><strong>（8）从处理后的参考图像中预测姿势</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python predict.py --cfg configs/gen6d_pretrain.yaml \</span><br><span class="line">                  --database custom/coffeebox_lied \</span><br><span class="line">                  --video data/custom/video/coffeebox-test.mp4 \</span><br><span class="line">                  --resolution 960 \</span><br><span class="line">                  --transpose \</span><br><span class="line">                  --output data/custom/ammeter_processed/test \</span><br><span class="line">                  --ffmpeg &lt;path-to-ffmpeg-exe&gt;</span><br></pre></td></tr></table></figure><h2 id="2-3-训练与评估">2.3 训练与评估</h2><p>将文件按照下面的形式组织</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Gen6D</span><br><span class="line">|-- data</span><br><span class="line">    |-- GenMOP</span><br><span class="line">        |-- chair </span><br><span class="line">            ...</span><br><span class="line">    |-- LINEMOD</span><br><span class="line">        |-- cat </span><br><span class="line">            ...</span><br><span class="line">    |-- shapenet</span><br><span class="line">        |-- shapenet_cache</span><br><span class="line">        |-- shapenet_render</span><br><span class="line">        |-- shapenet_render_v1.pkl</span><br><span class="line">    |-- co3d_256_512</span><br><span class="line">        |-- apple</span><br><span class="line">            ...</span><br><span class="line">    |-- google_scanned_objects</span><br><span class="line">        |-- 06K3jXvzqIM</span><br><span class="line">            ...</span><br><span class="line">    |-- coco</span><br><span class="line">        |-- train2017</span><br></pre></td></tr></table></figure><h3 id="2-3-1-训练detector">2.3.1 训练detector</h3><p>修改<code>train_meta_info.py</code>的第86行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;genmop_train&#x27;</span>: [<span class="string">f&#x27;genmop/<span class="subst">&#123;name&#125;</span>-test&#x27;</span> <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&#x27;ammeter&#x27;</span>, <span class="string">&#x27;coffeebox&#x27;</span>, <span class="string">&#x27;realsensebox&#x27;</span>]],</span><br></pre></td></tr></table></figure><p>修改<code>database.py</code>的第109行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">genmop_meta_info=&#123;</span><br><span class="line">    <span class="string">&#x27;ammeter&#x27;</span>: &#123;<span class="string">&#x27;gravity&#x27;</span>: np.asarray([<span class="number">0.0222805</span>, -<span class="number">0.409031</span>, <span class="number">0.912248</span>]), <span class="string">&#x27;forward&#x27;</span>: np.asarray([<span class="number">0.401556</span>, <span class="number">0.773825</span>, <span class="number">0.340199</span>],np.float32)&#125;,</span><br><span class="line">    <span class="string">&#x27;coffeebox&#x27;</span>: &#123;<span class="string">&#x27;gravity&#x27;</span>: np.asarray([<span class="number">0.0718405</span>, -<span class="number">0.471545</span>, <span class="number">0.878911</span>]), <span class="string">&#x27;forward&#x27;</span>: np.asarray([<span class="number">0.582604</span>, -<span class="number">0.490501</span>, -<span class="number">0.219265</span>],np.float32)&#125;,</span><br><span class="line">    <span class="string">&#x27;realsensebox&#x27;</span>: &#123;<span class="string">&#x27;gravity&#x27;</span>: np.asarray([<span class="number">0.103463</span>, -<span class="number">0.521284</span>, <span class="number">0.847088</span>],np.float32), <span class="string">&#x27;forward&#x27;</span>: np.asarray([-<span class="number">1.690831</span>, <span class="number">0.688506</span>, <span class="number">0.590004</span>],np.float32)&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>database.py</code>的第212行，修改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cameras, images, points3d = read_model(<span class="string">f&#x27;<span class="subst">&#123;GenMOP_ROOT&#125;</span>/<span class="subst">&#123;seq_name&#125;</span>/colmap/sparse/0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>开始训练</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_model.py --cfg configs/detector/detector_train.yaml</span><br></pre></td></tr></table></figure><h3 id="2-3-2-训练selector">2.3.2 训练selector</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_model.py --cfg configs/selector/selector_train.yaml</span><br></pre></td></tr></table></figure><h3 id="2-3-3-训练refiner">2.3.3 训练refiner</h3><p>为refiner训练进行数据准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">python prepare.py --action gen_val_set \</span><br><span class="line">                  --estimator_cfg configs/gen6d_train.yaml \</span><br><span class="line">                  --que_database linemod/cat \</span><br><span class="line">                  --que_split linemod_val \</span><br><span class="line">                  --ref_database linemod/cat \</span><br><span class="line">                  --ref_split linemod_val</span><br><span class="line"></span><br><span class="line">python prepare.py --action gen_val_set \</span><br><span class="line">                  --estimator_cfg configs/gen6d_train.yaml \</span><br><span class="line">                  --que_database genmop/tformer-test \</span><br><span class="line">                  --que_split all \</span><br><span class="line">                  --ref_database genmop/tformer-ref \</span><br><span class="line">                  --ref_split all </span><br></pre></td></tr></table></figure><p>该命令会在<code>data/val</code>生成信息，该信息会被用于生成refiner的有效数据</p><p>训练refiner</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train_model.py --cfg configs/refiner/refiner_train.yaml</span><br></pre></td></tr></table></figure><h3 id="2-3-4-评估所有组件">2.3.4 评估所有组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Evaluate on the object TFormer from the GenMOP dataset</span></span><br><span class="line">python eval.py --cfg configs/gen6d_train.yaml --object_name genmop/tformer</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Evaluate on the object <span class="built_in">cat</span> from the LINEMOD dataset</span></span><br><span class="line">python eval.py --cfg configs/gen6d_train.yaml --object_name linemod/cat</span><br></pre></td></tr></table></figure><h1>三、现存问题</h1><p><strong>优点</strong></p><ol><li>只需要对给定物体录制1-2分钟的视频，使用程序1-2小时<strong>添加数据集</strong>，即可实现新物体的位姿估计，不需要再训练网络</li><li><strong>精度</strong>还可以</li></ol><p><strong>缺点</strong></p><ol><li>对于<strong>方形凸形物体识别较好，对于物体内部存在中空区域</strong>，例如圆环等物体识别效果较差</li><li>由于<strong>参考视频要求物体静止，因此无法录到物体底面的特征</strong>，对于物体底面识别效果较差（可考虑物体正反放置录制两次，对于同一个物体使用两个参考视频进行预测，选择置信度高的位姿）</li><li>当进行识别时，如果<strong>图像中不存在物体也会生成一个估计位姿</strong>（可以考虑根据置信度判断输出，或者在位姿估计前使用yolo等算法预判断物体位置）</li><li>当存在<strong>遮挡时位姿估计效果较差</strong>，可能会出现只框处未被遮挡的部分，或者在遮挡物体上强行进行位姿估计。</li><li>当要同时识别的物体很多时，对于显卡显存要求比较大，而且计算会很慢，服务器1.5s/it。如果每次只对某个特定物体进行识别，速度还可以。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> Gen6D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6D位姿估计算法】GDRNPP算法</title>
      <link href="/post/250dc866.html"/>
      <url>/post/250dc866.html</url>
      
        <content type="html"><![CDATA[<h1>一、GDR-Net: Geometry-Guided Direct Regression Network for Monocular 6D Object Pose Estimation</h1><blockquote><p><strong>期刊 / 会议</strong>：CVPR2021<br><strong>作者 / 机构</strong>：Gu Wang,  Tsinghua University, BNRist<br><strong>关键词</strong>：位姿估计；端到端<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/THU-DA-6D-Pose-Group/GDR-Net">https://github.com/THU-DA-6D-Pose-Group/GDR-Net</a></p></blockquote><h2 id="1-目标问题-8">1 目标问题</h2><p>提出一种端到端的位姿估计算法。</p><h2 id="2-方法-8">2 方法</h2><p><img src="https://img.mahaofei.com/img/20230316104020.png" alt=""></p><p><strong>（1）网络架构</strong></p><p>首先向GDR-Net提供256x256的ROI图，预测出三个64x64的中间特征图</p><ul><li>稠密对应图$M_{2D-3D}$：将稠密坐标映射$M_{XYZ}$对跌倒2D像素坐标上得到，反映了对象的几何形状信息。</li><li>表面区域注意图$M_{SRA}$：采用最远点采样从$M_{XYZ}$中到处，代表了对象的对称性。</li><li>可见对象掩码$M_{vis}$</li></ul><p>使用一个简单的2D卷积Patch Pnp模块直接从特征图中回归6D对象姿态。Patch PnP模块由三个卷积层组成，然后用两个全连接层用于扁平化特征，最后连个全连接层输出R6D旋转和tSITE平移。</p><h2 id="3-思考-8">3 思考</h2><p>本文专注于图像的特征提取和处理工作，实现从单一图片预测位姿的功能。</p><h1>二、算法复现</h1><h2 id="2-1-数据集准备">2.1 数据集准备</h2><p>下载<a href="https://bop.felk.cvut.cz/datasets/">BOP数据集</a>和<a href="https://pjreddie.com/projects/pascal-voc-dataset-mirror/">VOC2012数据集</a>，从<a href="https://mailstsinghuaeducn-my.sharepoint.com/:f:/g/personal/liuxy21_mails_tsinghua_edu_cn/EgOQzGZn9A5DlaQhgpTtHBwB2Bwyx8qmvLauiHFcJbnGSw?e=EZ60La">Onedrive (password: groupji)</a>或者<a href="https://pan.baidu.com/s/1FzTO4Emfu-DxYkNG40EDKw">百度网盘(密码: vp58)</a>下载test_boxes，完成后datasets文件夹的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">datasets/</span><br><span class="line">├── BOP_DATASETS   # https://bop.felk.cvut.cz/datasets/</span><br><span class="line">    ├──tudl</span><br><span class="line">    ├──lmo</span><br><span class="line">    ├──ycbv</span><br><span class="line">    ├──icbin</span><br><span class="line">    ├──hb</span><br><span class="line">    ├──itodd</span><br><span class="line">    └──tless</span><br><span class="line">└──VOCdevkit</span><br></pre></td></tr></table></figure><p>从<a href="https://mailstsinghuaeducn-my.sharepoint.com/:f:/g/personal/liuxy21_mails_tsinghua_edu_cn/EgOQzGZn9A5DlaQhgpTtHBwB2Bwyx8qmvLauiHFcJbnGSw?e=EZ60La">Onedrive (password: groupji)</a>或者<a href="https://pan.baidu.com/s/1LhXblEic6pYf1i6hOm6Otw">百度网盘(密码10t3)</a>下载预训练模型，并将其放到<code>./output</code>文件夹内。</p><h2 id="2-2-环境准备">2.2 环境准备</h2><p>要求Ubuntu 18.04/20.04, CUDA 10.1/10.2/11.6, python &gt;= 3.7, PyTorch &gt;= 1.9, torchvision</p><p><strong>（1）创建虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n gdrnpp python=3.7</span><br><span class="line">conda activate gdrnpp</span><br></pre></td></tr></table></figure><p><strong>（2）安装依赖</strong></p><p>打开<code>requirements/requirement.txt</code>，修改第48行为<code>pytorch-lightning==1.6.0</code></p><p>运行<code>sh scripts/install_deps.sh</code></p><p><strong>（3）从<a href="https://github.com/facebookresearch/detectron2">源码</a>安装detectron2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install &#x27;git+https://github.com/facebookresearch/detectron2.git&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(add --user <span class="keyword">if</span> you don<span class="string">&#x27;t have permission)</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Or, to install it from a local clone:</span></span></span><br><span class="line">git clone https://github.com/facebookresearch/detectron2.git</span><br><span class="line">python -m pip install -e detectron2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">On macOS, you may need to prepend the above commands with a few environment variables:</span></span></span><br><span class="line">CC=clang CXX=clang++ ARCHFLAGS=&quot;-arch x86_64&quot; python -m pip install ...</span><br></pre></td></tr></table></figure><p><strong>（4）编译 fps 的cpp扩展</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh core/csrc/compile.sh</span><br></pre></td></tr></table></figure><p><strong>（5）编译egl_renderer的cpp扩展</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh lib/egl_renderer/compile_cpp_egl_renderer.sh</span><br></pre></td></tr></table></figure><h2 id="2-3-目标检测算法">2.3 目标检测算法</h2><p>从 <a href="https://mailstsinghuaeducn-my.sharepoint.com/:f:/g/personal/liuxy21_mails_tsinghua_edu_cn/EkCTrRfHUZVEtD7eHwLkYSkBCTXlh9ekDteSzK6jM4oo-A?e=m0aNCy">Onedrive</a> (password: groupji) or <a href="https://pan.baidu.com/s/1AU7DGCmZWsH9VgQnbTRjow">BaiDuYunPan</a>(password: aw68)中下载预训练模型。</p><p><strong>（1）训练</strong></p><p><code>./det/yolox/tools/train_yolox.sh &lt;config_path&gt; &lt;gpu_ids&gt; (other args)</code></p><p><strong>（2）测试</strong></p><p><code>./det/yolox/tools/test_yolox.sh &lt;config_path&gt; &lt;gpu_ids&gt; &lt;ckpt_path&gt; (other args)</code></p><h2 id="2-4-位姿估计算法">2.4 位姿估计算法</h2><p><strong>（1）训练</strong></p><p>打开<code>core/gdrn_modeling/datasets/lm_pbr.py</code>，注释第190行<code>assert osp.exists(xyz_path), xyz_path</code></p><p><code>./core/gdrn_modeling/train_gdrn.sh &lt;config_path&gt; &lt;gpu_ids&gt; (other args)</code></p><p>例如：</p><p><code>./core/gdrn_modeling/train_gdrn.sh configs/gdrn/ycbv/convnext_a6_AugCosyAAEGray_BG05_mlL1_DMask_amodalClipBox_classAware_ycbv.py 0</code></p><p><strong>（2）测试</strong></p><p><code>./core/gdrn_modeling/test_gdrn.sh &lt;config_path&gt; &lt;gpu_ids&gt; &lt;ckpt_path&gt; (other args)</code></p><p>例如：</p><p><code>./core/gdrn_modeling/test_gdrn.sh configs/gdrn/ycbv/convnext_a6_AugCosyAAEGray_BG05_mlL1_DMask_amodalClipBox_classAware_ycbv.py 0 output/gdrn/ycbv/convnext_a6_AugCosyAAEGray_BG05_mlL1_DMask_amodalClipBox_classAware_ycbv/model_final_wo_optim.pth</code></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> GDRNPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorBoard的使用丨深度学习曲线生成</title>
      <link href="/post/6db9da8f.html"/>
      <url>/post/6db9da8f.html</url>
      
        <content type="html"><![CDATA[<h1>TensorBoard的安装</h1><p>要求Pytorch版本必须在1.2.0以上。</p><p>使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from torch.utils.tensorboard import SummaryWriter</span><br></pre></td></tr></table></figure><h1>TensorBoard的代码调用</h1><p><strong>（1）导入包，并创建TensorBoard回调对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> TensorBoard</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs/learning_rate_scheduler&quot;</span>) <span class="comment">#指定TensorBoard日志目录</span></span><br></pre></td></tr></table></figure><p><strong>（2）在模型的训练过程中导入回调</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global_step = <span class="number">0</span> <span class="comment"># 初始化 global_step 为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        <span class="comment"># 训练过程</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将学习率和训练损失添加到 TensorBoard</span></span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Train/Loss&#x27;</span>, loss, global_step=global_step)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Train/Learning_Rate&#x27;</span>, lr, global_step=global_step)</span><br><span class="line">global_step += <span class="number">1</span>  <span class="comment"># 为每个batch更新 global_step 计数器</span></span><br></pre></td></tr></table></figure><h1>查看曲线</h1><p>训练开始后，打开一个终端，输入下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir logs/learning_rate_scheduler</span><br></pre></td></tr></table></figure><p>然后打开浏览器的<a href="http://localhost:6006/">http://localhost:6006/</a>页面，就可以看到曲线。</p><p><img src="https://img.mahaofei.com/img/20230323221410.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】ECCV2020-2022 6D位姿估计相关论文</title>
      <link href="/post/f0f72f50.html"/>
      <url>/post/f0f72f50.html</url>
      
        <content type="html"><![CDATA[<h1>ECCV2020</h1><h2 id="01-CosyPose-Consistent-multi-view-multi-object-6D-pose-estimation">01. CosyPose: Consistent multi-view multi-object 6D pose estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：ECCV2020<br><strong>作者 / 机构</strong>：Yann Labbe,  Ecole normale superieure, CNRS, PSL Research University, Paris, France<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/ylabbe/cosypose">https://github.com/ylabbe/cosypose</a></p></blockquote><h4 id="1-目标问题-3">1 目标问题</h4><p>在相机位置未知的情况下，利用多视角信息来提高物体姿态估计的准确性和鲁棒性</p><h4 id="2-方法-3">2 方法</h4><p><strong>（1）建立6D姿态初始候选对象</strong></p><p>给定一组具有已知3D模型的对象和场景的单个图像，我们为每个对象输出一组候选检测，并为每个检测输出对象相对于与图像相关联的相机的6D姿态。</p><p><strong>（2）对象候选匹配</strong></p><p>匹配多个视图中可见的对象，以获得单个一致的场景。</p><p><strong>（3）全局场景细化</strong></p><p>所有物体和相机的6D姿态都经过了优化，以最大限度地减少全局重投影误差。</p><h4 id="3-思考-3">3 思考</h4><p><strong>（1）创新点</strong></p><ul><li>提出了一种基于渲染和比较的单视角单物体6D姿态估计方法，用于生成每个图像中的物体姿态假设。</li><li>开发了一种基于RANSAC的鲁棒方法，用于匹配不同图像中的单个物体姿态假设，并利用这些对象级别的对应关系来恢复相机之间的相对位置。</li><li>开发了一种基于对象级别捆绑调整（object-level bundle adjustment）的全局优化方法，用于在所有视角下最小化重投影误差，并改善噪声单视角物体姿态。</li></ul><p><strong>（2）实用性</strong></p><p>从多个视图中推测物体的6D位姿，对于抓取场景实用性较差。</p><h1>ECCV2022</h1><h2 id="01-DProST-Dynamic-Projective-Spatial-Transformer-Network-for-6D-Pose-Estimation">01. DProST: Dynamic Projective Spatial Transformer Network for 6D Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：ECCV2022<br><strong>作者 / 机构</strong>：<br><strong>关键词</strong>：<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/parkjaewoo0611/DProST">https://github.com/parkjaewoo0611/DProST</a><br><strong>数据集</strong>：LINEMOD</p></blockquote><h4 id="1-目标问题-4">1 目标问题</h4><p>提出了一种新的基于投影网格的姿态估计系统。</p><p><img src="https://img.mahaofei.com/img/20230402093533.png" alt=""></p><h4 id="2-方法-4">2 方法</h4><ul><li>使用深度神经网络从RGB图像中提取特征，并预测物体位置和大小。</li><li>在相机空间上根据预测位置和大小生成一个锥形光束网格，并将其反向变换到物体空间。</li><li>使用参考图像和掩码从物体模型或重建特征中提取纹理特征，并将其映射到变换后的网格上。</li><li>使用双线性插值从映射后的纹理特征中采样得到重建图像，并与输入图像进行比较。</li><li>使用基于网格距离和网格匹配损失函数来优化网络参数和姿态参数。</li></ul><h4 id="3-思考-4">3 思考</h4><p>深度神经网络提取特征，投影网格重建图像，使用损失函数优化参数。</p><h2 id="02-DCL-Net-Deep-Correspondence-Learning-Network-for6D-Pose-Estimation">02. DCL-Net: Deep Correspondence Learning Network for6D Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：ECCV2022<br><strong>作者 / 机构</strong>：Hongyang Li, South China University of Technology, Guangzhou, China<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/Gorilla-Lab-SCUT/DCL-Net">https://github.com/Gorilla-Lab-SCUT/DCL-Net</a><br><strong>数据集</strong>：LINEMOD</p></blockquote><h4 id="1-目标问题-5">1 目标问题</h4><p>从点对应关系中直接估计6D物体姿态，而不是使用间接的对应学习目标</p><h4 id="2-方法-5">2 方法</h4><p>这篇论文的主要方法是提出了一种新的深度对应学习网络（DCL-Net），它利用双重特征解耦和对齐（FDA）模块，在特征空间中建立相机坐标系和物体坐标系之间的部分到部分对应关系和完整到完整对应关系。具体步骤如下：</p><ul><li>首先，对于部分物体观测和其CAD模型，分别提取它们的点特征图；</li><li>然后，设计两个FDA模块，分别建立部分到部分对应关系和完整到完整对应关系。具体来说，每个FDA模块将两个点特征图作为输入，并将每个特征图解耦为独立的姿态特征图和匹配特征图；然后利用匹配特征图学习一个注意力图来建立深度对应关系；最后，根据注意力图将两个系统的姿态特征图和匹配特征图进行对齐和配对，得到姿态特征对和匹配特征对；</li><li>接着，将两个FDA模块得到的两组对应关系进行融合，因为它们具有互补优势；然后利用融合后的匹配特征对学习置信度得分来衡量深度对应关系的质量；同时利用置信度得分加权融合后的姿态特征对来直接回归物体姿态；</li><li>最后，提出了一个基于置信度的姿态优化网络来进一步迭代地提高姿态精度。</li></ul><h4 id="3-思考-5">3 思考</h4><p>点特征方法。</p><h2 id="03-Perspective-Flow-Aggregation-for-Data-Limited-6D-Object-Pose-Estimation">03. Perspective Flow Aggregation for Data-Limited 6D Object Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：ECCV2022<br><strong>作者 / 机构</strong>：Yinlin Hu, EPFL CVLab, Lausanne, Switzerland<br><strong>关键词</strong>：位姿估计；少数据情况<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/cvlab-epfl/perspective-flow-aggregation">https://github.com/cvlab-epfl/perspective-flow-aggregation</a><br><strong>数据集</strong>：LINEMOD</p></blockquote><h4 id="1-目标问题-6">1 目标问题</h4><p>在数据有限的情况下，使用合成图像或少量真实图像来训练一个6D物体姿态估计的模型</p><h4 id="2-方法-6">2 方法</h4><ul><li>首先，利用合成图像和真实图像（如果有的话）来训练一个基于深度学习的特征提取器，用于从输入图像中提取出与物体姿态相关的特征。</li><li>然后，利用合成图像和真实图像（如果有的话）来训练一个基于透视流（perspective flow）的模块，用于将输入图像中的特征点映射到目标物体模型上。透视流是指由于相机和物体之间相对运动而导致的特征点在不同视角下的位移。</li><li>最后，利用一种称为透视流聚合（perspective flow aggregation）的技术，将多个透视流进行融合，并通过最小二乘法求解出最优的6D物体姿态。</li></ul><h4 id="3-思考-6">3 思考</h4><p>投影透视方法。</p><h2 id="04-Learning-Based-Point-Cloud-Registration-for-6D-Object-Pose-Estimation-in-the-Real-World">04. Learning-Based Point Cloud Registration for 6D Object Pose Estimation in the Real World</h2><blockquote><p><strong>期刊 / 会议</strong>：ECCV2022<br><strong>作者 / 机构</strong>：Zheng Dang, CVLab, EPFL, Lausanne, Switzerland<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/AnsonYanxin/MatchNorm">https://github.com/AnsonYanxin/MatchNorm</a><br><strong>数据集</strong>：LINEMOD</p></blockquote><h4 id="1-目标问题-7">1 目标问题</h4><h4 id="2-方法-7">2 方法</h4><ul><li>首先，它提出了一种基于深度学习的点云匹配模块，用于从源点云和目标点云中提取特征，并计算两个点云之间的相似度矩阵。</li><li>然后，它提出了一种基于归一化的点云对齐模块，用于根据相似度矩阵找到最佳的刚性变换矩阵，使得源点云和目标点云之间的距离最小化</li></ul><h4 id="3-思考-7">3 思考</h4><p>代码不完全。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> ECCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】CVPR2020-2022 6D位姿估计相关论文</title>
      <link href="/post/afed67af.html"/>
      <url>/post/afed67af.html</url>
      
        <content type="html"><![CDATA[<h1>CVPR 2020</h1><h2 id="01-HybridPose-6D-Object-Pose-Estimation-under-Hybrid-Representations">01. HybridPose: 6D Object Pose Estimation under Hybrid Representations</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2020<br><strong>作者 / 机构</strong>：Chen Song, The University of Texas at Austin<br><strong>关键词</strong>：位姿估计；混合特征<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/chensong1995/HybridPose">https://github.com/chensong1995/HybridPose</a></p></blockquote><h3 id="1-目标问题-9">1 目标问题</h3><p>6D位姿估计</p><h3 id="2-方法-9">2 方法</h3><p><img src="https://img.mahaofei.com/img/20230315170643.png" alt=""></p><p>算法由中间特征预测网络和姿态回归网络组成：</p><p><strong>（1）预测模块</strong></p><p>将图像作为输入，用三个预测网络输出预测的关键点、边缘向量和对称对应关系</p><ul><li>关键点：利用PVNet的关键点预测方法</li><li>边缘向量：每两个关键点之间的向量</li><li>对称对应关系：扩展了FlowNet网络，结合了像素流和语义掩码</li></ul><p><strong>（2）姿态回归模块</strong></p><p>姿态回归网络：包括初始化子模块和优化子模块</p><ul><li>初始化子模块：使用中间特征回归初始姿态</li><li>优化子模块：使用GM鲁棒范数并优化，获得最终姿态</li></ul><h3 id="3-思考-9">3 思考</h3><p>方法比较直观，使用关键点、关键点向量和对称关系进行姿态预测。</p><p>但是实际应用比较困难，训练前需要使用FSP生成关键点标签、使用SymSeg生成对称性标签，并且还要提供分割模板。而且还需要PVNet的融合数据。</p><hr><h2 id="02-Single-Stage-6D-Object-Pose-Estimation">02. Single-Stage 6D Object Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2020<br><strong>作者 / 机构</strong>：Yinlin Hu, CVLab, EPFL, Switzerland<br><strong>关键词</strong>：位姿估计；单阶段<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/cvlab-epfl/single-stage-pose">https://github.com/cvlab-epfl/single-stage-pose</a></p></blockquote><h3 id="1-目标问题-10">1 目标问题</h3><p>提出一种单阶段框架，解决两阶段框架（先建立3D对象关键点和2D图像的对应关系然后回归）的缺点，加快训练速度。</p><h3 id="2-方法-10">2 方法</h3><p><img src="https://img.mahaofei.com/img/20230316095154.png" alt=""></p><p>通过一些实例分割网络建立了3D物体和2D图像的关系后，使用三个主要模块来直接从这些对应聚类预测位姿：</p><ul><li><p>局部特征提取模块</p></li><li><p>特征聚合模块：在不同聚类中聚合特征</p></li><li><p>全局推理模块：有全连接层组成，用于将最终姿态估计为四元数和平移</p></li><li><p>提出了一种新颖的<strong>投影分布</strong>（Projection Distribution）表示法，将三维物体关键点在二维图像上的投影建模为一个概率分布，而不是一个确定的位置。</p></li><li><p>设计了一个<strong>单阶段6D姿态估计网络</strong>（Single-Stage 6D Pose Estimation Network），利用卷积神经网络和全连接层来预测每个物体关键点在图像上的投影分布参数。</p></li><li><p>采用了一种<strong>最大似然估计</strong>（Maximum Likelihood Estimation）方法，根据预测的投影分布参数和已知的三维物体模型来直接计算物体在相机坐标系下的旋转矩阵和平移向量。</p></li></ul><h3 id="3-思考-10">3 思考</h3><p>似乎需要与其它网络结合，从其他网络的中间层进行特征提取。</p><p>Github资料较少。</p><hr><h2 id="03-G2L-Net-Global-to-Local-Network-for-Real-time-6D-Pose-Estimation-with-Embedding-Vector-Features">03. G2L-Net: Global to Local Network for Real-time 6D Pose Estimation with Embedding Vector Features</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2020<br><strong>作者 / 机构</strong>：Wei Chen, School of Computer Science, University of Birmingham<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2020<br><strong>代码</strong>：<a href="https://github.com/DC1991/G2L_Net">https://github.com/DC1991/G2L_Net</a></p></blockquote><h3 id="1-目标问题-11">1 目标问题</h3><p>提高位姿估计算法的准确度和速度。</p><h3 id="2-方法-11">2 方法</h3><p><img src="https://img.mahaofei.com/img/20230316101524.png" alt=""></p><p><strong>（1）全局定位</strong></p><p>使用2D检测器（例如yolo）来预测目标的边界框和标签，并将得到的概率图中的最大概率位置作为球体中心（结合深度图的3D坐标），来获得一个球体空间，减少后续3D搜索空间。</p><p><strong>（2）平移定位</strong></p><p>进行3D分割和平移残差预测，并将对象点的坐标系转换为局部规范坐标系。</p><p><strong>（3）旋转定位</strong></p><p>使用逐点嵌入向量特征提取器来提取嵌入向量特征，然后输入解码器回归出输入点云的旋转。</p><h3 id="3-思考-11">3 思考</h3><p>相当于将DenseFusion的实例分割先验步骤进行了替换，使用了yolo+点云分割来代替。最后的特征还是逐点特征。</p><h1>CVPR2021</h1><h2 id="01-GDR-Net-Geometry-Guided-Direct-Regression-Network-for-Monocular-6D-Object-Pose-Estimation">01. GDR-Net: Geometry-Guided Direct Regression Network for Monocular 6D Object Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2021<br><strong>作者 / 机构</strong>：Gu Wang,  Tsinghua University, BNRist<br><strong>关键词</strong>：位姿估计；端到端<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/THU-DA-6D-Pose-Group/GDR-Net">https://github.com/THU-DA-6D-Pose-Group/GDR-Net</a></p></blockquote><h3 id="1-目标问题-12">1 目标问题</h3><p>提出一种端到端的位姿估计算法。</p><h3 id="2-方法-12">2 方法</h3><p><img src="https://img.mahaofei.com/img/20230316104020.png" alt=""></p><p><strong>（1）网络架构</strong></p><p>首先向GDR-Net提供256x256的ROI图，预测出三个64x64的中间特征图</p><ul><li>稠密对应图$M_{2D-3D}$：将稠密坐标映射$M_{XYZ}$对跌倒2D像素坐标上得到，反映了对象的几何形状信息。</li><li>表面区域注意图$M_{SRA}$：采用最远点采样从$M_{XYZ}$中到处，代表了对象的对称性。</li><li>可见对象掩码$M_{vis}$</li></ul><p>使用一个简单的2D卷积Patch Pnp模块直接从特征图中回归6D对象姿态。Patch PnP模块由三个卷积层组成，然后用两个全连接层用于扁平化特征，最后连个全连接层输出R6D旋转和tSITE平移。</p><h3 id="3-思考-12">3 思考</h3><p>本文专注于图像的特征提取和处理工作，实现从单一图片预测位姿的功能。方法不够直观。</p><h2 id="02-FS-Net-Fast-Shape-based-Network-for-Category-Level-6D-Object-Pose-Estimation-with-Decoupled-Rotation-Mechanism">02. FS-Net: Fast Shape-based Network for Category-Level 6D Object Pose Estimation with Decoupled Rotation Mechanism</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2021<br><strong>作者 / 机构</strong>：Wei Chen, School of Computer Science, University of Birmingham<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2021<br><strong>代码</strong>：<a href="https://github.com/DC1991/FS_Net">https://github.com/DC1991/FS_Net</a></p></blockquote><h3 id="1-目标问题-13">1 目标问题</h3><p>解决以往类别级姿态特征提取效率低，精度和推理速度低的问题。</p><h3 id="2-方法-13">2 方法</h3><p>设计了一种具有3D图卷积的方向感知自动编码器，用于潜在特征提取。</p><p>提出解耦旋转机制，利用两个解码器互补的访问旋转信息。</p><p>使用两个残差来估计平移。</p><p>提出一种在线box-cage的三维变形机制来增强训练数据。</p><p><img src="https://img.mahaofei.com/img/20230316151555.png" alt=""></p><ol><li>输入RGB图像。</li><li>使用yolov3检测对象的2D位置、类别标签、类概率图，并将最大概率的位置作为3D球体的中心。从而得到目标3D球体点云。</li><li>使用三维变形机制进行数据扩充。</li><li>使用基于形状的3DGC自动编码器来进行点云分割，用于旋转的潜在特征学习。<br>3DGC由m个单位向量组成，卷积值是核向量和n个最近向量之间的余弦相似度之和。</li><li>从潜在特征中将旋转信息解码为两个垂直向量。</li><li>利用残差估计网络预测平移。</li></ol><h3 id="3-思考-13">3 思考</h3><p>提出的使用三维变形机制进行数据扩充很有意思，或许后续很多方法都可以加上这个步骤，使得算法更具有鲁棒性。</p><p>需要训练yolo模型和FS_Net模型。</p><p><strong>NOCS数据集</strong></p><h1>CVPR2022</h1><h2 id="01-OVE6D-Object-Viewpoint-Encoding-for-Depth-based-6D-Object-Pose-Estimation">01. OVE6D: Object Viewpoint Encoding for Depth-based 6D Object Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Dingding Cai, Tampere University<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/dingdingcai/OVE6D-pose">https://github.com/dingdingcai/OVE6D-pose</a></p></blockquote><h3 id="1-目标问题-14">1 目标问题</h3><p>已知物体的分割掩码，物体的三维mesh模型，预测从物体坐标系到相机坐标系的变换R+T。</p><h3 id="2-方法-14">2 方法</h3><p><strong>（1）训练阶段</strong></p><p>使用ShapeNet中的3D物体模型来训练OVE6D模型，这个阶段只进行一次，得到的模型参数在后续保持固定。</p><p><strong>（2）编码阶段</strong></p><p>将目标物体的3D网络模型转换为view points编码本，这个阶段对每个物体只进行一次。（view points编码本是一个特征向量的集合）</p><p><strong>（3）推理阶段</strong></p><p>从输入的物体深度图像和物体分割掩码中推理物体的6D姿态</p><ol><li>视角估计：将输入图像和物体ID作为输入，通过与view points编码本中的特征向量进行余弦相似度匹配找到最接近的预定义视角，并输出索引和置信度。</li><li>平面旋转估计：输入图像、ID、预定视角索引、置信度，通过卷积神经网络回归出相对于相机坐标系的旋转。</li><li>平移估计：输入图像、ID、预定义视角索引、置信度、平面旋转角度，通过另一个卷积神经网络输出物体的3D位置。</li></ol><h3 id="3-思考-14">3 思考</h3><p>算法需要预先训练好ShapeNet，然后确定一个view points编码本，过程较复杂不够简洁直观。</p><h2 id="02-OnePose-One-Shot-Object-Pose-Estimation-without-CAD-Models">02. OnePose: One-Shot Object Pose Estimation without CAD Models</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Jiaming Sun, Zhejiang University<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/zju3dv/OnePose">https://github.com/zju3dv/OnePose</a></p></blockquote><h3 id="1-目标问题-15">1 目标问题</h3><p>实现不依赖于CAD模型的位姿估计</p><h3 id="2-方法-15">2 方法</h3><p>借鉴了视觉定位的思想，只需要一个简单的RGB视频扫描物体，就可以构建一个稀疏的SfM模型。然后，利用一个通用的特征匹配网络将这个模型与新的查询图像对齐，从而得到物体姿态。</p><p>提出了一种新的图注意力网络（GATs），可以将同一个SfM点对应的2D特征聚合成3D特征，并与查询图像中的2D特征进行自注意力和交叉注意力匹配。</p><p><img src="https://img.mahaofei.com/img/20230316201824.png" alt=""></p><ol><li>对于每一个物体，使用视频扫描得到一组相机姿态以及物体的3D边界框。</li><li>利用SFM重建一个稀疏的点云模型</li><li>SfM的2D-3D对应关系被建立起来</li><li>使用注意力聚合层，将2D描述符聚合到3D描述符</li><li>通过PnP回归计算出物体位姿</li></ol><p><strong>总体实现流程如下</strong></p><ul><li>使用一些AR工具捕获物体数据，包括物体中心位置，尺寸，绕Z州的旋转角，相机姿态等。</li><li>从捕获的视频中提取图像，使用SfM重建稀疏点云，所有的对应图中提取2D关键点和描述符。</li><li>定位时，实时捕获一系列图像，提取2D关键点和描述符进行匹配，从数据库中查询候选图像，从而找到相机姿态。</li></ul><h3 id="3-思考-15">3 思考</h3><p>大概就是创建一个数据库，包括2D图像和重建出的点云，以及相应的2D-3D关键点和描述符，对每一个输入图像提取特征后进行匹配查询。</p><h2 id="03-Focal-Length-and-Object-Pose-Estimation-via-Render-and-Compare">03. Focal Length and Object Pose Estimation via Render and Compare</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Georgy Ponimatkin, LIGM, Ecole des Ponts, Univ Gustave Eiffel, CNRS<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://ponimatkin.github.io/focalpose">https://ponimatkin.github.io/focalpose</a></p></blockquote><h3 id="1-目标问题-16">1 目标问题</h3><p>估计相机参数未知的照片中物体的6D姿态</p><h3 id="2-方法-16">2 方法</h3><ol><li>从一个3D模型库中选择一个与输入图像中物体最匹配的3D模型。</li><li>用一个CNN编码器将输入图像编码成一个特征向量。</li><li>用一个CNN解码器将特征向量解码成一个初始的6D姿态和焦距。</li><li>用渲染引擎根据初始的6D姿态和焦距渲染出一个虚拟视图，并与输入图像进行比较。</li><li>用一个损失函数计算虚拟视图和输入图像之间的差异，并反向传播更新6D姿态和焦距。</li><li>重复步骤4和5直到收敛或达到最大迭代次数。</li></ol><h3 id="3-思考-16">3 思考</h3><p>对于网络图像中物体的位姿估计，不知道实际应用场景是什么。</p><h2 id="04-ES6D-A-Computation-Efficient-and-Symmetry-Aware-6D-Pose-Regression-Framework">04. ES6D: A Computation Efficient and Symmetry-Aware 6D Pose Regression Framework</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Ningkai Mo, ShenZhen Key Lab of Computer Vision and Pattern Recognition<br><strong>关键词</strong>：位姿估计；对称<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/GANWANSHUI/ES6D">https://github.com/GANWANSHUI/ES6D</a></p></blockquote><h3 id="1-目标问题-17">1 目标问题</h3><p>主要解决如何利用RGB-D数据来估计刚体物体的6D姿态，特别是对于具有对称性的物体</p><h3 id="2-方法-17">2 方法</h3><ul><li>设计了一个全卷积的特征提取网络，叫做XYZNet，它可以高效地从RGB和深度图中提取点云特征，并将不同模态的特征融合起来。</li><li>提出了一种新的形状表示方法，叫做分组基元（GP），它只与物体的对称性有关，而忽略了形状的细节。</li><li>基于GP，设计了一种新的姿态距离度量，叫做平均（最大）分组基元距离，或者A(M)GPD。这种度量可以作为损失函数来训练回归网络，并保证网络收敛到正确的姿态。</li></ul><p><img src="https://img.mahaofei.com/img/20230316211632.png" alt=""></p><ol><li>从RGB-D图像生成RGB-XYZ数据。RGB-XYZ数据被馈送到CNN模块以提取局部特征，该局部特征对颜色和几何信息进行编码</li><li>点云特征是通过类似PointNet的CNN模块获得的，并填充到与局部特征相同的大小</li><li>将局部特征和点云特征连接为用于姿态估计的逐点特征</li><li>选择具有最大置信度的姿势作为最终结果</li></ol><h3 id="3-思考-17">3 思考</h3><p>同样是逐点特征，这篇论文提出了XYZNet，可以更高效的提取提取点云和RGB特征，不需要提供掩码图。</p><p>代码只提供T-LESS数据集方法。</p><h2 id="05-GPV-Pose-Category-level-Object-Pose-Estimation-via-Geometry-guided-Point-wise-Voting">05.  GPV-Pose: Category-level Object Pose Estimation via Geometry-guided Point-wise Voting</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：YanDi, Technical University of Munich<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/lolrudy/GPV_Pose">https://github.com/lolrudy/GPV_Pose</a></p></blockquote><h3 id="1-目标问题-18">1 目标问题</h3><p>主要解决了现有方法在处理未见过的物体实例时存在的不确定性和不稳定性的问题</p><h3 id="2-方法-18">2 方法</h3><p><img src="https://img.mahaofei.com/img/20230317093148.png" alt=""></p><ol><li>给定一副RGB-D图像，先使用如Maks-RCNN等方法将物体从深度图中分割出来。</li><li>然后从深度三维点云中抽取1028个点，并将它们输入到GPV-Pose位姿估计网络中。</li><li>由于3DGC对于点云的移动和缩放不敏感，所以以3DGC为主干提取全局和每个点的特征，凭借附加了三个并行分支，用于姿态预测，对称性，和逐点包围盒。</li></ol><p>注：</p><ul><li>3DGC方法首先将输入点云转换为一个k近邻图（kNN graph），其中每个点与其最近的k个邻居相连。使用多层图卷积（Graph Convolution）来提取每个点的局部特征，并使用最大池化（Max Pooling）来提取全局特征。3DGC方法将全局和逐点特征拼接起来，形成一个混合特征向量，用于后续的姿态估计、对称感知重建和点投票模块。</li></ul><h3 id="3-思考-18">3 思考</h3><p><strong>（1）创新点</strong></p><ul><li>引入了一种解耦的置信度驱动旋转表示，允许几何感知恢复相关旋转矩阵</li><li>提出了一种基于点投票的位移估计模块，利用几何约束来生成可靠和精确的位移预测</li><li>在一个端到端可训练的网络中整合这两个模块，并通过一个多任务损失函数进行优化</li></ul><p><strong>（2）与DenseFusion相比</strong></p><p>它们都使用了3D图卷积网络（3DGC）来从输入点云中提取每个点的局部特征，并将其与全局特征拼接起来，形成一个混合特征向量。</p><p>GPV-Pose使用了一种解耦的置信度驱动的旋转表示，可以通过几何关系恢复旋转矩阵，而DenseFusion使用了一种直接预测四元数的方法。</p><p><strong>使用NOCS数据集。</strong></p><h2 id="06-DGECN-A-Depth-Guided-Edge-Convolutional-Network-for-End-to-End-6D-Pose-Estimation">06. DGECN: A Depth-Guided Edge Convolutional Network for End-to-End 6D Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Tuo Cao, School of Computer Science, Wuhan University, Wuhan, Hubei, China<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/maplect/DGECN_CVPR2022">https://github.com/maplect/DGECN_CVPR2022</a></p></blockquote><h3 id="1-目标问题-19">1 目标问题</h3><p>从单目RGB图像中进行位姿估计。</p><h3 id="2-方法-19">2 方法</h3><p><strong>（1）深度细化网络DRN</strong></p><p>两个不同的深度估计网络分别输出深度图DA和DB，计算两个深度图之间的差异，并将差异超过阈值的区域定义为不确定区域。</p><p><strong>（2）特征提取</strong></p><ul><li>深度估计：将彩色图像作为输入，并执行深度图预测</li><li>对象分割：利用分割的掩码，将深度图转换为3D点云，并利用3D特征提取器来提取几何特征</li></ul><p><strong>（3）2D关键点定位</strong></p><p>采用最远点采样（FPS）算法来选择物体表面上的关键点。</p><p><strong>（4）从2D-3D对应关系学习6D位姿</strong></p><p>使用动态图PnP（DG-PnP）算法，通过边缘卷积构建一个图结构，利用2D-3D对应关系中的拓扑信息来直接学习6D姿态</p><h3 id="3-思考-19">3 思考</h3><p><strong>（1）创新点</strong></p><ul><li>用一个深度引导网络同时预测分割和深度图，并用一个深度优化网络（DRN）提高深度图的质量</li><li>根据分割和深度图建立2D-3D对应关系，即将图像上的关键点与3D模型上的点匹配</li><li>提出一个动态图PnP（DG-PnP）算法，通过边缘卷积构建一个图结构，利用2D-3D对应关系中的拓扑信息来直接学习6D姿态</li></ul><p><strong>（2）实用性</strong></p><p>从单目RGB图像进行位姿估计，通过网络回归深度图。</p><h2 id="07-Templates-for-3D-Object-Pose-Estimation-Revisited-Generalization-to-New-Objects-and-Robustness-to-Occlusions">07. Templates for 3D Object Pose Estimation Revisited: Generalization to New Objects and Robustness to Occlusions)</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Van Nguyen Nguyen, LIGM, Ecole des Ponts, Univ Gustave Eiffel, CNRS, France<br><strong>关键词</strong>：位姿估计<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/nv-nguyen/template-pose">https://github.com/nv-nguyen/template-pose</a><br><strong>数据集</strong>：LINEMOD</p></blockquote><h3 id="1-目标问题-20">1 目标问题</h3><p>提出了一种方法，只需要物体的CAD模型，就可以将输入对象匹配到一组模板，即使在部分遮挡的情况下也可以估计3D姿态。</p><h3 id="2-方法-20">2 方法</h3><p><img src="https://img.mahaofei.com/img/20230322150858.png" alt=""></p><p>训练时，使用由真实图像和合成模板组成的对，来计算局部特征，预测两幅图像的相似性。</p><p>然后对于未看到的图像，计算其局部特征，将图像与模板数据库匹配来检索对象姿态。</p><h3 id="3-思考-20">3 思考</h3><p>编码本思想，实用性较强，可尝试。</p><h2 id="08-Coupled-Iterative-Refinement-for-6D-Multi-Object-Pose-Estimation">08. Coupled Iterative Refinement for 6D Multi-Object Pose Estimation</h2><blockquote><p><strong>期刊 / 会议</strong>：CVPR2022<br><strong>作者 / 机构</strong>：Lahav Lipson, Princeton University<br><strong>关键词</strong>：位姿估计；迭代优化<br><strong>时间</strong>：2022<br><strong>代码</strong>：<a href="https://github.com/princeton-vl/Coupled-Iterative-Refinement">https://github.com/princeton-vl/Coupled-Iterative-Refinement</a><br><strong>数据集</strong>：LINEMOD</p></blockquote><h3 id="1-目标问题-21">1 目标问题</h3><p>给定一组已知的RGBD输入，检测每个对象的6D姿态。</p><h3 id="2-方法-21">2 方法</h3><p>算法复杂，迭代优化方法。</p><h3 id="3-思考-21">3 思考</h3><p>代码效果最好，但是代码较为复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> CVPR </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】DenseFusion被引论文丨无代码</title>
      <link href="/post/d3bc13be.html"/>
      <url>/post/d3bc13be.html</url>
      
        <content type="html"><![CDATA[<h1>01. 6D Pose Estimation for Bin-Picking based on Improved Mask R-CNN and DenseFusion</h1><blockquote><p><strong>期刊 / 会议</strong>：26th IEEE International Conference on Emerging Technologies and Factory Automation (ETFA)<br><strong>作者 / 机构</strong>：Hesheng Wang, 上海交通大学<br><strong>关键词</strong>：位姿估计, 实例分割, MaskRCNN, DenseFusion<br><strong>时间</strong>：2021<br><strong>代码</strong>：无</p></blockquote><h2 id="1-目标问题">1 目标问题</h2><p>将实例分割算法和位姿估计算法应用到工业机器人抓取中。</p><h2 id="2-方法">2 方法</h2><p>使用两级神经网络，将输入的RGB-D图像回归出6D位姿。</p><p><img src="https://img.mahaofei.com/img/20230314153950.png" alt=""></p><p><strong>（1）数据集生成</strong></p><p>由于基于学习的算法需要大量的已经标注的数据集，因此本文给出了一种工业零件的虚拟数据集的生成过程。使用Blender进行物理模拟，调整渲染参数，生成多种高质量的RGB图像及分割掩码和6D姿态标签。</p><p><strong>（2）实例分割</strong></p><p>使用ResNeXt与MaskRCNN完成目标检测与实例分割。</p><p><strong>（3）姿态估计</strong></p><p>基于DenseFusion来预测6D位姿，为了提高性能，增加了NonLocal模块，(图中的绿色块)，使得网络可以从提取的特征中学习空间结构特征，并且可以有效地在点特征之间建立连接。（好像没什么用）</p><p><img src="https://img.mahaofei.com/img/1678779913.png" alt=""></p><h2 id="3-思考">3 思考</h2><p>虚拟数据集可辅助提高训练结果的鲁棒性，可尝试。</p><h1>02. A Lightweight Two-End Feature Fusion Network for Object 6D Pose Estimation</h1><blockquote><p><strong>期刊 / 会议</strong>：Machines<br><strong>作者 / 机构</strong>：Ligang Zuo, 北京科技大学<br><strong>关键词</strong>：位姿估计, 特征融合<br><strong>时间</strong>：2022<br><strong>代码</strong>：无代码</p></blockquote><h2 id="1-目标问题-2">1 目标问题</h2><p>提出一种轻量化的位姿估计模型，用于部署在移动设备上。</p><h2 id="2-方法-2">2 方法</h2><ol><li>使用PointnoProblemNet网络提取点云特征</li><li>将点云特征与图像特征进行像素级融合</li><li>利用CNN进行特征提取</li><li>对每个特征进行位姿估计，选择置信度最高的作为最终结果<br>（这不就是DenseFusion的思路吗，只不过把PointNet换成了PointnoProblem）</li></ol><p>使用深度可分离卷积代替标准卷积，即将ResNet特征提取部分换为MobileNetv2，来减少模型参数的数量。</p><h2 id="3-思考-2">3 思考</h2><p>可以考虑尝试使用MobileNetv2特征提取网络，因为所使用的也是移动设备。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> DenseFusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows设置共享文件夹给Ubuntu或其它设备</title>
      <link href="/post/76e8a448.html"/>
      <url>/post/76e8a448.html</url>
      
        <content type="html"><![CDATA[<h1>一、Windows系统设置</h1><p>在需要的位置新建一个文件夹，然后【右键-共享】，将其设置为共享文件夹。</p><p><img src="https://img.mahaofei.com/img/202303111048877.png" alt=""></p><p>然后打开【设置-网络和Internet-高级网络设置-高级共享设置】，设置为如下的形式。<strong>主要是公用网络的两个都要打开，所有网络的共享打开，密码保护关闭</strong></p><p><img src="https://img.mahaofei.com/img/202303111048312.png" alt=""></p><h1>二、Ubuntu系统设置</h1><h2 id="2-1-临时挂载">2.1 临时挂载</h2><p>挂载方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs //192.168.3.67/home/Share ~/Share -o username=&#x27;admin&#x27;,password=&#x27;123456&#x27;,dir_mode=0777,file_mode=0777,vers=2.0</span><br></pre></td></tr></table></figure><h2 id="2-2-自动挂载">2.2 自动挂载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/fstab</span><br></pre></td></tr></table></figure><p>在最后面按照下面的格式添加</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//192.168.1.143/home/Share ~/share cifs defaults,username=admin,password=123456,dir_mode=0777,file_mode=0777,vers=2.0 0 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Windows工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用OneDrive</title>
      <link href="/post/ba007624.html"/>
      <url>/post/ba007624.html</url>
      
        <content type="html"><![CDATA[<h1>安装</h1><p><strong>（1）安装依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential </span><br><span class="line">sudo apt install libcurl4-openssl-dev -y</span><br><span class="line">sudo apt install libsqlite3-dev -y</span><br><span class="line">sudo apt install pkg-config -y</span><br><span class="line">sudo apt install libnotify-dev -y</span><br><span class="line">curl -fsS https://dlang.org/install.sh | bash -s dmd</span><br></pre></td></tr></table></figure><p>运行下面命令激活DMD（注意自己的命令行的输出里面就有这个命令，可能版本号会不一样）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/dlang/dmd-2.082.0/activate</span><br></pre></td></tr></table></figure><p><strong>（2）安装onedrive客户端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/abraunegg/onedrive.git</span><br><span class="line">cd onedrive</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1>使用</h1><p>输入以下命令登录onedrive</p><ul><li>打开终端中的链接，登录自己的微软帐号</li><li>登录完成后，复制浏览器地址栏中的地址，粘贴回终端，按回车确定</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive</span><br></pre></td></tr></table></figure><p>下载config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/onedrive</span><br><span class="line">wget https://raw.githubusercontent.com/abraunegg/onedrive/master/config -O ~/.config/onedrive/config</span><br><span class="line">nano ~/.config/onedrive/config</span><br></pre></td></tr></table></figure><p>取消config文件中的下面几行注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sync_dir = &quot;~/onedrive&quot;</span><br><span class="line">monitor_interval = &quot;60&quot;</span><br></pre></td></tr></table></figure><h1>同步</h1><p>第一次同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --synchronize</span><br></pre></td></tr></table></figure><p>可以看到命令行中开始同步你的Onedrive文件了。</p><p>但是上面的命令只能执行一次同步，如果想要实时同步，需要下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --monitor</span><br></pre></td></tr></table></figure><blockquote><p>参考链接</p><ol><li><a href="https://github.com/abraunegg/onedrive">abraunegg/onedrive</a></li><li><a href="https://www.moerats.com/archives/740/">Rat’s. 适用于Linux的OneDrive客户端，支持VPS和OneDrive之间实时同步/备份</a></li></ol></blockquote><h1>GUI 界面</h1><p>上面实现的看不到实时的同步过程。</p><p>可以考虑下载<a href="https://github.com/bpozdena/OneDriveGUI/releases">OneDriveGUI</a>项目中的AppImage。</p><p>授予可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x OneDriveGUI-1.0.3-x86_64.AppImage</span><br></pre></td></tr></table></figure><p>第一次启动，双击或命令行启动</p><ul><li>可以考虑将<code>OneDriveGUI-1.0.3-x86_64.AppImage</code>移动到一个其它目录，避免以后清理<code>Downloads</code>文件夹时误删</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/【你的路径】/OneDriveGUI-1.0.3-x86_64.AppImage</span><br></pre></td></tr></table></figure><p>选择【Import from existing config】，用户名输入自己的微软帐号，config文件选择刚刚修改的<code>~/.config/onedrive/config</code>这个文件。</p><p>这样就实现了有图形界面的OneDrive，点集左侧小三角即可开始同步。</p><p><img src="https://img.mahaofei.com/img/202312021956583.png" alt="image.png"></p><p>为了更方便，建议<code>/home/mahaofei/Downloads/OneDriveGUI-1.0.3-x86_64.AppImage</code>这行命令添加到开始菜单的【应用启动程序】中，设置为开机自启动。这样每次开机就会自动开始同步Onedrive文件。</p><p><img src="https://img.mahaofei.com/img/202312022032642.png" alt="image.png"></p><h1>替代方法</h1><p>此方法不太推荐，同步速度较慢，而且一旦取消同步本地文件都会清空。</p><h2 id="1-安装OneDriver">1. 安装OneDriver</h2><p>参考项目：<a href="https://github.com/jstaf/onedriver">https://github.com/jstaf/onedriver</a></p><p>根据作者的说明，对于Ubuntu系统，可以直接下载deb文件安装，下载链接为：<a href="https://software.opensuse.org/download.html?project=home%3Ajstaf&amp;package=onedriver">https://software.opensuse.org/download.html?project=home%3Ajstaf&amp;package=onedriver</a></p><p>选择Ubuntu，找到自己的Ubuntu版本，以及amd64/arm64，下载deb安装包并安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i onedriver_0.13.0-1_amd64.deb</span><br></pre></td></tr></table></figure><h1>2. OneDriver使用</h1><p>点击左上角<code>+</code>，选择本地同步文件夹。</p><p>然后输入用户名密码登录自己的OneDrive网盘。</p><p>点击右面的√，勾选系统登录时启动OneDriver。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【浏览器插件】iTab新建标签页</title>
      <link href="/post/999804d5.html"/>
      <url>/post/999804d5.html</url>
      
        <content type="html"><![CDATA[<h1>介绍</h1><p>本人之前很长一段时间都是实用的默认主页，并且只保留一个搜索框使主页尽可能简洁。</p><p>但是后来随着要用的网页越来越多，很多网站记不住经常需要搜索才能找到。</p><p>收藏夹又因为网站太多，我的收藏夹都是文件夹套文件夹套网址。</p><p>正巧看到了这个新建标签页，感觉还不错，有兴趣的可以体验一下，有点像之前用的infinite和青柠，但个人觉得这个更好一些。</p><h1>主页</h1><p>主页侧面是不同的分区，每个分区内可以添加很多不同的图标。</p><p><img src="https://img.mahaofei.com/img/20230310082742.png" alt=""></p><p>有官方给的图标，也可以自定义添加。</p><p><img src="https://img.mahaofei.com/img/20230310082814.png" alt=""></p><h1>其它</h1><p>而且itab支持网页版主页，也就是说，手机edge等无法安装浏览器扩展的应用，可以在设置里将主页改成<a href="https://go.itab.link/">https://go.itab.link/</a>就可以实现手机电脑使用同样的主页了。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 浏览器插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计学习方法笔记04】朴素贝叶斯法</title>
      <link href="/post/7bc6ebb.html"/>
      <url>/post/7bc6ebb.html</url>
      
        <content type="html"><![CDATA[<h1>一、贝叶斯定理</h1><h2 id="1-1-条件概率">1.1 条件概率</h2><p>条件概率属于概率论的内容，指的是已知在情况A的条件下，求发生事件B的概率，即P(B|A)，计算方法如下。</p><p>$$P(B|A)=\frac{P(AB)}{P(A)}$$</p><h2 id="1-2-贝叶斯定理">1.2 贝叶斯定理</h2><p>相对于条件概率，贝叶斯定理是其逆过程。已知发生事件B，求事件发生的情况A的概率，即P(A|B)，计算方法如下，其中分母是全概率公式。</p><p>$$P(A|B)=\frac{P(AB)}{P(B)}=\frac{P(A|B)\cdot P(B)}{P(B|A)\cdot P(A)+P(B|\hat A)\cdot P(\hat A)}$$</p><p>同理推广到分类问题，已知存在K类$c_1,c_2\dots c_k$，给定一个新的实例$x=(x^{(1)},x^{(2)}\dots x^{(n)})$，求该实例点归属于$c_i$类的可能。</p><p>$$P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{P(X=x)}=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{\sum^K_{i=1}P(X=x|Y=c_i)\cdot P(Y=c_i)}$$</p><h2 id="1-3-朴素贝叶斯">1.3 朴素贝叶斯</h2><p>朴素贝叶斯相较于贝叶斯，多了<strong>实例特征之间相互独立</strong>这个条件，这样更便于计算</p><p>即$P(X=x|Y=c_i)=\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)$</p><p>因此</p><p>$$P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)\cdot P(Y=c_i)}{\sum^K_{c_i}P(Y=c_i)\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}$$</p><p>$$P(Y=c_i|X=x)=\frac{P(Y=c_i)\cdot \prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}{\sum^K_{c_i}P(Y=c_i)\prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)}$$</p><p>可以看出$x$属于任何分类$c_i$的概率，其分母都是一样的，因此实际计算时只需要比较分子即可，即</p><p>$$argmax P(Y=c_i)\cdot \prod^n_{j=1}P(X^{(j)}=x^{(j)}|Y=c_i)$$</p><p>通过训练数据集，我们可以得到联合概率分布。</p><h1>二、后验概率最大化准则</h1><h1>三、极大似然估计</h1>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminator终端终结者常用快捷键</title>
      <link href="/post/79fdfcf6.html"/>
      <url>/post/79fdfcf6.html</url>
      
        <content type="html"><![CDATA[<h1>安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install terminator</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20230304085853.png" alt=""></p><h1>快捷键</h1><p><strong>常用快捷键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+O                    //水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端（有按键冲突）</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+Shift+W                    //关闭当前标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="（1）同一个窗口">（1）同一个窗口</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Alt+Up                          //★移动到上面的终端</span><br><span class="line">Alt+Down                        //★移动到下面的终端</span><br><span class="line">Alt+Left                        //★移动到左边的终端</span><br><span class="line">Alt+Right                       //★移动到右边的终端</span><br><span class="line">Ctrl+Shift+O                    //★水平分割终端</span><br><span class="line">Ctrl+Shift+E                    //垂直分割终端（有按键冲突）</span><br><span class="line">Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动</span><br><span class="line">Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动</span><br><span class="line">Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动</span><br><span class="line">Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动</span><br><span class="line">Ctrl+Shift+S                    //隐藏/显示滚动条</span><br><span class="line">Ctrl+Shift+F                    //搜索</span><br><span class="line">Ctrl+Shift+C                    //★复制选中的内容到剪贴板</span><br><span class="line">Ctrl+Shift+V                    //★粘贴剪贴板的内容到此处</span><br><span class="line">Ctrl+Shift+W                    //★关闭当前终端</span><br><span class="line">Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭</span><br><span class="line">Ctrl+Shift+X                    //★最大化显示当前终端</span><br><span class="line">Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大</span><br><span class="line">Ctrl+Shift+N or Ctrl+Tab        //移动到下一个终端</span><br><span class="line">Ctrl+Shift+P or Ctrl+Shift+Tab  //Crtl+Shift+Tab 移动到之前的一个终端</span><br></pre></td></tr></table></figure><h2 id="（2）不同窗口之间">（2）不同窗口之间</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">F11                             //全屏开关</span><br><span class="line">Ctrl+Shift+T                    //打开一个新的标签</span><br><span class="line">Ctrl+PageDown                   //移动到下一个标签</span><br><span class="line">Ctrl+PageUp                     //移动到上一个标签</span><br><span class="line">Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置</span><br><span class="line">Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置</span><br><span class="line">Ctrl+Plus (+)                   //增大字体</span><br><span class="line">Ctrl+Minus (-)                  //减小字体</span><br><span class="line">Ctrl+Zero (0)                   //恢复字体到原始大小</span><br><span class="line">Ctrl+Shift+R                    //重置终端状态</span><br><span class="line">Ctrl+Shift+G                    //重置终端状态并clear屏幕</span><br><span class="line">Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端</span><br><span class="line">Super+Shift+G                   //解除绑定</span><br><span class="line">Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端</span><br><span class="line">Super+Shift+T                   //解除绑定</span><br><span class="line">Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程</span><br><span class="line">Super+i                         //打开一个新窗口，新窗口与原来的窗口使用不同的进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多版本OpenCV共存安装</title>
      <link href="/post/96a605ae.html"/>
      <url>/post/96a605ae.html</url>
      
        <content type="html"><![CDATA[<p>假设此电脑已经安装了opencv4.0，现在需要安装opencv3，（其它版本同理）</p><h1>下载OpenCV并构建库</h1><p>为了避免冲突，在<code>/usr/local/</code>目录中新建<code>opencv3</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /usr/local/opencv3</span><br></pre></td></tr></table></figure><p>照常从<a href="https://opencv.org/releases/">opencv官网</a>中下载另一版本的opencv，使用以下命令build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=RELEASE -DWITH_TBB=ON  -DWITH_V4L=ON -DCMAKE_INSTALL_PREFIX=/usr/local/opencv3 ..  </span><br></pre></td></tr></table></figure><p>进入<code>build</code>文件夹后，你需要输入下面这种格式的cmake指令，<strong>需要根据你的实际情况，对下面的指令参数进行修改，不要复制过去就直接运行。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local/opencv3 -D OPENCV_EXTRA_MODULES_PATH=~/ros/sitepackages/opencv-3.4.2/opencv_contrib/modules/ -DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython2.7 ..</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1>切换opencv版本</h1><p>打开~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure><p>在文件末尾增加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Change OpenCV3</span></span><br><span class="line">export PKG_CONFIG_PATH=/usr/local/opencv3/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/opencv3/lib</span><br></pre></td></tr></table></figure><p>更新~/.bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc </span><br></pre></td></tr></table></figure><p>查询OpenCV版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion opencv</span><br></pre></td></tr></table></figure><p>如果输出3.4.2，就表明配置成功。</p><p><strong>如果想使用之前的版本，在~/.bashrc中注释掉增加的内容，然后source ~/.bashrc即可。</strong></p><p>如果只有一个版本的OpenCV，在CMakeList.txt中使用以下语句即可。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FIND_PACKAGE</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure><p>在OpenCV编译好后，所在目录中会生成OpenCVConfig.cmake文件，这个文件中指定了CMake要去哪里找OpenCV，其.h文件在哪里等。</p><p>存在多版本OpenCV时，需要找到所需版本对应的OpenCVConfig.cmake文件，并将其路径添加到工程的CMakeLists.txt中。<br>示例如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(OpenCV_INCLUDE_DIRS <span class="string">&quot;/usr/local/opencv3/include&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(OpenCV_LIB_DIR <span class="string">&quot;/usr/local/opencv3/lib&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(OpenCV_LIBS opencv_core opencv_highgui opencv_imgproc)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;OpenCV_LIB_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_target_name <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p><ol><li><a href="https://immortalqx.github.io/2021/07/06/opencv-notes-0/">刘权祥. Ubuntu配置OpenCV及多版本OpenCV共存</a></li><li><a href="https://blog.csdn.net/learning_tortosie/article/details/80594399">W_Tortoise. Ubuntu下多版本OpenCV共存和切换</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装与常用命令</title>
      <link href="/post/aa6eef91.html"/>
      <url>/post/aa6eef91.html</url>
      
        <content type="html"><![CDATA[<h1>一、Docker安装</h1><p>如果已经安装使用过Docker，可以跳过。</p><p>先删除旧版的docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>出现这样的信息就是ok的</p><p><img src="https://img.mahaofei.com/img/20230226193326.png" alt=""></p><p>安装一些docker的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><p>设置秘钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置软件源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>可以安装docker了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h1>二、Docker镜像拉取</h1><p>以Autoware为例，拉取了Autoware的官方docker。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/autowarefoundation/autoware.ai/docker.git</span><br><span class="line"><span class="built_in">cd</span> docker/generic/</span><br></pre></td></tr></table></figure><p>如果显卡显存大于4G，且装了CUDA，使用下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./run.sh</span><br></pre></td></tr></table></figure><p>如果没有装cuda，或者显存容量小于4G，或者用上面命令安装出现报错，就不要安装带有CUDA的版本了，使用下面的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./run.sh -c off</span><br></pre></td></tr></table></figure><h1>三、Docker常用命令</h1><p><strong>（1）镜像列表 image</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p><strong>（2）容器列表 container</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>（3）进入特定镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 90e973a21691</span><br></pre></td></tr></table></figure><p><strong>（4）多个终端进入同一个docker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it containerID bash</span><br></pre></td></tr></table></figure><p>这种情况下进入系统后，想要使用ros需要先<code>source /opt/ros/melodic/setup.bash</code></p><p><strong>（5）docker停止</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop containerID</span><br></pre></td></tr></table></figure><p><strong>（6）docker传输文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 本地文件的路径 container_id:&lt;docker容器内的路径&gt;</span><br><span class="line">docker cp container_id:&lt;docker容器内的路径&gt; &lt;本地保存文件的路径&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计学习方法笔记03】k近邻法</title>
      <link href="/post/72393bb6.html"/>
      <url>/post/72393bb6.html</url>
      
        <content type="html"><![CDATA[<h1>一、k近邻算法</h1><h2 id="1-1-算法">1.1 算法</h2><p>k近邻算法，假设给定了一个训练数据集，其中实例类别已定。</p><p>分类时，对新的实例，根据其k个最近邻的训练实例的类别， 通过多数表决等方式进行预测。 因此，k近邻法不具有显式的学习过程。</p><h2 id="1-2-模型">1.2 模型</h2><p>三个基本要素：距离度量、k值、分类决策规则</p><p>一般将特征空间，按照每个训练实例点xi，距离该点比其它点更近的所有点组合成一个单元。每个训练实例点拥有一个单元，单元内所有点都标记上类yi。</p><p>这样特征空间中每个点的类别都是确定的。</p><p><strong>（1）距离</strong></p><p>特征空间中两个实例点的距离一般使用欧式距离，或者更一般的$L_p$距离</p><p>$$L_p(x_i,x_j)=(\sum^n_{l=1}|x^{(l)}_i-x^{(l)}_j|)^{\frac{1}{p}}$$</p><p>其中l=2时为欧式距离，l=1时为曼哈顿距离，l=∞时为各个坐标距离的最大值。</p><p><strong>（2）k值</strong></p><p>如果k值过小，虽然可能会预测的比较准，但预测结果受邻近点影响过大，如果邻近点恰好为噪声，则会预测错误。</p><p>如果k值过大，与输入距离较远的示例也会起到预测作用。</p><p>如果k=N，那么总是输出实例中最多的类。</p><p><strong>（3）分类决策规则</strong></p><p>通常为k个近邻的实例中的最多数类。</p><h1>二、kd-tree</h1><p>在进行预测时，需要在训练数据中进行k近邻搜索，如果使用线性扫描，则需要计算输入点与所有训练实例的距离，速度过慢。</p><h2 id="2-1-构造kd-tree">2.1 构造kd-tree</h2><p>kd-tree的构造相当于不断用垂直于坐标轴的超平面将k维空间切分，每个节点对应一个k维超矩形区域。</p><p>构造过程：</p><ul><li>构造根结点：根结点对应的k维空间包含所有实例点的超矩形区域</li><li>递归切分：在超矩形区域中选择一个坐标轴和此坐标轴上的切分点，确定一个超平面，用此超平面将当前超矩形区域切分为左右两个子区域（子结点）</li><li>重复此过程，直到子区域内没有实例时终止（叶结点）</li></ul><h2 id="2-2-搜索kd-tree">2.2 搜索kd-tree</h2><p>输入：己构造的kd-tree， 目标点x<br>输出：x的最近邻</p><ul><li>在kd树中找出包含目标点x的叶结点：从根结点出发，递归地向下访问kd-tree。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。 直到子结点为叶结点为止。（有点类似二分法）</li><li>以此叶结点为“当前最近点”</li><li>递归地向上回退，在每个结点进行以下操作：<ul><li>如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点”。</li><li>当前最近点一定存在于该结点一个子结点对应的区域。 检査该子结点的父结点的另一子结点对应的区域是否有更近的点。即检査另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点” 间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点， 移动到另一个子结点。接着，递归地进行最近邻搜索；如果不相交， 向上回退。</li></ul></li><li>当回退到根结点时，搜索结束。最后的“当前最近点” 即为x的最近邻点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用内网穿透SakuraFrp远程连接服务器</title>
      <link href="/post/9ed2c32f.html"/>
      <url>/post/9ed2c32f.html</url>
      
        <content type="html"><![CDATA[<h1>Linux端配置</h1><p><strong>（1）ssh配置</strong></p><p>安装ssh服务器与客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install openssh-server</span><br><span class="line">sudo apt -y install openssh-client</span><br></pre></td></tr></table></figure><p>配置ssh客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><ul><li>​将<code>PermitRootLogin prohibt-password</code> 修改为 <code>PermitRootLogin yes</code></li><li>将<code>PasswordAuthentication yes</code> 前的#删除，取消注释</li></ul><p>重启ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>查看ssh服务运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh status</span><br></pre></td></tr></table></figure><p><strong>（2）Sakura配置</strong></p><p><a href="https://www.natfrp.com/user/">SakuraFrp</a></p><p>进入隧道列表新建隧道</p><ul><li>尽量选择国内节点</li><li>隧道类型为TCP隧道</li><li>本机端口为SSH</li><li>主机ip默认127.0.0.1即可(代指内网穿透本机)</li></ul><p><img src="https://img.mahaofei.com/img/20230405140317.png" alt=""></p><p>在官网下载对应版本的frpc，复制下载链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O frpc &lt;下载地址&gt;</span><br><span class="line">chmod 755 frpc</span><br><span class="line">ls -ls frpc</span><br><span class="line">md5sum frpc</span><br><span class="line">frpc -v</span><br></pre></td></tr></table></figure><p>隧道配置文件中复制隧道密钥</p><p>Ubuntu中使用下面的命令开启隧道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc -f &lt;复制的密钥&gt;</span><br></pre></td></tr></table></figure><h1>Windows端配置</h1><p>打开【设置-应用-添加功能】，添加OpenSSH 服务器和OpenSSH 客户端。</p><p>打开服务，找到 OpenSSH SSH Server 和 OpenSSH Authentication Agent -&gt; 启动服务并设为自动。</p><p>打开 power shell，使用以下命令检查安装和运行情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Service sshd</span><br></pre></td></tr></table></figure><p>打开Sakura官网，打开隧道列表，点击要连接的隧道，点击一键认证，下载exe认证程序并运行。</p><p>然后使用<code>ssh -p &lt;端口号&gt; &lt;用户名&gt;@&lt;地址&gt;</code>进行远程连接</p><h1>VSCode远程ssh开发环境</h1><p>安装插件 <code>Remote - SSH</code></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Linux工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计学习方法笔记02】感知机</title>
      <link href="/post/6d27098f.html"/>
      <url>/post/6d27098f.html</url>
      
        <content type="html"><![CDATA[<h1>一、感知机模型</h1><p>感知机是二类分类的线性分类模型，输入为实例的特征向量，输出为实例的类别，旨在求出将训练数据进行线性划分的分离超平面。</p><p>假设输入空间$X\subseteq R^n$，输出空间$Y={+1,-1}$。输入$x\in X$表示实例的特征向量，对应于输入空间的点。输出$y\in Y$表示实例的类别，则输入空间到输出空间的函数：</p><p>$$f(x)=sign(w\cdot x+b)$$</p><p>称为感知机。其中$w$称为权值向量，$b$称为偏置，sign时符号函数sign(x)= {+1(if x&gt;=0), -1(if x&lt;0)}。</p><h1>二、感知机学习策略</h1><h2 id="2-1-数据集的线性可分性">2.1 数据集的线性可分性</h2><p>给定一个数据集，如果存在某个超平面能够将数据集的正实例点和负实例点完全正确的划分到超平面的两侧，则数据集称为线性可分数据集，否则称线性不可分。</p><h2 id="2-2-学习策略">2.2 学习策略</h2><p>输入空间中任意一点$x_0$到超平面S的距离为：$\frac{1}{||w||}|w\cdot x_0+b|$</p><p>因此误分类点到超平面S的距离为：$-\frac{1}{||w||}y_i(w\cdot x_0+b)$</p><p>所有误分类点的总距离，即损失函数为：$L(w,b)=-\sum_{i=0}^M y_i(w\cdot x_0+b)$</p><p>显然损失函数是非负的，感知机的学习策略就是在假设空间中找到使损失函数最小的模型参数$w,b$</p><h2 id="2-3-学习算法">2.3 学习算法</h2><p>感知机的学习算法采用随机梯度下降法。每次随机选取一个误分类点使其梯度下降。</p><p>输入：线性可分数据集T，学习率$\eta$</p><p>输出：感知机模型$w,b$</p><p>（1）选取初值$w_0,b_0$<br>（2）在训练集中选取数据$(x_i,y_i)$<br>（3）如果$y_i(w\cdot x_i+b)\le0$，更新参数$w=w+\eta y_i x_i$，$b=b+\eta y_i$，其中$\eta$为学习率，后项为两个参数的梯度<br>（4）重复上述过程，直到训练集中没有误分类点</p><p>当训练数据集线性可分时，感知机学习算法是收敛的，即经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。</p><h1>三、习题</h1><h2 id="3-1-为什么感知机不能表示异或">3.1 为什么感知机不能表示异或</h2><p>画出训练集的分布情况，易知无法使用一个线性平面将±区域分开。</p><p><img src="https://img.mahaofei.com/img/20221208104808.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【统计学习方法笔记01】统计学习概论</title>
      <link href="/post/fba31b0c.html"/>
      <url>/post/fba31b0c.html</url>
      
        <content type="html"><![CDATA[<h1>一、统计学习</h1><h2 id="1-1-统计学习的概念">1.1 统计学习的概念</h2><p><strong>（1）概念</strong></p><p>统计学习是关于计算机基于数据构建概率统计模型，并运用模型对数据进行预测与分析的一门学科。</p><p>统计学习是计算机系统通过运用数据及统计方法提高系统性能的机器学习。</p><p><strong>（2）对象</strong></p><p>数据，如数字、文字、图像、视频、音频等。</p><p><strong>（3）目的</strong></p><p>从数据出发，提取数据的特征，抽象数据的模型，发现数据的知识，最后回到数据的分析与预测中。</p><h2 id="1-2-统计学习的分类">1.2 统计学习的分类</h2><h3 id="1-2-1-基本分类">1.2.1 基本分类</h3><p><strong>（1）监督学习</strong></p><p>从标注数据中学习预测模型的机器学习问题。即学习从输入到输出的映射的统计规律。</p><ul><li>输入空间与输出空间：输入与输出的所有可能取值。<ul><li>输入变量与输出变量均为连续变量，回归问题</li><li>输出变量为离散变量，分类问题</li><li>输入变量与输出变量均为变量序列，标注问题</li></ul></li><li>特征空间：输入可以用特征向量表示，所有特征向量存在的空间。</li><li>联合概率分布：假设训练数据与测试数据是一句联合概率分布P(X,Y)独立同分布产生的。</li><li>假设空间：由输入到输出的映射的集合。</li></ul><p><strong>（2）无监督学习</strong></p><p>从无标注数据中学习预测模型的机器学习问题。即学习数据的统计规律或潜在结构。</p><ul><li>输入空间与输出空间：模型的输入与输出的所有可能取值的集合。<ul><li>输入是实例，由特征向量表示。</li><li>输出是对输入的分析结果，由输入的类别、转换或概率表示。</li></ul></li><li>假设空间：所有模型z=g(x)的集合，其中X是输入空间，Z是隐式结构空间。</li></ul><p><strong>（3）强化学习</strong></p><p>智能系统在于环境的连续互动中学习最优行为策略的机器学习问题。智能系统观测到与环境互动得到的数据序列，本质是学习最优的序贯决策。</p><p>智能系统与环境的互动过程：每一步$t$，智能系统从环境观测到一个状态$s_t$和奖励$r_t$，采取一个动作$a_t$。环境根据智能系统的动作，确定下一步$t+1$的状态$s_{t+1}$和$r_{t+1}$。使系统实现长期累计奖励的最大化。</p><p>强化学习的马尔可夫决策过程由五元组&lt;S, A, P, r, $\gamma$&gt;组成：</p><ul><li>S：有限状态的集合</li><li>A：有限动作的集合</li><li>P：状态转移概率函数</li><li>r：奖励函数</li><li>$\gamma$：衰减系数</li></ul><p>策略：给定状态下的动作的函数<br>价值函数：策略从某一个状态开始的长期累积奖励的数学期望<br>动作价值函数：策略从某一个状态和动作开始的长期累计奖励的数学期望</p><p><strong>（4）半监督学习与主动学习</strong></p><p>半监督学习：利用标注数据和未标注数据学习预测模型的机器学习问题。</p><p>主动学习：机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。</p><h3 id="1-2-2-按模型分类">1.2.2 按模型分类</h3><p><strong>（1）概率模型与非概率模型</strong></p><ul><li>概率模型：取条件分布形式P(y|x)</li><li>非概率模型：函数形式y=f(x)</li></ul><p><strong>（2）线性模型与非线性模型</strong></p><ul><li>线性模型：感知机、线性支持向量机、k近邻、潜在语义分析</li><li>非线性模型：支持向量机、神经网络</li></ul><p><strong>（3）参数化模型与非参数化模型</strong></p><ul><li>参数化模型：假设模型参数的维度固定，模型可以由有限维参数完全刻画</li><li>非参数化模型：假设模型参数的维度不固定或者无穷大，随着训练数据量的增加而不断增大</li></ul><h3 id="1-2-2-按算法分类">1.2.2 按算法分类</h3><p><strong>（1）在线学习</strong></p><p>每次接受一个样本，进行预测，之后学习模型，并不断重复。</p><p><strong>（2）批量学习</strong></p><p>一次接受所有数据，学习模型，之后进行预测。</p><h3 id="1-2-3-按技巧分类">1.2.3 按技巧分类</h3><p><strong>（1）按贝叶斯学习</strong></p><p>在概率模型的学习和推理中，利用贝叶斯定理，计算在给定数据条件下模型的条件概率，并应用这个原理进行模型的估计。</p><p><strong>（2）核方法</strong></p><p>使用核函数表示和学习非线性模型的一种机器学习方法。</p><h1>二、统计学习的三要素</h1><h2 id="2-1-模型">2.1 模型</h2><ul><li>概率模型：假设空间为条件概率的集合。{f|Y=f(X)}</li><li>非概率模型：假设空间为决策函数的集合。{P|P(Y|X)}</li></ul><h2 id="2-2-策略">2.2 策略</h2><p><strong>（1）损失函数</strong></p><ul><li>0-1损失函数：$L(Y,f(x))=0,1$</li><li>平方损失函数：$L(Y,f(x))=(Y-f(X))^2$</li><li>绝对损失函数：$L(Y,f(x))=|Y-f(X)|$</li><li>对数损失函数：$L(Y,f(x))=-logP(Y|X)$</li></ul><p><strong>（2）风险函数</strong></p><p>损失函数的平均值，或称为期望损失。</p><p>当样本容量足够大时，经验风险最小化有利于保证很好的学习效果。当样本容量较小时，学习效果未必好，可能会产生过拟合。</p><p><strong>（3）结构风险</strong></p><p>结构风险在经验风险上加上表示模型复杂度的正则化项。</p><p>$R(f)=\frac{1}{N}\sum^N_{i=1}L(y_i,f(x_i))+\lambda J(f)$</p><p>其中$J(f)$为模型复杂度，模型越复杂其值越大。常取L1范数$||\omega||_1$或L2范数$\frac{||\omega||^2}{2}$<br>$\lambda$为系数，用于权衡风险函数与模型复杂度。</p><p>结构风险的思想其实就是奥卡姆剃刀原理，即在所有可能的模型函数中，选择能够很好的解释已知数据，并且最简单的模型。</p><h2 id="2-3-算法">2.3 算法</h2><h1>三、泛化能力</h1><p>泛化能力是学习到的模型对未知数据的预测能力。</p><h1>五、生成模型与判别模型</h1><p>极大似然估计：已知一组数据输出，定义该组数据的概率函数，通过求概率函数的极大值点，确定数据输入。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>制作自己的Linemod数据集（ObjectDatasetTools）</title>
      <link href="/post/82de970.html"/>
      <url>/post/82de970.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文过程参考该项目: <a href="https://github.com/F2Wang/ObjectDatasetTools">https://github.com/F2Wang/ObjectDatasetTools</a><br>本文修改和增加的代码已上传至Github: <a href="https://github.com/HaofeiMa/Linemod_Custom">https://github.com/HaofeiMa/Linemod_Custom</a><br>（代码可能不太完善，为demo测试所写，仅供参考）</p></blockquote><h1>介绍</h1><p>这个工具是一个纯python脚本，用来从RGBD相机中创建物体的掩码，边界框标签，3D物体mesh文件。</p><p>该工具可以为各种深度学习项目准备训练和测试数据，例如6D位姿估计、对象检测、实例分割等等。</p><h1>准备工作</h1><p>彩色打印arucomarkers文件夹下的aruco markers标记版，ID1-13，一共三页A4纸。</p><p>将标记一个一个剪下来，贴在物体周围。</p><p><img src="https://img.mahaofei.com/img/20220918100104.png" alt=""></p><p>使用conda新建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n objectdatasettools python=2.7</span><br><span class="line">conda activate objectdatasettools</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake git pkg-config libssl-dev libgl1-mesa-glx</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy Cython==0.19 pypng==0.0.18 scipy scikit-learn open3d==0.9.0 scikit-image tqdm pykdtree opencv-python==3.3.0.10 opencv-contrib-python==3.3.0.10  trimesh==2.38.24</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>ImportError: No module named pip._internal.cli.main</code>问题，则使用下面的指令安装<code>pip</code>。<br><code>python -m ensurepip</code><br><code>pip install --upgrade pip</code></p></blockquote><blockquote><p>如果出现<code>(from ipywidgets-&gt;open3d==0.9.0)</code>相关的问题，使用<code>conda install -c conda-forge ipywidgets</code>安装ipywidgets，然后重新安装依赖open3d</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pyrealsense2</span><br><span class="line"><span class="comment"># 如果过慢，可以使用pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyrealsense2</span></span><br></pre></td></tr></table></figure><h1>录制视频</h1><p><strong>（1）如果有Realsense相机</strong></p><p>使用Realsense相机录制一段物体的视频，<a href="http://xn--record-og8ii8dy87a7nk7p1a8hlv28a.py">对于旧模型使用record.py</a>，对librealsense SDK <a href="http://2.xn--0recordf2-bd9n9724a.py">2.0使用recordf2.py</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python record2.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>默认情况下，脚本在倒计时5后录制40秒，录制时间长度可以在record.py中的第20行进行修改。可以通过按“q”退出录制。</p><p>请稳定移动相机以获得物体的不同视图，同时始终保持 2-3 个标记在相机的视野范围内。</p><p>请注意，该项目假设所有序列都保存在名为“LINEMOD”的文件夹下，使用其他文件夹名称会导致错误发生。</p><p>如果使用record.py创建序列，彩色图像、深度图以及相机参数会自动保存在序列目录下。</p><p><img src="https://img.mahaofei.com/img/20220918154609.png" alt=""></p><p><strong>（2）如果有现有的图像</strong></p><p>如果已有彩色图像或者深度图像，则应将彩色图像（.jpg）放在名为“JPEGImages”的文件夹中，并将对其的深度图像放在“depth”文件夹中。</p><p>注意：该算法假定深度图与彩图对齐。将彩图按顺序从0.jpg、1.jpg、…、600.jpg和相应的深度图命名为：0.png,…,600.png，同时应在序列目录下创建一个名为“intrinsics.json”的文件，并按照如下形式手动输入相机参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;fx&quot;</span><span class="punctuation">:</span> <span class="number">614.4744262695312</span><span class="punctuation">,</span> <span class="attr">&quot;fy&quot;</span><span class="punctuation">:</span> <span class="number">614.4745483398438</span><span class="punctuation">,</span> <span class="attr">&quot;height&quot;</span><span class="punctuation">:</span> <span class="number">480</span><span class="punctuation">,</span> <span class="attr">&quot;width&quot;</span><span class="punctuation">:</span> <span class="number">640</span><span class="punctuation">,</span> <span class="attr">&quot;ppy&quot;</span><span class="punctuation">:</span> <span class="number">233.29214477539062</span><span class="punctuation">,</span> <span class="attr">&quot;ppx&quot;</span><span class="punctuation">:</span> <span class="number">308.8282470703125</span><span class="punctuation">,</span> <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;620201000292&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1>获取帧之间的变换</h1><p>计算第一帧的变换，以制定的间隔（可在config/registrationParameters修改间隔），将变换（4x4矩阵）保存为numpy数组。计算结果保存在<code>LINEMOD/OBJECTNAME/transforms.npy</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python compute_gt_poses.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python compute_gt_poses.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><h1>目标物体三维重建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python register_scene.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>上面代码会原始的registeredScene.ply将保存在指定的目录下（例如，LINEMOD/OBJECTNAME/registeredScene.ply）。registerScene.ply是整个场景的点云，包括桌面、标记纸，物体等等相机中的对象。</p><p><img src="https://img.mahaofei.com/img/20220918154806.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python register_segmented.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>使用上面的代码可跳过手动工作，来删除不需要的背景，并实现物体的三维重建</p><p>register_segmented.py会将物体点云转换为mesh网络。FILLBOTTOM设置为true，算法会自动使用平坦表面填充物体底部。</p><p>但是register_segmented.py可能会失败，这时候需要调整一些参数来使算法可以正常运行。最重要的参数是MAX_RADIUS，如果物体较大，需要增加此值以保证对象不会被截断。</p><p><strong>调整MAX_RADIUS参数，使模型尽可能精准。生成后使用MeshLAB手动删除孤立的点和区域，然后手动保存一次。</strong></p><h1>手动处理点云</h1><p>如果上面的register_segmented.py处理结果比较满意，可以跳过该步骤。</p><p>将生成的点云数据registeredScene.ply使用meshlab打开：</p><ol><li>删除背景</li><li>进行表面重建补全缺失的底部</li><li>处理重建后的网络</li><li>确保处理后的网格没有孤立地噪声</li></ol><p>最终生成mesh网格文件。</p><h1>生成图像掩码和标签文件</h1><p>当完成了物体mesh网格文件的生成后，使用以下程序创建图像掩码和标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_label_files.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python create_label_files.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><p>这一步骤会生成一个名为OBJECTNAME.ply的文件，用meshlab打开此文件，另存为mesh并取消勾选binary，保存的文件就是数据集的<strong>模型文件</strong>。其AABB以原点为圆心，并与OBB的尺寸相同，同时在mask文件夹下会生成图像的掩码，transforms文件夹下会保存新mesh的变换矩阵，labels文件夹内保存标签文件。</p><p>同时将打印出的min_xyz和size_xyz复制到<strong>models_info.yml</strong>文件中。</p><p>使用下面的命令可以检查创建的边界框和掩码的正确性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python inspectMasks.py LINEMOD/OBJECTNAME</span><br></pre></td></tr></table></figure><h1>获得物体比例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getmeshscale.py</span><br></pre></td></tr></table></figure><p>将物体直径复制到<strong>models_info.yml</strong>文件中。</p><h1>创建边界框标签</h1><p>在获取了物体的mask后，使用下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get_BBs.py</span><br></pre></td></tr></table></figure><p>会在根目录创建annotations.csv文件，包含所有图片的物体类别的标签和边界框信息。</p><h1>匹配数据集格式</h1><p>下面4个程序是自己写的，主要用来将生成的linemod数据集进行处理，整理成linemod_processed数据集的格式。</p><p>从<code>annotations.csv</code>中生成<code>gt.yml</code>与<code>info.yml</code>。需要修改每个物体对应的<code>obj_id</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python generate_yml.py LINEMOD/timer</span><br></pre></td></tr></table></figure><p>将图片重命名为如<code>0000.png</code>格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rename.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>根据每个物体的图片数量划分数据集，生成<code>train.txt</code>与<code>test.txt</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python data_divide.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure><p>（将ply文件中的坐标单位由m转为mm），使用meshlab打开<code>objectname.ply</code>文件，删除无效点后保存为<code>objectname_aligned.ply</code>，勾选<code>normal</code>和<code>color</code>，取消勾选<code>binary encoding</code>。</p><p>然后运行下面的指令，将点云文件的单位由m转换为mm：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python plym2mm.py <span class="built_in">all</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> Linemod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】FFB6D</title>
      <link href="/post/d027527.html"/>
      <url>/post/d027527.html</url>
      
        <content type="html"><![CDATA[<h1>一、概述</h1><p>该方法认为RGB图像和深度信息是两个数据源，关键在于如何使两者有机结合。</p><blockquote><p>Our key insight is that appearance information in the RGB image and geometry information from the depth image are two complementary data sources, and it still remains unknown how to fully leverage them.</p></blockquote><p>通过在RGB和深度信息的特征提取网络的每一层中建立<strong>双向融合通道</strong>，这样两个网络可以使用另一个网络的局部和全局特征。</p><blockquote><p>Specifically, at the representation learning stage, we build bidirectional fusion modules in the full flow of the two networks, where fusion is applied to each encoding and decoding layer . In this way, the two networks can leverage local and global complementary information from the other one to obtain better representations.</p></blockquote><p>在网络输出层，设计了考虑纹理和几何信息的<strong>关键点选取算法</strong>，简化了关键点定位，实现了精确的位姿估计。</p><blockquote><p>Moreover , at the output representation stage, we designed a simple but effective 3D keypoints selection algorithm considering the texture and geometry information of objects, which simplifies keypoint localization for precise pose estimation.</p></blockquote><h1>二、FFB6D的流程框图</h1><p><strong>整体流程</strong></p><p><img src="https://img.mahaofei.com/img/20221108111424.png" alt=""></p><p>利用CNN和点云网络分别对RGB和点云进行表示，两个网络的每一层之间通过双向融合模块搭建桥梁。最终提取的逐点特征被送入实例分割模块和3D关键点投票模块，最终回归出物体的6D位姿。</p><p><strong>像素-&gt;点云融合模块</strong></p><p><img src="https://img.mahaofei.com/img/20221108210334.png" alt=""></p><p>RGB特征图部分：对于每一个点云，找到它的空间最近邻点，搜索这些点对应的RGB特征图，通过池化和共享多层感知机将这些特征图生成为一个RGB特征图。</p><p>点云特征部分：直接提取点云特征。</p><p>两者组合成为一组新的RGB-点云特征，交给下一层进行处理。</p><p><strong>点云-&gt;像素融合模块</strong></p><p><img src="https://img.mahaofei.com/img/20221108210504.png" alt=""></p><p>与像素-&gt;点云为对偶处理方式。</p><h1>三、具体实现</h1><h2 id="3-1-总体流程">3.1 总体流程</h2><ul><li>逐点提取RGBD特征，用于每个物体的3D关键点定位<ul><li>CNN网络提取RGB特征</li><li>Point Cloud Net提取点云特征</li><li>两者双向融合</li></ul></li><li>将逐点特征输入到实例分割网络和3D关键点检测模块，提取每个物体的3D关键点</li><li>用最小二乘法拟合姿态参数</li></ul><h2 id="3-2-双向融合网络">3.2 双向融合网络</h2><blockquote><p>Full Flow Bidirectional Fusion Network</p></blockquote><p>在特征提取前首先用相机标定矩阵将深度图转换为点云图。</p><p>网络基本框架是分别用CNN和PCN网络对RGB和点云进行特征提取，并在两个网络之间添加双向通信模块。</p><p><strong>（1）像素-&gt;点云融合 Pixel-to-point fusion</strong></p><p>常规方法是从RGB图中生成图像的全局特征，添加到每一个，但这种方法会引入背景和其他物体的特征，对结果反而造成干扰。</p><p>本文所使用的方法为：</p><ul><li>接受<em>RGBD特征图</em>，对于点云特征图中每一个点云</li><li>找到其在XYZ空间对应的点，以及周围的最近邻点</li><li>找到这些点对应的RGB特征</li><li>将这些RGB特征通过最大池化和多层感知机压缩到一个通道中</li><li>把<em>一个点云特征</em>和<em>一个压缩好的图像特征</em>串联组合成<em>一组RGBD特征向量</em></li><li>同样方法计算所有点的RGBD特征向量，组成传递<em>RGBD特征图</em>给下一层</li></ul><p>注意：由于随深度的增加，特征图的尺寸将会减小，需要采取方法使每一个特征图像素能找到它对应的3D点云坐标。本文采取的方式是<em>在最近邻搜索算法中也使用同样步长的卷积核进行卷积</em>，这样图像特征图和点云特征图就可以对应了。（不将整个点云特征进行同样的卷积是为了避免前景背景深度大幅度变化导致的卷积噪声）</p><p><strong>（2）点云-&gt;像素融合 Point-to-pixel fusion</strong></p><p>与像素-&gt;点云融合类似</p><ul><li>接受<em>RGBD特征图</em>，对于RGB特征图中每一个像素</li><li>找到其在XYZ空间对应的点，以及周围的最近邻点</li><li>找到这些点对应的点云特征</li><li>将这些点云特征通过最大池化和多层感知机压缩到一个通道中</li><li>把<em>一个RGB特征</em>和<em>一个压缩好的点云特征</em>串联组合成<em>一组RGBD特征向量</em></li><li>同样方法计算所有点的RGBD特征向量，组成传递<em>RGBD特征图</em>给下一层</li></ul><h2 id="3-3-基于3D关键点的6D位姿估计">3.3 基于3D关键点的6D位姿估计</h2><p>该部分延续了PVN3D的3D关键点算法，进行了优化使算法能够充分利用图像和纹理信息。</p><p><strong>（1）逐对象的3D关键点检测</strong></p><p>通过实例语义分割模块来区分不同的对象，包括语义分割和中心点投票两个子模块。</p><ul><li>前者用于预测每个点的语义标签</li><li>后者计算每个点到对象中心的距离。</li></ul><p>通过添加关键点投票模块来恢复每个对象的3D关键点。学习选定的关键点（利用MeanShift聚类方式）的逐点偏移来实现。</p><p><strong>（2）关键点选择</strong></p><p>以前的方法是在物体表面通过最远点采样算法FPS，首<em>先确定一组随机点</em>，然后再物体表面逐个找到FPS最远点并加入到序列中，直到点数量到达N。<br>这种方法有时会随机到没有特征的平坦表面，得到的关键点反而没有特征。</p><p>本文提出了SIFT-FPS方法，通过<em>在二维平面中用SIFT算法找到特征点，作为初始序列</em>，然后使用FPS找到N个关键点。</p><p><strong>（3）最小二乘拟合</strong></p><p>上面计算的是物体坐标系的3D关键点，即每个关键点相对于物体中心的偏移量。</p><p>我们又有相机中每个点的3D关键点对应的点云坐标。</p><p>通过最小二乘拟合我们就可以计算物体的位姿了。</p><h2 id="3-4-网络体系">3.4 网络体系</h2><p><strong>RGB</strong>：使用ImageNet预训练的ResNet34作为RGB的编码器，使用PSPNet作为解码器</p><p><strong>PointCloud</strong>：从深度图中抽取了12288个点，使用RandLA-Net进行学习。</p><p>上述两个网络的编解码层，利用最大池化和共享MLP构建双向融合模块。</p><p><strong>常规优化</strong>：语义分割分支使用Focal Loss，中心点投票和3D关键点投票使用L1 Loss。</p><p><strong>SIFT-FPS</strong>：将目标物体放在球体的中心，并等距采样摄像机的视点，通过渲染引擎获得带有相机姿态的RGBD图像，然后使用SIFT检测2D关键点，并转换到3D，在转换为相机坐标系。<br>（应该是使用mesh模型获取RGBD图像和关键点）</p><h1>总结</h1><p>相比于DenseFusion，我认为FFB6D通过一些rgb工作做了很有用的改进。</p><p>首先DenseFusion是利用CNN和PCN单独提取RGB和点云的特征，再加上全局特征，三者合并组合成一个点的特征，然后进行姿态预测。</p><p>而FFB6D相当于在特征提取阶段就将RGB和点云信息进行了融合，然后进行实例分割和关键点检测。</p><p>用不恰当的比喻，类比到2D图像识别中：<br>DenseFusion是从用一个网络提取每个点的X方向特征，再用一个网络提取每个点的Y方向特征，在提取整张图的全局特征，三者串在一起就是一个点的特征向量，用这个特征向量再进行回归计算。<br>FFB6D是在每一个点上，在一个网络中每层都同时看X方向和Y方向的特征，得到的也是两者组合的特征。</p><p>特征的含义：同样类比与二维图像识别，例如人脸识别，前几层每个特征图提取的是局部特征，例如边界线，角点，中间几层特征图得到的是部分特征，例如嘴角，眼睛，鼻子等，最后几层特征图得到的是整体特征，每个特征图中基本都包含一个人脸。此处也类似，使用点特征也就对应二维的像素，前几层提取的是局部特征，就是物体的边、角等，最后几层特征图就会代表物体整体。</p><h1>问题</h1><p>既然有RGB卷积网络，为什么不能有4通道卷积，类比于图像处理，直接将RGBD通过一个卷积核得到一个数字，将D也作为一个通道，这样是否有效？</p><hr><hr><h1>代码复现</h1><h2 id="1-安装">1 安装</h2><h2 id="1-1-准备工作">1.1 准备工作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethnhe/FFB6D.git</span><br></pre></td></tr></table></figure><h2 id="1-2-环境搭建">1.2 环境搭建</h2><p><strong>创建虚拟环境</strong>（据说3.6可以正常使用，3.8无法成功）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n ffb6d python=3.6</span><br><span class="line">conda activate ffb6d</span><br></pre></td></tr></table></figure><p>修改<code>requirement.txt</code>，将<code>yaml</code>改为<code>pyyaml</code>，删除<code>pprint</code>和<code>glumpy</code>，并在最后添加下面这些包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tqdm  </span><br><span class="line">tensorboardX  </span><br><span class="line">pandas  </span><br><span class="line">scikit-learn  </span><br><span class="line">termcolor</span><br><span class="line">packaging</span><br></pre></td></tr></table></figure><p>然后<strong>安装依赖</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirement.txt</span><br><span class="line">pip3 install glumpy</span><br></pre></td></tr></table></figure><p><strong>安装apex</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/NVIDIA/apex</span><br><span class="line"><span class="built_in">cd</span> apex</span><br><span class="line"><span class="built_in">export</span> TORCH_CUDA_ARCH_LIST=<span class="string">&quot;6.0;6.1;6.2;7.0;7.5&quot;</span>  <span class="comment"># set the target architecture manually, suggested in issue https://github.com/NVIDIA/apex/issues/605#issuecomment-554453001</span></span><br><span class="line">pip3 install -v --disable-pip-version-check --no-cache-dir --global-option=<span class="string">&quot;--cpp_ext&quot;</span> --global-option=<span class="string">&quot;--cuda_ext&quot;</span> ./</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>python setup.py egg_info Check the logs for full command output</code>的错误<br>使用<code>python setup.py install -v</code>安装</p></blockquote><p><strong>安装normalSpeed</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hfutcgncas/normalSpeed.git</span><br><span class="line"><span class="built_in">cd</span> normalSpeed/normalSpeed</span><br><span class="line">python3 setup.py install --user</span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure><p><strong>安装tkinter</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-tk</span><br></pre></td></tr></table></figure><p><strong>编译RandLA-Net</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffb6d/models/RandLA/</span><br><span class="line">sh compile_op.sh</span><br></pre></td></tr></table></figure><h2 id="2-数据准备">2 数据准备</h2><ul><li><a href="https://hkustconnect-my.sharepoint.com/:u:/g/personal/yhebk_connect_ust_hk/ETW6iYHDbo1OsIbNJbyNBkABF7uJsuerB6c0pAiiIv6AHw?e=eXM1UE">LineMOD数据集</a></li><li><a href="https://rse-lab.cs.washington.edu/projects/posecnn/">YCB-Video数据集</a></li></ul><h2 id="3-训练、评估与可视化">3 训练、评估与可视化</h2><h2 id="4-自己的数据集">4 自己的数据集</h2><h3 id="4-1-生成mesh信息">4.1 生成mesh信息</h3><p><strong>（1）安装raster_triangle进行RGBD图像渲染</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ethnhe/raster_triangle.git</span><br><span class="line"><span class="built_in">cd</span> raster_triangle</span><br><span class="line">sh rastertriangle_so.sh</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>fatal error: opencv2/highgui/highgui.hpp: No such file or directory</code><br>修改<code>rastertriangle_so.sh</code>文件中<code>-I</code>部分为<code>-I /usr/include/opencv4</code></p><p>修改后如下:<br><code>g++ rastertriangle_so.cpp -o rastertriangle_so.so -shared -fPIC -Wall -I /usr/include/opencv4 -L/usr/lib/x86_64-linux-gnu -lopencv_stitching -lopencv_objdetect -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_video -lopencv_photo -lopencv_ml -lopencv_imgproc -lopencv_flann -lopencv_core</code></p></blockquote><p><strong>（2）编译FPS脚本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffb6d/utils/dataset_tools/fps/</span><br><span class="line">python3 setup.py build_ext --inplace</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p><strong>（3）安装python依赖</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirement.txt</span><br></pre></td></tr></table></figure><p><strong>（4）生成物体的信息，如半径、3D关键点等</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 gen_obj_info.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>如果使用ply模型，并且角点颜色信息包含在ply模型中，可以使用默认raster triangle来渲染。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以ape物体为例</span></span><br><span class="line"><span class="comment"># 需要根据情况设置单位参数scale2m，使生成的信息都以m为单位</span></span><br><span class="line">python3 gen_obj_info.py --obj_name=<span class="string">&#x27;ape&#x27;</span> --obj_pth=<span class="string">&#x27;example_mesh/ape.ply&#x27;</span> --scale2m=1000. --sv_fd=<span class="string">&#x27;ape_info&#x27;</span></span><br></pre></td></tr></table></figure><p>如果使用obj模型，可以将每一个角点转换为米为单位，然后使用pyrender。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以cracker box物体为例</span></span><br><span class="line">python3 gen_obj_info.py --obj_name=<span class="string">&#x27;cracker_box&#x27;</span> --obj_pth=<span class="string">&#x27;example_mesh/003_cracker_box/textured.obj&#x27;</span> --scale2m=1. --sv_fd=<span class="string">&#x27;cracker_box_info&#x27;</span> --use_pyrender</span><br></pre></td></tr></table></figure><blockquote><p><strong>bug：需要python3.8</strong></p></blockquote><h3 id="4-2-修改数据集信息">4.2 修改数据集信息</h3><p>先将<code>FFB6D/ffb6d/common.py</code>文件复制备份一个。</p><p>然后修改<code>FFB6D/ffb6d/common.py</code>文件内容。</p><h3 id="4-3-编写数据集预处理脚本">4.3 编写数据集预处理脚本</h3><p>参考<code>FFB6D/ffb6d/datasets/ycb/ycb_dataset.py</code>，注意要正确修改调用模型信息的函数，例如3D关键点、中心点、半径等。</p><h3 id="4-4-检查数据集预处理情况（非常重要）">4.4 检查数据集预处理情况（非常重要）</h3><p>通过可视化检查是否正确处理了数据，例如投影的关键点、中心点、每个点的语义标签等是否正确。</p><p>例如可以运行<code>python3 -m datasets.ycb.ycb_dataset</code>来可视化投影的中心点和所选的关键点。</p><h3 id="4-5-确保数据能被正确加载">4.5 确保数据能被正确加载</h3><p>检查<code>FFB6D/ffb6d/utils/pvn3d_eval_utils.py</code>中能否正确在物体坐标系中加载关键点、中心点、半径等信息。</p><h3 id="4-6-检查所有设置是否正确">4.6 检查所有设置是否正确</h3><p>利用ground_truth数据进行评估，检查所有设置是否正确，如果正确，结果应该接近100。</p><p>例如将<code>-test_gt</code>参数传给<code>train_ycb.py</code>，就可以获得YCB数据集的ground_truth结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tst_mdl=train_log/ycb/checkpoints/FFB6D_best.pth.tar</span><br><span class="line">python3 -m torch.distributed.launch --nproc_per_node=1 train_ycb.py --gpu <span class="string">&#x27;0&#x27;</span> -eval_net -checkpoint <span class="variable">$tst_mdl</span> -<span class="built_in">test</span> -test_pose -test_gt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】DenseFusion</title>
      <link href="/post/362c6c6a.html"/>
      <url>/post/362c6c6a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>标题</strong>：DenseFusion: 6D Object Pose Estimation by Iterative Dense Fusion<br><strong>作者团队</strong>：斯坦福大学（李飞飞）<br><strong>期刊会议</strong>：CVPR<br><strong>时间</strong>：2019<br><strong>代码</strong>：<a href="https://sites.google.com/view/densefusion/">https://sites.google.com/view/densefusion/</a></p></blockquote><h1>介绍</h1><p>以前的位姿估计工作，要么单独提取RGB和深度图，要么使用了昂贵的后处理过程，例如posecnn，这使得算法在聚集场景的应用与实时性受到了很大的限制。</p><p>本文提出了一种异形架构，对两个数据源（RGB和深度图）进行分别处理，并用一种新型的dense fusion network提取像素级稠密特征，从中估计姿态。</p><p>此外本文还提出了一种端到端的姿态优化步骤，进一步改善了估计过程，可以实现接近实时的判断。</p><h1>模型</h1><p>本文的模型是为了从一系列RGBD图像中估计物体的6D位姿。为了不丧失一般性，6D位姿使用齐次变换矩阵表示，即旋转矩阵$R\in SO(3)$和平移矩阵$T\in \mathbb R^3$。并且，由于物体的6D位姿来自相机，因此结果都是相对相机参考系。</p><p>本文的关键是如何从不同的两种数据（RGB和深度图）中提取特征，并进行适当的融合。</p><h2 id="总体架构">总体架构</h2><p>总体架构主要分为两个阶段：</p><ol><li>第一阶段：对RGB图进行语义分割，分割出所有已知的目标物体。然后将掩码对应的图像，以及深度像素送入第二阶段。</li><li>第二阶段：加工分割的结果，并估计物体的6D位姿。该阶段包含以下组件<ul><li>一个全卷积网络，处理颜色信息，并将裁减的图像中每个像素映射到一个颜色特征向量</li><li>一个基于PointNet的点云处理网络，将掩码对应的点云处理为一个几何特征向量</li><li>一个融合上面两个特征向量的像素级融合网络，并基于无监督置信度评分输出物体的6D位姿估计</li><li>一种迭代自优化方法，以学习的方式训练网络并迭代优化估计结果</li></ul></li></ol><p><img src="https://img.mahaofei.com/img/20220912191133.png" alt="网络结构"></p><p><img src="https://img.mahaofei.com/img/20220912194924.png" alt="迭代自优化方法"></p><h2 id="语义分割">语义分割</h2><p>语义分割网络，将图像作为输入，生成一个N+1通道的语义分割图（背景+N个物体分类），每个通道都是二维掩码。</p><p>本文使用的是现有的语义分割架构，由PoseCNN所提出的语义分割分支。</p><h2 id="稠密特征提取">稠密特征提取</h2><p>对于颜色信息和深度信息，本文分别单独处理它们，从特征向量中获得颜色和几何特征。</p><p><strong>(1)稠密3D点云特征</strong></p><p>以往方法通常将深度信息作为图像的额外通道进行处理，但这样会忽视隐含在深度通道的3D结构信息。因此本文将掩码分割出的深度像素转换为点云，然后使用类PointNet结构提取几何特征。</p><p>PointNet将原始点云作为输入，然后学习将每个点附近的信息和点云作为整体进行编码。本文提出了一个几何特征网络，通过映射每个分割点云的点到一个特征图中，来生成一个密集的逐点特征。</p><p><strong>(2)稠密颜色特征</strong></p><p>图像特征生成网络是一个基于CNN的编码解码架构，将图像$(H, W, 3)$映射为$(H, W, d_{rgb})$，每个像素点的特征向量代表了输入图像中该点的外观信息。</p><h2 id="像素级特征融合">像素级特征融合</h2><p>关键思想是进行局部的主像素融合，而不是全局融合，这样我们可以基于每个融合后的特征进行预测。这样我们就可以选择物体的可见部分进行预测，从而减少了遮挡和语义分割的噪声的影响。</p><p>首先，利用相机固有参数投影到图像平面，将每个点的几何特征与图像特征关联起来。将配对的特征送入另一个网络，利用对陈下降函数来产生固定大小的全局特征，用来丰富每个像素级特征。</p><p>然后将每个像素特征输入到一个最终的网络来预测物体的6D位姿。这个网络用来从每个密集的融合特征预测一个姿态，最终获得P个姿态。</p><p>同时网络还输出每个预测姿态的置信度，用来评价那个姿态估计的结果最好。</p><h2 id="损失函数">损失函数</h2><p>损失函数的设计与PoseCNN类似。</p><p>本文将损失函数定义为真实位姿的模型的采样点与预测位姿的模型的对应点之间的距离。</p><p><img src="https://img.mahaofei.com/img/20220912210553.png" alt=""></p><p>对于对称物体，损失函数定义为预测模型上每个点与真实位姿上最近的点之间的距离。</p><p><img src="https://img.mahaofei.com/img/20220912210610.png" alt=""></p><p>此外，由于每个像素的预测结果也同时输出了置信度，因此利用此置信度，对每个像素的损失进行加权。</p><p><img src="https://img.mahaofei.com/img/20220912210624.png" alt=""></p><h2 id="迭代优化">迭代优化</h2><p>以往的位姿估计算法，通常采用ICP来优化。但ICP的实时性不足够满足实际应用。</p><p>本文提出了一种基于神经网络的迭代优化方法，利用稠密融合的特征，可以改善最终的姿态估计结果，使其具有鲁棒性和快速性。</p><p>由于这个网络的作用是优化位姿估计的结果以减小误差，因此需要将上一个迭代的预测结果作为下一个迭代的输入的一部分。</p><p>该方法将先前的预测的姿态作为目标对象坐标系的估计，并将输入的点云转换为估计的坐标系中，通过这种方式转换的点云，就隐含了上一步估计的位姿。然后将转换后的点云输入到网络中，根据之前估计的位姿预测余项，通过不断迭代获得更精确的姿态估计。</p><h1>问题</h1><ol><li><p>new_target和new_points是当前点云经过逆变换的点，这个点代表了什么</p></li><li><p>PoseNet输入的img是实例分割后的mask区域img，测试时实例分割部分如何实现</p></li></ol><hr><h1>代码实现</h1><blockquote><p>参考：<a href="https://blog.csdn.net/weixin_44564705/article/details/125149491">https://blog.csdn.net/weixin_44564705/article/details/125149491</a></p></blockquote><h2 id="下载代码">下载代码</h2><p>原作者：</p><ul><li>原版：<a href="https://github.com/j96w/DenseFusion">https://github.com/j96w/DenseFusion</a></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/j96w/DenseFusion</span><br></pre></td></tr></table></figure><ul><li>Pytorch-1.0：<a href="https://github.com/j96w/DenseFusion/tree/Pytorch-1.0">https://github.com/j96w/DenseFusion/tree/Pytorch-1.0</a></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b Pytorch-1.0 https://github.com/j96w/DenseFusion</span><br></pre></td></tr></table></figure><p>RTX30系显卡适配：</p><ul><li>darpado构建的代码：<a href="https://github.com/drapado/DenseFusion-1/tree/Pytorch-1.6">https://github.com/drapado/DenseFusion-1/tree/Pytorch-1.6</a></li><li>并按照<a href="https://github.com/j96w/DenseFusion/pull/170#issuecomment-920496824">此评论修改loss_refiner.py</a></li></ul><h2 id="环境搭建">环境搭建</h2><p><strong>（1）创建conda环境</strong></p><p>使用anaconda创建一个虚拟环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name densefusion python=3.6</span><br></pre></td></tr></table></figure><p>激活虚拟环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate densefusion</span><br></pre></td></tr></table></figure><p><strong>（2）配置CUDA和Pytorch</strong></p><p>按照Github博主的Pytorch1.0分支，下载对应的版本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原版</span></span><br><span class="line">conda install pytorch==1.0.0 torchvision==0.2.1 cuda100 -c pytorch</span><br><span class="line"><span class="comment"># 30系</span></span><br><span class="line">conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><p>cuda和pytorch安装后，可以命令行输入<code>python</code>，进入后使用以下代码确认cuda是否可用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">print</span>(torch.__version__)</span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda)</span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available)</span><br></pre></td></tr></table></figure><p><strong>（3）安装依赖</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install trimesh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install scipy pyyaml matplotlib -y</span><br></pre></td></tr></table></figure><h2 id="数据集准备">数据集准备</h2><p>参考：[[05_【数据集制作】制作自己的Linemod数据集（ObjectDatasetTools）]]</p><h2 id="依赖库KNN">依赖库KNN</h2><p>knn需要在自己的环境中进行编译，RTX30系显卡在这一步是会出现各种错误，推荐使用<a href="https://github.com/drapado/DenseFusion-1/tree/Pytorch-1.6">darpado修改的源码</a>，并<a href="https://github.com/j96w/DenseFusion/pull/170#issuecomment-920496824">修改loss_refiner</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lib/knn</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>执行后会在lib/knn路径下出现一个dist文件夹，里面是编译好的.egg文件，将此文件解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line"><span class="comment">#输入你自己的编译文件名</span></span><br><span class="line">unzip knn_pytorch-0.1-py3.6-linux-x86_64.egg</span><br></pre></td></tr></table></figure><p>解压后会在dist文件夹里面生成两个文件夹，进入knn_pytorch文件夹里面，将下面两个文件移动到lib/knn里面：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> knn_pytorch</span><br><span class="line"><span class="built_in">cp</span> knn_pytorch.cpython-36m-x86_64-linux-gnu.so ../../</span><br><span class="line"><span class="built_in">cp</span> knn_pytorch.py ../../</span><br></pre></td></tr></table></figure><h2 id="开始训练">开始训练</h2><p>回到DenseFusion根目录，为sh文件添加可执行权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./experiments/scripts/train_linemode.sh</span><br></pre></td></tr></table></figure><h2 id="可能遇到的错误">可能遇到的错误</h2><ol><li>libgio-2.0.so.0: undefined symbol: g_uri_join while importing cv2 in conda environmnent</li></ol><p>参考：<a href="https://github.com/opencv/opencv/issues/20212">https://github.com/opencv/opencv/issues/20212</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv ~/anaconda3/envs/&lt;anaconda_env&gt;/lib/libgio-2.0.so.0 ~/anaconda3/envs/&lt;anaconda_env&gt;/lib/libgio-2.0.so.0.backup</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> DenseFusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6D位姿估计算法】PVNet</title>
      <link href="/post/9b3d9159.html"/>
      <url>/post/9b3d9159.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>PVNet尚未跑通，暂时放弃。</p></blockquote><blockquote><p><strong>标题</strong>：PVNet: Pixel-Wise Voting Network for 6DoF Pose Estimation<br><strong>作者团队</strong>：浙江大学<br><strong>期刊会议</strong>：CVPR<br><strong>时间</strong>：2018<br><strong>代码</strong>：<a href="https://zju3dv.github.io/pvnet/">https://zju3dv.github.io/pvnet/</a></p></blockquote><h1>环境搭建</h1><p><strong>（1）创建虚拟环境</strong></p><p>创建conda环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pvnet python=3.7</span><br><span class="line">conda activate pvnet</span><br><span class="line"></span><br><span class="line">conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=11.1 -c pytorch -c conda-forge</span><br><span class="line"></span><br><span class="line">pip install Cython==0.28.2</span><br><span class="line">sudo apt-get install libglfw3-dev libglfw3</span><br></pre></td></tr></table></figure><p>注释掉<code>requirement.txt</code>中<code>numpy</code>和<code>ipdb</code>的版本限制，然后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p><strong>（2）编译扩展程序</strong></p><p>创建环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CUDA_HOME=<span class="string">&quot;/usr/local/cuda-11.6&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd lib/cscr</span><br></pre></td></tr></table></figure><p>编译ransac_voting</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ransac_voting</span><br><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>编译nn</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../nn</span><br><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><p>编译fps</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../fps</span><br><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><h1>准备数据集</h1><p>使用Objectdatasettools创建数据集，并按照下面的格式整理：</p><p>整理好后的文件参考：<a href="https://zjueducn-my.sharepoint.com/:u:/g/personal/pengsida_zju_edu_cn/Ec6Hd9j7z4lCiwDhqIwDcScBGPw2rsbn6FJh1C2FwbPJTw?e=xcKGAw">此文件</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── /path/to/dataset</span><br><span class="line">│   ├── model.ply</span><br><span class="line">│   ├── camera.txt</span><br><span class="line">│   ├── diameter.txt  // the object diameter, whose unit is meter</span><br><span class="line">│   ├── rgb/</span><br><span class="line">│   │   ├── 0.jpg</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── 1234.jpg</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   ├── mask/</span><br><span class="line">│   │   ├── 0.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── 1234.png</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   ├── pose/</span><br><span class="line">│   │   ├── pose0.npy</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   ├── pose1234.npy</span><br><span class="line">│   │   ├── ...</span><br><span class="line">│   │   └──</span><br></pre></td></tr></table></figure><p>创建软连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/custom_dataset data/custom</span><br></pre></td></tr></table></figure><p>处理数据集</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run.py --<span class="built_in">type</span> custom</span><br></pre></td></tr></table></figure><blockquote><p>如果出现<code>ValueError: shapes (8,4) and (3,3) not aligned: 4 (dim 1) != 3 (dim 0)</code>的问题<br>修改<code>lib/utils/base_utils</code>第23行如下<br><code>xyz = np.dot(xyz, RT[:3, :3].T) + RT[:3, 3:].T</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6D位姿估计算法】PoseCNN</title>
      <link href="/post/9d61b56.html"/>
      <url>/post/9d61b56.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>标题</strong>：PoseCNN: A Convolutional Neural Network for 6D Object Pose Estimation in Cluttered Scenes<br><strong>作者团队</strong>：NVIDIA, 华盛顿大学<br><strong>期刊会议</strong>：<br><strong>时间</strong>：2018<br><strong>代码</strong>：<a href="https://rse-lab.cs.washington.edu/projects/posecnn/">https://rse-lab.cs.washington.edu/projects/posecnn/</a></p></blockquote><h1>一、介绍</h1><h2 id="1-1-问题提出">1.1 问题提出</h2><p>物体之间的遮挡和聚集增加了6D位姿估计的难度。</p><p>现有方法</p><ul><li>传统基于RGB图像，依赖纹理，无法处理弱纹理物体</li><li>基于RGBD模板，受遮挡影响较大</li><li>2D-&gt;3D的方法无法处理对称物体</li></ul><h2 id="1-2-方法介绍">1.2 方法介绍</h2><p><strong>（1）概述</strong></p><p>PoseCNN（利用RGB图像进行位姿估计，使用RGBD图像进行位姿优化）</p><ul><li>物体的3D位置和到相机的距离通过计算图像中物体的中心来估计。</li><li>物体的3D旋转通过回归到四元数来估计。</li></ul><p>提出了一种损失函数解决对称物体的估计。</p><p><strong>（2）思路</strong></p><p>PoseCNN的关键想法：将位姿估计解耦为位置和姿态两个不同的部分，使网络可以对两个系统的独立性和依赖性建模。</p><ul><li>预测每个像素的语义标签</li><li>估计2D图像坐标系下的物体中心</li><li>估计物体中心与相机的距离（利用每个像素语义标签和物体中心位置）</li><li>估计3D位置</li><li>估计3D姿态（通过边界框内物体的四元数）</li></ul><p><strong>（3）对称物体的处理</strong></p><p>由于对称物体在不同角度观测时可能得到同样的结果，无法估计它们的姿态。</p><p>提出ShapeMatch-Loss。</p><h1>二、PoseCNN</h1><p>物体的位姿估计，就是估计物体坐标系与相机坐标系之间的刚性变换SE3，包含旋转R和平移T。T决定了图像中物体的位置和大小，R决定了物体在图像中的形状和纹理。</p><h2 id="2-1-网络简述">2.1 网络简述</h2><p>PoseCNN主要分为两个阶段：</p><ol><li>主干网络：由13个卷积层和4个最大池化层组成，提取特征图。</li><li>将主干网络生成的高为特征图映射到低维。</li><li>进行三个不同的任务估计</li></ol><p><img src="https://img.mahaofei.com/img/20220906220501.png" alt=""></p><h2 id="2-2-语义标签">2.2 语义标签</h2><p>语义标签分支使用了两张特征图，通道数均为512，分辨率分别从原始图像降低了1/8和1/16。</p><p>该分支首先将特征图维度降为64，然后使用反卷积层将1/16图像的分辨率翻倍，获得两个64通道，1/8分辨率的特征图。</p><p>然后将两个特征图相加，在进行反卷积，将分辨率提高8倍，获得与原始图象大小相同的特征图。</p><p>最后对特征图进行卷积层运算，生成像素的语义标签分数。该层的输出有n个通道（n为语义分类数）。训练时使用Softmax交叉商损失函数训练语义标签分支，测试是使用softmax函数计算像素的类概率。</p><h2 id="2-3-3D位置估计">2.3 3D位置估计</h2><p><strong>（1）原理</strong></p><p>通过定位物体在图像中的中心和与相机的距离，估计3D平移。</p><p>原理是，只要获得T在图像上的投影$c=(c_x, c_y)^T$，以及距离$T_z$，就可以计算出$T_x$和$T_y$。</p><p><img src="https://img.mahaofei.com/img/20220907190136.png" alt=""></p><p>其中$f_x$和$f_y$是焦距，$p_x$和$p_y$是像主点。</p><p><strong>（2）确定物体中心</strong></p><p>常规的方法是直接检测中心点，但这样的问题是无法处理物体被遮挡的情况。</p><p>本文利用隐式形状模型的思想，将图像上的每一个像素，回归为3个变量：</p><p><img src="https://img.mahaofei.com/img/20220907191438.png" alt=""></p><p>其中$P=(x, y)$是图像中的一个像素点，$(c_x, c_y)$是物体中心座标点。$n_x$表示$x$方向上，像素点与中心点之间的偏移，并进行归一化处理。$n_y$表示y方向上的偏移，$T_z$表示像素点的预测深度。</p><p>因此需要预测的变量包括$(n_x, n_y, T_z)$。</p><p>由于需要回归三个变量，因此使用了128通道的特征图，最后一个卷积层有3xn通道，n为物体类别数。</p><p><strong>得到了每个像素预测的3个变量后，需要确定物体中心坐标</strong></p><p>引入了霍夫投票机制，将像素级 语义标签结果 和 中心回归结果 作为输入。</p><p>每个像素沿网络预测的射线方向对图像中心位置进行投票。当所有物体类中的像素完成投票后，可以获得所有的投票分数，选取分数最高的位置即为物体中心位置。</p><p><img src="https://img.mahaofei.com/img/20220907193804.png" alt=""></p><p>对于同一图像中有多个同类物体的情况，使用非极大抑制，通过设定阈值来实现分数选择。</p><p>通过以上操作，就可以确定物体中心的三维坐标，其中预测的$T_z$认为是物体内部中心点的距离。</p><h2 id="2-4-3D姿态估计">2.4 3D姿态估计</h2><p><strong>（1）网络结构</strong></p><p>3D旋转估计分支利用了主干网络得到的特征图的ROI区域部分，通过两个池化层，来实现3D回归。</p><p>将所有特征图加在一起，送入三个全连接层中，前两个全连接层维度为4096，最后一个全连接层维度为4xn，其中n为对象类别数，每个对象输出以四元数表示的3D旋转。</p><p><strong>（2）损失函数的设计</strong></p><p>为了回归四元数，设计了两个损失函数。</p><p><strong>PoseLoss（PLoss）</strong></p><p>在3维空间中计算，计算正确模型位姿的点与测量的位姿的点的平均平方距离。</p><p><img src="https://img.mahaofei.com/img/20220907194859.png" alt=""></p><p>其中$M$代表一系列三维模型的点，m为点的个数，$R(\overline q)$和$R(q)$分别代表计算的旋转矩阵和真实的旋转矩阵。</p><p><strong>ShapeMatch-Loss（SLOSS）</strong></p><p>由于PLoss损失函数无法处理对称物体的情况，对于对陈物体来说，会有很多个正确的三维旋转矩阵。</p><p>因此设计了损失函数如下：</p><p><img src="https://img.mahaofei.com/img/20220907195511.png" alt=""></p><p>该损失函数测量的是预测模型上的点与真实模型的最近的点的偏移量。通过这种方式，SLoss不会惩罚对称物体绕对称轴的等效旋转。</p><p>注意：是计算法中不需要在三维空间中计算距离，而是将变换后的点投影到图像上，计算图像空间中的距离（重投影误差）。</p><h1>三、实验</h1><h2 id="3-1-数据集">3.1 数据集</h2><p>在YCB数据集和Occluded-LINEMOD数据集（在LINEMOD数据集中挑选一段物体严重遮挡的视频）进行测试。</p><h2 id="3-2-对比基准">3.2 对比基准</h2><p>由于文章发布时主流的位姿估计方法是将图像像素回归到3D物体坐标。因此作者实现了一个根据PoseCNN网络修改的变体，在网络中直接回归每个像素在物体坐标系的三维坐标，移除了3D旋转预测分支，而是利用语义标签结果和三维物体坐标结果，通过RANSAC恢复6D位姿。</p><h2 id="3-3-改进">3.3 改进</h2><p>当深度可用时，使用ICP算法来优化6D姿态。</p><p><img src="https://img.mahaofei.com/img/20220907202451.png" alt=""></p><h1>四、PoseCNN可视化</h1><blockquote><p>以下内容原作者为<a href="https://blog.csdn.net/weixin_44564705" title="Panpanpan！">Panpanpan！</a><br>分类专栏： <a href="https://blog.csdn.net/weixin_44564705/category_11853299.html">【DenseFusion进阶】</a> 文章标签： <a href="https://so.csdn.net/so/search/s.do?q=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&amp;t=blog&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=">深度学习</a> <a href="https://so.csdn.net/so/search/s.do?q=pytorch&amp;t=blog&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=">pytorch</a> <a href="https://so.csdn.net/so/search/s.do?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89&amp;t=blog&amp;o=vip&amp;s=&amp;l=&amp;f=&amp;viparticle=">计算机视觉</a><br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/weixin_44564705/article/details/125129844">https://blog.csdn.net/weixin_44564705/article/details/125129844</a><br>DenseFusion系列代码全讲解目录：<a href="https://blog.csdn.net/weixin_44564705/article/details/125149491" title="【DenseFusion系列目录】代码全讲解+可视化+计算评估指标_Panpanpan！的博客-CSDN博客">【DenseFusion系列目录】代码全讲解+可视化+计算评估指标_Panpanpan！的博客-CSDN博客</a><br>这些内容均为个人学习记录，欢迎大家提出错误一起讨论一起学习！</p></blockquote><hr><h2 id="可视化的效果展示">可视化的效果展示</h2><p>选择要可视化的图片，输入路径，然后对其进行eval，估计姿态pred，输出target点云和pred点云在二维图像上的投影，如下：</p><p><img src="https://img-blog.csdnimg.cn/3e041aa30266491d9e42953b7863f314.png" alt=""><img src="https://img-blog.csdnimg.cn/062d962ea0174495860db8fe0a1b56d1.png" alt=""></p><p>左边的图为pred，右边的图为target。</p><h2 id="具体操作">具体操作</h2><p>代码放在了tools/draw_linemod.py</p><p>脚本放在了experiments/scripts/draw_linemod.sh</p><p>先看脚本文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">set -x</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">export PYTHONUNBUFFERED=&quot;True&quot;</span><br><span class="line">export CUDA_VISIBLE_DEVICES=0</span><br><span class="line"></span><br><span class="line">python3 ./tools/draw_linemod.py --data_root ./datasets/linemod/Linemod_preprocessed/data/08\</span><br><span class="line">  --item 0707\</span><br><span class="line">  --seg_root ./datasets/linemod/Linemod_preprocessed/segnet_results/08_label\</span><br><span class="line">  --obj 8\</span><br><span class="line">  --model_root ./datasets/linemod/Linemod_preprocessed/models\</span><br><span class="line">  --model trained_models/linemod/original/pose_model_current.pth\</span><br><span class="line">  --refine_model trained_models/linemod/original/pose_refine_model_current.pth\</span><br><span class="line">  --output ./</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数分别为：</p><blockquote><p>–data_root：要选择的图像类别文件夹路径<br>  --item：选择的图像编号<br>  --seg_root：因为是eval模式，需要用到标准分割的标签，这里输入选择的图像类别的语义分割路径<br>  --obj：图像类别编号<br>  --model_root：图像类别元数据模型路径<br>  --model：训练好的PoseNet路径<br>  --refine_model：训练好的PoseRefineNet路径</p><p>–output：可视化保存路径</p></blockquote><p>输入这些参数，然后在DenseFusion文件夹下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./experiments/scripts/draw_linemod.sh</span><br></pre></td></tr></table></figure><p>如果是最开始执行，可能会提示.sh文件没有权限，就要执行以下命令打开权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./experiments/scripts/draw_linemod.sh</span><br></pre></td></tr></table></figure><p>然后就能在保存路径里查看这两个图片。</p><p><img src="https://img-blog.csdnimg.cn/58319e90949d434293c276afc9310a8b.png" alt=""></p><h2 id="完整代码">完整代码</h2><p>draw_linemod.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> _init_paths</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> numpy.ma <span class="keyword">as</span> ma</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> lib.network <span class="keyword">import</span> PoseNet, PoseRefineNet</span><br><span class="line"><span class="keyword">from</span> lib.loss <span class="keyword">import</span> Loss</span><br><span class="line"><span class="keyword">from</span> lib.loss_refiner <span class="keyword">import</span> Loss_refine</span><br><span class="line"><span class="keyword">from</span> lib.knn.__init__ <span class="keyword">import</span> KNearestNeighbor</span><br><span class="line"><span class="keyword">from</span> lib.transformations <span class="keyword">import</span> euler_matrix, quaternion_matrix, quaternion_from_matrix</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">border_list = [-<span class="number">1</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">200</span>, <span class="number">240</span>, <span class="number">280</span>, <span class="number">320</span>, <span class="number">360</span>, <span class="number">400</span>, <span class="number">440</span>, <span class="number">480</span>, <span class="number">520</span>, <span class="number">560</span>, <span class="number">600</span>, <span class="number">640</span>, <span class="number">680</span>]</span><br><span class="line">img_width = <span class="number">480</span></span><br><span class="line">img_length = <span class="number">640</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mask_to_bbox</span>(<span class="params">mask</span>):</span><br><span class="line">    mask = mask.astype(np.uint8)</span><br><span class="line">    _, contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    </span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    w = <span class="number">0</span></span><br><span class="line">    h = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">        tmp_x, tmp_y, tmp_w, tmp_h = cv2.boundingRect(contour)</span><br><span class="line">        <span class="keyword">if</span> tmp_w * tmp_h &gt; w * h:</span><br><span class="line">            x = tmp_x</span><br><span class="line">            y = tmp_y</span><br><span class="line">            w = tmp_w</span><br><span class="line">            h = tmp_h</span><br><span class="line">    <span class="keyword">return</span> [x, y, w, h]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bbox</span>(<span class="params">bbox</span>):</span><br><span class="line">    bbx = [bbox[<span class="number">1</span>], bbox[<span class="number">1</span>] + bbox[<span class="number">3</span>], bbox[<span class="number">0</span>], bbox[<span class="number">0</span>] + bbox[<span class="number">2</span>]]</span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">0</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        bbx[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">1</span>] &gt;= <span class="number">480</span>:</span><br><span class="line">        bbx[<span class="number">1</span>] = <span class="number">479</span></span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">2</span>] &lt; <span class="number">0</span>:</span><br><span class="line">        bbx[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> bbx[<span class="number">3</span>] &gt;= <span class="number">640</span>:</span><br><span class="line">        bbx[<span class="number">3</span>] = <span class="number">639</span>                </span><br><span class="line">    rmin, rmax, cmin, cmax = bbx[<span class="number">0</span>], bbx[<span class="number">1</span>], bbx[<span class="number">2</span>], bbx[<span class="number">3</span>]</span><br><span class="line">    r_b = rmax - rmin</span><br><span class="line">    <span class="keyword">for</span> tt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(border_list)):</span><br><span class="line">        <span class="keyword">if</span> r_b &gt; border_list[tt] <span class="keyword">and</span> r_b &lt; border_list[tt + <span class="number">1</span>]:</span><br><span class="line">            r_b = border_list[tt + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    c_b = cmax - cmin</span><br><span class="line">    <span class="keyword">for</span> tt <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(border_list)):</span><br><span class="line">        <span class="keyword">if</span> c_b &gt; border_list[tt] <span class="keyword">and</span> c_b &lt; border_list[tt + <span class="number">1</span>]:</span><br><span class="line">            c_b = border_list[tt + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    center = [<span class="built_in">int</span>((rmin + rmax) / <span class="number">2</span>), <span class="built_in">int</span>((cmin + cmax) / <span class="number">2</span>)]</span><br><span class="line">    rmin = center[<span class="number">0</span>] - <span class="built_in">int</span>(r_b / <span class="number">2</span>)</span><br><span class="line">    rmax = center[<span class="number">0</span>] + <span class="built_in">int</span>(r_b / <span class="number">2</span>)</span><br><span class="line">    cmin = center[<span class="number">1</span>] - <span class="built_in">int</span>(c_b / <span class="number">2</span>)</span><br><span class="line">    cmax = center[<span class="number">1</span>] + <span class="built_in">int</span>(c_b / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> rmin &lt; <span class="number">0</span>:</span><br><span class="line">        delt = -rmin</span><br><span class="line">        rmin = <span class="number">0</span></span><br><span class="line">        rmax += delt</span><br><span class="line">    <span class="keyword">if</span> cmin &lt; <span class="number">0</span>:</span><br><span class="line">        delt = -cmin</span><br><span class="line">        cmin = <span class="number">0</span></span><br><span class="line">        cmax += delt</span><br><span class="line">    <span class="keyword">if</span> rmax &gt; <span class="number">480</span>:</span><br><span class="line">        delt = rmax - <span class="number">480</span></span><br><span class="line">        rmax = <span class="number">480</span></span><br><span class="line">        rmin -= delt</span><br><span class="line">    <span class="keyword">if</span> cmax &gt; <span class="number">640</span>:</span><br><span class="line">        delt = cmax - <span class="number">640</span></span><br><span class="line">        cmax = <span class="number">640</span></span><br><span class="line">        cmin -= delt</span><br><span class="line">    <span class="keyword">return</span> rmin, rmax, cmin, cmax</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ply_vtx</span>(<span class="params">path</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(path)</span><br><span class="line">    <span class="keyword">assert</span> f.readline().strip() == <span class="string">&quot;ply&quot;</span></span><br><span class="line">    f.readline()</span><br><span class="line">    f.readline()</span><br><span class="line">    N = <span class="built_in">int</span>(f.readline().split()[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">while</span> f.readline().strip() != <span class="string">&quot;end_header&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    pts = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        pts.append(np.float32(f.readline().split()[:<span class="number">3</span>]))</span><br><span class="line">    <span class="keyword">return</span> np.array(pts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">data_root, item, seg_root, obj, model_root, add_noise, noise_trans</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/rgb/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(data_root, item))</span><br><span class="line">    ori_img = np.array(img)</span><br><span class="line">    depth = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/depth/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(data_root, item)))</span><br><span class="line">    label = np.array(Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/&#123;1&#125;_label.png&#x27;</span>.<span class="built_in">format</span>(seg_root, item)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/depth/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(data_root, item))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/&#123;1&#125;_label.png&#x27;</span>.<span class="built_in">format</span>(seg_root, item))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/gt.yml&#x27;</span>.<span class="built_in">format</span>(data_root))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;/obj_&#123;1&#125;.ply&#x27;</span>.<span class="built_in">format</span>(model_root, <span class="string">&#x27;%02d&#x27;</span> % obj))</span><br><span class="line">    </span><br><span class="line">    meta_file = <span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/gt.yml&#x27;</span>.<span class="built_in">format</span>(data_root), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    meta = yaml.load(meta_file, Loader=yaml.FullLoader)</span><br><span class="line">    pt = ply_vtx(<span class="string">&#x27;&#123;0&#125;/obj_&#123;1&#125;.ply&#x27;</span>.<span class="built_in">format</span>(model_root, <span class="string">&#x27;%02d&#x27;</span> % obj))</span><br><span class="line">    </span><br><span class="line">    trancolor = transforms.ColorJitter(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.05</span>)</span><br><span class="line">    norm = transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    num = <span class="number">500</span></span><br><span class="line">    xmap = np.array([[j <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">640</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">480</span>)])</span><br><span class="line">    ymap = np.array([[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">640</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">480</span>)])</span><br><span class="line">    cam_cx = <span class="number">325.26110</span></span><br><span class="line">    cam_cy = <span class="number">242.04899</span></span><br><span class="line">    cam_fx = <span class="number">572.41140</span></span><br><span class="line">    cam_fy = <span class="number">573.57043</span></span><br><span class="line">    num_pt_mesh_large = <span class="number">500</span></span><br><span class="line">    num_pt_mesh_small = <span class="number">500</span></span><br><span class="line">    rank = <span class="built_in">int</span>(item)</span><br><span class="line">    <span class="keyword">if</span> obj == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(meta[obj])):</span><br><span class="line">            <span class="keyword">if</span> meta[rank][i][<span class="string">&#x27;obj_id&#x27;</span>] == <span class="number">2</span>:</span><br><span class="line">                meta = meta[rank][i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        meta = meta[rank][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    mask_depth = ma.getmaskarray(ma.masked_not_equal(depth, <span class="number">0</span>))</span><br><span class="line">    mask_label = ma.getmaskarray(ma.masked_equal(label, np.array(<span class="number">255</span>)))</span><br><span class="line">    mask = mask_label * mask_depth</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> add_noise:</span><br><span class="line">        img = trancolor(img)</span><br><span class="line"></span><br><span class="line">    img = np.array(img)[:, :, :<span class="number">3</span>]</span><br><span class="line">    img = np.transpose(img, (<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    img_masked = img</span><br><span class="line"></span><br><span class="line">    rmin, rmax, cmin, cmax = get_bbox(mask_to_bbox(mask_label))</span><br><span class="line">    img_masked = img_masked[:, rmin:rmax, cmin:cmax]</span><br><span class="line">    <span class="comment">#p_img = np.transpose(img_masked, (1, 2, 0))</span></span><br><span class="line">    <span class="comment">#scipy.misc.imsave(&#x27;evaluation_result/&#123;0&#125;_input.png&#x27;.format(index), p_img)</span></span><br><span class="line"></span><br><span class="line">    target_r = np.resize(np.array(meta[<span class="string">&#x27;cam_R_m2c&#x27;</span>]), (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">    target_t = np.array(meta[<span class="string">&#x27;cam_t_m2c&#x27;</span>])</span><br><span class="line">    add_t = np.array([random.uniform(-noise_trans, noise_trans) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">    choose = mask[rmin:rmax, cmin:cmax].flatten().nonzero()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(choose) == <span class="number">0</span>:</span><br><span class="line">        cc = torch.LongTensor([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span>(cc, cc, cc, cc, cc, cc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(choose) &gt; num:</span><br><span class="line">        c_mask = np.zeros(<span class="built_in">len</span>(choose), dtype=<span class="built_in">int</span>)</span><br><span class="line">        c_mask[:num] = <span class="number">1</span></span><br><span class="line">        np.random.shuffle(c_mask)</span><br><span class="line">        choose = choose[c_mask.nonzero()]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        choose = np.pad(choose, (<span class="number">0</span>, num - <span class="built_in">len</span>(choose)), <span class="string">&#x27;wrap&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    depth_masked = depth[rmin:rmax, cmin:cmax].flatten()[choose][:, np.newaxis].astype(np.float32)</span><br><span class="line">    xmap_masked = xmap[rmin:rmax, cmin:cmax].flatten()[choose][:, np.newaxis].astype(np.float32)</span><br><span class="line">    ymap_masked = ymap[rmin:rmax, cmin:cmax].flatten()[choose][:, np.newaxis].astype(np.float32)</span><br><span class="line">    choose = np.array([choose])</span><br><span class="line"></span><br><span class="line">    cam_scale = <span class="number">1.0</span></span><br><span class="line">    pt2 = depth_masked / cam_scale</span><br><span class="line">    pt0 = (ymap_masked - cam_cx) * pt2 / cam_fx</span><br><span class="line">    pt1 = (xmap_masked - cam_cy) * pt2 / cam_fy</span><br><span class="line">    cloud = np.concatenate((pt0, pt1, pt2), axis=<span class="number">1</span>)</span><br><span class="line">    cloud = cloud / <span class="number">1000.0</span></span><br><span class="line">    <span class="built_in">print</span>(cloud.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> add_noise:</span><br><span class="line">        cloud = np.add(cloud, add_t)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fw = open(&#x27;evaluation_result/&#123;0&#125;_cld.xyz&#x27;.format(index), &#x27;w&#x27;)</span></span><br><span class="line">    <span class="comment">#for it in cloud:</span></span><br><span class="line">    <span class="comment">#    fw.write(&#x27;&#123;0&#125; &#123;1&#125; &#123;2&#125;\n&#x27;.format(it[0], it[1], it[2]))</span></span><br><span class="line">    <span class="comment">#fw.close()</span></span><br><span class="line">    model_points = pt/ <span class="number">1000.0</span></span><br><span class="line">    dellist = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(model_points))]</span><br><span class="line">    dellist = random.sample(dellist, <span class="built_in">len</span>(model_points) - num_pt_mesh_small)</span><br><span class="line">    model_points = np.delete(model_points, dellist, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fw = open(&#x27;evaluation_result/&#123;0&#125;_model_points.xyz&#x27;.format(index), &#x27;w&#x27;)</span></span><br><span class="line">    <span class="comment">#for it in model_points:</span></span><br><span class="line">    <span class="comment">#    fw.write(&#x27;&#123;0&#125; &#123;1&#125; &#123;2&#125;\n&#x27;.format(it[0], it[1], it[2]))</span></span><br><span class="line">    <span class="comment">#fw.close()</span></span><br><span class="line"></span><br><span class="line">    target = np.dot(model_points, target_r.T)</span><br><span class="line">    <span class="keyword">if</span> add_noise:</span><br><span class="line">        target = np.add(target, target_t / <span class="number">1000.0</span> + add_t)</span><br><span class="line">        out_t = target_t / <span class="number">1000.0</span> + add_t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        target = np.add(target, target_t / <span class="number">1000.0</span>)</span><br><span class="line">        out_t = target_t / <span class="number">1000.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#fw = open(&#x27;evaluation_result/&#123;0&#125;_tar.xyz&#x27;.format(index), &#x27;w&#x27;)</span></span><br><span class="line">    <span class="comment">#for it in target:</span></span><br><span class="line">    <span class="comment">#    fw.write(&#x27;&#123;0&#125; &#123;1&#125; &#123;2&#125;\n&#x27;.format(it[0], it[1], it[2]))</span></span><br><span class="line">    <span class="comment">#fw.close()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.from_numpy(cloud.astype(np.float32)), \</span><br><span class="line">           torch.LongTensor(choose.astype(np.int32)), \</span><br><span class="line">           norm(torch.from_numpy(img_masked.astype(np.float32))), \</span><br><span class="line">           torch.from_numpy(target.astype(np.float32)), \</span><br><span class="line">           torch.from_numpy(model_points.astype(np.float32)), \</span><br><span class="line">           torch.LongTensor([obj])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data_root&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;ycb or linemod&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seg_root&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;ycb or linemod&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--model_root&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;ycb or linemod&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--item&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--obj&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>, <span class="built_in">help</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--model&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;resume PoseNet model&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--refine_model&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;resume PoseRefineNet model&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--output&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default = <span class="string">&#x27;&#x27;</span>,  <span class="built_in">help</span>=<span class="string">&#x27;resume PoseRefineNet model&#x27;</span>)</span><br><span class="line">opt = parser.parse_args() </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">estimator = PoseNet(num_points = <span class="number">500</span>, num_obj = <span class="number">13</span>)</span><br><span class="line">estimator.cuda()</span><br><span class="line">refiner = PoseRefineNet(num_points = <span class="number">500</span>, num_obj = <span class="number">13</span>)</span><br><span class="line">refiner.cuda()</span><br><span class="line">estimator.load_state_dict(torch.load(opt.model))</span><br><span class="line">refiner.load_state_dict(torch.load(opt.refine_model))</span><br><span class="line"></span><br><span class="line">bs = <span class="number">1</span></span><br><span class="line">num_points = <span class="number">500</span></span><br><span class="line">iteration = <span class="number">4</span></span><br><span class="line">knn = KNearestNeighbor(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">    points, choose, img, target, model_points, idx = get_data(opt.data_root, opt.item, opt.seg_root, opt.obj, opt.model_root, <span class="literal">True</span>, <span class="number">0.0</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(points.size()) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;No.&#123;0&#125; NOT Pass! Lost detection!&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    points, choose, img, target, model_points, idx = Variable(points.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(choose.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(img.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(target.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(model_points.unsqueeze(<span class="number">0</span>)).cuda(), \</span><br><span class="line">                                                        Variable(idx.unsqueeze(<span class="number">0</span>)).cuda()</span><br><span class="line">    pred_r, pred_t, pred_c, emb = estimator(img, points, choose, idx)</span><br><span class="line">    pred_r = pred_r / torch.norm(pred_r, dim=<span class="number">2</span>).view(<span class="number">1</span>, num_points, <span class="number">1</span>)</span><br><span class="line">    pred_c = pred_c.view(bs, num_points)</span><br><span class="line">    how_max, which_max = torch.<span class="built_in">max</span>(pred_c, <span class="number">1</span>)</span><br><span class="line">    pred_t = pred_t.view(bs * num_points, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    my_r = pred_r[<span class="number">0</span>][which_max[<span class="number">0</span>]].view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">    my_t = (points.view(bs * num_points, <span class="number">1</span>, <span class="number">3</span>) + pred_t)[which_max[<span class="number">0</span>]].view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">    my_pred = np.append(my_r, my_t)</span><br><span class="line">    <span class="keyword">for</span> ite <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iteration):</span><br><span class="line">        Tt = Variable(torch.from_numpy(my_t.astype(np.float32))).cuda().view(<span class="number">1</span>, <span class="number">3</span>).repeat(num_points, <span class="number">1</span>).contiguous().view(<span class="number">1</span>, num_points, <span class="number">3</span>)</span><br><span class="line">        my_mat = quaternion_matrix(my_r)</span><br><span class="line">        R = Variable(torch.from_numpy(my_mat[:<span class="number">3</span>, :<span class="number">3</span>].astype(np.float32))).cuda().view(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">        my_mat[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = my_t</span><br><span class="line">        </span><br><span class="line">        new_points = torch.bmm((points - Tt), R).contiguous()</span><br><span class="line">        pred_r, pred_t = refiner(new_points, emb, idx)</span><br><span class="line">        pred_r = pred_r.view(<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        pred_r = pred_r / (torch.norm(pred_r, dim=<span class="number">2</span>).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        my_r_2 = pred_r.view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">        my_t_2 = pred_t.view(-<span class="number">1</span>).cpu().data.numpy()</span><br><span class="line">        my_mat_2 = quaternion_matrix(my_r_2)</span><br><span class="line">        my_mat_2[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = my_t_2</span><br><span class="line"></span><br><span class="line">        my_mat_final = np.dot(my_mat, my_mat_2)</span><br><span class="line">        my_r_final = copy.deepcopy(my_mat_final)</span><br><span class="line">        my_r_final[<span class="number">0</span>:<span class="number">3</span>, <span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">        my_r_final = quaternion_from_matrix(my_r_final, <span class="literal">True</span>)</span><br><span class="line">        my_t_final = np.array([my_mat_final[<span class="number">0</span>][<span class="number">3</span>], my_mat_final[<span class="number">1</span>][<span class="number">3</span>], my_mat_final[<span class="number">2</span>][<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">        my_pred = np.append(my_r_final, my_t_final)</span><br><span class="line">        my_r = my_r_final</span><br><span class="line">        my_t = my_t_final</span><br><span class="line">    model_points = model_points[<span class="number">0</span>].cpu().detach().numpy()</span><br><span class="line">    my_r = quaternion_matrix(my_r)[:<span class="number">3</span>, :<span class="number">3</span>]</span><br><span class="line">    pred = np.dot(model_points, my_r.T) + my_t  </span><br><span class="line">    target = target[<span class="number">0</span>].cpu().detach().numpy()</span><br><span class="line"></span><br><span class="line">    pred = pred*<span class="number">1000.0</span></span><br><span class="line">    target = target*<span class="number">1000.0</span></span><br><span class="line">    cam_scale = <span class="number">1.0</span></span><br><span class="line">    cam_cx = <span class="number">325.26110</span></span><br><span class="line">    cam_cy = <span class="number">242.04899</span></span><br><span class="line">    cam_fx = <span class="number">572.41140</span></span><br><span class="line">    cam_fy = <span class="number">573.57043</span></span><br><span class="line"></span><br><span class="line">    depth_masked =  pred[:,<span class="number">2</span>] * cam_scale</span><br><span class="line">    ymap_masked_pred =  pred[:,<span class="number">0</span>] * cam_fx / pred[:,<span class="number">2</span>] + cam_cx</span><br><span class="line">    xmap_masked_pred = pred[:,<span class="number">1</span>] * cam_fy / pred[:,<span class="number">2</span>] + cam_cy</span><br><span class="line"></span><br><span class="line">    depth_masked =  target[:,<span class="number">2</span>] * cam_scale</span><br><span class="line">    ymap_masked_target =  target[:,<span class="number">0</span>] * cam_fx / target[:,<span class="number">2</span>] + cam_cx</span><br><span class="line">    xmap_masked_target = target[:,<span class="number">1</span>] * cam_fy / target[:,<span class="number">2</span>] + cam_cy</span><br><span class="line"></span><br><span class="line">    image = Image.<span class="built_in">open</span>(<span class="string">&#x27;&#123;0&#125;/rgb/&#123;1&#125;.png&#x27;</span>.<span class="built_in">format</span>(opt.data_root, opt.item))</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">12</span>)) <span class="comment"># 图像窗口名称</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.scatter(ymap_masked_pred,xmap_masked_pred,marker=<span class="string">&#x27;.&#x27;</span>,c=<span class="string">&#x27;r&#x27;</span>,alpha=<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;on&#x27;</span>) <span class="comment"># 关掉坐标轴为 off</span></span><br><span class="line">    plt.title(<span class="string">&#x27;image&#x27;</span>) <span class="comment"># 图像题目</span></span><br><span class="line">    plt.show()  </span><br><span class="line">    plt.savefig(<span class="string">&#x27;&#123;0&#125;/test_pred.png&#x27;</span>.<span class="built_in">format</span>(opt.output))</span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>,<span class="number">12</span>)) <span class="comment"># 图像窗口名称</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    plt.scatter(ymap_masked_target,xmap_masked_target,marker=<span class="string">&#x27;.&#x27;</span>,c=<span class="string">&#x27;r&#x27;</span>,alpha=<span class="number">1</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;on&#x27;</span>) <span class="comment"># 关掉坐标轴为 off</span></span><br><span class="line">    plt.title(<span class="string">&#x27;image&#x27;</span>) <span class="comment"># 图像题目</span></span><br><span class="line">    plt.show() </span><br><span class="line">    plt.savefig(<span class="string">&#x27;&#123;0&#125;/test_target.png&#x27;</span>.<span class="built_in">format</span>(opt.output))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt学习笔记05】Qt中调用ROS库</title>
      <link href="/post/eb9b1ae6.html"/>
      <url>/post/eb9b1ae6.html</url>
      
        <content type="html"><![CDATA[<h1>前提</h1><ol><li>安装配置好QT</li><li>安装配置好ROS</li></ol><h1>方法</h1><p><strong>（1）在QT配置文件中添加ros库</strong></p><p>在写的QT工程中加入:即在.pro文件中添加ros头文件路径和动态链接库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += /opt/ros/noetic/include</span><br><span class="line">DEPENDPATH += /opt/ros/noetic/include</span><br><span class="line">LIBS += -L/opt/ros/noetic/lib -lroscpp -lroslib -lrosconsole -lroscpp_serialization -lrostime</span><br></pre></td></tr></table></figure><p><strong>（2）修改QT执行程序</strong></p><p>修改执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.local/share/applications/DigiaQt-qtcreator-community.desktop</span><br></pre></td></tr></table></figure><p>修改<code>Exec</code>行为下面的格式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -i -c /home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p><strong>但是这样修改之后，每次开机只能启动一次QT，第二次点击QT快捷方式就启动不起来了。</strong></p><p>可以修改<code>~/.bashrc</code>，在最后一行添加下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias qt=/home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p>然后每次启动都在终端使用<code>qt</code>命令启动QT，这样就ok了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt学习笔记04】对话框</title>
      <link href="/post/e0de5819.html"/>
      <url>/post/e0de5819.html</url>
      
        <content type="html"><![CDATA[<h1>一、模态和非模态对话框</h1><p>上一节中，我们实现了搭建一个简单的窗口，并且添加了如菜单栏、工具栏等项目。</p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>但现在的窗口只是徒有其形，其内部的功能却一个都没有实现。</p><p>这节我们实现点击一个按钮，弹出一个对话框的功能。</p><h2 id="1-1-介绍-2">1.1 介绍</h2><p>对话框分为两种</p><ul><li>模态对话框：弹出后，可以对其他窗口进行操作</li><li>非模态对话框：弹出后，无法点击除了对话框以外的其他区域（代码阻塞）</li></ul><h2 id="1-2-代码创建">1.2 代码创建</h2><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span>`</span></span><br></pre></td></tr></table></figure><p>编写对话框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew,&amp;QAction::triggered,[=]()&#123;</span><br><span class="line"><span class="comment">//模态对话框 （不可以对其他窗口进行操作） 非模态对话框 （可以对其他窗口进行操作）</span></span><br><span class="line"><span class="comment">//模态创建 阻塞</span></span><br><span class="line">    QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">    dlg.<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;模态对话框弹出了&quot;</span>;   <span class="comment">//需要引入#include &lt;QDebug&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非模态对话框</span></span><br><span class="line">    QDialog * dlg2 = <span class="keyword">new</span> <span class="built_in">QDialog</span> (<span class="keyword">this</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">    dlg2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    dlg2-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;非模态对话框弹出了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二、标准对话框</h1><p>Qt提供了很多内置对话框：</p><table><thead><tr><th>Qt内置对话框</th><th>功能</th></tr></thead><tbody><tr><td>QColorDialog</td><td>选择颜色</td></tr><tr><td>QFileDialog</td><td>选择文件或者目录</td></tr><tr><td>QFontDialog</td><td>选择字体</td></tr><tr><td>QInputDialog</td><td>允许用户输入一个值，并将其值返回</td></tr><tr><td>QMessageBox</td><td>模态对话框，用于显示信息、询问问题等</td></tr><tr><td>QPageSetupDialog</td><td>为打印机提供纸张相关的选项</td></tr><tr><td>QPrintDialog</td><td>打印机配置</td></tr><tr><td>QPrintPreviewDialog</td><td>打印预览</td></tr><tr><td>QProgressDialog</td><td>显示操作过程</td></tr></tbody></table><p>以下以消息对话框为例。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt学习笔记03】UI设计</title>
      <link href="/post/549bf258.html"/>
      <url>/post/549bf258.html</url>
      
        <content type="html"><![CDATA[<h1>一、QMainWindow</h1><h2 id="1-1-QMainWindow结构概览">1.1 QMainWindow结构概览</h2><p>QMainWindow由一个菜单栏、多个工具栏、多个铆接部件、一个状态栏、一个中心部件组成。各部件的具体布局区域如图所示。</p><p><img src="https://img-blog.csdn.net/20180106132722303" alt=""></p><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><blockquote><p>上面图片所用到的代码及注释附在本文的最后</p></blockquote><h2 id="1-2-菜单栏QMenuBar">1.2 菜单栏QMenuBar</h2><p>菜单栏是窗口最上方的区域，基本每个软件的标题栏下面都会有这么一行，这就是菜单栏。</p><p><img src="https://img.mahaofei.com/img/20220902161029.png" alt=""></p><p>注意：菜单栏只能创建一个</p><p><strong>代码示例</strong></p><p>引入菜单栏QMenuBar</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>菜单栏创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br></pre></td></tr></table></figure><p>将菜单栏放入到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br></pre></td></tr></table></figure><p>创建菜单栏的菜单（比如文件、编辑、工具、帮助等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建菜单项（比如文件菜单下的新建、打开项）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902161412.png" alt=""></p><h2 id="1-3-工具栏QToolBar">1.3 工具栏QToolBar</h2><p>工具栏一般位于菜单栏下方，或者左右两侧、或底部。</p><p><img src="https://img.mahaofei.com/img/20220902161816.png" alt=""></p><p>注意：工具栏可以创建多个。</p><p><strong>代码示例</strong></p><p>引入工具栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建工具栏（工具栏创建后可以随意拖动）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将工具栏放入窗口，Qt::TopToolBarArea是默认放上侧，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br></pre></td></tr></table></figure><p>设置只允许左右停靠</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br></pre></td></tr></table></figure><p>设置浮动（可以拖拽，但移动不了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>设置移动（总开关，设为False后无法拖拽）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在工具栏中添加内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将刚才创建的菜单项Action添加到工具栏中</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line"><span class="comment">//添加另一个菜单项</span></span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line"><span class="comment">//工具栏中添加控件</span></span><br><span class="line">QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902162526.png" alt=""></p><h2 id="1-4-状态栏QStatusBar">1.4 状态栏QStatusBar</h2><p>状态栏是窗口最低不，显示软件状态的栏。（例如ppt、word最下面显示字数、幻灯片数量的那一行）</p><p><img src="https://img.mahaofei.com/img/20220902162734.png" alt=""></p><p>注意：状态栏最多有一个。</p><p><strong>代码示例</strong></p><p>引入状态栏头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建状态栏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br></pre></td></tr></table></figure><p>将状态栏设置到窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setStatusBar</span>(stBar);</span><br></pre></td></tr></table></figure><p>在菜单栏中放入标签控件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902163152.png" alt=""></p><h2 id="1-5-铆接部件QDockWidget">1.5 铆接部件QDockWidget</h2><p>铆接部件又称为浮动窗口，是窗口中，在中心窗口周围的部件，通常是可以修改位置，可以拖出来成为单独的窗口，也可以双击使其回到父窗口中。</p><p>常见的铆接部件包括（IDE左侧或右侧的项目栏、底部的编译输出栏等）</p><p><img src="https://img.mahaofei.com/img/Screenshot%20from%202022-09-02%2016-54-35.png" alt=""></p><p>铆接部件可以有多个</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建铆接部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>将铆接部件添加到窗口中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br></pre></td></tr></table></figure><p>设置铆接部件的停靠区域，例如只允许上下（与工具栏设置参数一致）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902172602.png" alt=""></p><h2 id="1-6-中心部件QTextEdit">1.6 中心部件QTextEdit</h2><p>中心部件就是一个程序中心的部分，例如IDE的程序编写区域，WPS的文字编辑区域等。</p><p>中心部件只能设置一个。</p><p><strong>代码示例</strong></p><p>引入头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建中心部件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>设置中心部件到父窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setCentralWidget</span>(edit);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220902192613.png" alt=""></p><p>中间白色的区域就是中心部件。</p><h2 id="1-7-UI工具设计图形界面">1.7 UI工具设计图形界面</h2><p>在Qt中也提供了图形化的UI设计界面。</p><p>通过双击项目文件中的<code>xxx.ui</code>文件，就可以打开设计页面。</p><p><img src="https://img.mahaofei.com/img/20220902192942.png" alt=""></p><p>在这里，上文提到的所有项目（菜单栏、工具栏等），以及各自的属性，都可以直接拖拽放置，并在右下角修改其属性。</p><p>创建的控件，在代码中通过<code>ui-&gt;abcd</code>可以找到所有控件。</p><p>但是这种布局方式所产生的代码结构较差。</p><p>通常是在代码中编写大概，然后在设计中进行微调。</p><h1>二、资源文件</h1><p>很多时候，在窗口中我们不仅需要文字，还需要添加一些图标，图片等，让应用显得更人性化。这就需要我们在项目中导入资源文件。</p><h2 id="2-1-资源文件的导入">2.1 资源文件的导入</h2><ol><li><p>首先将图片复制到项目文件夹中（注意图片必须是png格式，直接更改用户名无效，必须通过图片编辑软件转换）</p></li><li><p>右键项目名 -&gt; 添加新文件 -&gt; Qt -&gt; QtResourceFile</p></li></ol><p><img src="https://img.mahaofei.com/img/20220902193453.png" alt=""></p><ol start="3"><li><p>得到一个<code>.qrc</code>文件，右键，<code>open in edit</code></p></li><li><p>添加 -&gt; 前缀，自己设置一个前缀</p></li><li><p>添加 -&gt; 文件 -&gt; 找到图片文件夹 -&gt; 选中所有图片 -&gt; 打开</p></li><li><p>可以看到<code>.qrc</code>文件下方多了一个“前缀”文件夹</p></li></ol><h2 id="2-2-代码中使用">2.2 代码中使用</h2><p>代码中使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ui-&gt;actionNew-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(``<span class="string">&quot;:/前缀/图片文件夹名/图片文件名.png&quot;</span>``));`</span><br></pre></td></tr></table></figure><h1>附</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainwindow.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QToolBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStatusBar&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDockWidget&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTextEdit&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重置窗口大小</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏  只能最多有一个</span></span><br><span class="line">    <span class="comment">//菜单栏创建</span></span><br><span class="line">    QMenuBar * bar = <span class="built_in">menuBar</span>();</span><br><span class="line">    <span class="comment">//将菜单栏放入到窗口中</span></span><br><span class="line">    <span class="built_in">setMenuBar</span>(bar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单</span></span><br><span class="line">    QMenu * fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QMenu * editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建菜单项</span></span><br><span class="line">    QAction * newAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    QAction * openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏  可以有多个</span></span><br><span class="line">    QToolBar * toolBar = <span class="keyword">new</span> <span class="built_in">QToolBar</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addToolBar</span>(Qt::LeftToolBarArea,toolBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后期设置 只允许 左右停靠</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setAllowedAreas</span>( Qt::LeftToolBarArea | Qt::RightToolBarArea );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置浮动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置移动 (总开关)</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏中可以设置内容</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(newAction);</span><br><span class="line">    <span class="comment">//添加分割线</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">    <span class="comment">//工具栏中添加控件</span></span><br><span class="line">    QPushButton * btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;aa&quot;</span> , <span class="keyword">this</span>);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏 最多有一个</span></span><br><span class="line">    QStatusBar * stBar = <span class="built_in">statusBar</span>();</span><br><span class="line">    <span class="comment">//设置到窗口中</span></span><br><span class="line">    <span class="built_in">setStatusBar</span>(stBar);</span><br><span class="line">    <span class="comment">//放标签控件</span></span><br><span class="line">    QLabel * label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addWidget</span>(label);</span><br><span class="line"></span><br><span class="line">    QLabel * label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//铆接部件 （浮动窗口） 可以有多个</span></span><br><span class="line">    QDockWidget * dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;浮动&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea,dockWidget);</span><br><span class="line">    <span class="comment">//设置后期停靠区域，只允许上下</span></span><br><span class="line">    dockWidget-&gt;<span class="built_in">setAllowedAreas</span>( Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置中心部件 只能一个</span></span><br><span class="line">    QTextEdit * edit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">setCentralWidget</span>(edit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt学习笔记02】自定义信号与槽函数</title>
      <link href="/post/b61fb72.html"/>
      <url>/post/b61fb72.html</url>
      
        <content type="html"><![CDATA[<h1>一、自定义信号和槽</h1><p>实现功能：定义两个类，mysignal类，myslot类。mysignal类发出信号hello，myslot响应信号打印Hello World。</p><p><strong>（1）创建类</strong></p><p>首先右键项目-添加新文件-创建新的C++类，基类选择QObject。</p><p><img src="https://img.mahaofei.com/img/20220827210652.png" alt=""></p><p><strong>（2）自定义信号和槽函数</strong></p><p>自定义信号写到signals下。返回值是void，只需要声明，不需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysignal.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSIGNAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSIGNAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySignal</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySignal</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;   <span class="comment">//添加了自定义信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSIGNAL_H</span></span></span><br></pre></td></tr></table></figure><p>自定义槽函数写在public slots下。返回值是void，需要声明，也需要实现。可以有参数，可以重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSLOT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSLOT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySlot</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MySlot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printhello</span><span class="params">()</span></span>;    <span class="comment">//添加了自定义槽</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSLOT_H</span></span></span><br></pre></td></tr></table></figure><p>实现槽函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myslot.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span>    <span class="comment">//QDebug可在底部打印输出字符串</span></span></span><br><span class="line"></span><br><span class="line">MySlot::<span class="built_in">MySlot</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义槽函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySlot::printhello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;Hello World!&quot;</span>);    <span class="comment">//输出HelloWorld</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）创建两个类的对象并使用connect进行连接</strong></p><p>首先在widget.h中声明两个类的指针，然后在widget.cpp中new两个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span>  <span class="comment">//引入两个类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;    <span class="comment">//声明两个类的指针</span></span><br><span class="line">    MySlot * myslot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;    <span class="comment">//new两个对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）创建触发函数</strong></p><p>只有上面的代码，虽然创建了两个类，也定义了信号和槽函数，但是缺少触发条件，此时运行程序，程序无反应。</p><p>在widget.h的widget类的private中声明触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mysignal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myslot.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">widget</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">widget</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::widget *ui;</span><br><span class="line">    MySignal * mysignal;</span><br><span class="line">    MySlot * myslot;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mytrigger</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure><p>在widget.cpp下方定义触发函数，并在widget中添加触发函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">widget::<span class="built_in">widget</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QMainWindow</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;mysignal = <span class="keyword">new</span> MySignal;</span><br><span class="line">    <span class="keyword">this</span>-&gt;myslot = <span class="keyword">new</span> MySlot;</span><br><span class="line">    <span class="built_in">connect</span>(mysignal, &amp;MySignal::hello, myslot, &amp;MySlot::printhello);</span><br><span class="line">    <span class="built_in">mytrigger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">widget::mytrigger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    emit mysignal-&gt;<span class="built_in">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">widget::~<span class="built_in">widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220827213040.png" alt=""></p><h1>二、信号的连接与断开</h1><h2 id="2-1-信号连接信号">2.1 信号连接信号</h2><p>connect不仅可以连接信号与槽，也可以连接信号与信号，实现当触发一个信号时，由该信号继续触发另一个信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello);</span><br></pre></td></tr></table></figure><h2 id="2-2-信号与槽断开">2.2 信号与槽断开</h2><p>断开信号使用disconnect关键字，其参数与connect完全相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(btn, &amp;QPushButton::clicked, mysignal, &amp;MySignal::hello)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【QT学习笔记01】Qt基础、按钮、对象树以及信号和槽的基本使用</title>
      <link href="/post/e1f7a4b6.html"/>
      <url>/post/e1f7a4b6.html</url>
      
        <content type="html"><![CDATA[<h1>一、Qt</h1><h2 id="1-1-Qt介绍">1.1 Qt介绍</h2><p><strong>Qt</strong>是一个<strong>跨平台</strong>的<strong>C++图形用户界面应用程序框架</strong>。为应用程序开发者提供建立艺术级图形界面所需的所有功能。Qt是完全面向对象的，很容易扩展，且允许真正的组件编程。</p><p>支持Windows、Linux、MacOS、嵌入式平台等全平台开发。</p><p>Qt的优点</p><ul><li>跨平台，几乎支持所有平台</li><li>接口简单，容易上手</li><li>简化了内存回收机制</li><li>开发效率高，可快速构建应用程序</li><li>社区氛围好</li><li>可进行嵌入式开发</li></ul><p>Qt的案例</p><ul><li>Linux桌面环境KDE</li><li>WPS Office</li><li>Skype</li><li>Google Earth</li><li>VirtualBox<br>以上都是使用Qt进行开发的。</li></ul><h2 id="1-2-Qt的安装">1.2 Qt的安装</h2><p><strong>（1）Qt主程序与Qt Creator</strong></p><p>到QT官网下载windows安装包：[<a href="https://download.qt.io/archive/qt/5.12/5.12.12/">Index of /archive/qt/5.12/5.12.12</a>](<a href="https://download.qt.io/archive/qt/5.12/5.12.12/">Index of /archive/qt/5.12/5.12.12</a>)</p><p>从上面网站中找到<a href="https://download.qt.io/archive/qt/5.12/5.12.12/qt-opensource-windows-x86-5.12.12.exe">qt-opensource-windows-x86-5.12.12.exe</a>下载并安装，安装过程中选择下面这些组件：</p><p><img src="https://img.mahaofei.com/img/202305202149400.png" alt="image.png"></p><p><strong>（2）Visual Studio中配置Qt扩展</strong></p><p>在扩展菜单栏中点击管理扩展，点击联机扩展，搜索QT，下载<code>Qt Visual Studio Tools</code>插件，下载成功后重启VS2022并安装插件（关闭时会自动弹出安装插件界面，点击Modify即可）。</p><p>打开【扩展 -&gt; Qt VS Tools -&gt; Qt Versions】。</p><p>添加环境，路径就是刚刚安装QT5的路径中的<code>msvc2017</code>.</p><p>配置完成点击确定，关闭VS2022。</p><p>打开VS2022，创建新项目，选择<code>Qt Widgets Application</code>项目，选择<code>debug</code>调试版，有调试信息的，ok结束。</p><h1>二、第一个Qt程序</h1><h2 id="2-1-界面介绍">2.1 界面介绍</h2><p><img src="https://img.mahaofei.com/img/20220827133056.png" alt=""></p><ul><li>欢迎界面<ul><li>工程：创建、打开工程</li><li>示例：提供了各行各业一些现成的qt工程，可以直接打开学习其代码</li><li>教程：Qt官方提供的教程，感觉不如b站大学</li></ul></li><li>编辑<ul><li>进行应用程序代码编写，C++</li></ul></li><li>设计<ul><li>进行界面UI设计</li></ul></li><li>Debug<ul><li>如名</li></ul></li><li>项目<ul><li>进行一些项目配置</li></ul></li><li>帮助<ul><li>非常重要，很多想要实现的功能都可以通过查阅帮助文档实现</li></ul></li></ul><h2 id="2-2-第一个项目">2.2 第一个项目</h2><p>注意，项目名称和路径中都不要出现<strong>中文和空格</strong>。</p><p><strong>（1）创建项目</strong></p><p>基类：</p><ul><li>QWidget：是下面两种基类的父类，创建后什么都没有</li><li>QMainWindow：多了菜单栏和工具，以及底部状态栏</li><li>QDialog：多了对话框</li></ul><p>类名：</p><ul><li>创建自己的类</li></ul><p><img src="https://img.mahaofei.com/img/20220827135159.png" alt=""></p><p>创建完成后如图，注意这里没有勾选ui文件，因此工程目录如左面所示。</p><p><strong>（2）main文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span>  <span class="comment">//新建qt工程后的类.h文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span>  <span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main程序入口，argc命令行变量的数量，argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//a是应用程序对象，在Qt中有且只有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//通过自定义的类，实例化一个对象（窗口对象）</span></span><br><span class="line">    <span class="comment">//其父类在创建项目时选择</span></span><br><span class="line">    learning01 w;</span><br><span class="line">    <span class="comment">//窗口对象默认不会显示，必须调用show方法显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//让应用程序对象进入消息循环机制</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息循环机制：</p><p>在正常C++中，运行后窗口都会一闪而过，一般只有添加system(“pause”)才能看到输出窗口。而在qt中，应用程序会阻塞到return行，等待用户的鼠标键盘操作，或点击窗口右上角x才可以退出程序。</p><p><strong>（3）.pro文件</strong></p><p>注意：除非知道你在做什么，否则不要动.pro文件，里面的内容会根据项目自动更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Qt包含的模块</span></span><br><span class="line">QT       += core gui</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于4版本以上，包含 wigdet 模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标，生成的.exe程序的名称</span></span><br><span class="line">TARGET = learning01</span><br><span class="line"><span class="comment"># 模板，应用程序模板</span></span><br><span class="line">TEMPLATE = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件，自动追加</span></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp \</span><br><span class="line">        learning01.cpp</span><br><span class="line"><span class="comment"># 头文件，自动追加</span></span><br><span class="line">HEADERS += \</span><br><span class="line">        learning01.h</span><br></pre></td></tr></table></figure><p><strong>（4）头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEARNING01_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEARNING01_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含头文件QWidget窗口类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">learning01</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT    <span class="comment">//Q_OBJECT宏，允许类中 使用信号和槽的机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">learning01</span>(QWidget *parent = <span class="number">0</span>);    <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">learning01</span>();    <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// LEARNING01_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（5）cpp文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;learning01.h&quot;</span></span><br><span class="line"><span class="comment">#include &lt;QApplication&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    learning01 w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（6）快捷键</strong></p><ul><li>注释：ctrl + /</li><li>运行：ctrl + r</li><li>编译：ctrl + b</li><li>查找：ctrl + f</li><li>整行移动：ctrl + shift +↑/↓</li><li>字体缩放：ctrl + 滚轮</li><li>自动对齐：ctrl + i</li><li>同名之间的.h和.cpp切换：F4</li></ul><h1>三、按钮控件</h1><p><strong>（1）创建按钮</strong></p><p>使用QPushButton创建按钮，需要指定父类（否则会新建窗口生成按钮），设置文本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><strong>（2）其他操作</strong></p><p>见代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>四、对象树</h1><p>QObject是以对象树的形式组织的。</p><p>当创建一个QObject对象，并指定了父对象指针时，会自动将其添加到其父对象的children()列表。</p><p>当父对象析构时，children()列表的所有对象都会析构。</p><p><img src="https://img-blog.csdnimg.cn/2020121618000044.png" alt=""></p><h1>五、信号与槽</h1><p>实现点击按钮关闭窗口</p><p>具体过程如下：</p><ol><li>信号的发送者</li><li>发送具体信号</li><li>信号的接受者</li><li>对信号进行处理（槽函数）</li></ol><p>以上四个就是信号传递connect的四个参数。</p><p>信号槽的优点：松散耦合，信号发送端和接收端本身是没有关联的，通过connect函数进行连接。</p><p>connect()函数参数</p><ul><li>参数1：信号的发送者，按钮对象</li><li>参数2：发送的信号，clicked, pressed, released,toggled</li><li>参数3：信号的接受者，窗口，this</li><li>参数4：信号的处理，close</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning01.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">learning01::<span class="built_in">learning01</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/************* 创建按钮 ************/</span></span><br><span class="line">    <span class="comment">//创建按钮,按照空间的大小创建窗口</span></span><br><span class="line">    QPushButton * btn1 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>();</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;第一个按钮&quot;</span>);</span><br><span class="line">    QPushButton * btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;第二个按钮&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动btn2按钮</span></span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置窗口大小(可以拖拽边框)</span></span><br><span class="line">    <span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置固定的窗口大小(不可拖拽边框)</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口标题</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;第一个窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************* 按钮关闭窗口 ************/</span></span><br><span class="line">    <span class="comment">//参数1：信号的发送者; 参数2：发送的信号;</span></span><br><span class="line">    <span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;QWidget::close);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">learning01::~<span class="built_in">learning01</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记08】经典神经网络</title>
      <link href="/post/4a294477.html"/>
      <url>/post/4a294477.html</url>
      
        <content type="html"><![CDATA[<h1>一、目标定位</h1><h2 id="1-1-基本思想">1.1 基本思想</h2><p>目标定位是在图像分类的基础上发展而来的，而目标检测又是建立在目标定位的基础之上。</p><p>对于一张图片来说，我们可以通过卷积神经网络以及softmax函数实现图像的分类，例如人、车、自行车等。</p><p><strong>如果我们想要定位目标在图像中的位置，我们可以让softmax函数多输出几个数字，例如多输出4个数字来描述边界框的位置(bx, by, w, h)</strong>。这样训练集就不仅是图像的分类数据了，还要包括图像中的边界框坐标。</p><h2 id="1-2-标签的定义">1.2 标签的定义</h2><p>根据上面的思想，我们可以将图像的标签定义为如下：</p><p>$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有物体（区分物体与背景）</li><li>$b_x, b_y, b_w, b_h$：边界框的中心坐标以及宽高</li><li>$c_1, c_2, c_3$：图像中物体属于三类的概率</li></ul><h2 id="1-3-损失函数的设计">1.3 损失函数的设计</h2><p>对于上面定义的标签，如果采用平方损失策略，则损失函数定义如下：</p><p>如果$y_1=1$，即图片中有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2+(\hat y_2-y_2)^2+\dots+(\hat y_8-y_8)^2$</p><p>（由于标签中共有8个元素，因此从$y_1$到$y_8$）</p><p>如果$y_1=0$，即图片中没有目标物体：</p><p>$l(\hat y, y)=(\hat y_1-y_1)^2$</p><h1>二、特征点检测</h1><p>上面我们介绍了通过在标签中添加4个参数$b_x, b_y, b_w, b_h$来输出边界框的坐标。</p><p>特征点检测也是类似的原理。</p><p>加入我们出于某种原因，想要获取一个人的四个眼角在图像中的坐标，那么我们完全可以将其添加到标签中，事先标记好训练图像中每个人的眼角坐标，然后用神经网络进行训练。</p><p>$y = [P_c, l_{1x}, l_{1y}, l_{2x}, l_{2y}, \dots, l_{4x}, l_{4y}]^T$</p><p>其中</p><ul><li>$P_c$：代表图像中是否有人脸（图像分类）</li><li>$l_{1x}, l_{1y}, \dots, l_{4x}, l_{4y}$：四个眼角的xy坐标</li></ul><p>这与边界框的获取，图片的分类等等，都是同样的原理。</p><p>如果我们想更进一步，获取脸部表情，我们可以在人脸上设置多个特征点，然后再每一张图片上的人脸作标注，然后由神经网络来回归计算。</p><p>通过这种方式，就可以实现特征点的检测。</p><h1>三、目标检测</h1><p>目标检测的基础是图像分类。</p><h2 id="3-1-滑动窗口法">3.1 滑动窗口法</h2><p>以汽车检测为例：</p><p>首先在训练集来说，我们可以使用让汽车占满全部区域的图片来作为训练图片，可以通过在其他照片中裁减出来汽车所占据的区域。</p><p>对于一张给定图片，我们在图像上选取一个小窗口，将这个小窗口内的图像传入神经网络中，判断这个小窗口中的图像是不是一辆车，然后移动小窗口到下一个位置，继续检测。整幅图片遍历完成之后，再调整窗口的大小，重新遍历。</p><p><img src="https://img.mahaofei.com/img/20220910194902.png" alt=""></p><p>这种算法一般就被称为滑动窗口法。</p><p>这种算法的优点是算法设计简单，但也有很明显的缺点就是计算量太大，而且需要合理选择窗口大小和步幅，否则无法准确定位图像中的物体。</p><h2 id="3-2-获取更精准的边界框">3.2 获取更精准的边界框</h2><p>现有问题：使用滑动窗口法</p><ul><li>如果步长较大，所标出的窗口经常不能很好的完全覆盖目标物体，如果步长较小，计算量又过大。</li><li>目标物体有时不是规则的正方形，使用正方形的滑动窗口，获得的边界框精度不够</li></ul><p>解决思路</p><ol><li>利用图像定位算法，将图片分割成9个网格，对每一个网格进行图像定位，使用类似于$y = [P_c, b_x, b_y, b_w, b_h, c_1, c_2, c_3]^T$的标签进行训练。</li><li>这样每一个格子都会获得一个输出，例如$y = [1, b_x, b_y, b_w, b_h, 0, 1, 0]^T$，这样综合来看，输出的维度就是3x3x8。3x3是格子数量，8是输出参数个数。</li></ol><p>这样，相比于滑动窗口来说，滑动窗口是将覆盖范围最大的那个窗口，作为边界框输出。而这里则是将边界框作为四个参数作回归了。</p><p>优点：</p><ul><li>由于使用卷积处理不同格子时，很多计算步骤是共享的，因此大大提高了计算效率</li><li>并且由于是卷积实现，所以计算速度非常快，可以达到实时识别</li></ul><h2 id="3-3-非极大抑制NMS（Non-Max-Suppression）">3.3 非极大抑制NMS（Non-Max Suppression）</h2><p>问题：算法可能对同一个物体识别多次，我们需要采取某种措施使算法对每个对象只检测一次。</p><p><img src="https://img.mahaofei.com/img/20220911144627.png" alt=""></p><p>解决方法：</p><p>在输出结果中，找到识别结果概率最高的一个，例如图中的0.9，将与这个框交并比较大的其他框抑制掉，我们认为这个0.9的框就标出了一个对象。</p><p>然后找到剩余所有框中概率最高的一个，例如图中的0.8，将与这个框交并比较大的其他框抑制掉，得到预测结果。</p><blockquote><p>交并比$IOU=\frac{交集区域}{并集区域}$</p></blockquote><p>实现流程</p><ul><li>将图片分为nxn个格子，对每个格子进行预测，获得包括物体存在概率，边界框位置大小等参数</li><li>删除所有物体存在概率小于0.6的边界框</li><li>对剩余的边界框<ul><li>选取概率最高的边界框作为输出，认为其标出了某个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>在剩余的边界框中在找概率最高的边界框作为输出，认为其中也标出了另一个物体，并将与此边界框重叠度高于50%的边界框删除</li><li>重复过程</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记08】经典神经网络</title>
      <link href="/post/4a294477.html"/>
      <url>/post/4a294477.html</url>
      
        <content type="html"><![CDATA[<h1>LeNet-5</h1><p>该网络的作用可用于手写数字识别。</p><p><img src="https://img.mahaofei.com/img/20220820194640.png" alt=""></p><ul><li>输入：32x32x1的手写数字图片</li><li>卷积：f=5, s=1, filters=6，图像变为28x28x6</li><li>平均池化：f=2, s=2，图像变为14x14x6</li><li>卷积：f=5, s=2, filters=16，图像变为10x10x16</li><li>平均池化：f=2, s=2，图像变为5x5x16</li><li>全连接层：400 -&gt; 120</li><li>全连接层：120 -&gt; 84</li><li>分类：10类输出</li></ul><p>共计约6万个参数，使用sigmoid作为激活函数。</p><h1>AlexNet</h1><p><img src="https://img.mahaofei.com/img/20220821082332.png" alt=""></p><ul><li>输入：227x227x3的包含目标物体的图片</li><li>卷积：f=11, s=4, filters=96，图像变为55x55x96</li><li>最大池化：f=3, s=2，图像变为27x27x96</li><li>卷积same：f=5, padding=2,filters=256，图像变为27x27x256</li><li>最大池化：f=3, s=2，图像变为13x13x256</li><li>卷积same：f=3, padding=1, filters=384，图像变为13x13x384</li><li>卷积same：f=3, padding=1, filters=384，图像维度不变</li><li>卷积same：f=3, padding=1, filters=256，图像变为13x13x256</li><li>最大池化：f=3, s=2，图像变为6x6x256</li><li>全连接层：9216 -&gt; 4096</li><li>全连接层：4096 -&gt; 4096</li><li>分类输出：softmax分为1000类</li></ul><p>共计约6000万个参数，使用ReLU作为激活函数，</p><h1>VGG-16</h1><p><img src="https://img.mahaofei.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-08-21%20083422.png" alt=""></p><ul><li>输入：224x224x3的图片</li><li>卷积网络<ul><li>卷积：f=3, s=1, same</li><li>最大池化：f=2, s=2</li><li>重复16次</li></ul></li><li>全连接层</li><li>softmax</li></ul><p>共计约1.38亿参数，每一组卷积层后，图像缩小一倍，通道数量翻倍。</p><h1>ResNet</h1><p><img src="https://img.mahaofei.com/img/20220821092154.png" alt=""></p><h2 id="残差块">残差块</h2><p>ResNet网络是由残差块构成的。</p><p><img src="https://img.mahaofei.com/img/20220821084324.png" alt=""><br><img src="https://img.mahaofei.com/img/20220821084748.png" alt=""></p><p>这样$a^{[l+2]}=g(z^{[l+2]}+a^{[l]})$</p><h2 id="ResNet的意义">ResNet的意义</h2><p>对于没有残差连接的普通神经网络而言，网络越深，优化算法越难训练，并且随着网络深度的加深，训练错误会越来越多。</p><p>如果有了ResNet，即使网络深度很深，错误率也不会上升。</p><h2 id="为什么ResNet有效">为什么ResNet有效</h2><p>如果在很深的网络处，有某层网络出现了梯度消失的问题，即W=0。</p><p>根据$a^{[l+2]}=g(z^{[l+1]}+a^{[l]})=g(w^{[l+2]}a^{[l+1]}+b^{[l+2]}+a^{[l]})$</p><p>由于梯度消失，$w^{[l+2]}=0$，此时若$b^{[l+2]}=0$，则$a^{[l+2]}=g(0+0+a^{[l]})=g(a^{[l]})$，因为激活函数是ReLU函数，$a^{[l]}$已经激活过，因此$a^{[l+2]}=g(a^{[l]})=a^{[l]}$。</p><p>这样就相当于跳过了梯度消失的部分。</p><h1>Inception网络</h1><p><img src="https://img.mahaofei.com/img/20220821100948.png" alt=""></p><p>上图为Inception模块，原理就是将不同卷积核卷积出的结果，按通道叠加连接成一个具有所有卷积特征的大方块。</p><p>由于提供了各种不同的卷积核，因此网络训练时可以自动选择效果最好的一种或几种卷积核组合，避免了使用单一类型的卷积核的限制。</p><p><img src="https://img.mahaofei.com/img/20220821101431.png" alt=""></p><p>这是Inception网络的结构，其就是将传统的卷积层替换为了Inception模块。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记07】卷积神经网络</title>
      <link href="/post/c2525cf1.html"/>
      <url>/post/c2525cf1.html</url>
      
        <content type="html"><![CDATA[<h1>一、卷积运算</h1><p>前面已经提到，对于一个神经网络来说，例如人脸识别，前面的层主要用来提取图像的边缘，中间的层主要用来检测部分如眼睛鼻子嘴等，后面的层主要用来检测整个人脸。</p><h2 id="1-1-如何检测边缘">1.1 如何检测边缘</h2><p>通常使用不同的卷积核或者称过滤器来实现各种边缘检测。</p><p><strong>（1）垂直边缘</strong></p><p>使用如下的卷积核进行检测：</p><p><img src="https://img.mahaofei.com/img/20220818095121.png" alt=""></p><p>例如，对于一张具有垂直边缘的图像，利用此卷积核进行卷积运算，输出结果在边缘处数值较大，在图像变化缓慢的区域数值较小。</p><p><img src="https://img.mahaofei.com/img/20220818095338.png" alt=""></p><p>上面的卷积运算可以很好的计算出图像中边缘在什么位置，并且，如果卷积的结果是正值，说明从左到右是从亮到暗的变化，如果是负值，说明从左到右是从暗到亮的变化。</p><p><strong>（2）水平边缘</strong></p><p><img src="https://img.mahaofei.com/img/20220818095712.png" alt=""></p><p>此卷积核可以计算图像的水平边缘，并且正值代表上方亮下方暗，数值越大边缘变化越明显。</p><p><strong>（3）其他滤波器</strong></p><p><img src="https://img.mahaofei.com/img/20220818100201.png" alt=""></p><p>通过定义卷积核中的值的分布，可以实现检测不同方向的，不仅是水平竖直，也可以是45°75°。</p><p>此外还可以改变各行的数值，例如1：2：1，来实现更有目标的检测。</p><h2 id="1-2-Padding">1.2 Padding</h2><p><strong>（1）普通卷积存在的问题</strong></p><ul><li>图像缩小：对于一个(n, n)的图像，使用(f, f)的卷积核做卷积，得到的图像大小是(n-f+1, n-f+1)，因此每做一次卷积，图像大小都会减小。</li><li>边缘信息丢失：图像角落的像素只会被一个卷积核处理，边缘像素相比于中间的像素，也会容易丢失很多信息。</li></ul><p><strong>（2）解决方法</strong></p><p>在进行卷积操作之前，先在图像边缘填充一层像素。</p><p>例如在图像边缘添加p层像素，那么卷积后图像大小是(n+2p-f+1, n+2p-f+1)。</p><p><strong>通常情况下，卷积核边长是奇数</strong></p><h2 id="1-3-卷积步长">1.3 卷积步长</h2><p>使用一个(f, f)的卷积核，卷积一个(n, n)的图像，padding为p，步长为s，输出的图像维度为$(\frac{n+2p-f}{s}+1, \frac{n+2p-f}{s}+1)$</p><h1>二、三维卷积</h1><h2 id="2-1-三维卷积基础">2.1 三维卷积基础</h2><p>例如对于一个RGB图像来说，其有(w, h, 3)的维度，对其进行卷积，必须是(f, f, 3)的维度。</p><p>即<strong>图像和卷积核的通道数要相同</strong>。</p><p><strong>卷积完成后的输出图像是(w-f+1, h-f+1, n)的n通道图像，其中n是卷积核的个数。</strong></p><p><img src="https://img.mahaofei.com/img/20220818205222.png" alt=""></p><h2 id="2-2-三维卷积在神经网络的应用">2.2 三维卷积在神经网络的应用</h2><p>三维卷积在神经网络的应用，与传统方法基本一致。</p><p>在传统方法中有，$z^{[1]}=w^{[1]}a^{[0]}+b^{[1]}$，其中$a^{[0]}$就是输入x，$a^{[1]}=g(z^{[1]})$</p><p>而若是卷积运算，则只需将输入图片替换x，卷积核替换w，然后同样添加偏差和非线性激活函数即可。</p><p><img src="https://img.mahaofei.com/img/20220818210442.png" alt=""></p><h1>三、池化层</h1><p>池化层可以缩小模型大小，提高运算速度，提高模型的鲁棒性。</p><h2 id="3-1-最大池化">3.1 最大池化</h2><p>例如对一个4x4的输入，最大池化选择2x2，那么输出就是将4x4的输入分成4部分，每部分取最大值填充到2x2中。最大池化输出维度的计算方法与卷积相同。</p><p><img src="https://img.mahaofei.com/img/20220818215833.png" alt=""></p><p>最大池化的作用是，如果卷积过滤提取到了某个特征，那么保留其最大值，如果没有提取到特征，那么最大值也还是很小。</p><h2 id="3-2-平均池化">3.2 平均池化</h2><p>平均池化与最大池化类似，是在不同区域内求平均值，主要用在很深的网络。</p><p>目前来说最大池化比平均池化更常用。</p><h2 id="3-3-池化总结">3.3 池化总结</h2><p>池化的参数主要有：</p><ul><li>f：池化过滤器大小</li><li>s：补偿</li><li>最大或平均池化</li></ul><p>由于池化层没有权重，只有上面一些超参数，因此一般来说会将卷积层和池化层合并称为一层。</p><h1>四、全连接层</h1><p>在神经网络的最后，经过多轮的卷积和池化处理，最后的输出往往是宽高较小，通道数较多。这是我们会将其展开成为一个向量，这个向量的长度就等于上一层输出的$w\times h\times c$，将向量中的所有参数作为同样数量单元的输入，进行常规神经网络计算，这就是全连接层。</p><h1>五、代码实现</h1><p><strong>（1）添加padding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero_pad</span>(<span class="params">X, pad</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对数据集X的所有图像添加pad，padding被应用再一张图片的宽和高方向上。</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- numpy数组，shape (m, n_H, n_W, n_C) 代表批量为m的图片</span></span><br><span class="line"><span class="string">    pad -- 整数，图片边缘填充的pad大小</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">    X_pad -- 添加了以0填充的pad图片，shape (m, n_H + 2*pad, n_W + 2*pad, n_C)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    X_pad = np.pad(X, ((<span class="number">0</span>, <span class="number">0</span>), (pad, pad), (pad, pad), (<span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_pad</span><br></pre></td></tr></table></figure><p><strong>（2）单步卷积（numpy实现）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_single_step</span>(<span class="params">a_slice_prev, W, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在上一层的一个切片用卷积核W进行卷积, 并添加偏差b</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    a_slice_prev -- 输入数据的切片，shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- 权重参数，以卷积核的形式体现，shape (f, f, n_C_prev)</span></span><br><span class="line"><span class="string">    b -- 偏置参数，shape (1, 1, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    Z -- 标量，滑动窗口(W, b)与输入切片x的卷积计算的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># a_slice 和 W 按元素相乘并添加偏置.</span></span><br><span class="line">    S = np.multiply(W, a_slice_prev) + b</span><br><span class="line">    <span class="comment"># 求和</span></span><br><span class="line">    Z = np.<span class="built_in">sum</span>(S)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z</span><br></pre></td></tr></table></figure><p><strong>（3）三维卷积（numpy实现）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv_forward</span>(<span class="params">A_prev, W, b, hparameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    卷积前向计算</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 上一层的激活输出，shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    W -- 权重, shape (f, f, n_C_prev, n_C)</span></span><br><span class="line"><span class="string">    b -- 偏置, shape (1, 1, 1, n_C)</span></span><br><span class="line"><span class="string">    hparameters -- 包含 &quot;stride&quot; 和 &quot;pad&quot; 的字典</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    Z -- 卷积输出，shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- 缓存，用于conv_backward()函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 A_prev 的维度  </span></span><br><span class="line">    m, n_H_prev, n_W_prev, n_C_prev = A_prev.shape</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取 W 的维度</span></span><br><span class="line">    f, _, n_C_prev, n_C = W.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 hparameters 中的参数</span></span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    pad = hparameters[<span class="string">&quot;pad&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算卷积输出的维度</span></span><br><span class="line">    n_H = (n_H_prev - f + <span class="number">2</span> * pad) // stride + <span class="number">1</span></span><br><span class="line">    n_W = (n_W_prev - f + <span class="number">2</span> * pad) // stride + <span class="number">1</span></span><br><span class="line">    n_C = W.shape[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 零初始化卷积输出变量Z</span></span><br><span class="line">    Z = np.zeros((m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用函数，填充0创建 A_prev_pad </span></span><br><span class="line">    A_prev_pad = zero_pad(A_prev, pad)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在训练样本的批量中循环</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 选择第e个填充样本</span></span><br><span class="line">        A_prev_pad_e = A_prev_pad[e]</span><br><span class="line">        <span class="comment"># 在输出Z的竖直方向遍历</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n_H):</span><br><span class="line">            <span class="comment"># 在输出Z的水平方向遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n_W):</span><br><span class="line">                <span class="comment"># 遍历所有通道，通道数为卷积核个数</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_C):</span><br><span class="line">                    <span class="comment"># Find the corners of the current &quot;slice&quot; (≈4 lines)</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + pad</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 确定被卷积区域</span></span><br><span class="line">                    A_prev_pad_slice = A_prev_pad_e[vert_start:vert_end, horiz_start:horiz_end, :]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 使用卷积核W和偏置b进行卷积</span></span><br><span class="line">                    Z[e, h, w, c] = np.<span class="built_in">sum</span>(np.multiply(A_prev_pad_slice, W[:, :, :, c]) + b[:, :, :, c])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出维度正确</span></span><br><span class="line">    <span class="keyword">assert</span>(Z.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将信息保存在cache中，用于反向传播</span></span><br><span class="line">    cache = (A_prev, W, b, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Z, cache</span><br></pre></td></tr></table></figure><p><strong>（4）池化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: pool_forward</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pool_forward</span>(<span class="params">A_prev, hparameters, mode = <span class="string">&quot;max&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前向传播的池化层</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 输入数据，shape (m, n_H_prev, n_W_prev, n_C_prev)</span></span><br><span class="line"><span class="string">    hparameters -- 包含 &quot;f&quot; 和 &quot;stride&quot; 的python字典</span></span><br><span class="line"><span class="string">    mode -- 想要使用的池化模式, 定义为字符串 (&quot;max&quot; or &quot;average&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    A -- 池化层输出，shape (m, n_H, n_W, n_C)</span></span><br><span class="line"><span class="string">    cache -- 保存池化层的数据，用于反向传播</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取输入数据的维度</span></span><br><span class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从 &quot;hparameters&quot; 中获取超参数</span></span><br><span class="line">    f = hparameters[<span class="string">&quot;f&quot;</span>]</span><br><span class="line">    stride = hparameters[<span class="string">&quot;stride&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义输出维度</span></span><br><span class="line">    n_H = <span class="built_in">int</span>(<span class="number">1</span> + (n_H_prev - f) / stride)</span><br><span class="line">    n_W = <span class="built_in">int</span>(<span class="number">1</span> + (n_W_prev - f) / stride)</span><br><span class="line">    n_C = n_C_prev</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化输出矩阵A</span></span><br><span class="line">    A = np.zeros((m, n_H, n_W, n_C))              </span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 在训练样本的批量中循环</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="comment"># 在输出Z的竖直方向遍历</span></span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(n_H):</span><br><span class="line">            <span class="comment"># 在输出Z的水平方向遍历</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(n_W):</span><br><span class="line">                <span class="comment"># 遍历所有通道</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_C):</span><br><span class="line">                    <span class="comment"># 找到当前要进行池化的区域</span></span><br><span class="line">                    vert_start = h * stride</span><br><span class="line">                    vert_end = vert_start + f</span><br><span class="line">                    horiz_start = w * stride</span><br><span class="line">                    horiz_end = horiz_start + f</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 使用上面的角坐标定义slice区域</span></span><br><span class="line">                    A_prev_slice = A_prev[e, vert_start:vert_end, horiz_start:horiz_end, c]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 根据池化模式在slice进行计算，求最大值或平均值</span></span><br><span class="line">                    <span class="keyword">if</span> mode == <span class="string">&quot;max&quot;</span>:</span><br><span class="line">                        A[e, h, w, c] = np.<span class="built_in">max</span>(A_prev_slice)</span><br><span class="line">                    <span class="keyword">elif</span> mode == <span class="string">&quot;average&quot;</span>:</span><br><span class="line">                        A[e, h, w, c] = np.mean(A_prev_slice)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 保存输入和超参数，用于反向传播</span></span><br><span class="line">    cache = (A_prev, hparameters)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保输出维度正确</span></span><br><span class="line">    <span class="keyword">assert</span>(A.shape == (m, n_H, n_W, n_C))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A, cache</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记06】参数调试处理</title>
      <link href="/post/bd5d217b.html"/>
      <url>/post/bd5d217b.html</url>
      
        <content type="html"><![CDATA[<h1>一、超参数的取值</h1><p><strong>需要处理的参数通常包括：</strong></p><table><thead><tr><th>参数</th><th>常用取值范围</th><th>调试重要度</th></tr></thead><tbody><tr><td>学习率$\alpha$</td><td>0.1</td><td>最重要</td></tr><tr><td>动量</td><td>0.9</td><td>重要</td></tr><tr><td>优化参数$\beta_1,\beta_2,\epsilon$</td><td>$\beta_1=0.9,\beta_2=0.999,\epsilon=10^{-8}$</td><td>一般不修改</td></tr><tr><td>层数layers</td><td></td><td>一般</td></tr><tr><td>隐藏单元数hidden units</td><td></td><td>重要</td></tr><tr><td>学习率衰减learning rate decay</td><td></td><td>一般</td></tr><tr><td>批量大小mini-batch size</td><td></td><td>重要</td></tr></tbody></table><p><strong>如何调试选择参数：</strong></p><ol><li>首先大范围随机选择参数，根据随机取点测试超参数的效果，确定影响最大的参数是哪个。因为对于实际问题而言，很难确定哪个超参数对结果的影响更大，在众多参数中如果一个一个测试往往找不到需要调试的参数。</li><li>采用由粗糙到精细的策略，找到随机测试中结果较好的参数范围，然后放大这一范围，在其中更密集的取值测试，搜索超参数的最优选择。</li></ol><p><strong>如何有效的随机取值</strong></p><p>例如在搜索学习率$\alpha$的取值，其取值可能范围是0.0001-1。如果使用常规的随机取值，那么取到的值将有90%在0.1-1，只有10%在0.0001-0.1，而实际情况是学习率在后者的可能性更大。</p><p>为了解决这个问题，可以采用对数轴。在对数轴上随机取值，这样就可以保证在0.0001-0.1的取值数量大幅增加。</p><p><img src="https://img.mahaofei.com/img/20220814172926.png" alt=""></p><p>又例如在搜索动量$\beta$的值，其取值范围可能是0.9-0.999，但是实际取值肯定会更接近0.9，因此也可以使用上面的方法，通过用上面的方法取$1-\beta$的值[0.001,0.1]，来间接取$\beta$的值。</p><blockquote><p>关于为什么要采用非线性轴取值？因为超参数在不同的范围，对结果的灵敏度不同，以动量$\beta$为例，其在0.9变化为0.9001，比从0.999变为0.9991，对结果的影响要大很多。因此需要更多的在灵敏度高的区间取值，故采用了非线性轴取值方法。</p></blockquote><h1>二、Batch-Normalization(BN)</h1><h2 id="2-1-BN的基本思路">2.1 BN的基本思路</h2><p>在logistic回归中，我们使用了归一化方法（计算平均值、方差），改善了训练样本，加快了梯度下降的速度。</p><p>但在深层网络中，下一层做梯度下降的数据是上一层网络的输出结果。实际中会将上一层的数据，在激活之前进行归一化，然后再激活，传递给下一层。</p><p>在神经网络中，假设有一些隐藏单元值$z^{(1)}\dots z^{(m)}$，计算：</p><p>$\mu=\frac{1}{m}\sum_i z^{(i)}$<br>$\sigma^2=\frac{1}{m}\sum_i(z_i-\mu)^2$<br>$Z^{(i)}_{norm}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^2+\epsilon}}$</p><p>这样就实现了将每层网络的输出z进行了标准化，这时输出就是平均值0和方差1的数据，我们虽然想通过正则化规范数据，加快梯度下降，但我们不想让它们都服从同样均值和方差的分布，因此有了下面的变式：</p><p>$\widetilde z^{(i)}=\gamma z_{norm}^{(i)}+\beta$</p><p>这里的$\gamma,\beta$是新的超参数，作用是设置输出z的平均值和方差。</p><h2 id="2-2-BN为何有效">2.2 BN为何有效</h2><p>BN可以使权重比网络更滞后或更深层。</p><p>对于神经网络的某一层而言，其输入数据就是上一层的输出，由于随着参数的更新，上一层的输出是实时变化的，这就导致当前层的训练总是面对不同分布的输入。</p><p>使用BN后，可以将上一层的数据归一化到同一分布中，使上一层的输出数据更加稳定，进而保证之后的层有更好的基础。</p><p>总而言之，BN减弱了前层参数的作用与后层参数作用之间的联系，使网络每层都可以自己学习，稍微独立于整个网络，这样有助于加速整个网络的学习。</p><h1>三、Softmax</h1><h2 id="3-1-softmax数学表示">3.1 softmax数学表示</h2><p>前面提到的分类方法都是用于二分分类，而softmax回归则适用于多种分类。常用C表示输入类别个数，也等于输出层单元数。</p><p>使用时就是将最后一层的激活函数换成softmax。</p><p>例如设网络的最后一层为$l$，则该softmax层计算过程如下：</p><p>计算线性部分：<br>$z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$</p><p>计算临时变量：<br>$t=e^{z^{[L]}}$</p><p>计算输出，也就是各个分类的概率：<br>$a^{[l]}=\frac{t_i}{\sum t_i}$</p><p>假设$z^{[l]}$是一个(4,1)的向量，那么$t,a^{[l]}$的维度都是(4,1)，其中$a^{[l]}$内的四个值就是四种分类的概率。</p><h2 id="3-2-训练softmax网络">3.2 训练softmax网络</h2><p><strong>（1）损失函数</strong></p><p>由于softmax的输出与分类个数相同，因此需要新的损失函数。</p><p>$l(\hat y,y)=-\sum_{j=1}y_jlog\hat y_j$</p><p>要想让损失函数尽量小，就需要让$log\hat y_j$尽可能大，也就是对应的概率尽可能大。</p><p><strong>（2）梯度下降</strong></p><p>关键步骤是对softmax层求导：</p><p>$dz^{[l]}=\hat y-y$</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6D位姿估计算法】linemod的介绍与代码测试</title>
      <link href="/post/401267a0.html"/>
      <url>/post/401267a0.html</url>
      
        <content type="html"><![CDATA[<h1>一、LineMod算法介绍</h1><p>LineMod算法是Hinterstoisser等人在2011年提出的，通过采用模板匹配的方法，解决了杂乱场景下少纹理三维物体的实时监测与6D位姿估计定位问题。</p><p>算法使用3D物体的RGB-D数据作为输入，通过PCL数据处理库分析目标点云数据，利用预先采集好的三维物体的无噪声或少噪声模板经过较短时间训练得到物体各个方向每个像素点梯度方向和幅值变化，在较短的时间内完成模板训练。识别时用采集到的点云数据与模板对比得到物体信息、位姿和置信度。</p><p>需要注意的是由于LineMod算法是将整个物体作为一个单个模板用于之后的模板匹配，因此限制了其不具备多目标及遮挡场景的识别能力。</p><h1>二、LineMod算法原理</h1><p>总的来说，LineMod算法的实现可分为以下三个阶段。</p><ol><li>模板采集阶段：在多个视角、多种距离、多个方向上对目标物体的特征进行采集</li><li>模板训练阶段：计算目标物体的特征点和特征向量的计算，得到各特征点的坐标并进行存储</li><li>模板匹配阶段：对被测图像进行特征处理，延梯度方向展开得到预处理相应图，然后构造响应表进行线性化存储，最后通过滑窗匹配计算与模板的相似度。</li></ol><h2 id="2-1-模板采集阶段">2.1 模板采集阶段</h2><p>LineMod是基于模板匹配的算法，因此在进行三维物体识别前需要获取识别物体的低噪声、高精度的完成模型，获取模型有两种方法。</p><ol><li>通过深度相机从多个视角、多个距离、多个方向对目标进行模板采集，但这种方法容易产生较多的噪声，对之后的目标识别会产生干扰，且费时费力。</li><li>通过OpenGL手动渲染想要识别的三维物体的模型，利用Solidworks等三维仿真软件就可以对物体进行三维模型的创建和渲染，这种方法可以很好的控制噪声，有利于后续算法对物体的识别精度。</li></ol><p>目前网上已经出现了很多常见三维物体的模板库，例如：<a href="https://www.thingiverse.com/">Thingiverse</a>、<a href="https://www.youmagine.com/">YouMagine</a>、<a href="https://pinshape.com/">Pinshape</a>，等网站都提供常见物品的三维物体模型文件。</p><h2 id="2-2-模板训练">2.2 模板训练</h2><p>LineMod算法将模板图像上各视点的梯度和法向量方向的特征进行提取保存编码，这些根据特征生成的二进制字符串就是之后进行模板匹配的关键。在模板训练阶段需要进行特征点的特征向量的计算、特征点坐标的计算、以及信息的存储。</p><p><strong>1. 计算特征点的特征向量</strong></p><ol><li>将模型的RGB-D和物体的ID信息导入算法。</li><li>LineMod算法会在空间中进行不同角度、不同缩放尺度，进而得到待训练模板。</li><li>待训练模板、训练距离、掩模图像作为特征点的输入，通过高斯模糊和低通滤波完成候选点的去噪以及预处理。</li><li>通过Sobel算子计算候选点梯度幅度，得到物体图像边缘。</li><li>通过Phase函数计算候选点的梯度方向。</li><li>在360°空间范围内对候选点的梯度方向按照16个区间共十个方向进行投影，量化候选点的梯度方向</li><li>通过设置阈值和3x3梯度直方图统计3x3区域内的候选点梯度方向，将候选点最多的梯度方向作为整个区域的梯度方向</li><li>得到特征点的梯度方向和梯度幅值，保存特征计算结果。</li></ol><p><img src="https://img.mahaofei.com/img/20220405172556.png" alt=""></p><p><strong>2. 特征点坐标计算</strong></p><p>LineMod算法通过遍历输入图像的图像金字塔，通过下采样的方式提取金字塔每一层特征点所在的坐标位置，在训练中不断循环计算特征点坐标并进行修正，最后得到3x3区域内特征点对应的坐标位置。</p><p><strong>3. 特征点信息存储</strong></p><p>训练得到的特征向量（梯度幅度和梯度方向）和特征点的坐标位置后，结果通过<code>shapes.save_infos</code>保存训练信息，通过<code>detector.writerClasses</code>写入预设待匹配模板特征点信息。</p><h2 id="2-3-模板匹配">2.3 模板匹配</h2><p><img src="https://img.mahaofei.com/img/20220406083922.png" alt=""></p><p>输入的测试图会将图像的宽度和高度调整为16的倍数便于后续的图像处理，各个特征点的特征向量和坐标计算与模板训练阶段一样，在得到测试图像特征点的特征向量和坐标后，进行以下操作。</p><p><strong>1. 梯度方向展开</strong></p><p>将每一个像素点及其3x3的邻域按照离散化的方向进行或运算，并按邻域直径T循环TxT次完成邻域像素点的梯度方向值遍历，并在内存中存储为连续的特征信息数据。</p><p><img src="https://img.mahaofei.com/img/20220406084455.png" alt=""></p><p>梯度方向展开的过程如图：a)像素点的梯度方向；b)以该像素点为中心进行3x3邻域梯度方向展开；c)每个邻域对应方向量化值。计算结束后将会创建梯度响应表(图c)用于存储梯度方向量化值。</p><p><strong>2. 线性化存储</strong></p><p>LineMod算法会预处理相应图，将像素点x处的多个特征进行编码，由扩散得到的多个特征将编码的独一无二的字符串会在匹配阶段使用。LineMod算法通过预先为每个离散方向创建n0个查超标供与二进制字符串匹配搜索过程，而查找表的索引号对应该字符串、索引值对应像素点的位置与离散特征方向的余弦值。这样就完成了测试图像像素特征处理、方向扩散、构造响应表以及线性化存储梯度方向量化值的过程。</p><p><img src="https://img.mahaofei.com/img/20220406085830.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220406085837.png" alt=""></p><p><strong>3. 相似度计算</strong></p><p>LineMod提取出训练阶段的模板特征点信息，通过将模板在测试图像上进行水平和垂直方向上的滑窗匹配，比较训练模板特征点与测试图像对应像素点在查找表上对应的梯度值差异性，产生一个二维相似度矩阵，完成测试图像的一次滑窗匹配。</p><p>测试图像在不同的金字塔不断进行模板的滑窗匹配，得到不同的相似度（梯度方向余弦值）。对同一个模板进行相似度叠加得到整体相似度，这样就是一个测试图像对应不同位置方向角度模板得到不同的整体相似度，通过相似度即可判断是否匹配成功。</p><p><img src="https://img.mahaofei.com/img/20220406090244.png" alt=""></p><h1>三、LineMod算法实现</h1><h2 id="3-1-运行环境搭建">3.1 运行环境搭建</h2><p>系统环境：ROS系统（本文使用Ubuntu20.04+ROS Noetic）</p><blockquote><p>[[01_Ubuntu20.04安装ROS Noetic|ROS安装方法参考此文章]]</p></blockquote><p>硬件设备：3D相机（本文使用Realsense D435i）</p><blockquote><p>Realsense的安装参考<a href="https://github.com/IntelRealSense/librealsense/blob/master/doc/distribution_linux.md">Github主页</a></p><p>如果出现[camera/realsense2_camera_manager-2] process has died exit code 127的问题<br>则将LD_LIBRARY_PATH=/opt/ros/indigo/lib加入到.bashrc中</p></blockquote><p>这里使用realsense官网的例程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch realsense2_camera rs_rgbd.launch</span><br></pre></td></tr></table></figure><p>发布的RGBD信息为：</p><table><thead><tr><th>信息</th><th>话题</th></tr></thead><tbody><tr><td>rgb_frame_info</td><td>/camera/color/camera_info</td></tr><tr><td>rgb_image_topic</td><td>/camera/color/</td></tr><tr><td>depth_frame_info</td><td>/camera/depth/camera_info</td></tr><tr><td>depth_image_topic</td><td>/camera/depth/image_rect_raw</td></tr></tbody></table><h2 id="3-2-安装ork">3.2 安装ork</h2><p>在已经完整安装ROS的情况下，运行下面指令即可安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export DISTRO=noetic</span><br><span class="line">sudo apt-get install libopenni-dev ros-$&#123;DISTRO&#125;-catkin ros-$&#123;DISTRO&#125;-ecto* ros-$&#123;DISTRO&#125;-opencv-candidate ros-$&#123;DISTRO&#125;-moveit-msgs</span><br><span class="line">sudo apt-get install ros-$&#123;DISTRO&#125;-object-recognition-*</span><br></pre></td></tr></table></figure><p>进入<code>catkin_ws/src</code>文件夹下，运行下面的指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg-perception/object_recognition_msgs</span><br><span class="line">git clone https://github.com/wg-perception/object_recognition_ros</span><br><span class="line">git clone https://github.com/wg-perception/object_recognition_ros_visualization</span><br><span class="line">git clone https://github.com/wg-perception/object_recognition_core</span><br><span class="line">git clone https://github.com/wg-perception/linemod</span><br><span class="line">git clone https://github.com/wg-perception/ork_renderer</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h2 id="3-3-下载ork-tutorials">3.3 下载ork_tutorials</h2><p>进入<code>catkin_ws/src</code>文件夹，下载<code>ork_tutorials</code>包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg-perception/ork_tutorials</span><br></pre></td></tr></table></figure><p>进入刚下载的包中<code>ork_tutorials/data</code>文件夹，执行以下语句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun object_recognition_core object_add.py -n &quot;coke &quot; -d &quot;A universal can of coke&quot; --commit</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_ws/src</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_msgs</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_ros</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_ros_visualization</span><br><span class="line">cd ../ &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_ws/src</span><br><span class="line">git clone http://github.com/wg-perception/object_recognition_core</span><br><span class="line">git clone http://github.com/wg-perception/linemod</span><br><span class="line">git clone http://github.com/wg-perception/ork_renderer</span><br><span class="line">cd ../ &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure><blockquote><p>参考文章<br><a href="https://www.guyuehome.com/34796">LineMod模板匹配算法的原理与实现 （第一篇 原理及公式）</a><br><a href="https://www.guyuehome.com/34798"># LineMod模板匹配算法的原理与实现 （第三篇 原理及实现）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记05】深度学习常用优化算法</title>
      <link href="/post/6b1d78ca.html"/>
      <url>/post/6b1d78ca.html</url>
      
        <content type="html"><![CDATA[<h1>一、Mini-batch梯度下降法</h1><p><strong>（1）为什么需要mini-batch</strong></p><p>我们知道，在神经网络中常使用向量化的方法，来实现较快速的处理所有m个样本。</p><p>但是这样的方法，对于超大数量的样本来说，比如对于一个有100万样本的数据集，使用向量化的方法就代表将创建一个有100万列的超大矩阵，并且需要对整个数据集进行处理后才能进一步做梯度下降，这种方法称为batch梯度下降法。</p><p>为了解决这个问题，可以把训练集分割为小一些的子训练集，这些子集称为mini-batch，比如每次取出1000个样本进行训练，然后再取1000个样本训练。</p><p><strong>（2）如何理解mini-batch</strong></p><p>使用mini-batch梯度下降法时，每次迭代过程需要处理的是$X^$和$y^$，因此做出的成本函数图在取不同子集的过程中是不一样的，但由于权重和偏置是随着训练逐渐优化，因此整体的成本函数是震荡下降的。</p><p><img src="https://img.mahaofei.com/img/20220809182523.png" alt=""></p><p><strong>（3）超参数：batch_size</strong></p><p>在设置minibatch的过程中用到的一个超参数就是batch大小，如果训练集的大小是m的话：</p><ul><li>batch_size=m：mini-batch子集与整个训练集一样，其实就是batch梯度下降法，这种情况相对噪声低一些，幅度大一些，在此方法后可以继续寻找最小值。</li><li>batch_size=1：叫做梯度下降法，每个样本都是独立的mini-batch，这种方法大部分情况下会像最小值靠近，有时会远离最小值，且有很多噪声，而且该方法永远不会手链，而是会一直在最小值附近波动。</li></ul><p>实际工作中选择的mini-batch大小通常在两种极限情况之间，即1&lt;batch_size&lt;m。并且如果样本数量较小，就没必要划分子集了，直接使用batch梯度下降法即可，对于数目较大的数据，一般batch_size选择为64到512，根据电脑内存情况选取。</p><p><strong>（4）编程实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_mini_batches</span>(<span class="params">X, Y, mini_batch_size = <span class="number">64</span>, seed = <span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从(X, Y)创建随机的mini-batch</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入数据, shape (input size, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 真值向量, shape (1, number of examples)</span></span><br><span class="line"><span class="string">    mini_batch_size -- mini-batches的大小，整形</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    mini_batches -- 同步的列表 (mini_batch_X, mini_batch_Y)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    m = X.shape[<span class="number">1</span>]                  <span class="comment"># 训练样本的数量</span></span><br><span class="line">    mini_batches = []</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Step 1: 打乱 (X, Y)</span></span><br><span class="line">    permutation = <span class="built_in">list</span>(np.random.permutation(m))</span><br><span class="line">    shuffled_X = X[:, permutation]</span><br><span class="line">    shuffled_Y = Y[:, permutation].reshape((<span class="number">1</span>,m))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Step 2: 分区 (shuffled_X, shuffled_Y). </span></span><br><span class="line">    num_complete_minibatches = math.floor(m/mini_batch_size) <span class="comment"># 以mini_batch_size为大小的分区的数量</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_complete_minibatches):</span><br><span class="line">        mini_batch_X = shuffled_X[:, k*mini_batch_size : (k+<span class="number">1</span>)*mini_batch_size]</span><br><span class="line">        mini_batch_Y = shuffled_Y[:, k*mini_batch_size : (k+<span class="number">1</span>)*mini_batch_size]</span><br><span class="line">        mini_batch = (mini_batch_X, mini_batch_Y)</span><br><span class="line">        mini_batches.append(mini_batch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理剩余的样本（少于mini_batch_size的样本）</span></span><br><span class="line">    <span class="keyword">if</span> m % mini_batch_size != <span class="number">0</span>:</span><br><span class="line">        mini_batch_X = shuffled_X[:, num_complete_minibatches*mini_batch_size : m]</span><br><span class="line">        mini_batch_Y = shuffled_Y[:, num_complete_minibatches*mini_batch_size : m]</span><br><span class="line">        mini_batch = (mini_batch_X, mini_batch_Y)</span><br><span class="line">        mini_batches.append(mini_batch)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mini_batches</span><br></pre></td></tr></table></figure><h1>二、动量梯度下降法</h1><h2 id="2-1-指数加权平均数">2.1 指数加权平均数</h2><p><strong>（1）什么是指数加权平均数</strong></p><p>指数加权平均数，可以将震荡往复的噪声曲线拟合为一条平滑的曲线。</p><p><img src="https://img.mahaofei.com/img/20220809194847.png" alt=""></p><p>其数学表达式如下：</p><p>$V_t=\beta V_{t-1}+(1-\beta)\theta_t$</p><p><strong>（2）如何理解指数加权平均数</strong></p><p>以$\beta=0.9$为例，我们可以写出下面的式子</p><p>$V_{100}=0.9V_{99}+0.1\theta_{100}$<br>$V_{99}=0.9V_{98}+0.1\theta_{99}$<br>$V_{98}=0.9V_{97}+0.1\theta_{98}$</p><p>我们将后两式代入第一式就可以得到：</p><p>$V_{100}=0.9V_{99}+0.1\theta_{100}$<br>$=0.1\theta_{100}+0.9(0.9V_{98}+0.1\theta_{99})$<br>$=0.1\theta_{100}+0.9(0.1\theta_{99}+0.9(0.9V_{97}+0.1\theta_{98}))$<br>$=0.1\theta_{100}+0.1\times 0.9\theta_{99}+0.1\times 0.9^2\theta_{98}++0.1\times 0.9^3\theta_{97}+\dots$</p><p>可以看出来，这是一个对$\theta$的加和和平均，对于$V_{100}$来说，它由前99个数据决定，并且离100越近的数据，权重越大，离得越远的数据权重越小，权重是成指数衰减的函数。</p><p><strong>（3）超参数：$\beta$</strong></p><p>在公式$V_t=\beta V_{t-1}+(1-\beta)\theta_t$中，如果$\beta$较大，说明在加权过程中，权重衰减更慢，因此可以看作对更多个数据的平均。如果$\beta$较小，说明加权过程中，权重衰减更快，可以看作只对临近几个数据平均。</p><p><strong>指数加权平均公式的好处在于，它占用极少的内存，每次只存储上一次的变量，然后计算最新的数据并不断覆盖就可以了，而不需要为了拟合曲线读入所有的数据。</strong></p><h2 id="2-2-动量梯度下降法">2.2 动量梯度下降法</h2><p>基本思想为计算梯度的加权平均数，并利用该梯度更新权重。</p><p>比如要优化某个成本函数，梯度下降的过程中总是会慢慢摆动直到下降到最小值，这样的上下波动减慢了梯度下降的速度，并且不能使用更大的学习率，因为一旦学习率过大，结果就可能会超出函数的范围。</p><p><img src="https://img.mahaofei.com/img/20220809194602.png" alt=""></p><p><strong>总结来说，我们希望在b方向学习慢一些，减少不必要的摆动，在W方向上加快学习，快速接近最小值。</strong></p><p>因此，一个可以的解决方法是，使用动量梯度下降法。在每次迭代过程中，计算微分dW和db，并计算$V_{dW}=\beta V_{dW}+(1-\beta)dW$，同样计算$V_{db}=\beta V_{db}+(1-\beta)db$，并将计算后的值重新赋值给dW和db，这样做有什么好处呢。</p><p><img src="https://img.mahaofei.com/img/20220809194847.png" alt=""></p><p>类似于上面的图，通过加权平均，将震荡往复的梯度值dW和db转换为连续变化的梯度值，使得在b方向上正负抵消，dW的摆动减小了，W方向上由于所有微分方向一致，因此W方向运动更快了。</p><p>可以理解为成本函数是一个碗状函数，梯度下降就是在碗的边缘滚下一个球，$(1-\beta)dW$和$(1-\beta)db$项相当于在每一刻提供一个加速度，$\beta v_{dW}$和$\beta v_{db}$相当于上一时刻的瞬时速度。因此速度会越滚越快，并且由于$\beta$小于1，类似于表现出一些摩擦力，所以球不会无限加速下去。</p><p>因此动量梯度下降法过程如下：</p><p>$V_{dW}=\beta V_{dW}+(1-\beta)dW$<br>$V_{db}=\beta V_{db}+(1-\beta)db$<br>$W=W-\alpha v_{dW}$<br>$b=b-\alpha v_{db}$</p><p>这个过程中超参数有两个：动量$\beta$和学习率$\alpha$</p><h2 id="2-3-编程实现">2.3 编程实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters_with_momentum</span>(<span class="params">parameters, grads, v, beta, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用动量更新参数</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的python字典:</span></span><br><span class="line"><span class="string">                    parameters[&#x27;W&#x27; + str(l)] = Wl</span></span><br><span class="line"><span class="string">                    parameters[&#x27;b&#x27; + str(l)] = bl</span></span><br><span class="line"><span class="string">    grads -- 包含所有参数的梯度的python字典:</span></span><br><span class="line"><span class="string">                    grads[&#x27;dW&#x27; + str(l)] = dWl</span></span><br><span class="line"><span class="string">                    grads[&#x27;db&#x27; + str(l)] = dbl</span></span><br><span class="line"><span class="string">    v -- 包含当前速度的python字典:</span></span><br><span class="line"><span class="string">                    v[&#x27;dW&#x27; + str(l)] = ...</span></span><br><span class="line"><span class="string">                    v[&#x27;db&#x27; + str(l)] = ...</span></span><br><span class="line"><span class="string">    beta -- 动量超参数，标量</span></span><br><span class="line"><span class="string">    learning_rate -- 学习率，标量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有更新后的参数的python字典</span></span><br><span class="line"><span class="string">    v -- 包含所有更新后的速度的python字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span> <span class="comment"># 神经网络的层数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每个参数的Momentum更新</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="comment"># 计算速度</span></span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta) * grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta) * grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        parameters[<span class="string">&#x27;W&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        parameters[<span class="string">&#x27;b&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> parameters, v</span><br></pre></td></tr></table></figure><h1>三、RMSprop</h1><p>RMSprop的全称是root mean square prop算法，也可以加速梯度下降。</p><p><strong>数学表示如下：</strong></p><p>$S_{dW}=\beta S_{dW}+(1-\beta)dW^2$<br>$S_{dW}=\beta S_{dW}+(1-\beta)dW^2$</p><p><strong>参数更新过程如下：</strong></p><p>$W=W-\alpha \frac{dW}{\sqrt{S_{dW}}}$<br>$b=b-\alpha \frac{db}{\sqrt{S_{db}}}$</p><p><strong>原理如下：</strong></p><p>我们希望学习速度快，并且要减缓摆动。于是有了$S_{dW}$和$S_{db}$，我们希望$S_{dW}$较小，所以要除以一个较小的数，希望$S_{db}$较大，所以要除以一个较大的数，这样就可以减缓b上的摆动。而且这些微分项里面，由于斜率在b的方向上要大于在W的方向，因此db大一些，dW小一些，$S_{dW}$除以一个较小的数也就是dW$S_{db}$除以一个较小的数也就是db，因此有了上面的式子。</p><h1>四、Adam</h1><p>Adam优化算法全称为Adaptive Moment Estimation。是动量梯度下降法Momentum和RMSprop的结合。</p><p>具体步骤如下：</p><p>$V_{dW}=\beta_1 v_{dW}+(1-\beta_1)dW$<br>$V_{db}=\beta_1 v_{db}+(1-\beta_1)db$<br>$S_{dW}=\beta_2 S_{dW}+(1-\beta_2)dW^2$<br>$S_{dW}=\beta_2 S_{dW}+(1-\beta_2)dW^2$</p><p>$W=W-\alpha \frac{V_{dW}}{\sqrt{S_{dW}}+\epsilon}$<br>$b=b-\alpha \frac{V+{db}}{\sqrt{S_{db}}+\epsilon}$</p><p>其中的$\epsilon$常取$10^{-8}$，是为了避免出现除以0的情况，所以附加的微小值。</p><p>该算法结合了Momentum和RMSprop两种方法，被证明有效适用于不同的神经网络。</p><p><strong>本算法涉及了多个超参数</strong></p><ul><li>$\alpha$：学习率</li><li>$\beta_1$：Momentum相关的项，常用的缺省值为0.9</li><li>$\beta_2$：Adam相关的项，常用的缺省值为0.99</li><li>$\epsilon$：常用$10^{-8}$，该参数对算法没什么影响</li></ul><p><strong>编程实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters_with_adam</span>(<span class="params">parameters, grads, v, s, t, learning_rate = <span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                                beta1 = <span class="number">0.9</span>, beta2 = <span class="number">0.999</span>,  epsilon = <span class="number">1e-8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用Adam进行参数更新</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的python字典</span></span><br><span class="line"><span class="string">                    parameters[&#x27;W&#x27; + str(l)] = Wl</span></span><br><span class="line"><span class="string">                    parameters[&#x27;b&#x27; + str(l)] = bl</span></span><br><span class="line"><span class="string">    grads -- 包含所有参数梯度的python字典</span></span><br><span class="line"><span class="string">                    grads[&#x27;dW&#x27; + str(l)] = dWl</span></span><br><span class="line"><span class="string">                    grads[&#x27;db&#x27; + str(l)] = dbl</span></span><br><span class="line"><span class="string">    v -- Adam变量, 梯度一次项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    s -- Adam变量, 梯度平方项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    learning_rate -- 学习率，标量</span></span><br><span class="line"><span class="string">    beta1 -- 第一种动量优化Momentum的指数衰减超参数</span></span><br><span class="line"><span class="string">    beta2 -- 第二种动量优化RMSprop的指数衰减超参数</span></span><br><span class="line"><span class="string">    epsilon -- 放置Adam参数更新过程中可能出现的0除现象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有更新后参数的字典</span></span><br><span class="line"><span class="string">    v -- Adam变量, 梯度一次项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    s -- Adam变量, 梯度平方项的移动的平均值, python字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span>                 <span class="comment"># 神经网络的层数</span></span><br><span class="line">    v_corrected = &#123;&#125;                         <span class="comment"># 初始化第一种动量优化，字典</span></span><br><span class="line">    s_corrected = &#123;&#125;                         <span class="comment"># 初始化第二种动量优化，字典</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用Adam方法更新所有参数</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        <span class="comment"># 移动梯度的平均值. 输入: &quot;v, grads, beta1&quot;. 输出: &quot;v&quot;.</span></span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta1 * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta1) * grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">        v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta1 * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta1) * grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算第一种动量优化的偏差矫正项. 输入: &quot;v, beta1, t&quot;. 输出: &quot;v_corrected&quot;.</span></span><br><span class="line">        v_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta1 ** t)</span><br><span class="line">        v_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta1 ** t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动平方梯度的平均值. 输入: &quot;s, grads, beta2&quot;. 输出: &quot;s&quot;.</span></span><br><span class="line">        s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta2 * s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta2) * (grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] ** <span class="number">2</span>)</span><br><span class="line">        s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta2 * s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta2) * (grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算第二种动量优化的偏差矫正项. 输入: &quot;s, beta2, t&quot;. 输出: &quot;s_corrected&quot;.</span></span><br><span class="line">        s_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta2 ** t)</span><br><span class="line">        s_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - beta2 ** t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新参数. 输入: &quot;parameters, learning_rate, v_corrected, s_corrected, epsilon&quot;. 输出: &quot;parameters&quot;.</span></span><br><span class="line">        parameters[<span class="string">&#x27;W&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] -= learning_rate * v_corrected[<span class="string">&#x27;dW&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] / (np.sqrt(s_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]) + epsilon)</span><br><span class="line">        parameters[<span class="string">&#x27;b&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] -= learning_rate * v_corrected[<span class="string">&#x27;db&#x27;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] / (np.sqrt(s_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]) + epsilon)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters, v, s</span><br></pre></td></tr></table></figure><h1>五、学习率衰减</h1><p>由于在梯度下降过程中，会围绕最小值往复震荡，但是不会精确的收敛，为了保证算法的效率。可以在初期设置较大的学习率，这样学习相对较快，梯度下降速度较快。接近最小值附近时，减小学习率，也就是减小步伐，逐渐逼近最小值。</p><p>因此可以这样操作，每一次遍历所有数据集，都让学习率减小一些。</p><p><strong>（1）最常用的衰减公式</strong></p><p>$\alpha=\frac{1}{1+decay_rate\times epoch_num}$</p><p>其中decay_rate为衰减率，epoch_num为迭代次数。随着epoch_num的增大，学习率$\alpha$会逐渐减小。</p><p><strong>（2）指数衰减</strong></p><p>$\alpha=0.95^{epoch_num}\cdot\alpha_0$</p><p><strong>（3）反比衰减</strong></p><p>$\alpha=\frac{k}{\sqrt{epoch_num}}\cdot a_0$</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单理解时间复杂度</title>
      <link href="/post/b260c83a.html"/>
      <url>/post/b260c83a.html</url>
      
        <content type="html"><![CDATA[<h1>关于代码执行次数</h1><p>给出一段代码，这段代码的总执行次数可以用T(n)表示，其中n是输入数据的大小或数据量，<strong>T(n)是在输入数量为n时，某段代码的总执行次数</strong>。</p><p>以下面两段代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码的执行次数为T(n)=2<br>（两条语句各执行一次）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码的执行次数为T(n)=3n+3<br>（int i = 0执行1次，i&lt;n执行n+1次，i++执行n次，printf执行n次，return执行1次）</p><p>但实际中一般不会一条一条语句去数，而是采用估算。</p><h1>时间复杂度</h1><p><strong>代码执行次数的简化估算值就是时间复杂度。</strong></p><h2 id="如何通过代码执行次数得到时间复杂度">如何通过代码执行次数得到时间复杂度</h2><p>代码执行次数T和时间复杂度O的简化估算关系如下：</p><table><thead><tr><th>代码执行次数T</th><th>时间复杂度O</th></tr></thead><tbody><tr><td>常数</td><td>O(1)</td></tr><tr><td>常数 × n + 常数</td><td>O(n)</td></tr><tr><td>常数 × n^2 + 常数 × n + 常数</td><td>O(n^2)</td></tr><tr><td>常数 × n^a + 常数 × n^(a-1) …</td><td>O(n^a)</td></tr></tbody></table><p>例如，如果T(n)=常数，那么时间复杂度可以估算为1。</p><p>例如，对于多项式，只选取最高此项并忽略系数，因为低次项的增长远远不及最高次项</p><h2 id="常见代码的时间复杂度">常见代码的时间复杂度</h2><h3 id="常规情况">常规情况</h3><p><strong>（1）没有循环</strong></p><p>时间复杂度：O(1)</p><p><strong>（2）有一重循环</strong></p><p>时间复杂度：O(n)</p><p><strong>（3）有二重循环</strong></p><p>时间复杂度：O(n^2)</p><p><strong>（4）有多重循环</strong></p><p>时间复杂度：O(n^a)<br>其中a为循环层数</p><p><strong>（5）有多个循环</strong></p><p>时间复杂度：O(n^a)<br>其中a为层数最多的循环层数</p><p><strong>（6）if…else…嵌套循环</strong></p><p>以时间复杂度最多的分支计算</p><h3 id="特殊情况">特殊情况</h3><p><strong>（1）i成比例增长</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码总执行次数：T(n)=3log2(n)+2<br>时间复杂度：O(log(n))</p><h2 id="时间复杂度的意义">时间复杂度的意义</h2><p>时间复杂度不同，随着输入数据量的增加，代码运行的时间也会增加。</p><p>例如O(1)无论输入数据如何增多，代码运行时间都不变。而O(n)的运行时间和输入数据量成正比。如果时间复杂度过高，例如O(2^n)，那么在小数据情况下，代码还可以运行，一旦数据量增大，则代码的运行时间将会几何级增加。</p><p><img src="https://img.mahaofei.com/img/20220802162544.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220802162602.png" alt=""></p><p>代码执行时间总结如下：</p><table><thead><tr><th>名称</th><th>时间复杂度</th></tr></thead><tbody><tr><td>常数时间</td><td>O(1)</td></tr><tr><td>对数时间</td><td>O(log n)</td></tr><tr><td>线性时间</td><td>O(n)</td></tr><tr><td>线性对数时间</td><td>O(nlog n)</td></tr><tr><td>二次时间</td><td>O(n^2)</td></tr><tr><td>三次时间</td><td>O(n^3)</td></tr><tr><td>指数时间</td><td>O(2^n)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记04】改善训练效果与训练速度的一些要素</title>
      <link href="/post/7969f91b.html"/>
      <url>/post/7969f91b.html</url>
      
        <content type="html"><![CDATA[<h1>一、训练集、验证集和测试集</h1><p>对于输入数据，我们通常将它分成几个部分：训练集、交叉验证集和测试集。</p><p>在先前机器学习的小数据量时代，通常将所有数据划分为60%训练集20%验证集，20%测试集。这是当时普遍认可的比较合理的方法。</p><p>但在大数据时代，验证集和测试集的比例会变小，例如对于一百万条数据，我们只需要一万条做验证集，一万条做测试集，即98%训练集，1%验证集，1%测试集。</p><p>选择数据时要确保验证集和测试集要来自同一分布。</p><h1>二、偏差和方差</h1><p>偏差过大时，会出现拟合曲线与实际值差值过大，即欠拟合现象。</p><p>方差过大时，会出现拟合曲线过于复杂，即过拟合现象。</p><p>训练集错误率远低于验证集错误率时，说明我们过拟合了训练集，没有充分利用交叉验证集的作用，这种情况即高方差情况。</p><p>训练集错误率和验证集的错误率都较高时，说明训练数据的拟合度不高，就是欠拟合现象，也就是高偏差情况。</p><p>训练集错误率</p><h1>三、机器学习基础</h1><p>首先我们要计算算法的偏差，如果偏差很高，纳闷我们可以选择一个新网络，选择更多的隐藏层，或者花费更多时间训练算法，扩大网络的规模，这些方法可能会起作用，可能不会。</p><p>然后评估算法的方差，如果方差高，最好的解决方法就是增加数据量，也可以使用正则化来减少过拟合。</p><p>当我们找到低偏差和低方差的算法，我们就成功做好了机器学习。</p><p>需要注意的是偏差和方差是两种不同的问题，需要采取不同的解决方法。</p><h1>四、正则化</h1><h2 id="4-1-如何实现正则化">4.1 如何实现正则化</h2><p>当神经网络存在过拟合现象，也就是出现高方差时，通常都会想到正则化。（另一个常用的方法是增大数据量）</p><p>对损失函数$J(w,b)$添加正则化：</p><p>$J(w,b)=\frac{1}{m}\sum^m_{i=1}l(\hat y^{(i)},y^{(i)})+\frac{\lambda}{2m}||w||_2^2$</p><p>其中$\frac{\lambda}{2m}||w||^2_2$就是正则项，也称为$L_2$正则化（由于利用了$||w||^2$），这种正则化方式也是应用最多的方式。$L_1$正则化项为$\frac{\lambda}{2m}\sum^{n_x}_{j=1}|w_j|$。</p><p>$\lambda$为正则化参数，我们需要使用验证集来配置这个参数，尝试各种各样的数据集来调整参数，因此$\lambda$是一个超参数。</p><p>在神经网络中：</p><p>$J(w^{[1]}, b^{[1]}\dots w^{[L]}, b^{[L]})=\frac{1}{m} \sum^n_{i=1}l(\hat y, y)+\frac{\lambda}{2m}\sum^L_{l=1}||w^{[l]}||^2_F$</p><p>其中$||w^{[l]}||^2_F=\sum^{n^{[l-1]}}<em>{i=1}\sum^{n^{l}}</em>{j=1}(w_{ij}^{[l]})^2$，称为Frobenius norm，是矩阵中所有元素的平方求和。</p><p>在计算梯度时会计算$\frac{\partial J}{\partial w}$，因此求出来的梯度会在原有基础上多一个正则项：</p><p>$dw^{[l]}=(backprop)+\frac{\lambda}{m}w^{[l]}$</p><p>所以在参数更新时，也会附加一个正则项</p><p>$w^{[l]}=w^{[l]}-\alpha[(backprop)+\frac{\lambda}{m}w^{[l]}]$</p><p>相当于对参数更新的速度进行缩小，因此$L_2$正则化也称为权重衰减。</p><h2 id="4-2-为什么正则化可以减少过拟合">4.2 为什么正则化可以减少过拟合</h2><p>添加正则化后，可以避免权值矩阵过大。</p><p>直观上理解就是如果正则化参数$\lambda$设置的足够大，权重矩阵就会被设置为接近0的值，于是就消除了这些隐藏单元的许多影响，因此整个神经网络就变成了类似于有许多隐藏层，但每个隐藏层只有一个隐藏单元的高偏差情况。</p><p><img src="https://img.mahaofei.com/img/20220728155026.png" alt=""></p><p>另一方面，当权重矩阵W变小时，$Z=Wa+b$也会变小，因此对于类似于tanh的激活函数来说，$g(z)$就会落在靠近y轴两侧的近线性区域，简化了模型，更不容易出现过拟合。</p><h2 id="4-3-Dropout正则化">4.3 Dropout正则化</h2><p>Dropout会遍历网络的每一层，并为每一层设置消除或保留神经节点的概率，设置完后，会在每一层消除一些节点。然后用反向传播训练精简后的模型，对于所有样本，我们都随机设置概率。</p><p><strong>（1）如何实现Dropout正则化</strong></p><p>最常用的方法是<strong>反向随机激活</strong>。</p><p>以一个三层网络举例，首先定义向量d3=np.random.rand(a3.shape[0], a3.shape[1])，即d3与a3同纬度。</p><p>比较d3&lt;keep.prob，表示保留隐藏单元的概率。将d3中各个元素小于keep.prob的设置为1，大于keep.prob设置为0。</p><p>然后过滤d3中所有等于零的元素，a3=np.multiply(a3,d3)。</p><p>向外扩展a3，a3/=keep.prob，主要是为了保证$Z=Wa+b$中的Z期望值不变，由于消除了a中的80%的元素，因此将剩余元素扩大1/0.8倍，Z的期望不变。</p><p><strong>（2）如何理解Dropout正则化</strong></p><p>对于每一个神经元节点来说，它的输入特征（上一层的节点）随时都有可能消除，因此不能依赖任何一个特征，因此将不会在某一个输入上加太多的权重，因此会对所有输入同等看待。</p><p>并且，不同的层其keep.prob值也不一样，对于可能出现过拟合的层，可以设置keep.prob值比其他层更低。</p><p>dropout算法通常应用在计算机视觉领域，其他学科应用的不是那么广泛。</p><p>由于每次迭代都会随即删除一些节点，因此很难评价J，J将不会是单调递减情况，通常情况下会先关闭dropout正则化，再调试好J为单调递减后，在开启。</p><h2 id="4-4-其他正则化">4.4 其他正则化</h2><p><strong>（1）数据增广</strong></p><p>对于图片分类情况来说，如果我们想要扩展数据集，可以采用如翻转图片、旋转图片、放缩裁剪图片等方法，并添加到数据集中，虽然这种方法不如采集新数据有效，但对于消除过拟合仍然有作用。</p><p><img src="https://img.mahaofei.com/img/20220728164014.png" alt=""></p><p><strong>（2）提前终止</strong></p><p>当运行梯度下降时，我们可以绘制出损失函数的曲线（通常是单调递减的），也可以绘制验证集上的误差，通常会发现，验证机误差是先下降再上升的，这个时候我们可以找到验证集误差最小的地方，然后停止迭代。</p><p><img src="https://img.mahaofei.com/img/20220728163947.png" alt=""></p><h1>五、归一化</h1><p>假设有一个训练集，有两个输入，归一化输入有两个步骤</p><p><strong>（1）零均值化</strong></p><p>$\mu=\frac{1}{m}\sum^m_{i=1}x^{(i)}$<br>$x=x-\mu$</p><p><strong>（2）归一化</strong></p><p>$\sigma^2=\frac{1}{m}\sum^m_{i=1}x^{(i)^2}$<br>$x/=\sigma$</p><p>这样之后x1和x2就是以0为中心，方差为1的数据集。</p><p><strong>（3）为什么要标准化</strong></p><p>如果两个输入特征的值差距很大，那么得到的权值矩阵W1和W2中的值差距也会很大，这就会导致损失函数的梯度曲线十分不均匀，需要将学习率设置为非常小才能得到最优解。</p><p>相反如果归一化后，那么无论从哪个位置开始，都可以很好的梯度下降到最优解。</p><p><img src="https://img.mahaofei.com/img/20220728165807.png" alt=""></p><h1>六、梯度消失与梯度爆炸</h1><p>对于一个有很深很深层的神经网络来说，它的预测值$\hat y$可能是这样的：</p><p>$\hat y=w^{[l]}+w^{[l-1]}+\dots+w^{[3]}+w^{[2]}+w^{[1]}$</p><p>这样就会导致如果每一层的w大于1，那么$\hat y$以及梯度$dw$等的值就会爆炸式增长，如果每一层的w小于1，那么$\hat y$的值就会指数级下降。</p><h1>七、权重初始化</h1><p>对于某一个节点来说，如果它的输入特征过多，例如：</p><p>$z=w_1x_1+w_2x_2+\dots+w_nx_n$</p><p>那么随着输入特征数量n越多，每一个权值$w_i$就越小。</p><p>因此通常的做法会将每一个$w_i$变小为$\frac{1}{n}$倍，实际中采用以下做法</p><p>$W^{[l]}=np.random.randn(shape)*np.sqrt(\frac{2}{n^{[l-1]}})$</p><p>对于ReLU激活函数，最右侧使用$np.sqrt(\frac{2}{n^{[l-1]}})$</p><p>对于tanh激活函数，最右侧使用$np.sqrt(\frac{1}{n^{[l-1]}})$，或者$np.sqrt(\frac{2}{n^{[l-1]}+n^{[l]}})$</p><p>也可以将分子的1或者2作为一个超参数进行调整，虽然作用不大就是了。</p><h1>八、梯度检验</h1><p>注意梯度检验只用于debug环节，实际训练时不要开启此功能，因为它运算太慢了。</p><p>假设网络中含有以下参数：$W^{[1]},b^{[1]}\dots W^{[l]},b^{[l]}$</p><p>首先要将所有参数矩阵转换成向量并连接起来，形成一个巨大的向量$\theta$。</p><p>因此$J(W^{[1]},b^{[1]}\dots W^{[l]},b^{[l]})=J(\theta)$</p><p>同样获得一个巨大的梯度向量$d\theta$。</p><p><strong>（1）计算近似梯度</strong></p><p>$d\theta_{approx}[i]=\frac{J(\theta_1,\theta_2,\dots,\theta_i+\epsilon,\dots)-J(\theta_1,\theta_2,\dots,\theta_i-\epsilon,\dots)}{2\epsilon}$</p><p>其中的$\epsilon$通常取$10^{-7}$</p><p><strong>（2）计算近似梯度与所求梯度的距离</strong></p><p>通常采用欧几里得距离$\frac{||d\theta_{approx}-d\theta||<em>2}{||d\theta</em>{approx}||+||d\theta||}$</p><p>如果计算出来的距离大约为$10^{-7}$，说明没问题，如果过大比如$10^{-5}$，说明其中某个环节可能存在问题，可以对逐个i计算，看看是哪个环节存在问题。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记03】线性回归与Softmax回归及其损失函数</title>
      <link href="/post/c7220817.html"/>
      <url>/post/c7220817.html</url>
      
        <content type="html"><![CDATA[<h1>一、线性模型</h1><h2 id="1-1-模型的数学表示">1.1 模型的数学表示</h2><ul><li>输入：$\textbf x=[x_1,x_2,\dots,x_n]^T$</li><li>权重：$\textbf w=[w_1, w_2, \dots, w_n]^T$，决定每个特征对预测值的英雄</li><li>偏差：$b$，决定特征都为0时，预测值应为多少。</li><li><strong>输出为输入的加权和</strong>：$y=w_1x_1+w_2x_2+\dots+w_nx_n+b$</li><li>向量形式的输出：$y=&lt;\textbf w,\textbf x&gt;+b$</li></ul><p><strong>线性模型可以看作单层神经网络。</strong></p><h2 id="1-2-衡量预估质量">1.2 衡量预估质量</h2><p>衡量预估的质量就是比较真实值和预估值，假设$y$是真实值，$\hat y$是估计值，可以有多种形式衡量两者的差距，例如<strong>平方损失</strong>：$l(y,\hat y)=\frac{1}{2}(y-\hat y)^2$</p><h2 id="1-3-训练数据的表示">1.3 训练数据的表示</h2><p>通常我们会收集一些数据点包括训练样本和对应的真实值，记为：</p><p>$\textbf X=[\textbf x_1,\textbf x_2,\cdots,\textbf x_n]^T$</p><p>$\textbf y=[y_1,y_2,\cdots,y_n]^T$</p><p>其中$\textbf x_n$是列向量，代表每一个样本数据。这样$\textbf X$的每一行就是一个样本。</p><p>这样所有样本的预测值就可以表示为：</p><p>$\hat{\textbf y}=\textbf X\textbf w+b$</p><h2 id="1-4-参数学习">1.4 参数学习</h2><p>训练的损失带入1.2中提到的平方损失公式。</p><p>$l(\textbf w,b)=\frac{1}{2}(y-\hat y)^2=\frac{1}{2}\left(\mathbf{w}^\top \mathbf{x} + b - \hat y\right)$</p><p>$L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.$</p><p>通过令$L(\textbf w,b)$最小，找到对应的参数$\textbf w$和$b$。</p><h2 id="1-5-线性模型求解">1.5 线性模型求解</h2><p>为了便于计算，令$\textbf X=[\textbf X, 1]$，$\textbf w=[\textbf w, b]^T$，在$\textbf X$的最右侧添加全一的列，在$\textbf w$的下面添加标量$b$。这样就可以直接计算$\textbf y = \textbf X \textbf w$</p><p>带入损失函数：</p><p>$l(\textbf X,\textbf y,\textbf w)=\frac{1}{2n}||\textbf y-\textbf X \textbf w||^2$</p><p>$\frac{\partial}{\partial \textbf w}l(\textbf X,\textbf y，\textbf w)=\frac{1}{n}(\textbf y-\textbf X \textbf w)^T\textbf X$</p><p>由于损失函数是凸函数，所以最优解满足梯度为0，可以解得</p><p>$\textbf w^*=(\textbf X^T\textbf X)^{-1}\textbf X\textbf y$</p><h2 id="1-6-线性回归的从零实现">1.6 线性回归的从零实现</h2><p><strong>（1）导入包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l    <span class="comment"># pip install d2l</span></span><br></pre></td></tr></table></figure><p><strong>（2）构造数据集</strong></p><p>创建一个带有噪声的人造数据集，使用真实的$w$和$b$生成数据集及标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成 y = Xw + b + 噪声。&quot;&quot;&quot;</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))  <span class="comment"># 均值为0，方差为1的随机数样本</span></span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)  <span class="comment"># 添加均值为0，方差为0.01的噪声</span></span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>features的每一行都包含一个二维数据样本，labels中的每一行都包含一个标签值。</p><p><strong>（3）读取批量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)  <span class="comment"># 样本数量</span></span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))  <span class="comment"># 生成每个样本的index</span></span><br><span class="line">    random.shuffle(indices)  <span class="comment"># 将index随机打乱</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):  <span class="comment"># 步长为batch_size</span></span><br><span class="line">    <span class="comment"># 获取i到i+batch_size的下标</span></span><br><span class="line">        batch_indices = torch.tensor(indices[i:<span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="comment"># 每次yield返回一个值，下次调用从上次的yield开始</span></span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><strong>（4）初始化模型参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>, <span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>（5）定义模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X, w, b</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性回归模型。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X, w) + b</span><br></pre></td></tr></table></figure><p><strong>（6）定义损失函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape))**<span class="number">2</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>（7）定义优化算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;小批量随机梯度下降。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size</span><br><span class="line">            param.grad.zero_()</span><br></pre></td></tr></table></figure><p><strong>（8）训练过程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y)</span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-7-线性回归的简单实现">1.7  线性回归的简单实现</h2><p><strong>（1）导入包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"><span class="comment"># 利用人工数据合成函数，生成样本和标签</span></span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）调用框架中现有的API读取数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;构造一个PyTorch数据迭代器。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 把输入的两类数据一一对应</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="comment"># 重新排序后返回</span></span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面代码用于在屏幕显示读取到的数据，打包成iter迭代器，然后依次读取</span></span><br><span class="line"><span class="built_in">next</span>(<span class="built_in">iter</span>(data_iter))</span><br></pre></td></tr></table></figure><p><strong>（3）定义模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将线性层放到Sequential容器中</span></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))  <span class="comment"># 指定输入维度2，输出维度1</span></span><br><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)  <span class="comment"># 第0层线性层 -&gt; 权重w -&gt; 数据 -&gt; 使用正态分布替换data</span></span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)  <span class="comment"># 第0层线性层 -&gt; 偏差b -&gt; 数据 -&gt; 填充0</span></span><br></pre></td></tr></table></figure><p><strong>（4）均方误差</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br></pre></td></tr></table></figure><p><strong>（5）随机梯度下降</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)</span><br></pre></td></tr></table></figure><p><strong>（6）训练过程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X), y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>二、基础优化方法——梯度下降</h1><p>当一个模型没有显式解时，一般通过这种方法求解。</p><ol><li>挑选一个初始值$w_0$</li><li>在训练中重复迭代参数：$w_t=w_{t-1}-\eta\frac{\partial l}{\partial w_{t-1}}$（$\eta$：学习率）</li></ol><p>也就是说让$w$沿梯度方向（数值下降最快的方向）进行参数更新来找到最优解。类似于下山时一直找坡度最陡的方向走，最终到达山脚（最优解）。</p><p><strong>（1）超参数1：学习率</strong></p><p>其中的学习率代表每一次参数更新的大小，学习率太小参数更新很慢，学习率太大模型会震荡找不到最优解。</p><p><strong>（2）超参数2：批量大小</strong></p><p>由于在整个训练集上计算梯度时间消耗太大，可能需要数分钟乃至数个小时。</p><p>因此通常随机采样$b$个样本来近似训练集的损失。</p><p>同样批量大小不能太大，也不能太小。如果批量太小，不适合并行计算利用GPU资源，如果批量太大，内存消耗增加，浪费计算。</p><h1>三、Softmax回归</h1><p>上面提到的回归，目的是估计一个连续值。而分类问题是用来预测一个离散类别。Softmax回归虽然名字叫回归，但其实是一个分类问题。</p><p>常见的分类问题包括：手写数字识别、自然物体分类、蛋白质显微镜图片分类、恶意软件分类、恶意评论分类。</p><p>对比回归与分类</p><table><thead><tr><th>回归</th><th>分类</th></tr></thead><tbody><tr><td>单连续值数值输出</td><td>多个输出</td></tr><tr><td>跟真实值的区别作为损失</td><td>输出i是预测i的置信度</td></tr></tbody></table><h2 id="1-1-如何将分类问题转化为回归问题">1.1 如何将分类问题转化为回归问题</h2><p><strong>（1）类别编码</strong></p><p>对于n个类别，可以用一维有效编码来编码。那么标号就是长为n的向量，每个类别的标号向量分别是$\textbf y_1,\textbf y_2\dots \textbf y_n$。</p><p>其中第i个类别的标号是$\textbf y_i=[0,0,1,0\dots 0]$，其中只有第i个元素是1，其余元素都是0。</p><p><strong>（2）确定损失函数</strong></p><p>在Softmax中可以选择使用均方损失函数训练。</p><p><strong>（3）进行预测</strong></p><p>$\hat y=argmax\ o_i$</p><p>其中$o_i$是每个类别的置信度，$argmax\ o_i$是置信度最大的类别的索引。这样就能找到置信度最大的那个类别。</p><p>进行检测的关键是使对于正确类的置信度远大于其它类别。通常需要保证$o_y-o_i\ge\Delta(y,i)$</p><p><strong>（4）置信度转换为概率</strong></p><p>我们获得了所有类别的置信度$\textbf o=[o_1,o_2,\dots,o_n]$。</p><p>但是置信度只是预测的物体与每个类别的匹配程度，而非识别为该物体的概率，具体转换方法如下：</p><p>$\hat{\textbf y}=softmax(\textbf o)$</p><p>$\hat y_i=\frac{exp(o_i)}{\sum_k exp(o_k)}$</p><p>这样就实现了置信度$\textbf o$的所有元素非负，且和为1。</p><p>然后将真实的概率$\textbf y$与$\hat {\textbf y}$的区别作为损失。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记02】数据操作的实现与线性代数基础</title>
      <link href="/post/6ce4808.html"/>
      <url>/post/6ce4808.html</url>
      
        <content type="html"><![CDATA[<h1>一、数据操作与数据预处理</h1><h2 id="1-1-数据操作">1.1 数据操作</h2><p><strong>（1）N维数组</strong></p><p>0维，标量，表示一个类别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>1维，向量，表示一个特征向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.0</span>, <span class="number">2.7</span>, <span class="number">3.4</span>]</span><br></pre></td></tr></table></figure><p>2维，矩阵，表示一个样本或特征矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1.0</span>, <span class="number">2.7</span>, <span class="number">3.4</span>]</span><br><span class="line"> [<span class="number">5.0</span>, <span class="number">0.2</span>, <span class="number">4.6</span>]</span><br><span class="line"> [<span class="number">4.3</span>, <span class="number">8.5</span>, <span class="number">0.2</span>]]</span><br></pre></td></tr></table></figure><p>3维，表示一个RGB图片（宽×高×通道）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="number">1.0</span>, <span class="number">2.7</span>, <span class="number">3.4</span>]</span><br><span class="line">  [<span class="number">5.0</span>, <span class="number">0.2</span>, <span class="number">4.6</span>]</span><br><span class="line">  [<span class="number">4.3</span>, <span class="number">8.5</span>, <span class="number">0.2</span>]]</span><br><span class="line"> [[<span class="number">3.2</span>, <span class="number">5.7</span>, <span class="number">3.4</span>]</span><br><span class="line">  [<span class="number">5.4</span>, <span class="number">6.2</span>, <span class="number">3.2</span>]</span><br><span class="line">  [<span class="number">4.1</span>, <span class="number">3.5</span>, <span class="number">6.2</span>]]]</span><br></pre></td></tr></table></figure><p>4维，表示一个视频或RGB图片的批量（批量大小×宽×高×通道）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[[[...</span><br><span class="line">...</span><br><span class="line">...]]]]</span><br></pre></td></tr></table></figure><p>5维，表示一个视频批量（批量大小×时间×宽×高×通道）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[[[[...</span><br><span class="line"> ...</span><br><span class="line"> ...]]]]]</span><br></pre></td></tr></table></figure><p><strong>（2）数组相关</strong></p><p>创建数组需要</p><ol><li>形状</li><li>每个元素的数据类型</li><li>每个元素的值</li></ol><p>访问元素</p><ol><li>一个元素：[1, 2]</li><li>一行：[1, :]</li><li>一列：[:, 1]</li><li>子域：[1:3, 1:]</li><li>跳跃访问：[::3, ::2]</li></ol><h2 id="1-2-数据操作的实现">1.2 数据操作的实现</h2><p><strong>（1）导入torch</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure><p><strong>（2）创建张量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 输出：tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])</span></span><br></pre></td></tr></table></figure><p><strong>（3）获取张量的形状</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.shape</span><br><span class="line"><span class="comment"># 输出：torch.Size([12])</span></span><br></pre></td></tr></table></figure><p><strong>（4）获取张量中元素的个数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.numel()</span><br><span class="line"><span class="comment"># 输出：12</span></span><br></pre></td></tr></table></figure><p><strong>（5）改变张量的形状</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = x.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：reshape只是创建了一个浅拷贝，例如<br>a = torch.arange(6)<br>b = a.reshape((2,3))<br>b[:]=2<br>结果运算过后，a也变成了tensor([2, 2, 2, 2, 2, 2])<br>相当于b创建了一个a的view，只是用特定的方式观察a，地址空间仍然是同一个。</p></blockquote><p><strong>（6）创建初始化矩阵</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">torch.ones(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>（7） 将列表转换为张量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.tensor(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><p><strong>（8）张量的标准运算符是按元素运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">x + y</span><br><span class="line">x - y</span><br><span class="line">x * y</span><br><span class="line">x / y</span><br><span class="line">x ** y</span><br></pre></td></tr></table></figure><p><strong>（9）多个张量连在一起</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">torch.cat((X, Y), dim = <span class="number">0</span>) <span class="comment"># 按行堆叠，纵向堆叠</span></span><br><span class="line">torch.cat((X, Y), dim = <span class="number">1</span>) <span class="comment"># 按列堆叠，横向堆叠</span></span><br></pre></td></tr></table></figure><p><strong>（10）张量元素求和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 输出：tensor(66.)</span></span><br></pre></td></tr></table></figure><p><strong>（11）广播机制：形状不同的张量可以通过广播实现按元素运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a: tensor([[0],</span></span><br><span class="line"><span class="string">   [1],</span></span><br><span class="line"><span class="string">   [2]])</span></span><br><span class="line"><span class="string">b: tensor([[0, 1]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a + b</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a+b: tensor([[0, 1],</span></span><br><span class="line"><span class="string">     [1, 2],</span></span><br><span class="line"><span class="string">     [2, 3]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（12）转换为numpy张量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = X.numpy() <span class="comment"># numpy.ndarray</span></span><br></pre></td></tr></table></figure><h2 id="1-3-数据预处理实现">1.3 数据预处理实现</h2><p><strong>（1）创建数据集</strong></p><p>创建一个人工数据集，并存储在csv逗号分隔值文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）从创建的csv文件中加载原始数据集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果没有安装pandas，只需取消对以下行的注释来安装pandas</span></span><br><span class="line"><span class="comment"># !pip install pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><p><strong>（3）处理缺失数据</strong></p><p>常见的方法包括：</p><ul><li>将缺失数据的行删除</li><li>插值</li></ul><p>对于数值数据，进行插值替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:, <span class="number">0</span>:<span class="number">2</span>], data.iloc[:, <span class="number">1</span>]</span><br><span class="line">inputs = inputs.fillna(inputs.mean()) <span class="comment"># 将其他的NaN转换成当前列剩余值的均值</span></span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p>对于类别值或离散值，我们将NaN视为一个类别，再转换成数值类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure><p><strong>（4）数据转换张量</strong></p><p>由于读取的数据条目都是数值类型，可以转换为张量格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">X, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">X, y</span><br></pre></td></tr></table></figure><h1>二、线性代数的实现</h1><h2 id="2-1-线性代数">2.1 线性代数</h2><p><strong>（1）标量</strong></p><p>标量，由只有一个元素的张量表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor(<span class="number">3.0</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）向量</strong></p><p>向量是由标量组成的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>（3）矩阵</strong></p><p>通过二维数组作为矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(20).reshape(5, 4)</span><br></pre></td></tr></table></figure><p>矩阵的转职</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure><p><strong>（4）张量的形状</strong></p><p>访问向量的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(x)</span><br></pre></td></tr></table></figure><p>访问张量的形状</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure><p><strong>（5）张量的运算</strong></p><p>给定具有相同形状的任何两个张量，任何按元素二元运算的结果都是相同形状的张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">B = A.clone()  <span class="comment"># 通过分配新内存，将A的一个副本分配给B</span></span><br><span class="line">A, A + B</span><br></pre></td></tr></table></figure><p><strong>计算元素的和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="built_in">sum</span>() <span class="comment">#直接使用得到的是一个标量，不管矩阵是什么维度都得到标量</span></span><br><span class="line">A.<span class="built_in">sum</span>(axis = <span class="number">0</span>) <span class="comment"># 按第0轴求和</span></span><br><span class="line">A.<span class="built_in">sum</span>(axis = <span class="number">1</span>) <span class="comment"># 按第1轴求和</span></span><br><span class="line">A.<span class="built_in">sum</span>(axis = <span class="number">2</span>) <span class="comment"># 按第2轴求和</span></span><br></pre></td></tr></table></figure><blockquote><p>对于一个张量，其有三个维度，可以理解为RGB图像的（宽，高，通道数），或者直观理解为一个长方体的（宽，长，高）<br>其高度方向或者RGB的通道数是最高维度，也就是第0轴。<br>对于axis=0进行求和，相当于将长方体高度方向压扁，或者将RGB三个通道合成一个通道<br>对于axis=1进行求和，相当于将长方体长度方向压扁，或者将RGB图像沿每个通道的高方向压扁<br>对于axis=2进行求和，相当于将长方体宽度方向压扁，或者将RGB图像沿每个通道的宽方向压扁</p></blockquote><blockquote><p>此外sum方法还有一个keepdims参数，如果为True，那么将在求和时保持维度不变，将被压扁的维度设置为1。（这样方便通过广播实现A/A.sum）</p></blockquote><p><strong>计算平均值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.mean</span><br><span class="line">A.mean(axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>（6）矩阵的乘法</strong></p><p>按元素乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * B</span><br></pre></td></tr></table></figure><p>点积是按元素乘积的和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = torch.ones(<span class="number">4</span>, dtype = torch.float32)</span><br><span class="line">x, y, torch.dot(x, y)</span><br></pre></td></tr></table></figure><p>矩阵乘向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.mv(A, x)</span><br></pre></td></tr></table></figure><p>矩阵乘矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.mm(A, B)</span><br></pre></td></tr></table></figure><p><strong>（7）范数</strong></p><p>L2范数是向量元素平方和的平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.norm(u)</span><br></pre></td></tr></table></figure><p>L1范数是向量元素的绝对值之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p>矩阵的F范数是矩阵元素的平方和的平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.norm(torch.ones(A))</span><br></pre></td></tr></table></figure><h1>三、矩阵计算</h1><h2 id="3-1-梯度">3.1 梯度</h2><p>梯度是导数从标量拓展到向量的形式</p><p><strong>（1）标量对向量的导数</strong></p><p>$x = [x_1, x_2, \cdots, x_n].T$</p><p>$\frac{\partial y}{\partial \textbf{x}}=[\frac{\partial y}{\partial x_1},\frac{\partial y}{\partial x_2},\cdots,\frac{\partial y}{\partial x_n}]$</p><p>例如，对于函数$y=x_1^2+2x_2^2$，其对向量$\textbf x=[x_1, x_2]$的导数是</p><p>$\frac{\partial y}{\partial \textbf x} = \frac{\partial x_1^+2x_2^2}{\partial \textbf x}=[2x_1, 4x_2]$</p><p>可以直观理解为$y=x_1^2+2x_2^2$是一圈圈椭圆，对于任意给定的$[x_1, x_2]$，都可以找到$[2x_1, 4x_2]$这个方向是$y$下降最快的方向。即梯度就是函数值下降最快的<strong>方向</strong>。</p><p><strong>（2）向量对标量的导数</strong></p><p>$y = [y_1, y_2, \cdots, y_n].T$</p><p>$\frac{\partial \textbf y}{\partial x}=[\frac{\partial y_1}{\partial x},\frac{\partial y_2}{\partial x},\cdots,\frac{\partial y_n}{\partial x}].T$</p><p>即$\frac{\partial y}{\partial \textbf{x}}$是行向量，$\frac{\partial \textbf y}{\partial x}$是列向量。</p><p><strong>（3）向量对向量的导数</strong></p><p>向量对向量的导数是一个矩阵：</p><p><img src="https://img.mahaofei.com/img/20220719151518.png" alt=""></p><h2 id="3-2-向量链式法则">3.2 向量链式法则</h2><p>标量的链式法则：</p><p>$y=f(u),u=g(x)$，则$\frac{\partial y}{\partial x}=\frac{\partial y}{\partial u}\frac{\partial u}{\partial x}$</p><p>向量的链式法则：</p><p>$\frac{\partial y}{\partial \textbf x}=\frac{\partial y}{\partial u}\frac{\partial u}{\partial \textbf x}$    (1,n) = (1, )(1, n)</p><p>$\frac{\partial y}{\partial \textbf x}=\frac{\partial y}{\partial \textbf u}\frac{\partial \textbf u}{\partial \textbf x}$    (1,n) = (1, k)(k, n)</p><p>$\frac{\partial \textbf y}{\partial \textbf x}=\frac{\partial \textbf y}{\partial \textbf u}\frac{\partial \textbf u}{\partial \textbf x}$    (m,n) = (m,k)(k.n)</p><h2 id="3-3-自动求导">3.3 自动求导</h2><p>自动求导是计算一个函数在指定值上的导数。</p><p><strong>（1）计算图</strong></p><p>计算图是将代码反结成操作子，将计算表示成一个无环图。相当于将函数求导过程使用链式法则求导</p><p><img src="https://img.mahaofei.com/img/20220719154036.png" alt=""></p><p><strong>（2）自动求导的模式</strong></p><p>链式法则：$\frac{\partial y}{\partial x}=\frac{\partial y}{\partial u_n}\frac{\partial u_n}{\partial u_{n-1}}\cdots \frac{\partial u_2}{\partial u_1}\frac{\partial u_1}{\partial x}$</p><ul><li><p>正向积累：$\frac{\partial y}{\partial x}=\frac{\partial y}{\partial u_n}(\frac{\partial u_n}{\partial u_{n-1}}(\cdots (\frac{\partial u_2}{\partial u_1}\frac{\partial u_1}{\partial x})))$</p></li><li><p>反向传递：$\frac{\partial y}{\partial x}=(((\frac{\partial y}{\partial u_n}\frac{\partial u_n}{\partial u_{n-1}})\cdots) \frac{\partial u_2}{\partial u_1})\frac{\partial u_1}{\partial x}$</p></li></ul><p>一般对于输入数据会先正向计算结果，再反向计算梯度，正向计算时会保存所有的中间变量。计算梯度的时候已经有了abz的具体值了，直接带入就能得到导数，比如dz/db=2b。同理其它操作子的导数也可以直接带数得到，根据链式法则最终的梯度就是各个操作子导数的乘积。</p><p><strong>（3）自动求导的pytorch实现</strong></p><p>假设对函数$\textbf y=2\textbf x^T \textbf x$对于列向量$\textbf x$求导</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建输入</span></span><br><span class="line">x = torch.arange(<span class="number">4.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空间存储梯度值，执行后x.grad就可以存储梯度值，默认为none</span></span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算y</span></span><br><span class="line">y = <span class="number">2</span> * torch.dot(x, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用反向传播函数计算y关于x每个分量的梯度，结果将自动保存在x.grad中</span></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，pytorch会累计梯度，如果需要计算其他函数的梯度，需要先清除之前的值</span></span><br><span class="line">x.grad.zero_()</span><br></pre></td></tr></table></figure><p>有时我们需要将某些参数移动到计算图之外：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清空x.grad</span></span><br><span class="line">x.grad.zero_()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义y</span></span><br><span class="line">y = x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将y从计算图中剔除，y的当前结果保存为u，则u=x*x是一个固定的值</span></span><br><span class="line">u = y.detach()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时u和x无关，u.backward()是0向量</span></span><br><span class="line"><span class="comment"># y仍然和x有关，y.backward()是2 * x</span></span><br></pre></td></tr></table></figure><p>上面的步骤就实现了将y这个参数的当前值保存出来记为u，而y不受影响，在深度学习中会用到这种操作。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF去水印方法总结</title>
      <link href="/post/cc430c5f.html"/>
      <url>/post/cc430c5f.html</url>
      
        <content type="html"><![CDATA[<h1>自动去水印</h1><p>使用福昕pdf编辑器，打开【页面管理 - 水印 - 全部移除】，大部分后期添加的水印就可以被自动去除了。</p><p><img src="https://img.mahaofei.com/img/20220718214014.png" alt=""></p><h1>去除背景形式的水印</h1><p>使用福昕pdf编辑器，打开【页面管理 - 背景 - 全部移除】，部分水印以背景的方式添加，也可以通过这种方法去除。</p><p><img src="https://img.mahaofei.com/img/20220718214108.png" alt=""></p><h1>去除文字格式水印</h1><p>使用福昕pdf编辑器，打开【编辑 - 编辑文本】，这时整个pdf文件的文字都已经可以编辑了。</p><p><img src="https://img.mahaofei.com/img/20220718215020.png" alt=""></p><p>选中复制需要删除的文字，在右上角打开【搜索 &amp; 替换】窗口，将要删除的文字复制进去。</p><p><img src="https://img.mahaofei.com/img/20220718215146.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220718215309.png" alt=""></p><p>查找内容为【要删除的文字】，替换内容为【空格】，选择全部替换即可。</p><p><img src="https://img.mahaofei.com/img/20220718215409.png" alt=""></p><h1>覆盖水印</h1><p>原理是使用白色方框覆盖水印图片，达到去除水印的目的。</p><p><img src="https://img.mahaofei.com/img/20220718214324.png" alt=""></p><p>在需要覆盖的区域画框：</p><p><img src="https://img.mahaofei.com/img/20220718214403.png" alt=""></p><p>点击浏览，选择一张纯白颜色图像文件，然后点击高级，将比例设置为不按比例，随后确定。</p><p><img src="https://img.mahaofei.com/img/20220718214503.png" alt=""></p><p>可以看到水印已经被白色方框覆盖了（这个边框只有在编辑时才有，正常查看以及打印时是没有的）</p><p><img src="https://img.mahaofei.com/img/20220718214710.png" alt=""></p><p>右键白色方框，选择放置到多个页面</p><p><img src="https://img.mahaofei.com/img/20220718214745.png" alt=""></p><p>我这里所有页面的同一位置都有水印，大家可以根据自己需要设置，点击确定后可以看到所有页面的同一位置都被白色方框覆盖了。</p><p><img src="https://img.mahaofei.com/img/20220718214845.png" alt=""></p><p>如果还有其它水印可以如法炮制，流程一样。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> Windows工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录Ubuntu安装后的系统配置、常用软件安装过程</title>
      <link href="/post/cdee659e.html"/>
      <url>/post/cdee659e.html</url>
      
        <content type="html"><![CDATA[<h1>〇、安装系统</h1><p>安装win10系统，然后按下面步骤安装Ubuntu系统。</p><h2 id="0-1-BIOS设置">0.1 BIOS设置</h2><p><strong>（1）安装前</strong></p><p>开机按Delete键进入BIOS：SETTINGS/BOOT/UEFI Hard Disk Drive BBS Priorities设置为Disable。</p><p><strong>打开独显直连（Discreate）。</strong></p><p><strong>关闭Secure Boot。</strong></p><p>保存后，开机选择U盘启动。</p><p><strong>（2）安装后</strong></p><p>还是上面那个选项，将ubuntu设为优先。</p><h2 id="0-2-显卡问题">0.2 显卡问题</h2><p>ubuntu安装时需要临时禁用显卡，不然会出各种毛病。</p><p><strong>（1）安装时</strong></p><p>在选择引导的界面，选中安装Ubuntu的那一项，按<code>e</code></p><p>将<code>quiet splash ---</code>改为<code>quiet splash pci=nomis pci noaer pcie_aspm=off</code></p><p>然后按F10继续安装。</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/142114459">https://zhuanlan.zhihu.com/p/142114459</a></p></blockquote><p><strong>（2）第一次启动时</strong></p><p>在选择引导的界面，选中启动Ubuntu的那一项，按<code>e</code></p><p>将<code>quiet splash @xxxxxxxx</code>那一行最后加上<code>nomodeset pcie_aspm=off</code></p><p>然后按F10正常启动。</p><p><strong>（3）第一次启动后</strong></p><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/default/grub</span><br></pre></td></tr></table></figure><p>找到这一行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=“quiet splash”  </span><br><span class="line"><span class="comment"># 修改为：  </span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=“quiet splash nomodeset pcie_aspm=off”</span><br></pre></td></tr></table></figure><h1>一、系统配置</h1><h2 id="1-1-系统更新">1.1 系统更新</h2><p>打开<code>Software &amp; Updates</code></p><p>勾选<code>Source code</code>。</p><p>将软件源改为<code>https://mirrors.hit.edu.cn/ubuntu</code>，速度会快很多。</p><p>然后更新软件源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>安装编译必须组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libncurses-dev bison flex libssl-dev libelf-dev</span><br></pre></td></tr></table></figure><h2 id="1-2-安装openssh-server">1.2 安装openssh-server</h2><p>Ubuntu远程连接的基础功能包。<br>如果不安装此包直接使用Putty连接，会报错Network error Connection refused。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><h2 id="1-3-安装net-tools">1.3 安装net-tools</h2><p>安装net-tools后即可使用<code>ifconfig</code>查看本机IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure><h2 id="1-4-安装vim">1.4 安装vim</h2><p>常用的文件编辑工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><h2 id="1-5-同步时间">1.5 同步时间</h2><p>安装ubuntu和windows双系统后，重新打开windows会发现时间错误，原因是两个系统的时区匹配出现了问题。可在ubuntu系统内按以下指令解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br><span class="line">timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure><h2 id="1-6-双系统修改默认启动顺序">1.6 双系统修改默认启动顺序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure><p>修改启动顺序（一般0是ubuntu，2是windows，默认0 ubuntu）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT=2</span><br></pre></td></tr></table></figure><p>修改等待时间（根据自己需要修改，默认10s）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_TIMEOUT=3</span><br></pre></td></tr></table></figure><p>重新生成启动配置项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure><h2 id="1-7-挂载硬盘">1.7 挂载硬盘</h2><p>查看硬盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p>永久挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/fstab</span><br></pre></td></tr></table></figure><p>最下面添加下面一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/nvme0n1p4  /home/mahaofei/Data  ntfs  utf8,unmask=0 </span><br></pre></td></tr></table></figure><h1>二、系统驱动</h1><h2 id="2-1-NVIDIA显卡驱动">2.1 NVIDIA显卡驱动</h2><p>建议先到<code>Software &amp; Updates</code>里的<code>Additional Drivers</code>里面看自己显卡支持的NVIDIA驱动版本，然后直接选择安装。</p><p>（1）方法一（推荐）：在<code>Software &amp; Updates</code>里面安装</p><p>打开<code>Software &amp; Updates</code>，然后点击<code>Additional Drivers</code>，可以看到有一系列驱动，任意选择一个版本然后应用安装即可。（不建议选择带有test字样的，可能会在某些情况下出bug）</p><p>（2）方法二（推荐）：通过命令行安装</p><p>查看可以安装的推荐显卡驱动型号，后缀recommend是系统推荐安装的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo ubuntu-drivers devices</span><br></pre></td></tr></table></figure><p>安装具体型号显卡驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nvidia-driver-xxx</span><br></pre></td></tr></table></figure><p>（3）方法三（不推荐）：官网驱动下载安装</p><blockquote><p>本人4060显卡尝试过此方法：在官网下载驱动安装包，然后手动运行安装，重启后<code>nvidia-smi</code>虽然正常了，但是HDMI外接显示屏没有反应。</p></blockquote><p>到NVIDIA官网下载驱动：<a href="https://www.nvidia.cn/geforce/drivers/">https://www.nvidia.cn/geforce/drivers/</a></p><p>然后使用<code>chmod +x</code>指令赋予下载的驱动文件可执行权限。</p><p>然受使用<code>sudo ./驱动文件名.run</code>来安装驱动。</p><h2 id="2-2-ROS系统">2.2 ROS系统</h2><p><strong>（1）添加软件源</strong></p><p>打开软件与更新，将下载选项前四个都选上。<br><strong>一定要确保都勾选上，不然后续安装时会出现依赖关系问题</strong><br><img src="https://img.mahaofei.com/img/202112231642871-ubuntu-ros-1.png" alt=""></p><p>然后执行以下命令添加软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（2）添加公钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><p>更新索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p><strong>（3）安装ROS</strong></p><p>建议安装桌面完整版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>首先安装rosdep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure><p>然后进行初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><blockquote><p>rosdep init如果出现【ERROR: cannot download default sources list from:…<br>Website may be down.】<br>rosdep update如果出现超时问题<br><strong>解决方法：</strong><br>1.<code>sudo apt-get install python3-pip</code><br>2.<code>sudo pip3 install rosdepc</code><br>3.<code>sudo rosdepc init</code><br>4.<code>rosdepc update</code></p></blockquote><p><strong>（4）安装其它工具和依赖包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br></pre></td></tr></table></figure><p><strong>（5）设置bash环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="2-3-Realsense驱动">2.3 Realsense驱动</h2><blockquote><p>参考官方文档：<a href="https://github.com/IntelRealSense/librealsense/blob/master/doc/distribution_linux.md">librealsense/distribution_linux.md at master · IntelRealSense/librealsense · GitHub</a></p></blockquote><p><strong>（1）安装Realsense SDK</strong></p><p>注册服务器的公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key F6E65AC044F831AC80A06380C8B3A55A6F3EFCDE</span><br></pre></td></tr></table></figure><p>如果仍然无法检索公钥，请检查并指定代理设置<code>export http_proxy=&quot;http://&lt;proxy&gt;:&lt;port&gt;&quot;</code></p><p>将服务器添加到存储库列表中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb https://librealsense.intel.com/Debian/apt-repo $(lsb_release -cs) main&quot; -u</span><br></pre></td></tr></table></figure><p>安装库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install librealsense2-dkms</span><br><span class="line">sudo apt-get install librealsense2-utils</span><br><span class="line">sudo apt-get install librealsense2-dev  </span><br><span class="line">sudo apt-get install librealsense2-dbg</span><br></pre></td></tr></table></figure><p>验证安装，使用<code>realsense-viewer</code>测试驱动是否安装完成。</p><p><strong>（2）安装ROS包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line">cd ~/catkin_ws/src</span><br><span class="line">git clone -b ros1-legacy https://github.com/IntelRealSense/realsense-ros.git</span><br><span class="line">cd ~/catkin_ws &amp;&amp; catkin_make</span><br></pre></td></tr></table></figure><p>一定要注意clone的分支，默认是ros2，如果是ros1环境需要指定分支。</p><h1>三、常用软件</h1><h2 id="3-0-AppImage系列软件">3.0 AppImage系列软件</h2><blockquote><p>注意：最好先打开一下软件，看一下左侧dock栏中<strong>软件名称</strong>是什么，设置desktop<strong>文件名</strong>和文件中的<strong>软件名称</strong>也要一样。否则会出现即使收藏到了dock栏，但是点开还是会在最下面多出一个一样的图标。</p></blockquote><p><strong>软件目录</strong></p><ul><li>MeshLab_64bit_fp: <a href="https://www.meshlab.net/">https://www.meshlab.net/</a></li><li>picgo: <a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></li><li>OneDriveGUI: <a href="https://github.com/bpozdena/OneDriveGUI">https://github.com/bpozdena/OneDriveGUI</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x ./*.AppImage</span><br></pre></td></tr></table></figure><p><strong>添加到收藏夹dock栏</strong></p><p>创建快捷方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Desktop</span><br><span class="line">touch 软件名称.desktop</span><br><span class="line">gedit 软件名称.desktop</span><br></pre></td></tr></table></figure><p>根据自己的情况修改信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=软件名称</span><br><span class="line">Exec=/home/用户名/Software/AppImage/软件名称.AppImage</span><br><span class="line">Icon=/home/用户名/Software/AppImage/软件名称.png</span><br><span class="line">Terminal=False</span><br><span class="line">Type=Application</span><br><span class="line">StartupNotify=False</span><br><span class="line">Categories=Application</span><br></pre></td></tr></table></figure><p>修改该文件权限为可读可写，作为可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 软件名称.desktop</span><br><span class="line">sudo mv 软件名称.desktop /usr/share/applications</span><br></pre></td></tr></table></figure><h2 id="3-1-浏览器">3.1 浏览器</h2><p>谷歌浏览器：<a href="https://www.google.cn/chrome/index.html">https://www.google.cn/chrome/index.html</a><br>Edge浏览器：<a href="https://www.microsoft.com/zh-cn/edge/download">https://www.microsoft.com/zh-cn/edge/download</a></p><h2 id="3-2-安装xrdp远程桌面">3.2 安装xrdp远程桌面</h2><p>使用国外大佬制作的脚本，非常非常方便。</p><p>脚本下载链接：<a href="http://www.c-nergy.be/products.html">http://www.c-nergy.be/products.html</a>（xRDP Installation Script）</p><p>官方使用教程：<a href="https://c-nergy.be/blog/?p=18205">https://c-nergy.be/blog/?p=18205</a></p><p>官方使用教程如下：</p><ol><li><p>下载脚本，刚才已经下载过了</p></li><li><p>解压压缩包</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip xrdp-installer-1.4.3.zip</span><br></pre></td></tr></table></figure><ol start="3"><li>设置可执行权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x  xrdp-installer-1.4.3.sh</span><br></pre></td></tr></table></figure><ol start="4"><li>以普通用户的权限运行脚本，<strong>注意不要加sudo</strong>，另外用户路径下一定要有Downloads文件夹（如果是中文的下载，就新建一个/home/用户名/Downloads）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xrdp-installer-1.4.3.sh</span><br></pre></td></tr></table></figure><ol start="5"><li>查看本机ip</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>记住192.168.x.x这个ip地址。</p><p><strong>完成之后重启</strong>。</p><p><strong>注意！！！重启之后不要登录用户，直接在win10搜索远程桌面连接，进行连接</strong></p><p><strong>如果win10连接时出现黑屏的问题</strong></p><p>重启ubuntu机器和windows电脑</p><h2 id="3-3-安装科学上网工具">3.3 安装科学上网工具</h2><p>具体原理与使用介绍参考<a href="https://www.mahaofei.com/post/24b9bc9.html">科学上网方法（如何访问Google,ChatGPT）</a></p><p><strong>（1）Clash for Windows (Ubuntu版)</strong></p><ol><li>下载</li></ol><p>首先从GitHub上下载clash</p><p><s>下载链接：<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></s></p><p><s>下载 Clash.for.Windows-0.18.8-x64-linux.tar.gz（一般个人电脑请选择 x64-linux）</s></p><p>==Clash 作者 Fndroid 已经将 Clash_for_Windows 各平台客户端内核删库停更，但是当前各个版本依然能用。==</p><p>最后一版备份链接：<a href="https://archive.org/download/clash_for_windows_pkg">https://archive.org/download/clash_for_windows_pkg</a></p><p>打不开上面的备份链接可以从这里下载：<a href="https://www.clash.la/archives/750/">https://www.clash.la/archives/750/</a></p><p>下载其中的 <a href="https://archive.org/download/clash_for_windows_pkg/Clash.for.Windows-0.20.39-x64-linux.tar.gz">Clash.for.Windows-0.20.39-x64-linux.tar.gz</a></p><ol start="2"><li>解压缩</li></ol><p>下载完毕后，在ubuntu内解压缩</p><p>进入到解压后的文件夹，在当前终端运行命令</p><p><code>./cfw</code></p><ol start="3"><li>设置代理</li></ol><p>打开设置-网络-网络代理（齿轮），将http/https代理指向本机的clash默认端口7890（clash界面启动页可以修改Port），具体配置参考下面图片</p><p><img src="https://img.mahaofei.com/img/20230313151428.png" alt=""></p><ol start="4"><li>设置订阅链接</li></ol><p>从代理服务商处获取订阅链接，填入clash,选好节点即可</p><ol start="5"><li>在clash配置界面设置开机自启动，重启后就不需要再<code>./cfw</code>了</li></ol><p><strong>（2）Warp-Cloudflare</strong></p><p>程序安装步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add cloudflare gpg key</span></span><br><span class="line">curl https://pkg.cloudflareclient.com/pubkey.gpg | sudo gpg --yes --dearmor --output /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add this repo to your apt repositories</span></span><br><span class="line">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/cloudflare-client.list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install cloudflare-warp</span><br></pre></td></tr></table></figure><p>图形化界面安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mrmoein/warp-cloudflare-gui</span><br><span class="line">cd warp-cloudflare-gui</span><br><span class="line">python3 install.py</span><br><span class="line">sudo chmod +x ~/.local/share/applications/warp-gui.desktop</span><br></pre></td></tr></table></figure><p>设置开机自启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 /home/mahaofei/Software/warp-cloudflare-gui/main.py --hide</span><br></pre></td></tr></table></figure><h2 id="3-4-安装输入法">3.4 安装输入法</h2><p><strong>（1）搜狗输入法（推荐）</strong></p><p><a href="https://shurufa.sogou.com/linux">搜狗输入法linux</a></p><p>安装fcitx输入法框架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx</span><br><span class="line">sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/</span><br><span class="line">sudo apt purge ibus</span><br></pre></td></tr></table></figure><p>安装搜狗输入法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_版本号_amd64.deb</span><br></pre></td></tr></table></figure><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2</span><br><span class="line">sudo apt install libgsettings-qt1</span><br></pre></td></tr></table></figure><p>重启电脑</p><p>如果还没有搜狗拼音，那么点右上角的【键盘图标-Configure】，点击左下角加号+，取消勾选Only Show Current Language，然后搜索so，添加搜狗输入法。</p><p><strong>（2）ibus 输入法（推荐）</strong></p><p>首先在设置中安装中文语言，并将键盘系统设置为ibus</p><p>回到语言设置，在Input Sources中添加Chinese(Intelligent Pinyin)</p><p>就需要安装 ibus 输入法了，安装 ibus 框架需要在 Terminal 中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4</span><br></pre></td></tr></table></figure><p>ibus框架安装完成后，再切换到ibus框架，即在Terminal中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im-config -s ibus</span><br></pre></td></tr></table></figure><p>切换到ibus框架之后，再接着安装中文拼音引擎，即在Terminal中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-pinyin</span><br></pre></td></tr></table></figure><p>然后调出 IBus Preference 窗口来添加该中文拼音输入法，即在Terminal中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ibus-setup</span><br></pre></td></tr></table></figure><p>如果需要词库，可以下载搜狗词库，然后通过<a href="http://tools.bugscaner.com/sceltotxt/">此在线工具</a>转换为 txt 格式，再导入至用户数据。</p><p><strong>（3）Rime 输入法（实测不太好用）</strong></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ibus-rime</span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/rime/plum/master/rime-install | bash</span><br></pre></td></tr></table></figure><p>应用：在ubuntu系统设置里 -&gt; 区域&amp;语言（Region &amp; Language） -&gt; 输入法（Input Sources）设置为Rime。（可能需要注销重新登录才能显示）</p><p>配置rime多端同步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.config/ibus/rime/installation.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">distribution_code_name:</span> <span class="string">&quot;ibus-rime&quot;</span></span><br><span class="line"><span class="attr">distribution_name:</span> <span class="string">Rime</span></span><br><span class="line"><span class="attr">distribution_version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">install_time:</span> <span class="string">&quot;Mon Nov 20 13:45:04 2023&quot;</span></span><br><span class="line"><span class="attr">installation_id:</span> <span class="string">&quot;ubuntu&quot;</span> <span class="comment"># 区分多个设备</span></span><br><span class="line"><span class="attr">rime_version:</span> <span class="number">1.5</span><span class="number">.3</span></span><br><span class="line"><span class="attr">sync_dir:</span> <span class="string">&quot;/home/mahaofei/Documents/OneDrive/Documents/Rime&quot;</span> <span class="comment"># 同步路径</span></span><br></pre></td></tr></table></figure><p>配置rime横向：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.config/ibus/rime/build/ibus_rime.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">style:</span></span><br><span class="line">  <span class="attr">horizontal:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置候选词数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.config/ibus/rime/default.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">page_size:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>更新配置：点击右上角rime输入法的部署，或者重启ibus（<code>ibus restart</code>）。</p><h2 id="3-5-OneDrive">3.5 OneDrive</h2><p>参考项目：<a href="https://github.com/abraunegg/onedrive">abraunegg/onedrive</a>来使用[[03_Ubuntu使用OneDrive|OneDrive同步文件]]。</p><p><strong>（1）安装依赖</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install build-essential </span><br><span class="line">apt install libcurl4-openssl-dev -y</span><br><span class="line">apt install libsqlite3-dev -y</span><br><span class="line">apt install pkg-config -y</span><br><span class="line">apt install libnotify-dev -y</span><br><span class="line">curl -fsS https://dlang.org/install.sh | bash -s dmd</span><br></pre></td></tr></table></figure><p>激活DMD</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/dlang/dmd-2.082.0/activate</span><br></pre></td></tr></table></figure><p><strong>（2）安装onedrive客户端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/abraunegg/onedrive.git</span><br><span class="line">cd onedrive</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>（3）第一次配置</strong></p><p>输入以下命令登录onedrive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive</span><br></pre></td></tr></table></figure><p>下载config文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.config/onedrive</span><br><span class="line">wget https://raw.githubusercontent.com/abraunegg/onedrive/master/config -O ~/.config/onedrive/config</span><br><span class="line">nano ~/.config/onedrive/config</span><br></pre></td></tr></table></figure><p>打开config文件中的下面几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sync_dir = &quot;~/disk/ubuntu/onedrive&quot;</span><br><span class="line">monitor_interval = &quot;60&quot;</span><br><span class="line">skip_dir = &quot;图片&quot; #跳过同步的路径，可以用|来分割，例如：&quot;Desktop|Documents/IISExpress*&quot;</span><br></pre></td></tr></table></figure><p><strong>（4）同步</strong></p><p>第一次同步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --synchronize</span><br></pre></td></tr></table></figure><p>实时同步（可添加到自动启动程序中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onedrive --monitor</span><br></pre></td></tr></table></figure><p><strong>（5）图形化界面</strong></p><p>下载<a href="https://github.com/bpozdena/OneDriveGUI/releases">OneDriveGUI</a>项目中的AppImage。</p><p>授予可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x OneDriveGUI-1.0.3-x86_64.AppImage</span><br></pre></td></tr></table></figure><p>第一次启动，双击或命令行启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/mahaofei/Downloads/OneDriveGUI-1.0.3-x86_64.AppImage</span><br></pre></td></tr></table></figure><p>选择【Import from existing config】，用户名输入自己的微软帐号，config文件选择刚刚修改的<code>~/.config/onedrive/config</code>这个文件。</p><p>完成，将<code>/home/mahaofei/Downloads/OneDriveGUI-1.0.3-x86_64.AppImage</code>这行命令添加到开始菜单的【应用启动程序】中，设置为开机自启动。</p><h2 id="3-6-Zotero">3.6 Zotero</h2><p>在<a href="https://www.zotero.org/">Zotero官网</a>下载tar.bz2安装包，解压之后移动到保存软件的位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv Zotero_linux-x86_64/* /opt/zotero/</span><br></pre></td></tr></table></figure><p>然后更新zotero的desktop位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/zotero</span><br><span class="line">sudo ./set_launcher_icon</span><br></pre></td></tr></table></figure><p>然后创建软连接添加图标</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/zotero/zotero.desktop ~/.local/share/applications/zotero.desktop</span><br></pre></td></tr></table></figure><p>注意一定是绝对路径。</p><h2 id="3-7-VMWare">3.7 VMWare</h2><p>到<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware</a>官网下载安装包，然后使用下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x VMware-Workstation-Full-17.0.2-21581411.x86_64.bundle</span><br><span class="line">sudo ./VMware-Workstation-Full-17.0.2-21581411.x86_64.bundle</span><br></pre></td></tr></table></figure><p>使用以下命令卸载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止vmware服务</span></span><br><span class="line">sudo systemctl stop vmware.service</span><br><span class="line">sudo systemctl stop vmware-workstation-server.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到安装包执行卸载命令</span></span><br><span class="line">cd path_to_vmware_install_package/vmware-workstation/</span><br><span class="line">sudo ./vmware-installer --uninstall-product vmware-workstation</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除数据</span></span><br><span class="line">sudo rm -rf /usr/lib/vmware-workstation/</span><br><span class="line">sudo rm -rf /etc/vmware-workstation/</span><br><span class="line">sudo rm -rf /var/lib/vmware-workstation/</span><br><span class="line">rm -rf ~/.vmware/</span><br></pre></td></tr></table></figure><h2 id="3-8-QQ">3.8 QQ</h2><p>下载链接：<a href="https://im.qq.com/linuxqq/index.shtml">https://im.qq.com/linuxqq/index.shtml</a></p><p>下载<code>x86</code>的<code>.deb</code>文件</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请更换为自己的版本号</span></span><br><span class="line">sudo dpkg -i linuxqq_3.2.2-18394_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="3-9-QQ-Music">3.9 QQ Music</h2><p>下载链接：<a href="https://y.qq.com/download/download.html">https://y.qq.com/download/download.html</a></p><p>下载<code>Linux</code>的<code>.deb</code>文件</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">请更换为自己的版本号</span></span><br><span class="line">sudo dpkg -i qqmusic_1.1.5_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="3-10-微信">3.10 微信</h2><p>进入<a href="https://www.ubuntukylin.com/applications/">优麒麟软件库</a>，下载<a href="https://www.ubuntukylin.com/applications/119-cn.html">微信(Wine)</a></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f -y ./ukylin-wine_70.6.3.25_amd64.deb</span><br><span class="line">sudo apt-get install -f -y ./ukylin-wechat_3.0.0_amd64.deb</span><br></pre></td></tr></table></figure><h2 id="3-11-Tailscale">3.11 Tailscale</h2><p><a href="https://tailscale.com/">Tailscale</a> 是一个远程构建局域网的工具，可以让你在任何一个网络下像访问局域网的设备一样，操作所有登录自己 tailscale 账号的设备。</p><p><strong>安装：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://tailscale.com/install.sh | sh</span><br></pre></td></tr></table></figure><p><strong>启动</strong>，然后登录自己的账号，在控制台可以查看自己的 tailscale IP，只要其它电脑也登录了同义账号，就可以使用此 IP 直接 ssh 或远程桌面，任意网络都可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tailscale up</span><br></pre></td></tr></table></figure><p><strong>设置开机启动</strong>（需要 sudo 权限无法直接添加应用启动程序）</p><p>检查系统目录/lib/systemd/system/rc-local.service，如果没有自己新建，文件内容为（如果文件存在本身是没有[Install]项的，需要自己添加进去）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /lib/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### 文件中本身就有的</span></span></span><br><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">Documentation=man:systemd-rc-local-generator(8)</span><br><span class="line">ConditionFileIsExecutable=/etc/rc.local</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">GuessMainPID=no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###  需要自己添加</span></span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查/etc/systemd/system/rc-local.service，进行以上修改，如果没有就创建一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure><p>创建/etc/rc.local 脚本文件，并写入想要运行的脚本程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/rc.local</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里就是需要开机启动的程序</span></span><br><span class="line">sudo tailscale up</span><br></pre></td></tr></table></figure><p>给 rc.local 执行的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>启用服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable rc-local</span><br><span class="line">sudo systemctl start rc-local.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">sudo systemctl status rc-local.service</span><br></pre></td></tr></table></figure><h1>四、编程工具</h1><h2 id="4-1-Anaconda">4.1 Anaconda</h2><p><a href="https://www.anaconda.com/products/distribution">https://www.anaconda.com/products/distribution</a></p><h2 id="4-2-Qt5-9">4.2 Qt5.9</h2><p><strong>（1）下载</strong></p><p>官网链接：<a href="https://download.qt.io/archive/qt/">https://download.qt.io/archive/qt/</a></p><p>或者直接在终端下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.qt.io/official_releases/qt/5.9/5.9.9/qt-opensource-linux-x64-5.9.9.run</span><br></pre></td></tr></table></figure><p><strong>（2）安装</strong></p><p>调整权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x qt-opensource-linux-x64-5.9.9.run</span><br></pre></td></tr></table></figure><p>安装 g++ (若没有安装过g++，则安装，安装过执行也无影响)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure><p>安装通用字体配置库- runtime</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libfontconfig1</span><br></pre></td></tr></table></figure><p>执行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qt-opensource-linux-x64-5.9.9.run</span><br></pre></td></tr></table></figure><p><strong>（3）修改QT执行程序</strong></p><p><strong>正常使用QT进行ROS开发时会出现一些错误，通过修改QT执行程序来解决。</strong></p><p>修改执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.local/share/applications/DigiaQt-qtcreator-community.desktop</span><br></pre></td></tr></table></figure><p>修改<code>Exec</code>行为下面的格式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec=bash -i -c /home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p><strong>但是这样修改之后，每次开机只能启动一次QT，第二次点击QT快捷方式就启动不起来了。</strong></p><p>可以修改<code>~/.bashrc</code>，在最后一行添加下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias qt=/home/huffie/Software/QT/Tools/QtCreator/bin/qtcreator</span><br></pre></td></tr></table></figure><p>然后每次启动都在终端使用<code>qt</code>命令启动QT，这样就ok了。</p><h2 id="4-3-VSCode">4.3 VSCode</h2><p>下载key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; packages.microsoft.gpg</span><br></pre></td></tr></table></figure><p>加入key到系统并注入官网地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo install -o root -g root -m 644 packages.microsoft.gpg /usr/share/keyrings/</span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/packages.microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main&quot; &gt; /etc/apt/sources.list.d/vscode.list&#x27;</span><br></pre></td></tr></table></figure><p>更新获取VSCode信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install code # or code-insiders</span><br></pre></td></tr></table></figure><p>这样，以后就可以直接执行apt命令更新和管理code了。</p><p><strong>插件</strong></p><ul><li>WakaTime: <a href="https://wakatime.com/dashboard">https://wakatime.com/dashboard</a></li><li>Jupyter</li><li>C++</li><li>Python</li><li>HTML CSS</li><li>Remote SSH</li></ul><h2 id="4-4-PyCharm">4.4 PyCharm</h2><p><strong>社区版不能用Jupyter，考虑专业版</strong></p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/622701924">https://zhuanlan.zhihu.com/p/622701924</a></p><p><strong>（1）下载资源</strong></p><p>到Pycharm官网下载2023.1.1版本的Pycharm：<a href="https://www.jetbrains.com/pycharm/download/other.html">https://www.jetbrains.com/pycharm/download/other.html</a><br>下载<code>jetbrains-agent.jar</code>(原作者提供)</p><p><strong>（2）破解文件</strong></p><p>将pycharm的tar.gz压缩包提取出来，并将里面的<code>pycharm-2023.1</code>移动到你保存程序的地方。</p><p>进入此文件夹，找到<code>bin/pycharm64.vmoptions</code>文件，编辑此文件，在文件的最后添加fineagent.jar的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:/your_path/fineagent.jar</span><br></pre></td></tr></table></figure><p><strong>（3）激活PyCharm</strong></p><p>终端运行bin目录的<code>pycharm.sh</code>文件，然后输入参考链接中的License Server。</p><p>激活成功！</p><h2 id="4-5-CUDA">4.5 CUDA</h2><ol><li>去官网下载cuda安装包：<a href="https://developer.nvidia.com/cuda-11-6-0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=20.04&amp;target_type=deb_local">CUDA11.6</a>，相关选项如下（根据实际情况选择）：</li></ol><p><img src="https://pic3.zhimg.com/80/v2-667ab3e5e1f8de904b454bbb56c25b4a_720w.webp" alt=""></p><ol start="2"><li>运行网页提示的命令进行安装：</li></ol><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.6.0/local_installers/cuda_11.6.0_510.39.01_linux.run</span><br><span class="line">sudo sh cuda_11.6.0_510.39.01_linux.run</span><br></pre></td></tr></table></figure><pre><code>可能会报一个警告：</code></pre><p><img src="https://pic4.zhimg.com/80/v2-ffbf901af98e48003991dc72428a6823_720w.webp" alt=""></p><p>可以卸载旧版本<code>sudo apt-get remove --purge nvidia*</code>，再Continue就好。然后根据提示选择安装选项，注意不要勾选第一个安装显卡驱动的，因为之前已经安装过了。 安装完成后提示</p><p><img src="https://pic3.zhimg.com/80/v2-756a4bd5e7b8df867b2afd6190f052b2_720w.webp" alt=""></p><ol start="2"><li>根据上图提示需要配置环境变量：</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano  ~/.bashrc</span><br></pre></td></tr></table></figure><p>再文件最后加入以下语句：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export CUDA_HOME=/usr/local/cuda-11.6</span><br><span class="line">export LD_LIBRARY_PATH=$&#123;CUDA_HOME&#125;/lib64</span><br><span class="line">export PATH=$&#123;CUDA_HOME&#125;/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure><p>然后使其生效：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><ol start="3"><li>可以使用命令<code>nvcc -V</code>查看安装的版本信息：</li></ol><p><img src="https://pic4.zhimg.com/80/v2-e45956e3032e486ee4485830d1e0453f_720w.webp" alt=""></p><h2 id="4-6-CuDNN">4.6 CuDNN</h2><p>进入到CUDNN的下载官网：<a href="https://link.zhihu.com/?target=https%3A//developer.nvidia.com/rdp/cudnn-download">cuDNN Download | NVIDIA Developer</a>，然点击Download开始选择下载版本，当然在下载之前还有登录，选择版本界面如下：</p><p><img src="https://pic4.zhimg.com/80/v2-b39bf69766e2bff31548cd2ccbb6e003_720w.webp" alt=""></p><p>我们选择和之前cuda版本对应的cudnn版本：</p><p><img src="https://pic1.zhimg.com/80/v2-e4c256e6cee42ba18a2c01de6c3798e4_720w.webp" alt=""></p><p>下载之后是一个压缩包，对它进行解压，命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf cudnn-11.x-linux-x64-v8.0.5.39.tgz</span><br></pre></td></tr></table></figure><p>使用以下两条命令复制这些文件到CUDA目录下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/lib/* /usr/local/cuda-11.6/lib64/</span><br><span class="line">sudo cp cuda/include/* /usr/local/cuda-11.6/include/</span><br></pre></td></tr></table></figure><p>拷贝完成之后，可以使用以下命令查看CUDNN的版本信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2</span><br></pre></td></tr></table></figure><p>可以看到版本信息如下，为<code>8.0.5</code>：</p><p><img src="https://pic2.zhimg.com/80/v2-61030edf86acd862ac404470b05988c5_720w.webp" alt=""></p><h2 id="4-7-GitHub-Desktop">4.7 GitHub Desktop</h2><p>项目链接：<a href="https://github.com/shiftkey/desktop">https://github.com/shiftkey/desktop</a></p><p>添加源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://apt.packages.shiftkey.dev/gpg.key | gpg --dearmor | sudo tee /usr/share/keyrings/shiftkey-packages.gpg &gt; /dev/null</span><br><span class="line">sudo sh -c &#x27;echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/shiftkey-packages.gpg] https://apt.packages.shiftkey.dev/ubuntu/ any main&quot; &gt; /etc/apt/sources.list.d/shiftkey-packages.list&#x27;</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install github-desktop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COLMAP+OpenMVS实现物体三维重建mesh模型</title>
      <link href="/post/227160b0.html"/>
      <url>/post/227160b0.html</url>
      
        <content type="html"><![CDATA[<h1>一、环境准备</h1><p><strong>(1) COLMAP</strong></p><p>进入<a href="https://demuc.de/colmap/">COLMAP官网</a>，打开<a href="https://demuc.de/colmap/">下载页面</a>，下载<a href="https://github.com/colmap/colmap/releases">COLMAP程序</a>。</p><p><strong>(2) OpenMVS</strong></p><p>OpenMVS可以自己从源码下载进行编译。如果觉得编译openmvs可能要费点时间，那也可以直接下载编译好的可执行程序。</p><p>Github源码：<a href="https://github.com/cdcseacave/openMVS">https://github.com/cdcseacave/openMVS</a><br>可执行程序：<a href="https://github.com/cdcseacave/openMVS_sample">https://github.com/cdcseacave/openMVS_sample</a></p><h1>二、COLMAP重建得到稠密点云</h1><ol><li><strong>新建一个文件夹</strong>，在其中<strong>新建images文件夹</strong>，以及一个<strong>Database.db的空文件</strong>，注意文件路径不要出现中文。<strong>images文件夹中放入需要重建的图片</strong>，图片越多重建时间越长，图片过少可能会重建失败，我这里以96张图片为例，生成稠密点云05。</li></ol><p>本文使用DTU数据集进行测试。</p><p>自建数据集要求：</p><ul><li>尽量使用单反相机或专业数码相机进行数据采集，如果要用手机进行采集，请使用单摄像头的手机进行数据采集。</li><li>尽量选择纹理丰富的外界环境进行数据采集，避免玻璃围墙、瓷砖和打蜡地板等强反光材料环境</li><li>尽量选择光照明亮，且光照条件变化不剧烈的环境，最好选择室内环境。如室内客厅，开启客厅大灯进行灯光补偿。</li><li>尽量围绕重建物体或环境采集较多的影像，且在采集过程中控制快门速度，避免模糊。</li></ul><p><img src="https://img.mahaofei.com/img/20220627202501.png" alt=""></p><ol start="2"><li>打开colmap程序(COLMAP.bat)，<strong>点击File-New Project</strong>，在Database栏点击open，选择刚才新建的Database.db文件，在Images栏选择刚才新建的存放图片的images文件夹，点击save保存。</li></ol><p><img src="https://img.mahaofei.com/img/20220627203432.png" alt=""></p><ol start="3"><li>点击<strong>Processing-Feature Extraction</strong>，默认参数即可，点击Extract，等待程序运行完毕可看到右侧有log信息输出。</li></ol><p><img src="https://img.mahaofei.com/img/20220627203638.png" alt=""></p><ol start="4"><li>点击<strong>Processing-Feature matching</strong>，默认参数即可，点击Run，等待程序运行完毕可看到右侧有log信息输出。</li></ol><p><img src="https://img.mahaofei.com/img/20220627203803.png" alt=""></p><ol start="5"><li>点击<strong>Reconstruncion-Start reconstruction</strong>，等待执行完毕，即可得到重建的结果。</li></ol><p><img src="https://img.mahaofei.com/img/20220627210221.png" alt=""></p><ol start="6"><li>在之前images的同级目录下，<strong>新建一个文件夹dense</strong>。点击<strong>Reconstruncion-Dense reconstrction</strong>，点击select，选择刚才新建的dense文件夹用来保存稠密点云结果。依次点击<strong>Undistorion、Stereo、Fusion</strong>，执行完毕。</li></ol><p><img src="https://img.mahaofei.com/img/20220702085342.png" alt=""></p><ol start="7"><li><p>在程序中点击<strong>File-export model as txt</strong>，选择dense文件夹下的sparse文件夹（由于openmvs支支持txt格式的，所以需要将重建的文件转成txt文件）</p></li><li><p>检查camera.txt内的相机模型是否为Pinhole，如果不是则直接改成pinhole，不管之前选的是不是这里都可以直接改就行。</p></li></ol><h1>三、OpenMVS重建得到mesh模型</h1><p>以编译好的openmvs_sample为例，我们要把colmap生成的稠密点云以及图片路径信息等转换成openmvs的.mvs文件。</p><ol><li>打开命令提示窗口CMD，进入openmvs_sample下的bin目录，执行命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interfaceCOLMAP.exe -i E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense -o E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\scene.mvs --image-folder E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\images</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220702185742.png" alt=""></p><p>可以看到dense文件夹下生成了scene.mvs文件（-o为输出文件目录，默认是在当前文件夹下，也可以指定其它路径）。</p><ol start="2"><li>执行命令重建</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReconstructMesh.exe -i E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\scene.mvs -o E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\mesh.mvs</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220702190554.png" alt=""></p><ol start="3"><li>执行命令添加纹理（这一步比较占用计算机资源，本人电脑较老，运行时蓝屏重启了，大家酌情尝试一下）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextureMesh.exe -i E:\Projects\2022.06-3DReconstruction\<span class="built_in">test</span>\dense\mesh.mvs</span><br></pre></td></tr></table></figure><p>可以看到文件夹内新生成了四个文件，可以使用meshlab打开其中的.ply文件（三维mesh模型），下图为Solidworks打开的样子（未添加纹理）。</p><p><img src="https://img.mahaofei.com/img/mesh%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 3D点云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 三维重建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python复习笔记5——常用模块</title>
      <link href="/post/eaf704aa.html"/>
      <url>/post/eaf704aa.html</url>
      
        <content type="html"><![CDATA[<h1>一、内建模块</h1><h2 id="1-1-datetime日期时间">1.1 datetime日期时间</h2><p><strong>（1）导入模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure><p>仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code></p><p><strong>（2）获取日期时间</strong></p><p>获取当前日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now() <span class="comment"># 获取当前datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(now)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">16</span>:<span class="number">28</span>:<span class="number">07.198690</span></span><br></pre></td></tr></table></figure><p>获取指定日期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(dt)</span><br><span class="line"><span class="number">2015</span>-04-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p><strong>（3）日期时间加减</strong></p><p>加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(hours=<span class="number">10</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now - timedelta(days=<span class="number">1</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br></pre></td></tr></table></figure><p><strong>（4）时区转换</strong></p><p>通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(utc_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> 09:05:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(bj_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">17</span>:05:<span class="number">12.377316</span>+08:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为东京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(tokyo_dt)</span><br><span class="line"><span class="number">2015</span>-05-<span class="number">18</span> <span class="number">18</span>:05:<span class="number">12.377316</span>+09:<span class="number">00</span></span><br></pre></td></tr></table></figure><p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p><p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p><p><strong>（5）datetime与timestamp的转换</strong></p><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>。当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>把一个<code>datetime</code>类型转换为timestamp只需要简单调用<code>timestamp()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></span><br><span class="line"><span class="number">1429417200.0</span></span><br></pre></td></tr></table></figure><p>要把timestamp转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(datetime.fromtimestamp(t))</span><br><span class="line"><span class="number">2015</span>-04-<span class="number">19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure><p><strong>（6）datetime与str的转换</strong></p><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间。</p><p>转换方法是通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">&#x27;2015-6-1 18:19:59&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(cday)</span><br><span class="line"><span class="number">2015</span>-06-01 <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure><p>详细的指使符参考<a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">Python官方文档</a></p><p>要把日期格式化为字符串显示给用户，需要转换成str，转换方法是通过<code>strftime()</code>实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%a, %b %d %H:%M&#x27;</span>))</span><br><span class="line">Mon, May 05 <span class="number">16</span>:<span class="number">28</span></span><br></pre></td></tr></table></figure><h2 id="1-2-collections集合">1.2 collections集合</h2><p><strong>（1）namedtuple</strong></p><p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>（2）deque</strong></p><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈（代替list存在）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;x&#x27;</span>])</span><br></pre></td></tr></table></figure><p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p><p><strong>（3）OrderedDict</strong></p><p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></span><br><span class="line">OrderedDict([(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure><p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p><h2 id="1-3-itertools">1.3 itertools</h2><p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p><p><strong>（1）无限迭代器</strong></p><p><code>count()</code>会创建一个无限的迭代器，根本停不下来，只能按<code>Ctrl+C</code>退出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>natuals = itertools.count(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> natuals:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>cycle()</code>会把传入的一个序列无限重复下去，同样停不下来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cs = itertools.cycle(<span class="string">&#x27;ABC&#x27;</span>) <span class="comment"># 注意字符串也是序列的一种</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> cs:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="string">&#x27;C&#x27;</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="string">&#x27;C&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ns = itertools.repeat(&#x27;A&#x27;, 3)</span><br><span class="line">&gt;&gt;&gt; for n in ns:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p><strong>（2）有限迭代</strong></p><p><code>takewhile()</code>函数根据条件判断来截取出一个有限的序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>natuals = itertools.count(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ns = itertools.takewhile(<span class="keyword">lambda</span> x: x &lt;= <span class="number">10</span>, natuals)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(ns)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><code>chain()</code>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> itertools.chain(<span class="string">&#x27;ABC&#x27;</span>, <span class="string">&#x27;XYZ&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 迭代效果：&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27; &#x27;X&#x27; &#x27;Y&#x27; &#x27;Z&#x27;</span></span><br></pre></td></tr></table></figure><p><code>groupby()</code>把迭代器中相邻的重复元素挑出来放在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">&#x27;AAABBBCCAAA&#x27;</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(key, <span class="built_in">list</span>(group))</span><br><span class="line">...</span><br><span class="line">A [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">B [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">C [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">A [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br></pre></td></tr></table></figure><h1>二、第三方模块</h1><h2 id="2-1-Pillow">2.1 Pillow</h2><p>Pillow就是PIL的更新版本。由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，即Pillow。</p><blockquote><p>Pillow官方文档：<a href="https://pillow.readthedocs.org/">https://pillow.readthedocs.org/</a></p></blockquote><p><strong>（1）Pillow安装</strong></p><p>若使用Anaconda，则Pillow已默认安装。若自己搭建的python环境，使用以下命令安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow</span><br></pre></td></tr></table></figure><p><strong>（2）图像操作</strong></p><p>导入Pillow</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><p>打开图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个jpg图像文件，注意是当前路径:</span></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>保存图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把缩放后的图像用jpeg格式保存:</span></span><br><span class="line">im.save(<span class="string">&#x27;thumbnail.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>获得图像尺寸</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得图像尺寸:</span></span><br><span class="line">w, h = im.size</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Original image size: %sx%s&#x27;</span> % (w, h))</span><br></pre></td></tr></table></figure><p>缩放图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缩放到50%:</span></span><br><span class="line">im.thumbnail((w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>模糊图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用模糊滤镜:</span></span><br><span class="line">im2 = im.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br></pre></td></tr></table></figure><p><strong>（3）绘图</strong></p><p>创建图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (width, height), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br></pre></td></tr></table></figure><p>创建font对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font = ImageFont.truetype(<span class="string">&#x27;Arial.ttf&#x27;</span>, <span class="number">36</span>)</span><br></pre></td></tr></table></figure><p>创建draw对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw = ImageDraw.Draw(image)</span><br></pre></td></tr></table></figure><p>填充像素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw.point((x, y))</span><br></pre></td></tr></table></figure><p>输出文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">draw.text((x, y), <span class="string">&quot;Text&quot;</span>, font=font)</span><br></pre></td></tr></table></figure><p>示例：生成验证码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机字母:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rndChar</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(random.randint(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机颜色1:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rndColor</span>():</span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">64</span>, <span class="number">255</span>), random.randint(<span class="number">64</span>, <span class="number">255</span>), random.randint(<span class="number">64</span>, <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机颜色2:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rndColor2</span>():</span><br><span class="line">    <span class="keyword">return</span> (random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>), random.randint(<span class="number">32</span>, <span class="number">127</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 240 x 60:</span></span><br><span class="line">width = <span class="number">60</span> * <span class="number">4</span></span><br><span class="line">height = <span class="number">60</span></span><br><span class="line">image = Image.new(<span class="string">&#x27;RGB&#x27;</span>, (width, height), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line"><span class="comment"># 创建Font对象:</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">&#x27;Arial.ttf&#x27;</span>, <span class="number">36</span>)</span><br><span class="line"><span class="comment"># 创建Draw对象:</span></span><br><span class="line">draw = ImageDraw.Draw(image)</span><br><span class="line"><span class="comment"># 填充每个像素:</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        draw.point((x, y), fill=rndColor())</span><br><span class="line"><span class="comment"># 输出文字:</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    draw.text((<span class="number">60</span> * t + <span class="number">10</span>, <span class="number">10</span>), rndChar(), font=font, fill=rndColor2())</span><br><span class="line"><span class="comment"># 模糊:</span></span><br><span class="line">image = image.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">image.save(<span class="string">&#x27;code.jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://www.liaoxuefeng.com/files/attachments/966760380198752" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python复习笔记4——文件和目录操作</title>
      <link href="/post/d8e454a.html"/>
      <url>/post/d8e454a.html</url>
      
        <content type="html"><![CDATA[<h1>一、文件读写</h1><h2 id="1-1-读文件">1.1 读文件</h2><p><strong>（1）打开文件</strong></p><p>使用Python内置的<code>open()</code>函数，传入文件名和标示符，打开一个文件对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p>标示符<code>'r'</code>表示读，这样，我们就成功地打开了一个文件。</p><p>Python引入了<code>with</code>语句来避免程序出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><p>上面的代码相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p><strong>（2）读文件内容</strong></p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>read()</td><td>一次读取文件的全部内容</td></tr><tr><td>read(size)</td><td>每次最多读取size个字节的内容</td></tr><tr><td>readline()</td><td>每次读取一行内容</td></tr><tr><td>readlines()</td><td>一次读取所有内容并按行返回</td></tr></tbody></table><p><strong>（3）关闭文件</strong></p><p>调用<code>close()</code>方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p><strong>（4）读取其它编码格式文件</strong></p><p>要读取二进制文件，比如图片、视频等等，用<code>'rb'</code>模式打开文件即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&#x27;</span> <span class="comment"># 十六进制表示的字节</span></span><br></pre></td></tr></table></figure><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;测试&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-写文件">1.2 写文件</h2><p>调用<code>open()</code>，传入标识符<code>'w'</code>或者<code>'wb'</code>表示写文本文件或写二进制文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br></pre></td></tr></table></figure><p>可以反复调用<code>write()</code>来写入文件，但是务必要调用<code>f.close()</code>来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。</p><p>所以通常，还是使用<code>with</code>语句写文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>二、文件和目录操作</h1><p>Python内置的<code>os</code>模块可以直接调用操作系统提供的接口函数。</p><h2 id="2-1-目录操作">2.1 目录操作</h2><p><strong>（1）查看目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录的绝对路径:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（2）创建目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael/testdir&#x27;</span></span><br><span class="line"><span class="comment"># 然后创建一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.mkdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（3）删除目录</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉一个目录:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rmdir(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（4）合并与拆分路径</strong></p><p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/Users/michael&#x27;</span>, <span class="string">&#x27;testdir&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/Users/michael/testdir&#x27;</span></span><br></pre></td></tr></table></figure><p>要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(<span class="string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（5）获取扩展名</strong></p><p><code>os.path.splitext()</code>可以直接让你得到文件扩展名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(<span class="string">&#x27;/path/to/file.txt&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-文件操作">2.2 文件操作</h2><p><strong>（1）文件重命名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对文件重命名:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.rename(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）文件删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删掉文件:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.remove(<span class="string">&#x27;test.py&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>（3）复制与移动文件</strong></p><p><code>os</code>模块中并未提供复制与移动文件的函数，但<code>shutil</code>模块提供了<code>copyfile()</code>的函数，可以看作是<code>os</code>模块的补充。</p><p><code>shutil.copy(src_file, target_path)</code><br><code>shutil.move(src_file, target_path)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">shutil.copy(<span class="string">&#x27;/Users/michael/testdir1/file.txt&#x27;</span>, <span class="string">&#x27;/Users/michael/testdir2&#x27;</span>)</span><br><span class="line">shutil.move(<span class="string">&#x27;/Users/michael/testdir1/file.txt&#x27;</span>, <span class="string">&#x27;/Users/michael/testdir2&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>三、JSON</h1><p>要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，最常用的就是序列化为JSON。</p><p>因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p><h2 id="3-1-Python-dict-JSON">3.1 Python dict -&gt; JSON</h2><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>(name=<span class="string">&#x27;Bob&#x27;</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。<br><code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p><h2 id="3-2-JSON-Python-dict">3.2 JSON -&gt; Python dict</h2><p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">88</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Python-Class-JSON">3.3 Python Class -&gt; JSON</h2><p>由于通常情况下，我们会用<code>class</code>表示对象，如果直接将对象序列化肯定会报错，原因是<code>Student</code>对象不是一个可序列化为JSON的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: &lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10603cc50</span>&gt; <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</span><br></pre></td></tr></table></figure><p>但，<code>dumps()</code>方法还提供了一大堆的可选参数，其中<strong>可选参数<code>default</code>就支持通过提供转换函数</strong>，为<code>dumps()</code>传入对象实例以及转换函数，就可以实现序列化。</p><p>精简后的写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(json.dumps(s, default=<span class="keyword">lambda</span> obj: obj.__dict__))</span><br></pre></td></tr></table></figure><p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。</p><h2 id="3-4-JSON-Python-Class">3.4 JSON -&gt; Python Class</h2><p>如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dict2student</span>(<span class="params">d</span>):</span><br><span class="line">    <span class="keyword">return</span> Student(d[<span class="string">&#x27;name&#x27;</span>], d[<span class="string">&#x27;age&#x27;</span>], d[<span class="string">&#x27;score&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10cd3c190</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python复习笔记3——测试与调试技巧</title>
      <link href="/post/ab5ff75c.html"/>
      <url>/post/ab5ff75c.html</url>
      
        <content type="html"><![CDATA[<h1>一、错误处理</h1><h2 id="1-1-try">1.1 try</h2><p>Python内置了一套<code>try...except...finally...</code>的错误处理机制。</p><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">    r = <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result:&#x27;</span>, r)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except:&#x27;</span>, e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面的代码在计算<code>10 / 0</code>时会产生一个除法运算错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">except</span>: division by zero</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。</p><p>此外，如果没有错误发生，可以在<code>except</code>语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句</p><blockquote><p>常见的错误类型和继承关系参考：<a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p></blockquote><h2 id="1-2-记录错误">1.2 记录错误</h2><p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息打印出来，然后分析错误原因，同时，让程序继续执行下去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;END&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同样是出错，但程序打印完错误信息后会继续执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ERROR:root:division by zero</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">13</span>, <span class="keyword">in</span> main</span><br><span class="line">    bar(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> bar</span><br><span class="line">    <span class="keyword">return</span> foo(s) * <span class="number">2</span></span><br><span class="line">  File <span class="string">&quot;err_logging.py&quot;</span>, line <span class="number">6</span>, <span class="keyword">in</span> foo</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / <span class="built_in">int</span>(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="1-3-抛出错误">1.3 抛出错误</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;invalid value: %s&#x27;</span> % s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        foo(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p>在<code>bar()</code>函数中，捕获了错误打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去了。这种处理方式较为常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p><p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。</p><h1>二、调试</h1><p>众所周知，程序能一次写完并正常运行的概率几乎不存在。总会有各种各样的bug，因此，需要一整套调试程序的手段来修复bug。</p><h2 id="2-1-print">2.1 print</h2><p>最简单粗暴的方法就是用<code>print()</code>把可能有问题的变量打印出来看看，用<code>print()</code>最大的坏处是将来还得删掉它。</p><h2 id="2-2-断言assert">2.2 断言assert</h2><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：<code>assert 表达式, '打印的信息'</code>，如果断言assert表达式为True，则无效果继续执行，如果断言表达式出错，则打印信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">assert</span> n != <span class="number">0</span>, <span class="string">&#x27;n is zero!&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span> / n</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    foo(<span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则打印信息。</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>，这样程序中如果到处充斥着<code>assert</code>，和<code>print()</code>相比也好不到哪去。不过，启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -O err.py</span><br></pre></td></tr></table></figure><h2 id="2-3-logging">2.3 logging</h2><p>和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line"></span><br><span class="line">s = &#x27;0&#x27;</span><br><span class="line">n = int(s)</span><br><span class="line">logging.info(&#x27;n = %d&#x27; % n)</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure><p>它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。</p><h2 id="2-4-单步调试与断点">2.4 单步调试与断点</h2><p><strong>（1）pdb</strong></p><p>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pdb err.py</span><br></pre></td></tr></table></figure><p>以参数<code>-m pdb</code>启动后，pdb定位到下一步要执行的代码。</p><ul><li>输入命令<code>l</code>来查看代码</li><li>输入命令<code>n</code>可以单步执行代码。</li><li>输入命令<code>p 变量名</code>来查看变量</li><li>输入命令<code>q</code>结束调试，退出程序</li></ul><p><strong>（2）pdb.set_trace()</strong></p><p>这个方法也是用pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点。</p><p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行。</p><p><strong>（3）IDE</strong></p><p>使用一个支持调试功能的IDE，可以更好的设置断点、单步执行。</p><p>常规使用推荐Visual Studio Code：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>，需要安装Python插件。</p><p>大型项目推荐PyCharm：<a href="http://www.jetbrains.com/pycharm/">http://www.jetbrains.com/pycharm/</a>。</p><h1>三、测试</h1><h2 id="3-1-单元测试">3.1 单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p><p>比如对函数<code>abs()</code>，我们可以编写出以下几个测试用例：</p><ol><li>输入正数，比如<code>1</code>、<code>1.2</code>、<code>0.99</code>，期待返回值与输入相同；</li><li>输入负数，比如<code>-1</code>、<code>-1.2</code>、<code>-0.99</code>，期待返回值与输入相反；</li><li>输入<code>0</code>，期待返回<code>0</code>；</li><li>输入非数值类型，比如<code>None</code>、<code>[]</code>、<code>&#123;&#125;</code>，期待抛出<code>TypeError</code>。</li></ol><p>把上面的测试用例放到一个测试模块里，就是一个完整的单元测试。</p><p><strong>（1）编写单元测试</strong></p><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p><p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStudent</span>(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_80_to_100</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">80</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">        self.assertEqual(s1.get_grade(), <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        self.assertEqual(s2.get_grade(), <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_60_to_80</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">60</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">79</span>)</span><br><span class="line">        self.assertEqual(s1.get_grade(), <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">        self.assertEqual(s2.get_grade(), <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_0_to_60</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">        self.assertEqual(s1.get_grade(), <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        self.assertEqual(s2.get_grade(), <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_invalid</span>(<span class="params">self</span>):</span><br><span class="line">        s1 = Student(<span class="string">&#x27;Bart&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line">        s2 = Student(<span class="string">&#x27;Lisa&#x27;</span>, <span class="number">101</span>)</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(ValueError):</span><br><span class="line">            s1.get_grade()</span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(ValueError):</span><br><span class="line">            s2.get_grade()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEqual()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></span><br></pre></td></tr></table></figure><p><strong>（2）运行单元测试</strong></p><p>最简单的运行方式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest mydict_test</span><br></pre></td></tr></table></figure><h2 id="3-2-文档测试">3.2 文档测试</h2><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p>当我们编写注释时，如果写上这样的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Calculate 1*2*...*n</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(10)</span></span><br><span class="line"><span class="string">    3628800</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p><p>使用doctest进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>运行测试程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br></pre></td></tr></table></figure><p>什么输出也没有。这说明我们编写的doctest运行都是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python复习笔记2——面向对象编程</title>
      <link href="/post/604a94da.html"/>
      <url>/post/604a94da.html</url>
      
        <content type="html"><![CDATA[<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p><p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><h1>一、类Class和实例Instance</h1><p>面向对象最重要的概念就是类和实例。</p><ul><li>类是抽象的模板</li><li>实例是根据类创建出来的一个个具体的“对象”</li></ul><p>在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong><code>class</code>后面紧接着是类名</strong>，即<code>Student</code>，<strong>类名通常是大写开头的单词</strong>，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><p><strong>创建实例是通过类名+()实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huffie = Student()</span><br></pre></td></tr></table></figure><p>变量<code>bart</code>指向的就是一个<code>Student</code>的实例</p><h1>二、面向对象的三大特性：封装、继承、多态</h1><h2 id="2-1-封装">2.1 封装</h2><p><strong>（1）__init__方法</strong></p><p>通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p><p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">huffie = Student(<span class="string">&#x27;huffie&#x27;</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure><p><strong>（2）类的方法</strong></p><p><code>Student</code>实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法。</p><p>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure><p>要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bart.print_score()</span><br></pre></td></tr></table></figure><p><strong>（3）访问限制</strong></p><p>类的内部可以有属性和方法，外部代码通过实例变量的方法来操作数据，这样就隐藏了内部的复杂逻辑。</p><p>但外部代码还是可以自由的修改实例的属性。</p><p>要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>。在Python中，<strong>实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private）</strong>，只有内部可以访问，外部不能访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))</span><br></pre></td></tr></table></figure><p>这样就确保了外部代码不能随意修改对象的属性，使代码更稳定可靠。</p><p>如果外部代码要获取name和score，或者要修改score，可以给Student类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">        self.__score = score</span><br></pre></td></tr></table></figure><p><strong>（4）类属性和实例属性</strong></p><p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.score = <span class="number">90</span></span><br></pre></td></tr></table></figure><p>给类绑定属性可以直接在class中定义属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br></pre></td></tr></table></figure><p>类属性的特性参考以下测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    name = <span class="string">&#x27;Student&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p><h2 id="2-2-继承">2.2 继承</h2><p>定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p><strong>（1）继承的优点1：子类拥有父类的属性和方法</strong></p><p>继承最大的好处是子类获得了父类的全部功能。即子类自动拥有父类的所有共有属性和方法。</p><p>举例如下，对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。<code>Cat</code>和<code>Dog</code>类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>（2）继承的优点2：子类可以修改父类的方法</strong></p><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-多态">2.3 多态</h2><p>首先说明，<strong>当我们定义一个class的时候，我们实际上就定义了一种数据类型</strong>。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样。</p><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p><p><strong>（1）多态的优点</strong></p><p>当新增子类时，任何依赖父类作为参数的函数或方法都可以不加修改的正常运行。即</p><ul><li>对扩展开放：允许新增<code>父类</code>的子类；</li><li>对修改封闭：不需要修改依赖<code>父类</code>类型的函数。（例如<code>def func(父类)</code>）</li></ul><p><strong>（2）动态语言</strong></p><p>定义一个Animal类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>参考如下依赖<code>Animal</code>类的函数，其中调用了<code>Animal</code>类的方法<code>run</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>即使<code>Timer</code>类和<code>Animal</code>类毫无关系，但只要他们都有<code>run</code>方法就可以使用依赖<code>Animal</code>的函数。</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">animal = Animal()</span><br><span class="line">timer = Timer()</span><br><span class="line"></span><br><span class="line">run_twice(animal)</span><br><span class="line">run_twice(timer)</span><br></pre></td></tr></table></figure><h1>三、面向对象高级编程</h1><h2 id="3-1-property">3.1 @property</h2><p>前面介绍了<code>set</code>和<code>get</code>方法用来保证代码的稳定性，但这种调用方式过于复杂。因此…对于追求完美的Python程序员来说，参数的使用必须要简单！</p><p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了。<br>把一个setter方法变成属性，只需要加上<code>@func_name.setter</code>就可以了<br>只定义getter方法，不定义setter方法就是一个只读属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><h2 id="3-2-定制类">3.2 定制类</h2><p><strong>（1）<strong>slot</strong></strong></p><p>定义类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>为实例绑定属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 动态给实例绑定一个属性</span></span><br></pre></td></tr></table></figure><p>为实例绑定方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, age</span>): <span class="comment"># 定义一个函数作为实例方法</span></span><br><span class="line"><span class="meta">... </span>    self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span><br></pre></td></tr></table></figure><p>为类绑定方法，所有实例均可调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line"><span class="meta">... </span>    self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.set_score = set_score</span><br></pre></td></tr></table></figure><p>上面可以看到，在定义了实例后可以任意添加实例的属性，但如果我们想要限制实例的属性怎么办。</p><p>Python允许在定义class的时候，<strong>定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 绑定属性&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性&#x27;age&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性&#x27;score&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></span><br></pre></td></tr></table></figure><p>使用<code>__slots__</code>要注意，<strong><code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</strong>。</p><p><strong>（2）<strong>str</strong></strong></p><p>我们先定义一个<code>Student</code>类，打印一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb190</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x109afb190</span>&gt;</span><br></pre></td></tr></table></figure><p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。</p><p>怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法和<code>__repr__</code>方法，返回一个好看的字符串就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s) from __str__&#x27;</span> % self.name</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;Student object (name: %s) from __repr__&#x27;</span> % self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">Student <span class="built_in">object</span> (name: Michael) <span class="keyword">from</span> __str__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">Student <span class="built_in">object</span> (name: Michael) <span class="keyword">from</span> __repr__</span><br></pre></td></tr></table></figure><p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。</p><p>简便写法：<code>__repr__ = __str__</code></p><p><strong>（3）<strong>getattr</strong></strong></p><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。</p><p>要避免这个错误，除了可以加上一个<code>score</code>属性外，Python还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, attr</span>):</span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">&#x27;score&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">25</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;\&#x27;Student\&#x27; object has no attribute \&#x27;%s\&#x27;&#x27;</span> % attr)</span><br></pre></td></tr></table></figure><p>当调用不存在的属性或方法时，就会有返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">&#x27;Michael&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p><strong>（4）<strong>call</strong></strong></p><p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">&#x27;Michael&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s() <span class="comment"># self参数不要传入</span></span><br><span class="line">My name <span class="keyword">is</span> Michael.</span><br></pre></td></tr></table></figure><p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><h2 id="3-3-枚举类">3.3 枚举类</h2><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，好处是简单，缺点是类型是<code>int</code>，并且仍然是变量。</p><p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure><p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure><p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p><p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python复习笔记1——Python的高级特性与函数式编程</title>
      <link href="/post/88692170.html"/>
      <url>/post/88692170.html</url>
      
        <content type="html"><![CDATA[<h1>一、Python的高级特性</h1><p>Python中许多功能的实现都有许多方法。在python中并不是代码越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。基于这一思想，python中设计了许多非常有用的高级特性。</p><h2 id="1-1-列表生成式">1.1 列表生成式</h2><p><strong>（1）简单列表生成式</strong></p><p>例如要生成前10个数的平方<code>[1x1, 2x2, 3x3, ..., 10x10]</code>，使用常规办法需要借助循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">L.append(x * x)</span><br></pre></td></tr></table></figure><p>这种方式太过繁琐，而列表生成式可以使用一行语句代替上面的循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure><p>写列表生成式时，<strong>把要生成的元素<code>x*x</code>放到前面，后面跟for循环</strong>，就可以把list创建出来。</p><p><strong>（2）两层循环与多变量循环</strong></p><p>列表生成式支持多重循环，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;]</span></span><br></pre></td></tr></table></figure><p>三层以上的循环就很少用到了。</p><p>由于for循环支持两个甚至多个变量，因此列表生成式也支持同样的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;z&#x27;</span>: <span class="string">&#x27;C&#x27;</span> &#125;</span><br><span class="line">[k + <span class="string">&#x27;=&#x27;</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;y=B&#x27;, &#x27;x=A&#x27;, &#x27;z=C&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>（3）列表生成式的if用法</strong></p><p>for循环加if用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>跟在for后面的if是一个筛选条件。</p><p><strong>（4）列表生成式的if…else用法</strong></p><p>for循环加if…else用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]</span></span><br></pre></td></tr></table></figure><p>for前面的部分是一个表达式，它必须根据for循环得到的x计算出一个结果，作为列表的一个元素。</p><p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据x计算出确定的结果。如果只用if不加else，则考察表达式：<code>x if x % 2 == 0</code>，它无法根据x计算出结果，因此程序会报错。</p><p><strong>综上，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</strong></p><h2 id="1-2-生成器">1.2 生成器</h2><p>由于内存的限制，列表的容量是有限的，如果我们需要创建一个包含100万个元素的列表，但每次仅需要访问前几个元素，这样不仅占用了很大的存储空间，其它绝大多数元素占用的空间都白白浪费了。</p><p>如果元素列表可以按照某种算法推算出来，就可以在循环过程中不断推算列表元素，这样就不必一次创建完成的list，从而节省大量的空间，这种一边循环一边计算的机制，称为生成器generator。</p><p><strong>（1）创建生成器</strong></p><p>创建generator最简单的方法，把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span></span><br></pre></td></tr></table></figure><p>调用生成器generator的元素，可以通过for循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><p><strong>（2）使用yield创建生成器</strong></p><p>如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 1&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>可以通过<code>next()</code>函数获得generator的下一个返回值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p><p>generator函数和普通函数的执行流程不一样。普通函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>调用该generator函数时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = odd()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">step <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(o)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>把函数改成generator函数后，我们基本上从来不会用<code>next()</code>来获取下一个返回值，而是直接使用<code>for</code>循环来迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> odd():</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><h1>二、函数式编程</h1><h2 id="2-1-高阶函数">2.1 高阶函数</h2><p><strong>（1）变量指向函数</strong></p><p>函数本身也可以赋值给变量，即：变量可以指向函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">abs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(-<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>说明变量<code>f</code>现在已经指向了<code>abs</code>函数本身。直接调用<code>abs()</code>函数和调用变量<code>f()</code>完全相同。</p><p><strong>（2）函数名也是变量</strong></p><p>函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span> = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;int&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></table></figure><p>把<code>abs</code>指向<code>10</code>后，就无法通过<code>abs(-10)</code>调用该函数了！因为<code>abs</code>这个变量已经不指向求绝对值函数而是指向一个整数<code>10</code>！（当然实际代码不可能这么写）</p><p><strong>（3）传入函数</strong></p><p>一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y, f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure><p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，实现绝对值加法计算。</p><p><strong>（4）map/reduce</strong></p><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><p>举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="built_in">map</span>(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p><code>reduce()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>。<br><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p>例如把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">x, y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"><span class="number">13579</span></span><br></pre></td></tr></table></figure><p><strong>（5）filter</strong></p><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p><code>filter()</code>接收一个函数和一个序列，把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 == 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><p><strong>（6）sorted</strong></p><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。</p><p>Python内置的<code>sorted()</code>函数就可以对list进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])</span><br><span class="line">[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p>默认情况下，对字符串排序，是按照ASCII的大小比较的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>])</span><br><span class="line">[<span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</span><br></pre></td></tr></table></figure><p>若要忽略大小写，按照字母序排序，只要我们能用一个key函数把字符串映射为忽略大小写排序即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>]</span><br></pre></td></tr></table></figure><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="2-2-返回函数">2.2 返回函数</h2><p><strong>（1）函数作为返回值</strong></p><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p><p>例如如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function lazy_sum.&lt;<span class="built_in">locals</span>&gt;.<span class="built_in">sum</span> at <span class="number">0x101c6ed90</span>&gt;</span><br></pre></td></tr></table></figure><p>调用函数<code>f</code>时，才真正计算求和的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p><strong>（2）闭包</strong></p><p>上面例子中内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量。</p><p>闭包就是<strong>能够读取其他函数内部变量的函数</strong>。</p><p>需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常。但是，如果对外层变量赋值，由于Python解释器会把<code>x</code>当作函数<code>fn()</code>的局部变量，它会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inc</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> x</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(f()) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>原因是<code>x</code>作为局部变量并没有初始化，直接计算<code>x+1</code>是不行的。但我们其实是想引用<code>inc()</code>函数内部的<code>x</code>，所以需要在<code>fn()</code>函数内部加一个<code>nonlocal x</code>的声明。加上这个声明后，解释器把<code>fn()</code>的<code>x</code>看作外层函数的局部变量，它已经被初始化了，可以正确计算<code>x+1</code>。</p><h2 id="2-3-匿名函数">2.3 匿名函数</h2><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><p>也可以把匿名函数作为返回值返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span>: x * x + y * y</span><br></pre></td></tr></table></figure><h2 id="2-4-装饰器">2.4 装饰器</h2><p>假设我们要增强某个函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p><p>本质上，decorator就是一个返回函数的高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>观察上面的<code>log</code>，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。（其中<code>__name__</code>属性，可以拿到函数的名字）</p><p>使用log函数时要借助Python的@语法，把decorator置于函数的定义处</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2022-6-28&#x27;</span>)</span><br></pre></td></tr></table></figure><p>把<code>@log</code>放到<code>now()</code>函数的定义处，相当于执行了语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now = log(now)</span><br></pre></td></tr></table></figure><p>调用<code>now()</code>函数，不仅会运行<code>now()</code>函数本身，还会在运行<code>now()</code>函数前打印一行日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2022</span>-<span class="number">6</span>-<span class="number">28</span></span><br></pre></td></tr></table></figure><p>由于函数有<code>__name__</code>等属性，但经过decorator装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p><p>一个完整的decorator的写法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>带参数的decorator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><h2 id="2-5-偏函数">2.5 偏函数</h2><p>Python的<code>functools</code>模块提供了偏函数（Partial function）功能。把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>例如<code>int()</code>函数提供了额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br></pre></td></tr></table></figure><p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="built_in">int</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">&#x27;1010101&#x27;</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维重建方法汇总</title>
      <link href="/post/cff1c9b1.html"/>
      <url>/post/cff1c9b1.html</url>
      
        <content type="html"><![CDATA[<h1>一、什么是三维重建</h1><p>三维重建是用相机拍摄真实世界的物体、场景，通过计算机视觉技术进行处理，从而得到物体的三维模型。</p><p>主要涉及技术包括：多视图立体几何、深度图估计、点云处理、网格重建和优化、纹理贴图、马尔可夫随机场、图像分割等。</p><p>主要应用领域包括：增强现实、混合现实、机器人导航、自动驾驶、工业工件尺寸检测、平整度检测等。</p><h1>二、传统三维重建方法</h1><h2 id="2-1-RGBD">2.1 RGBD</h2><h3 id="基础">基础</h3><p>深度相机：可以直接获取被测对象三维信息的相机。</p><p>深度相机主要分为结构光相机和ToF相机。结构光相机是指通过一个红外投影仪向前方投射光栅或激光散斑，再使用相机拍摄是光栅和光斑的形状尺寸，从而得到物体三维信息。ToF是通过测量发射脉冲与接受之间的时间，从而计算目标距离。</p><h3 id="KinectFusion-2011">KinectFusion - 2011</h3><blockquote><p>论文：<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6162880" title="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6162880">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6162880</a><br>代码：<a href="https://github.com/chrdiller/KinectFusionApp" title="https://github.com/chrdiller/KinectFusionApp">https://github.com/chrdiller/KinectFusionApp</a></p></blockquote><p>KinectFusion是第一个使用RGBD相机的三维重建系统，使用的地图是TSDF地图，后续很多实时三维重建系统都是在KinectFusion上扩展的。</p><p>实现流程：首先获取RGBD图像，计算点云以及归一化后的法向量；然后通过ICP算法计算当前帧的相机位姿；之后将当前点云融合到TSDF地图中，最后通过TSDF地图以及当前帧的位姿预测处当前帧的深度图像。</p><p>TSDF地图是一种网格式的地图，先选定要建模的三维空间，按照一定分辨率，将这个空间分成许多小块，存储每个小块内部的信息。每个TSDF体素内，存储了该小块与最近的物体表面的距离。如果小块在最近物体表面的前方，它就有一个正的值；反之，如果该小块位于表面之后，那么这个值就为负。由于物体表面通常是很薄的一层，所以就把值太大的和太小的都取成1和-1，这就得到了截断之后距离，也就是所谓的TSDF。</p><h3 id="BundleFunsion-2016">BundleFunsion - 2016</h3><blockquote><p>论文：<a href="https://arxiv.org/abs/1604.01093">https://arxiv.org/abs/1604.01093</a><br>代码：<a href="https://github.com/niessner/BundleFusion">https://github.com/niessner/BundleFusion</a></p></blockquote><p>大致流程：输入的color+depth的数据流首先需要做帧与帧之间的对应关系匹配，然后做全局位姿优化，将整体的漂移校正过来（上图下方所示），整个重建过程中模型是在不断动态更新的。</p><p>在匹配方面，这里使用的是一种sparse-then-dense的并行全局优化方法。也就是说，先使用稀疏的SIFT特征点来进行比较粗糙的配准，因为稀疏特征点本身就可以用来做loop closure检测和relocalization。然后使用稠密的几何和光度连续性进行更加细致的配准。</p><p>在位姿优化方面。这里使用了一种分层的 local-to-global 的优化方法，如下图所示。总共分为两层，在最低的第一层，每连续10帧组成一个chunk，第一帧作为关键帧，然后对这个chunk内所有帧做一个局部位姿优化。在第二层，只使用所有的chunk的关键帧进行互相关联然后进行全局优化。为什么要分层这么麻烦呢？或者说这样分层有什么好处呢？因为可以剥离出关键帧，减少存储和待处理的数据。并且这种分层优化方法减少了每次优化时的未知量，保证该方法可扩展到大场景而漂移很小。</p><p>在稠密场景重建方面。该算法在特征匹配设置了三道筛选策略。第一种是直接对关键点本身分布的一致性和稳定性进行考验。第二道关卡是对特征匹配对跨越的表面面积进行考验，去掉特别小的，因为跨越面积较小的的话很容易产生歧义。第三道关卡是进行稠密的双边几何和光度验证，去掉重投影误差较大的匹配对。</p><p>特点：GPU下实时鲁棒跟踪，可以解决漂移现象，去除了实施以来。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/51b4d97353b2b296c7f8ef78c724cae1.png" alt=""></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f47535ef08447d692dc7d03afaab8693.png" alt=""></p><h2 id="2-2-MVS多帧图像重建">2.2 MVS多帧图像重建</h2><h3 id="基础-2">基础</h3><p>MVS是从一系列图像中重建3D模型。</p><p>流程：图像采集 - 位姿计算 - 模型重建 - 纹理贴图。其中图像采集可以是视频等序列化图像，也可以是非连续图像。在位姿计算中根据是否为序列化图像，有不同的方法进行位姿计算。</p><p>应用：影音娱乐，AR文物，自动驾驶，大型场景三维重建等。</p><p>综述：<a href="https://ieeexplore.ieee.org/document/8637125">Multi-View Stero: A Tutorial</a></p><h3 id="COLMAP-2016">COLMAP - 2016</h3><blockquote><p>论文：<a href="https://ieeexplore.ieee.org/document/7780814">https://ieeexplore.ieee.org/document/7780814</a><br>代码：<a href="https://github.com/colmap/colmap">https://github.com/colmap/colmap</a></p></blockquote><p>SFM通常首先进行特征提取/匹配以及后续的几何校验滤出外点，经过上述步骤可以得到所谓的场景图scene graph，该场景图是后续的增量式的基础（提供数据关联等信息）。增量式重建中需要非常仔细地挑选两帧进行重建，在图像进行注册（即定位当前帧在地图中的位姿）之前，需要进行三角化场景点/滤出外点以及BA优化当前的模型。</p><p>COLMAP算法的创新点在于</p><ul><li>提出了一种多模型几何校验策略：提高了初始化与三角化的鲁棒性；</li><li>后续最优帧选择策略：提升位姿结算鲁棒性与精度；</li><li>提出鲁棒三角化方法：使得重建的场景结构更加完整；</li><li>提出迭代BA，重三角化以及外点滤除策略对重建的完整性与精度都有贡献；</li><li>高效BA参数化方法对稠密图像的重建具有帮助；</li></ul><h3 id="OpenMVS">OpenMVS</h3><blockquote><p>代码：<a href="https://github.com/cdcseacave/openMVS">https://github.com/cdcseacave/openMVS</a></p></blockquote><p>OpenMVS的输入是图像和位姿，其中位姿可以是从COLMAP、SLAM等多种方式计算得到。然后进行稠密重建 - 点云融合 - 初始网格重建 - 网格优化 - 纹理贴图。</p><p>OpenMVS是目前的三维重建的框架中，复原效果比较好的；而且提供自动化的脚本，使用起来也不是很难，可以在github中下载编译安装。</p><h1>三、基于深度学习的三维重建</h1><h2 id="3-1-mesh重建">3.1 mesh重建</h2><h3 id="基于3DMM重建">基于3DMM重建</h3><p>3DMM（3D Morphable Model）可形变模型：任意一张人脸图像都可以根据如下公式重建</p><p>$$S_{model} = S^2+\sum^{m-1}<em>{i=1}\alpha_i S_i, T</em>{model} = T^2+\sum^{m-1}_{i=1}\beta_i T_i$$</p><p><img src="https://pic3.zhimg.com/v2-6c4cbef2157bb3be585894736edd20e6_b.webp" alt=""></p><p>拓展网络：Nonlinear 3D Face Morphable Model</p><ul><li>学习了一个非线性模型，比传统的线性模型具有更大的表示能力；</li><li>弱监督学习：利用大量没有三维扫描的二维图像，共同学习模型和模型拟合算法</li></ul><p>拓展网络：2DASL</p><ul><li>自监督模型，克服3D标注数据不足问题</li></ul><p>拓展网络：PRNet</p><ul><li>以端到端的方式解决了人脸对齐和三维人脸的问题，使其一起完成，而且不受低维解空间的限制</li><li>运行速度超过100FPS的轻量级框架</li></ul><p><img src="https://pic4.zhimg.com/80/v2-690d70ccd148f2dcc9c127709ffdadcb_720w.jpg" alt=""></p><h3 id="IF-Nets">IF-Nets</h3><p>IF-NETS是物体、人体重建网络。该网络可以将稀疏、稠密点云重建为mesh模型。由于数据集的限制（大多数据是CAD模型渲染得到的），真实场景的模型恢复效果一般。</p><h3 id="PifuHD">PifuHD</h3><p>PIFu是人体重建网络。</p><p>算法优点</p><ul><li>同时支持 single-view 和 multi-view；</li><li>高度复杂的形状，如发型、服装，以及它们的变化和变形都可以用统一的方式数字化</li><li>重建精度、细节表现比现有的方法更优；</li><li>与体素表示不同，内存效率更高，可以处理任意拓扑结构，并且生成的表面与输入图像在空间上对齐</li></ul><h2 id="3-1-深度图重建MVSNet">3.1 深度图重建MVSNet</h2><p>网络结构：输入是任意位姿的多张图像，且多张图片之间的关系需要被整体考虑。</p><p>MVSNet本质是借鉴基于两张图片cost volume的双目立体匹配的深度估计方法，扩展到多张图片的深度估计，而基于cost volume的双目立体匹配已经较为成熟，所以MVSNet本质上也是借鉴一个较为成熟的领域，然后提出基于可微分的单应性变换的cost volume用于多视图深度估计。</p><p>过程：</p><p>（1）输入一张r<strong>eference image（为主）</strong> 和几张<strong>source images（辅助）</strong>；</p><p>（2）分别用网络提取出下采样四分之一的32通道的特征图；</p><p>（3）采用立体匹配（即双目深度估计）里提出的cost volume的概念，将几张source images的特征利用<strong>单应性变换( homography warping)<strong>转换到reference image，在转换的过程中，<strong>类似极线搜索</strong>，引入了深度信息。构建</strong>cost volume</strong>可以说是<strong>MVSNet的关键</strong>。</p><p><strong>具体costvolume上一个点是所有图片在这个点和深度值上特征的方差，方差越小，说明在该深度上置信度越高。</strong></p><p>（4）利用3D卷积操作cost volume，先输出每个深度的概率，然后求深度的加权平均得到预测的深度信息，用L1或smoothL1回归深度信息，是一个回归模型。</p><p>（5）利用多张图片之间的重建约束（<em>photometric</em> and <em>geometric</em> consistencies）来选择预测正确的深度信息，重建成三维点云。</p><p><img src="https://pic2.zhimg.com/80/v2-bd6adb618c98e7b8c2cb09f4c1f2b805_720w.jpg" alt=""></p><p>拓展网络：MVS-JDACS-MS<br>在无监督网络框架中引入协同分割和数据增强策略，克服不同视角图像之间天然存在的光照差异干扰。</p><p>拓展网络：MVS-PatchMatchNet<br>一种基于传统PatchMatch算法的高效multi-view stereo框架。</p><h1>四、算法测评网站</h1><p>双目立体匹配：<a href="https://vision.middlebury.edu/stereo/eval3/">https://vision.middlebury.edu/stereo/eval3/</a></p><p><img src="https://img.mahaofei.com/img/20220625201059.png" alt=""></p><p>车载双目立体相关算法：<a href="http://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo">http://www.cvlibs.net/datasets/kitti/eval_scene_flow.php?benchmark=stereo</a></p><p><img src="https://img.mahaofei.com/img/20220625201353.png" alt=""></p><p>室外场景：<a href="https://www.eth3d.net/low_res_two_view">https://www.eth3d.net/low_res_two_view</a></p><p><img src="https://img.mahaofei.com/img/20220625201519.png" alt=""></p><p>计算机视觉相关论文、模型、数据集、代码汇总：<a href="https://paperswithcode.com/sota">https://paperswithcode.com/sota</a></p><p><img src="https://img.mahaofei.com/img/20220625201724.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220625202144.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 3D点云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 三维重建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio实现喷漆、打磨等功能（曲面路径生成与仿真）</title>
      <link href="/post/3feb0033.html"/>
      <url>/post/3feb0033.html</url>
      
        <content type="html"><![CDATA[<h1>任务介绍</h1><p>在Robotstudio中导入一个CAD模型，如汽车外壳等复杂曲面模型。使用Robotstudio进行路径规划，实现机械臂的汽车外壳的喷漆功能。</p><h1>所用环境</h1><p>实现本功能，使用到了ABB公司发布的<code>ABB Machining PowerPac</code>功能包。该功能包可以实现的功能包括打磨产品（规则的方形体）、涂胶、火焰切割、卫浴打磨、复杂的大型曲面体打磨、磨边等。</p><p>下载链接如下：<a href="https://robotapps.blob.core.windows.net/apps/d2d4e3fc-1810-4c05-937d-8154d31fca13machiningpowerpac6.04.zip">https://robotapps.blob.core.windows.net/apps/d2d4e3fc-1810-4c05-937d-8154d31fca13machiningpowerpac6.04.zip</a></p><p>如果链接失效，该插件下载方式如下图，找到插件后，在右侧点击链接下载。<br>（由于插件页面无法上下滚动，所以如果屏幕看不到下面的下载链接，还需要调高屏幕分辨率或者把缩放改成100%，下载后再改回来即可）</p><p><img src="https://img.mahaofei.com/img/2022-06-24-153954.png" alt=""></p><blockquote><p>下载后为压缩包格式，解压后运行其中exe再进行解压，注意这次解压不要选带中文的路径，找到解压后的exe运行即可安装。</p><p>该插件为6.04版本，支持<code>Robotstudio6.04</code>及以上版本使用，低于此版本的使用插件时可能会出现兼容性问题，建议使用Robotstudio 6.08，该版本对于大多数插件都有较好的兼容性。使用时双击插件即可加载，加载成功后在<code>Add-Ins</code>栏中即可看到<code>Machining 6.04</code>插件。</p></blockquote><h1>实现方法</h1><h2 id="1-创建工件坐标与工具">1. 创建工件坐标与工具</h2><p>（1）首先创建工件坐标。</p><p><img src="https://img.mahaofei.com/img/20220624161214.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624172529.png" alt=""></p><p>（2）然后创建工具。</p><p><img src="https://img.mahaofei.com/img/20220624161651.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624163115.png" alt=""></p><p>侧面加工与端面加工，在图中可以直观理解为，使用圆柱的侧面、底面端面加工。</p><p>工具的类型如下：</p><ul><li>T_Cutter：T型刀</li><li>Chamfger_Cutter：倒角铣刀</li><li>Flame_Cutter：火焰切割枪</li><li>Swallow_Cutter：燕尾槽铣刀</li><li>Ball_Cutter：球型铣刀</li><li>None：无形状</li></ul><p><strong>对于喷漆作业来说，选择端面加工；使用T型刀，调整接触圈高度为喷头到工件的距离。</strong></p><p>（3）新建一个空程序组</p><p><img src="https://img.mahaofei.com/img/20220624163500.png" alt=""></p><h2 id="2-提取加工曲面">2. 提取加工曲面</h2><p>（1）新建几何</p><p><img src="https://img.mahaofei.com/img/20220624163756.png" alt=""></p><p>（2）设置曲线类型</p><p><img src="https://img.mahaofei.com/img/20220624182636.png" alt=""></p><p>类型：</p><ul><li>Projection Geometry：投影几何</li><li>Intersection Geometry：交叉口几何</li><li>UV Curve：UV曲线</li><li>Edge Curve：边缘曲线</li><li>Customized Curve：自定义曲线</li></ul><p>对于喷漆来说，我们选择使用Intersection Geometry复杂曲线。</p><p>（3）选择加工区域</p><p><img src="https://img.mahaofei.com/img/20220624173012.png" alt=""></p><p>（4）指定切割平面</p><p><img src="https://img.mahaofei.com/img/20220624182535.png" alt=""></p><h2 id="4-新建操作">4. 新建操作</h2><p>（1）新建一个操作</p><p><img src="https://img.mahaofei.com/img/20220624180205.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624183344.png" alt=""></p><p>（2）设置外轴移动模式为：<strong>固定距离模式</strong></p><p><img src="https://img.mahaofei.com/img/20220624180233.png" alt=""></p><p>（3）点击刀具插补设置，点击可达率，在图表中选择一个100%可达率的角度，然后点击应用。</p><p><img src="https://img.mahaofei.com/img/20220624180319.png" alt=""></p><h2 id="5-模拟仿真">5. 模拟仿真</h2><p><img src="https://img.mahaofei.com/img/20220624183434.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220624184458.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习Buglist（不定时更新）</title>
      <link href="/post/4ce74988.html"/>
      <url>/post/4ce74988.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>建议Ctrl+F，输入关键词查找该网页有没有你遇到的bug<br>或者看左侧的目录</p></blockquote><p>下面所有问题以及解决方法都是本人亲自遇到，且根据解决方法成功解决的，如果仍然有问题欢迎各位评论区讨论。</p><h1>版本问题</h1><h2 id="1-使用不用版本的Pytorch训练的权重模型无法加载。">1. 使用不用版本的Pytorch训练的权重模型无法加载。</h2><blockquote><p>pickle.UnpicklingError: A load persistent id instruction was encountered,<br>but no persistent_load function was specified.</p></blockquote><p><strong>Bug原因:</strong> 训练和测试的torch版本不一致。训练的时候是1.x，测试的时候是1.m。<br><strong>解决办法：</strong> 先在1.x版本下加载模型，然后在保存的时候设置<code>_use_new_zipfile_serialization=False</code>就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), model_path, use_new_zipfile_serialization=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="2-ValueError-numpy-ufunc-size-changed-may-indicate-binary-incompatibility">2. ValueError: numpy.ufunc size changed, may indicate binary incompatibility.</h2><p>numpy版本过低导致，需要对numpy版本进行升级即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall numpy</span><br><span class="line">pip install numpy</span><br><span class="line">pip install --upgrade numpy </span><br></pre></td></tr></table></figure><h2 id="3-maskrcnn训练提示：FutureWarning-Input-image-dtype-is-bool">3. maskrcnn训练提示：FutureWarning: Input image dtype is bool</h2><p>参考博客：<a href="https://blog.csdn.net/qq_39483453/article/details/118598535">https://blog.csdn.net/qq_39483453/article/details/118598535</a></p><p>scikit-image=0.17.2 的版本存在的问题，修改scikit-image包版本为0.16.2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U scikit-image==0.16.2</span><br></pre></td></tr></table></figure><h2 id="4-CUDA-版本不匹配">4. CUDA 版本不匹配</h2><blockquote><p>问题日志：<br>The detected CUDA version (12.1) mismatches the version that was used to compile PyTorch (11.3). Please make sure to use the same CUDA versions.</p></blockquote><p>解决方法：安装多版本CUDA</p><p><strong>（1）下载CUDA</strong></p><p>前往<a href="https://developer.nvidia.com/cuda-toolkit-archive">官网</a>，下载低版本的cuda并安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.3.0/local_installers/cuda_11.3.0_465.19.01_linux.run</span><br><span class="line">sudo sh cuda_11.3.0_465.19.01_linux.run</span><br></pre></td></tr></table></figure><p>取消安装cuda驱动Driver</p><p>Do you want to install a symbolic link at /usr/local/cuda? # 是否将安装目录通过软连接的方式 link 到 /usr/local/cuda<br>选择yes</p><p><strong>（2）多版本切换</strong></p><p>修改<code>~/.bashrc</code>中cuda的路径：打开<code>~/.bashrc</code>文件，在最后添加如下：（根据需要使用cuda版本修改版本号）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/cuda-10.2/bin:$PATH&quot;</span><br><span class="line">export LD_LIBRARY_PATH=&quot;/usr/lcoal/cuda-10.2/lib64:$LD_LIBRARY_PATH&quot;</span><br></pre></td></tr></table></figure><p>使用 <code>source ~/.bashrc</code> 个更新配置</p><p>使用<code>nvcc --version</code>检查，如果发现显示为刚刚安装的CUDA版本，说明安装成功。</p><h1>环境配置/包安装</h1><h2 id="1-No-module-named-‘pycocotools‘">1. No module named ‘pycocotools‘</h2><p>参考博客：<a href="https://blog.csdn.net/weixin_42410915/article/details/109368497">超简单解决No module named ‘pycocotools‘</a></p><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple/pycocotools-windows/">各版本pycocotools.whl文件</a></p><p>点击连接中任意一个版本，（我安装的是2.0.0），下载的时候一定要注意对应的python版本，cp36指的是python3.6，cp37和cp38同理。</p><p>下载之后，放入你喜欢的文件夹中，然后启动命令行，进入whl文件所在的目录，输入以下命令即可，注意install后面是你自己下载的whl文件全称</p><p><img src="https://img-blog.csdnimg.cn/20201029204744983.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">activate tensorflow</span><br><span class="line">E:</span><br><span class="line">cd E:/windows/Downloads</span><br><span class="line">pip install pycocotools_windows-2.0-cp36-cp36m-win_amd64.whl</span><br></pre></td></tr></table></figure><h2 id="2-成功解决AttributeError-‘str‘-object-has-no-attribute-‘decode‘">2. 成功解决AttributeError: ‘str‘ object has no attribute ‘decode‘</h2><p>参考博客：<a href="https://blog.csdn.net/qq_41185868/article/details/82079079">https://blog.csdn.net/qq_41185868/article/details/82079079</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &#x27;h5py&lt;3.0.0&#x27; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="3-使用Google-Colab时，将Tensorflow版本转换到1-x版本">3. 使用Google Colab时，将Tensorflow版本转换到1.x版本</h2><p>参考博客：<a href="https://blog.csdn.net/qq_44262417/article/details/105222696">https://blog.csdn.net/qq_44262417/article/details/105222696</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">tensorflow_version 1.x</span></span><br></pre></td></tr></table></figure><h2 id="4-长时间卡在Successfully-opened-dynamic-library-libcudnn-so-7">4. 长时间卡在Successfully opened dynamic library libcudnn.so.7</h2><p>原因是tensorflow版本与CUDA版本不匹配，我使用的是cuda11.6与tensorflow2.2.0。</p><p>经过查找，可以使用的组合包括CUDA11.2+Tensorflow2.5.0。</p><h2 id="5-pip-安装包出现错误">5. pip 安装包出现错误</h2><p><strong>错误1: ImportError: No module named pip._internal.cli.main</strong></p><p>问题日志：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/mahaofei/anaconda3/envs/linemod/bin/pip&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    from pip._internal.cli.main import main</span><br><span class="line">ImportError: No module named pip._internal.cli.main</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>原因是python2.7的环境安装时pip版本太旧，无法正常安装很多包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m ensurepip</span><br><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><p><strong>错误2: Could not find a version that satisfies the requirement</strong></p><p>问题日志：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement comm&gt;=0.1.3 (from ipywidgets) (from versions: 0.0.1)</span><br><span class="line">ERROR: No matching distribution found for comm&gt;=0.1.3 (from ipywidgets)</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install package -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>如果是ipywidgets无法通过pip安装，则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge ipywidgets</span><br></pre></td></tr></table></figure><h1>数据格式不匹配</h1><h2 id="1-TypeError-expected-str-bytes-or-os-PathLike-object-not-NoneType">1. TypeError: expected str, bytes or os.PathLike object, not NoneType</h2><p>出现这个问题多半是没有指定路径，上述问题翻译过来是，期望一个字符串或者字节路径，而不是默认值，出现这个问题需要把指定路径的变量赋值即可。这种错误多半出现在运行开源代码时出现。</p><p>检查代码中对应位置的字符串变量，是否传入了确定的值，而非None。</p><h1>多GPU问题</h1><h2 id="1-ValueError-Memory-growth-cannot-differ-between-GPU-devices">1. ValueError: Memory growth cannot differ between GPU devices</h2><p>多显卡问题。默认计算时使用所有的显卡，但是<code>set_memory_growth</code>只为了部分显卡设定，就造成了显卡模式不匹配的问题。比较简单的解决方法如下，在报错的代码之前添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.environ[&#x27;CUDA_VISIBLE_DEVICES&#x27;]=&#x27;0&#x27;</span><br></pre></td></tr></table></figure><p>而且需要知道一点，那就是os.environ[‘CUDA_VISIBLE_DEVICES’]='0’这样的设置必须在调用TensorFlow框架之前声明否则不生效。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典实例分割模型Mask RCNN</title>
      <link href="/post/ef73cea9.html"/>
      <url>/post/ef73cea9.html</url>
      
        <content type="html"><![CDATA[<h1>一、Mask RCNN简介</h1><p>区域卷积神经网络 RCNN（Region-Convolutional Neural Networks）为两阶段目标检测器。通过对图像生成候选区域，提取特征，判别特征类别并修正候选框位置。 RCNN系列目前包含两个代表模型：Faster RCNN，Mask RCNN。</p><p>Mask R-CNN是He Kaiming大神2017年的力作，其在进行目标检测的同时进行实例分割，取得了出色的效果。</p><p><img src="https://img.mahaofei.com/img/20220515154938.png" alt=""></p><p>Mask-RCNN使用Resnet101作为主干特征提取网络，也就是图中的CNN部分，其对输入的图像image要求其是正方形且宽高可以整除2的6次方，不足的将会在外侧添加灰色区域。</p><ol><li><strong>Resnet101主干特征提取（CNN）</strong></li></ol><p>一张图像image传入到 <strong>Resnet101(CNN)</strong> 之后，会对其进行特征提取，然后将图像长宽压缩两次、三次、四次、五次来构造特征金字塔，目的是为了实现特征多尺度融合。</p><p><img src="https://img.mahaofei.com/img/20220515161629.png" alt=""></p><p>也就是下图中的左侧部分，分别得到了C2、C3、C4、C5五种特征层（五种尺寸的图像）。</p><p><img src="https://img.mahaofei.com/img/20220515162541.png" alt=""></p><ul><li>P5：对最小的C5(32,32)图像进行二维卷积，然后再次卷积作为一个有效特征层P5(32,32)（下方绿色框）</li><li>P6：将P5(32,32)最大池化得到有效特征层P6(16,16)。</li><li>P4：将C5(32,32)一次卷积的结果上采样得到(64,64)图像，与C4(64,64)进行Add运算，然后再次卷积得到另一个有效特征层P4。</li><li>P3：将C4一次卷积结果上采样，并与C3进行Add运算，然后再次卷积得到有效特征层P3。</li><li>P2：将C3一次卷积结果上采样，并与C2进行Add运算，再次卷积得到有效特征层P2。</li></ul><p>提取到的P2、P3、P4、P5、P6五个有效特征层，就是Resent101的输出feature maps，可以用于接下来RPN建议网络获取建议框。</p><ol start="2"><li><strong>RPN区域建议网络（Region Proposal）</strong></li></ol><p>对有效特征层使用RPN建议网络（region proposal），获得许多建议框regions，这些建议框可能包含物体，可能没包含物体。不管包括没包括，接下来都会利用这些建议框截取P2~P5的图像，得到一个个可能存在目标的截取图像（P6不截取）。</p><ol start="3"><li><strong>ROI区域对齐（ROI Align）</strong></li></ol><p>对于所有建议框截取图像，RoI Align都会将其调整图像尺寸为一个正方形，便于后续特征的匹配操作。</p><ol start="4"><li><strong>FC Layers</strong></li></ol><p>根据截取出的建议框图像，利用Classifier回归模型判断截取的区域是否有物体，然后利用Classifier预测框网络对有效特征层进行解码获得最终的预测框。</p><ol start="5"><li><strong>Mask语义分割网络</strong></li></ol><p>利用获取的最终预测框，再次在有效特征层P2~P5中截取目标图像（这次由于相当于进行了以便筛选，截取出的图像数量会少很多），将这次截取出的图像传给Mask语义分割网络进行语义分割。</p><h1>二、Mask R-CNN实现过程</h1><h2 id="2-1-Resnet101-主干特征提取网络">2.1 Resnet101-主干特征提取网络</h2><p>ResNet101有两个基本的块，分别是<code>Conv Block</code>和<code>Identity Block</code>。其中<code>Conv Block</code>的输入和输出维度不同，不能持续串联，它的作用是改变网络的维度；<code>Identity Block</code>的输入维度和输出维度相同，可以串联，用于加深网络。</p><p><img src="https://img.mahaofei.com/img/20220515195957.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220515195949.png" alt=""></p><p>以coco数据集中输入的shape为例，输入的shape为1024x1024，shape变化如下：</p><p><img src="https://img.mahaofei.com/img/20220515200117.png" alt=""></p><p>我们取出长宽压缩了两次、三次、四次、五次的结果来进行下面特征金字塔结构的构造。</p><p>相关代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> ZeroPadding2D,Conv2D,MaxPooling2D,BatchNormalization,Activation,Add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">identity_block</span>(<span class="params">input_tensor, kernel_size, filters, stage, block,</span></span><br><span class="line"><span class="params">                   use_bias=<span class="literal">True</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</span><br><span class="line">    conv_name_base = <span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line">    bn_name_base = <span class="string">&#x27;bn&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">&#x27;2a&#x27;</span>,</span><br><span class="line">                  use_bias=use_bias)(input_tensor)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2a&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2b&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2b&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base + <span class="string">&#x27;2c&#x27;</span>,</span><br><span class="line">                  use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2c&#x27;</span>)(x, training=train_bn)</span><br><span class="line"></span><br><span class="line">    x = Add()([x, input_tensor])</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_out&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv_block</span>(<span class="params">input_tensor, kernel_size, filters, stage, block,</span></span><br><span class="line"><span class="params">               strides=(<span class="params"><span class="number">2</span>, <span class="number">2</span></span>), use_bias=<span class="literal">True</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line"></span><br><span class="line">    nb_filter1, nb_filter2, nb_filter3 = filters</span><br><span class="line">    conv_name_base = <span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line">    bn_name_base = <span class="string">&#x27;bn&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_branch&#x27;</span></span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter1, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2a&#x27;</span>, use_bias=use_bias)(input_tensor)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2a&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter2, (kernel_size, kernel_size), padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                  name=conv_name_base + <span class="string">&#x27;2b&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2b&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    x = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), name=conv_name_base +</span><br><span class="line">                  <span class="string">&#x27;2c&#x27;</span>, use_bias=use_bias)(x)</span><br><span class="line">    x = BatchNormalization(name=bn_name_base + <span class="string">&#x27;2c&#x27;</span>)(x, training=train_bn)</span><br><span class="line"></span><br><span class="line">    shortcut = Conv2D(nb_filter3, (<span class="number">1</span>, <span class="number">1</span>), strides=strides,</span><br><span class="line">                         name=conv_name_base + <span class="string">&#x27;1&#x27;</span>, use_bias=use_bias)(input_tensor)</span><br><span class="line">    shortcut = BatchNormalization(name=bn_name_base + <span class="string">&#x27;1&#x27;</span>)(shortcut, training=train_bn)</span><br><span class="line"></span><br><span class="line">    x = Add()([x, shortcut])</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;res&#x27;</span> + <span class="built_in">str</span>(stage) + block + <span class="string">&#x27;_out&#x27;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_resnet</span>(<span class="params">input_image,stage5=<span class="literal">False</span>, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment"># Stage 1</span></span><br><span class="line">    x = ZeroPadding2D((<span class="number">3</span>, <span class="number">3</span>))(input_image)</span><br><span class="line">    x = Conv2D(<span class="number">64</span>, (<span class="number">7</span>, <span class="number">7</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&#x27;conv1&#x27;</span>, use_bias=<span class="literal">True</span>)(x)</span><br><span class="line">    x = BatchNormalization(name=<span class="string">&#x27;bn_conv1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment"># Height/4,Width/4,64</span></span><br><span class="line">    C1 = x = MaxPooling2D((<span class="number">3</span>, <span class="number">3</span>), strides=(<span class="number">2</span>, <span class="number">2</span>), padding=<span class="string">&quot;same&quot;</span>)(x)</span><br><span class="line">    <span class="comment"># Stage 2</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;a&#x27;</span>, strides=(<span class="number">1</span>, <span class="number">1</span>), train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">    C2 = x = identity_block(x, <span class="number">3</span>, [<span class="number">64</span>, <span class="number">64</span>, <span class="number">256</span>], stage=<span class="number">2</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Stage 3</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/8,Width/8,512</span></span><br><span class="line">    C3 = x = identity_block(x, <span class="number">3</span>, [<span class="number">128</span>, <span class="number">128</span>, <span class="number">512</span>], stage=<span class="number">3</span>, block=<span class="string">&#x27;d&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Stage 4</span></span><br><span class="line">    x = conv_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    block_count = <span class="number">22</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(block_count):</span><br><span class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">256</span>, <span class="number">256</span>, <span class="number">1024</span>], stage=<span class="number">4</span>, block=<span class="built_in">chr</span>(<span class="number">98</span> + i), train_bn=train_bn)</span><br><span class="line">    <span class="comment"># Height/16,Width/16,1024</span></span><br><span class="line">    C4 = x</span><br><span class="line">    <span class="comment"># Stage 5</span></span><br><span class="line">    <span class="keyword">if</span> stage5:</span><br><span class="line">        x = conv_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;a&#x27;</span>, train_bn=train_bn)</span><br><span class="line">        x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;b&#x27;</span>, train_bn=train_bn)</span><br><span class="line">        <span class="comment"># Height/32,Width/32,2048</span></span><br><span class="line">        C5 = x = identity_block(x, <span class="number">3</span>, [<span class="number">512</span>, <span class="number">512</span>, <span class="number">2048</span>], stage=<span class="number">5</span>, block=<span class="string">&#x27;c&#x27;</span>, train_bn=train_bn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        C5 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> [C1, C2, C3, C4, C5]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于残差神经网络，可以参考此文章：<a href="https://zhuanlan.zhihu.com/p/349717627">ResNet：残差神经网络</a></p><h2 id="2-2-Feature-Pyramid-FPN构建特征金字塔">2.2 Feature Pyramid-FPN构建特征金字塔</h2><p>上文经过主干特征提取后可以得到长宽压缩了两次C2、三次C3、四次C4、五次C5的结果，用这些结果进行特征金字塔的构造，主要是为了得到P2~P6五个有效特征层。</p><p><img src="https://img.mahaofei.com/img/20220515162541.png" alt=""></p><p>具体过程为：</p><ul><li>P5：对【C5】进行一次256通道的卷积，再进行一次256通道的卷积，得到P5。</li><li>P6：将P5进行最大池化得到P6。</li><li>P4：将【C5一次卷积的结果】进行上采样，再与【C4进行256通道卷积的结果】的进行Add运算，再进行一次256通道的卷积，得到P4。</li><li>P3、P2过程类似P4。</li></ul><p>提取到的P2、P3、P4、P5、P6可以作为RPN网络的有效特征层，利用RPN建议框网络对有效特征层进行下一步的操作，对先验框进行解码获得建议框。</p><p>提取到的P2、P3、P4、P5可以作为Classifier和Mask网络的有效特征层，利用Classifier预测框网络对有效特征层进行下一步的操作，对建议框解码获得最终预测框；利用Mask语义分割网络对有效特征层进行下一步的操作，获得每一个预测框内部的语义分割结果。</p><p>具体代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得Resnet里的压缩程度不同的一些层</span></span><br><span class="line">_, C2, C3, C4, C5 = get_resnet(input_image, stage5=<span class="literal">True</span>, train_bn=config.TRAIN_BN)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合成特征金字塔的结构</span></span><br><span class="line"><span class="comment"># P5长宽共压缩了5次</span></span><br><span class="line"><span class="comment"># Height/32,Width/32,256</span></span><br><span class="line">P5 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c5p5&#x27;</span>)(C5)</span><br><span class="line"><span class="comment"># P4长宽共压缩了4次</span></span><br><span class="line"><span class="comment"># Height/16,Width/16,256</span></span><br><span class="line">P4 = Add(name=<span class="string">&quot;fpn_p4add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p5upsampled&quot;</span>)(P5),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c4p4&#x27;</span>)(C4)])</span><br><span class="line"><span class="comment"># P4长宽共压缩了3次</span></span><br><span class="line"><span class="comment"># Height/8,Width/8,256</span></span><br><span class="line">P3 = Add(name=<span class="string">&quot;fpn_p3add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p4upsampled&quot;</span>)(P4),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c3p3&#x27;</span>)(C3)])</span><br><span class="line"><span class="comment"># P4长宽共压缩了2次</span></span><br><span class="line"><span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">P2 = Add(name=<span class="string">&quot;fpn_p2add&quot;</span>)([</span><br><span class="line">    UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>), name=<span class="string">&quot;fpn_p3upsampled&quot;</span>)(P3),</span><br><span class="line">    Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">1</span>, <span class="number">1</span>), name=<span class="string">&#x27;fpn_c2p2&#x27;</span>)(C2)])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 各自进行一次256通道的卷积，此时P2、P3、P4、P5通道数相同</span></span><br><span class="line"><span class="comment"># Height/4,Width/4,256</span></span><br><span class="line">P2 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p2&quot;</span>)(P2)</span><br><span class="line"><span class="comment"># Height/8,Width/8,256</span></span><br><span class="line">P3 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p3&quot;</span>)(P3)</span><br><span class="line"><span class="comment"># Height/16,Width/16,256</span></span><br><span class="line">P4 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p4&quot;</span>)(P4)</span><br><span class="line"><span class="comment"># Height/32,Width/32,256</span></span><br><span class="line">P5 = Conv2D(config.TOP_DOWN_PYRAMID_SIZE, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;SAME&quot;</span>, name=<span class="string">&quot;fpn_p5&quot;</span>)(P5)</span><br><span class="line"><span class="comment"># 在建议框网络里面还有一个P6用于获取建议框</span></span><br><span class="line"><span class="comment"># Height/64,Width/64,256</span></span><br><span class="line">P6 = MaxPooling2D(pool_size=(<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">2</span>, name=<span class="string">&quot;fpn_p6&quot;</span>)(P5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># P2, P3, P4, P5, P6可以用于获取建议框</span></span><br><span class="line">rpn_feature_maps = [P2, P3, P4, P5, P6]</span><br><span class="line"><span class="comment"># P2, P3, P4, P5用于获取mask信息</span></span><br><span class="line">mrcnn_feature_maps = [P2, P3, P4, P5]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-构建RPN建议网络模型">2.3 构建RPN建议网络模型</h2><p>RPN建议网络的模型</p><ul><li>首先进行一次3x3的通道为512的卷积</li><li>然后分别进行一次<code>anchors_per_location x 2</code>的卷积和<code>anchors_per_location x 4</code>的卷积。<ul><li><code>anchors_per_location x 2</code>的卷积用于预测<strong>公共特征层上 每一个网格点上 每一个预测框</strong>内部是否包含物体。</li><li><code>anchors_per_location x 4</code>的卷积用于预测<strong>公共特征层上 每一个网格点上 每一个先验框</strong>的变化情况。</li></ul></li></ul><p>例如输入图片的shape是1024x1024x3时，公共特征层的shape就是256x256x256、128x128x256、64x64x256、32x32x256、16x16x256。这些公共特征层上的每一个点，映射到原始图片上就是间隔不同的网格点，每个网格默认存在3(anchors_per_location)个先验框，这些先验框有不同的大小。</p><p><img src="https://img.mahaofei.com/img/20220516162352.png" alt=""></p><p><strong>anchors_per_location x 4的卷积</strong>的结果会对这些先验框进行调整，获得一个新的框。<br><strong>anchors_per_location x 2的卷积</strong>会判断上述获得的新框是否包含物体。</p><p>到这里我们可以获得了一些有用的框，这些框会利用<strong>anchors_per_location x 2的卷积</strong>判断是否存在物体。</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   五个不同大小的特征层会传入到</span></span><br><span class="line"><span class="comment">#   RPN当中，获得建议框</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rpn_graph</span>(<span class="params">feature_map, anchors_per_location</span>):</span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   利用一个3x3卷积进行特征整合，基础的层</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    shared = Conv2D(<span class="number">512</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&#x27;same&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>, name=<span class="string">&#x27;rpn_conv_shared&#x27;</span>)(feature_map)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   batch_size, num_anchors, 2</span></span><br><span class="line">    <span class="comment">#   代表这个先验框是否包含物体</span></span><br><span class="line">    <span class="comment">#   anchor_per_location的默认值是3</span></span><br><span class="line">    <span class="comment">#   意味着特征层对图像进行网格的划分后，每个网格上先验框的数量是3</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    x = Conv2D(anchors_per_location * <span class="number">2</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&#x27;valid&#x27;</span>, activation=<span class="string">&#x27;linear&#x27;</span>, name=<span class="string">&#x27;rpn_class_raw&#x27;</span>)(shared)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reshape到最后一个维度是2的维度，是一个分类网络，有非常多先验框</span></span><br><span class="line">    rpn_class_logits = Reshape([-<span class="number">1</span>,<span class="number">2</span>])(x)</span><br><span class="line">    rpn_probs = Activation(<span class="string">&quot;softmax&quot;</span>, name=<span class="string">&quot;rpn_class_xxx&quot;</span>)(rpn_class_logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    <span class="comment">#   batch_size, num_anchors, 4</span></span><br><span class="line">    <span class="comment">#   这个先验框的调整参数</span></span><br><span class="line">    <span class="comment">#------------------------------------#</span></span><br><span class="line">    x = Conv2D(anchors_per_location * <span class="number">4</span>, (<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">&quot;valid&quot;</span>, activation=<span class="string">&#x27;linear&#x27;</span>, name=<span class="string">&#x27;rpn_bbox_pred&#x27;</span>)(shared)</span><br><span class="line">    rpn_bbox = Reshape([-<span class="number">1</span>, <span class="number">4</span>])(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出包括：</span></span><br><span class="line">    <span class="comment"># 先验框是否真实的包含物体</span></span><br><span class="line">    <span class="comment"># bbox先验框的调整参数</span></span><br><span class="line">    <span class="keyword">return</span> [rpn_class_logits, rpn_probs, rpn_bbox]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立建议框网络模型</span></span><br><span class="line"><span class="comment">#   RPN模型</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_rpn_model</span>(<span class="params">anchors_per_location, depth</span>):</span><br><span class="line">    <span class="comment"># 输入的长和宽都是None，代表输入的有效特征层大小是变化的，256、64等都可以</span></span><br><span class="line">    <span class="comment"># 输入的depth是256</span></span><br><span class="line">    input_feature_map = Input(shape=[<span class="literal">None</span>, <span class="literal">None</span>, depth], name=<span class="string">&quot;input_rpn_feature_map&quot;</span>)</span><br><span class="line">    <span class="comment"># 将输入的图像传入到rpn_graph中</span></span><br><span class="line">    outputs = rpn_graph(input_feature_map, anchors_per_location)</span><br><span class="line">    <span class="keyword">return</span> Model([input_feature_map], outputs, name=<span class="string">&quot;rpn_model&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-4-Anchors先验框的获取">2.4 Anchors先验框的获取</h2><p><strong>先验框就是图像上的一定的区域，这些区域是人为规定好的</strong>，这些区域可能包含物体，可能不包含物体，我们网络的预测结果就会判断哪些先验框是包含物体的，然后对先验框进行调整。</p><p>在MaskRCNN中，建议框网络的预测结果就会对这些先验框进行调整，获得建议框，并判断哪些先验框是包含物体的。</p><p>本节介绍如何获得<strong>先验框</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#  Anchors</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_anchors</span>(<span class="params">scales, ratios, shape, feature_stride, anchor_stride</span>):</span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   获得所有框的长度和比例的组合</span></span><br><span class="line">    <span class="comment">#   相当于在每一个网格点上获得了两个长方形(1:2)、(2:1)和一个正方形</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    scales, ratios = np.meshgrid(np.array(scales), np.array(ratios))</span><br><span class="line">    scales = scales.flatten()</span><br><span class="line">    ratios = ratios.flatten()</span><br><span class="line">    heights = scales / np.sqrt(ratios)</span><br><span class="line">    widths = scales * np.sqrt(ratios)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   生成网格中心</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    shifts_y = np.arange(<span class="number">0</span>, shape[<span class="number">0</span>], anchor_stride) * feature_stride</span><br><span class="line">    shifts_x = np.arange(<span class="number">0</span>, shape[<span class="number">1</span>], anchor_stride) * feature_stride</span><br><span class="line">    shifts_x, shifts_y = np.meshgrid(shifts_x, shifts_y)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   获得先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    box_widths, box_centers_x = np.meshgrid(widths, shifts_x)</span><br><span class="line">    box_heights, box_centers_y = np.meshgrid(heights, shifts_y)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   更变格式</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment"># 对先验框的中心堆叠，然后reshape，reshape后的结果代表每一个先验框的中心坐标</span></span><br><span class="line">    box_centers = np.stack([box_centers_y, box_centers_x], axis=<span class="number">2</span>).reshape([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 对先验框的高和宽堆叠，然后reshape，reshape后的结果代表每一个先验框的高和宽</span></span><br><span class="line">    box_sizes = np.stack([box_heights, box_widths], axis=<span class="number">2</span>).reshape([-<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算出(y1, x1, y2, x2)</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    boxes = np.concatenate([box_centers - <span class="number">0.5</span> * box_sizes, box_centers + <span class="number">0.5</span> * box_sizes], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boxes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成特征金字塔先验框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_pyramid_anchors</span>(<span class="params">scales, ratios, feature_shapes, feature_strides,  anchor_stride</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成不同特征层的anchors，并利用concatenate进行堆叠</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   Anchors</span></span><br><span class="line">    <span class="comment">#   [anchor_count, (y1, x1, y2, x2)]</span></span><br><span class="line">    <span class="comment">#   P2对应的scale是32</span></span><br><span class="line">    <span class="comment">#   P3对应的scale是64</span></span><br><span class="line">    <span class="comment">#   P4对应的scale是128</span></span><br><span class="line">    <span class="comment">#   P5对应的scale是256</span></span><br><span class="line">    <span class="comment">#   P6对应的scale是512</span></span><br><span class="line">    <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">    anchors = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对scales进行for循环，是传入的anchor_scales，是32、64、128、256、512</span></span><br><span class="line">    <span class="comment"># 对应不同特征层上先验框的基础大小，再在此基础上获得调整，获得不同长宽大小的先验框</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scales)):</span><br><span class="line">        <span class="comment"># ratio的值是0.5、1、2，对应每个网格点上三个先验框</span></span><br><span class="line">        <span class="comment"># feature_shapes就是获得的每一个有效特征层的大小，代表我们要将图片分割成多少网格</span></span><br><span class="line">        <span class="comment"># feature_strides对应backbone_strides，是4、8、16、32、64</span></span><br><span class="line">        <span class="comment"># anchor_stride的值为1</span></span><br><span class="line">        anchors.append(generate_anchors(scales[i], ratios, feature_shapes[i], feature_strides[i], anchor_stride))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.concatenate(anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_backbone_shapes</span>(<span class="params">config, image_shape</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array( [[<span class="built_in">int</span>(math.ceil(image_shape[<span class="number">0</span>] / stride)), <span class="built_in">int</span>(math.ceil(image_shape[<span class="number">1</span>] / stride))] <span class="keyword">for</span> stride <span class="keyword">in</span> config.BACKBONE_STRIDES])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用下面的函数获取先验框</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_anchors</span>(<span class="params">config, image_shape</span>):</span><br><span class="line">    <span class="comment"># 计算主干特征提取网络获得的有效特征层的shape</span></span><br><span class="line">    <span class="comment"># 为了事先放置先验框，我们需要知道网格大小，因此需要先获得有效特征层的shape</span></span><br><span class="line">    backbone_shapes = compute_backbone_shapes(config, image_shape)</span><br><span class="line">    anchor_cache = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">tuple</span>(image_shape) <span class="keyword">in</span> anchor_cache:</span><br><span class="line">        <span class="comment"># 将backbone_shapes传入下面的函数</span></span><br><span class="line">        <span class="comment"># 生成特征金字塔的先验框</span></span><br><span class="line">        a = generate_pyramid_anchors(</span><br><span class="line">            config.RPN_ANCHOR_SCALES,</span><br><span class="line">            config.RPN_ANCHOR_RATIOS,</span><br><span class="line">            backbone_shapes,</span><br><span class="line">            config.BACKBONE_STRIDES,</span><br><span class="line">            config.RPN_ANCHOR_STRIDE)</span><br><span class="line">        anchor_cache[<span class="built_in">tuple</span>(image_shape)] = norm_boxes(a, image_shape[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> anchor_cache[<span class="built_in">tuple</span>(image_shape)]</span><br></pre></td></tr></table></figure><h2 id="2-5-先验框调整获得建议框">2.5 先验框调整获得建议框</h2><p>利用<code>ProposalLayer</code>对先验框解码获取建议框。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   对先验框进行解码，获得先验框解码后的建议框的坐标</span></span><br><span class="line">    <span class="comment">#   rpn_rois            : Batch_size, proposal_count, 4</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">    proposal_count = config.POST_NMS_ROIS_TRAINING</span><br><span class="line">    rpn_rois = ProposalLayer(proposal_count=proposal_count, nms_threshold=config.RPN_NMS_THRESHOLD, name=<span class="string">&quot;ROI&quot;</span>, config=config)([rpn_class, rpn_bbox, anchors])</span><br><span class="line">    active_class_ids = Lambda(<span class="keyword">lambda</span> x: parse_image_meta_graph(x)[<span class="string">&quot;active_class_ids&quot;</span>])(input_image_meta)</span><br></pre></td></tr></table></figure><p>输入参数有三个分别是<code>rpn_class</code>、<code>rpn_bbox</code>、<code>anchors</code>，这里的<code>rpn_class</code>代表所有先验框是否包含物体的置信度，<code>rpn_bbox</code>代表所有先验框的调整参数，<code>anchors</code>之前获得的所有先验框。</p><p>其中<code>ProposalLayer</code>的具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   Proposal Layer</span></span><br><span class="line"><span class="comment">#   该部分代码用于将先验框转化成建议框</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProposalLayer</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, proposal_count, nms_threshold, config=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(ProposalLayer, self).__init__(**kwargs)</span><br><span class="line">        self.config = config</span><br><span class="line">        self.proposal_count = proposal_count</span><br><span class="line">        self.nms_threshold = nms_threshold</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   输入的inputs有三个内容</span></span><br><span class="line">        <span class="comment">#   inputs[0]   rpn_class   : Batch_size, num_anchors, 2</span></span><br><span class="line">        <span class="comment">#   inputs[1]   rpn_bbox    : Batch_size, num_anchors, 4</span></span><br><span class="line">        <span class="comment">#   inputs[2]   anchors     : Batch_size, num_anchors, 4</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框内部是否有物体[Batch_size, num_anchors, 1]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        scores = inputs[<span class="number">0</span>][:, :, <span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框的调整参数[batch, num_rois, 4]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        deltas = inputs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框的坐标</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        anchors = inputs[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   RPN_BBOX_STD_DEV[0.1 0.1 0.2 0.2] 改变数量级</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        deltas = deltas * np.reshape(self.config.RPN_BBOX_STD_DEV, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   筛选出得分前6000个的框</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        pre_nms_limit = tf.minimum(self.config.PRE_NMS_LIMIT, tf.shape(anchors)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得这些框的索引</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        ix = tf.nn.top_k(scores, pre_nms_limit, <span class="built_in">sorted</span>=<span class="literal">True</span>, name=<span class="string">&quot;top_anchors&quot;</span>).indices</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得先验框、及其得分与调整参数</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        scores = batch_slice([scores, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)</span><br><span class="line">        deltas = batch_slice([deltas, ix], <span class="keyword">lambda</span> x, y: tf.gather(x, y), self.config.IMAGES_PER_GPU)</span><br><span class="line">        pre_nms_anchors = batch_slice([anchors, ix], <span class="keyword">lambda</span> a, x: tf.gather(a, x), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;pre_nms_anchors&quot;</span>])</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   [batch, pre_nms_limit, (y1, x1, y2, x2)]</span></span><br><span class="line">        <span class="comment">#   对先验框进行解码</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        boxes = batch_slice([pre_nms_anchors, deltas], <span class="keyword">lambda</span> x, y: apply_box_deltas_graph(x, y), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;refined_anchors&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   [batch, pre_nms_limit, (y1, x1, y2, x2)]</span></span><br><span class="line">        <span class="comment">#   防止超出图片范围</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        window = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], dtype=np.float32)</span><br><span class="line">        boxes = batch_slice(boxes, <span class="keyword">lambda</span> x: clip_boxes_graph(x, window), self.config.IMAGES_PER_GPU, names=[<span class="string">&quot;refined_anchors_clipped&quot;</span>])</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#---------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   在非极大抑制后</span></span><br><span class="line">        <span class="comment">#   获得一个shape为[batch, NMS_ROIS, 4]的proposals</span></span><br><span class="line">        <span class="comment">#---------------------------------------------------------#</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">nms</span>(<span class="params">boxes, scores</span>):</span><br><span class="line">            indices = tf.image.non_max_suppression(boxes, scores, self.proposal_count, self.nms_threshold, name=<span class="string">&quot;rpn_non_max_suppression&quot;</span>)</span><br><span class="line">            proposals = tf.gather(boxes, indices)</span><br><span class="line">            padding = tf.maximum(self.proposal_count - tf.shape(proposals)[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            proposals = tf.pad(proposals, [(<span class="number">0</span>, padding), (<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">            <span class="keyword">return</span> proposals</span><br><span class="line">        proposals = batch_slice([boxes, scores], nms, self.config.IMAGES_PER_GPU)</span><br><span class="line">        <span class="keyword">return</span> proposals</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_output_shape</span>(<span class="params">self, input_shape</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, self.proposal_count, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>其中利用到了下面的函数对建议框的位置和长宽进行调整</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   利用先验框调整参数调整先验框，获得建议框的坐标</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">apply_box_deltas_graph</span>(<span class="params">boxes, deltas</span>):</span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    height = boxes[:, <span class="number">2</span>] - boxes[:, <span class="number">0</span>]</span><br><span class="line">    width = boxes[:, <span class="number">3</span>] - boxes[:, <span class="number">1</span>]</span><br><span class="line">    center_y = boxes[:, <span class="number">0</span>] + <span class="number">0.5</span> * height</span><br><span class="line">    center_x = boxes[:, <span class="number">1</span>] + <span class="number">0.5</span> * width</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算出调整后的先验框的中心和宽高</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    center_y += deltas[:, <span class="number">0</span>] * height</span><br><span class="line">    center_x += deltas[:, <span class="number">1</span>] * width</span><br><span class="line">    height *= tf.exp(deltas[:, <span class="number">2</span>])</span><br><span class="line">    width *= tf.exp(deltas[:, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    <span class="comment">#   计算左上角和右下角的点的坐标</span></span><br><span class="line">    <span class="comment">#---------------------------------------#</span></span><br><span class="line">    y1 = center_y - <span class="number">0.5</span> * height</span><br><span class="line">    x1 = center_x - <span class="number">0.5</span> * width</span><br><span class="line">    y2 = y1 + height</span><br><span class="line">    x2 = x1 + width</span><br><span class="line"></span><br><span class="line">    result = tf.stack([y1, x1, y2, x2], axis=<span class="number">1</span>, name=<span class="string">&quot;apply_box_deltas_out&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="2-6-利用建议框对共享特征层进行截取">2.6 利用建议框对共享特征层进行截取</h2><p>ROI Align层的作用就是根据建议框对不同的特征层进行截取。主要代码如下，其功能就是根据建议框的大小，判断建议框属于哪一个特征层，然后利用建议框对对应的特征层进行截取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用建议框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]</span></span><br><span class="line">    <span class="comment">#   pool_size 是对共享特征层截取后resize后的局部特征层的大小</span></span><br><span class="line">    <span class="comment">#   rois是初步筛选后的建议框</span></span><br><span class="line">    <span class="comment">#   image_meta是保存了图片的必要信息</span></span><br><span class="line">    <span class="comment">#   feature_maps共享特征层</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_classifier&quot;</span>)([rois, image_meta] + feature_maps)</span><br></pre></td></tr></table></figure><p>其中<code>PyramidROIAlign</code>函数的定义如下：</p><p>首先获取建议框的坐标、图片信息、特征层。然后根据建议框的大小，判断建议框属于哪一个特征层（较大的特征层比如256x256的，网格划分密集，每一个建议框大小比较小，以此判断）。利用循环对于P2~P5五个特征层进行截取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   ROIAlign Layer</span></span><br><span class="line"><span class="comment">#   利用建议框在特征层上截取内容</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyramidROIAlign</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pool_shape, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(PyramidROIAlign, self).__init__(**kwargs)</span><br><span class="line">        self.pool_shape = <span class="built_in">tuple</span>(pool_shape)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得建议框的坐标</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        boxes = inputs[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   image_meta包含了一些必要的图片信息</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_meta = inputs[<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   取出所有的特征层[batch, height, width, channels]</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        feature_maps = inputs[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得建议框的宽高</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        y1, x1, y2, x2 = tf.split(boxes, <span class="number">4</span>, axis=<span class="number">2</span>)</span><br><span class="line">        h = y2 - y1</span><br><span class="line">        w = x2 - x1</span><br><span class="line">  </span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得输入进来的图像的大小，对image的内容进行分割</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_shape = parse_image_meta_graph(image_meta)[<span class="string">&#x27;image_shape&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   通过建议框的大小找到这个建议框属于哪个特征层，第一层256划分区域多建议框较小32</span></span><br><span class="line">        <span class="comment">#----------------------------------------------------------#</span></span><br><span class="line">        image_area = tf.cast(image_shape[<span class="number">0</span>] * image_shape[<span class="number">1</span>], tf.float32)</span><br><span class="line">        roi_level = log2_graph(tf.sqrt(h * w) / (<span class="number">224.0</span> / tf.sqrt(image_area)))</span><br><span class="line">        roi_level = tf.minimum(<span class="number">5</span>, tf.maximum(<span class="number">2</span>, <span class="number">4</span> + tf.cast(tf.<span class="built_in">round</span>(roi_level), tf.int32)))</span><br><span class="line">        <span class="comment"># roi_level是每张图片里每个建议框对应的特征层是哪个</span></span><br><span class="line">        roi_level = tf.squeeze(roi_level, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        pooled = []</span><br><span class="line">        box_to_level = []</span><br><span class="line">        <span class="comment"># 分别在P2-P5中进行截取</span></span><br><span class="line">        <span class="keyword">for</span> i, level <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>)):</span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            <span class="comment">#   找到每个特征层对应的建议框</span></span><br><span class="line">            <span class="comment">#   level_boxes存放所有属于该特征层的建议框</span></span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            ix = tf.where(tf.equal(roi_level, level))</span><br><span class="line">            level_boxes = tf.gather_nd(boxes, ix)</span><br><span class="line">            box_to_level.append(ix)</span><br><span class="line">  </span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            <span class="comment">#    获得这些建议框所属的图片</span></span><br><span class="line">            <span class="comment">#-----------------------------------------------#</span></span><br><span class="line">            box_indices = tf.cast(ix[:, <span class="number">0</span>], tf.int32)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 停止梯度下降</span></span><br><span class="line">            level_boxes = tf.stop_gradient(level_boxes)</span><br><span class="line">            box_indices = tf.stop_gradient(box_indices)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">            <span class="comment">#   利用建议框对特征层进行截取  </span></span><br><span class="line">            <span class="comment">#   [batch * num_boxes, pool_height, pool_width, channels]</span></span><br><span class="line">            <span class="comment">#   box_indices表示是截取哪张图片里的特征层</span></span><br><span class="line">            <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">            pooled.append(tf.image.crop_and_resize(</span><br><span class="line">                feature_maps[i], level_boxes, box_indices, self.pool_shape,</span><br><span class="line">                method=<span class="string">&quot;bilinear&quot;</span>))</span><br><span class="line"></span><br><span class="line">        pooled = tf.concat(pooled, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   将顺序和所属的图片进行堆叠</span></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        box_to_level = tf.concat(box_to_level, axis=<span class="number">0</span>)</span><br><span class="line">        box_range = tf.expand_dims(tf.<span class="built_in">range</span>(tf.shape(box_to_level)[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">        box_to_level = tf.concat([tf.cast(box_to_level, tf.int32), box_range], axis=<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># box_to_level[:, 0]表示第几张图</span></span><br><span class="line">        <span class="comment"># box_to_level[:, 1]表示第几张图里的第几个框</span></span><br><span class="line">        sorting_tensor = box_to_level[:, <span class="number">0</span>] * <span class="number">100000</span> + box_to_level[:, <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 进行排序，将同一张图里的某一些聚集在一起</span></span><br><span class="line">        ix = tf.nn.top_k(sorting_tensor, k=tf.shape(</span><br><span class="line">            box_to_level)[<span class="number">0</span>]).indices[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按顺序获得图片的索引</span></span><br><span class="line">        ix = tf.gather(box_to_level[:, <span class="number">2</span>], ix)</span><br><span class="line">        pooled = tf.gather(pooled, ix)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   重新reshape为如下</span></span><br><span class="line">        <span class="comment">#   [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]</span></span><br><span class="line">        <span class="comment">#--------------------------------------------------------------------------#</span></span><br><span class="line">        shape = tf.concat([tf.shape(boxes)[:<span class="number">2</span>], tf.shape(pooled)[<span class="number">1</span>:]], axis=<span class="number">0</span>)</span><br><span class="line">        pooled = tf.reshape(pooled, shape)</span><br><span class="line">        <span class="keyword">return</span> pooled</span><br></pre></td></tr></table></figure><h2 id="2-7-局部公用特征层到预测结果">2.7 局部公用特征层到预测结果</h2><p>如何利用调整后的局部特征层获得预测结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    mrcnn_class_logits, mrcnn_class, mrcnn_bbox =\</span><br><span class="line"></span><br><span class="line">        fpn_classifier_graph(rpn_rois, mrcnn_feature_maps, input_image_meta,</span><br><span class="line"></span><br><span class="line">                                config.POOL_SIZE, config.NUM_CLASSES,</span><br><span class="line"></span><br><span class="line">                                train_bn=config.TRAIN_BN,</span><br><span class="line"></span><br><span class="line">                                fc_layers_size=config.FPN_CLASSIF_FC_LAYERS_SIZE)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立classifier模型，该函数主要实现目标检测功能</span></span><br><span class="line"><span class="comment">#   这个模型的预测结果会调整建议框</span></span><br><span class="line"><span class="comment">#   获得最终的预测框</span></span><br><span class="line"><span class="comment">#------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fpn_classifier_graph</span>(<span class="params">rois, feature_maps, image_meta,</span></span><br><span class="line"><span class="params">                         pool_size, num_classes, train_bn=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">                         fc_layers_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用建议框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, POOL_SIZE, POOL_SIZE, channels]，调整后的局部特征层</span></span><br><span class="line">    <span class="comment">#   pool_size 是对共享特征层截取后resize后的局部特征层的大小</span></span><br><span class="line">    <span class="comment">#   rois是初步筛选后的建议框</span></span><br><span class="line">    <span class="comment">#   image_meta是保存了图片的必要信息</span></span><br><span class="line">    <span class="comment">#   feature_maps共享特征层</span></span><br><span class="line">    <span class="comment">#---------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_classifier&quot;</span>)([rois, image_meta] + feature_maps)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   利用卷积进行特征整合，首先进行7x7的卷积，相当于两次全连接</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, 1, 1, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(fc_layers_size, (pool_size, pool_size), padding=<span class="string">&quot;valid&quot;</span>),  name=<span class="string">&quot;mrcnn_class_conv1&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_class_bn1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, 1, 1, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(fc_layers_size, (<span class="number">1</span>, <span class="number">1</span>)), name=<span class="string">&quot;mrcnn_class_conv2&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_class_bn2&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : [batch, num_rois, fc_layers_size]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    shared = Lambda(<span class="keyword">lambda</span> x: K.squeeze(K.squeeze(x, <span class="number">3</span>), <span class="number">2</span>),  name=<span class="string">&quot;pool_squeeze&quot;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   Classifier head</span></span><br><span class="line">    <span class="comment">#   这个的预测结果代表这个先验框内部的物体的种类</span></span><br><span class="line">    <span class="comment">#   mrcnn_probs   : [batch, num_rois, num_classes]，每一张图片里，每一个先验框里面，物体的种类</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    mrcnn_class_logits = TimeDistributed(Dense(num_classes), name=<span class="string">&#x27;mrcnn_class_logits&#x27;</span>)(shared)</span><br><span class="line">    mrcnn_probs = TimeDistributed(Activation(<span class="string">&quot;softmax&quot;</span>), name=<span class="string">&quot;mrcnn_class&quot;</span>)(mrcnn_class_logits)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   BBox head</span></span><br><span class="line">    <span class="comment">#   这个的预测结果会对先验框进行调整</span></span><br><span class="line">    <span class="comment">#   mrcnn_bbox : [batch, num_rois, num_classes, 4]</span></span><br><span class="line">    <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Dense(num_classes * <span class="number">4</span>, activation=<span class="string">&#x27;linear&#x27;</span>), name=<span class="string">&#x27;mrcnn_bbox_fc&#x27;</span>)(shared)</span><br><span class="line">    mrcnn_bbox = Reshape((-<span class="number">1</span>, num_classes, <span class="number">4</span>), name=<span class="string">&quot;mrcnn_bbox&quot;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mrcnn_class_logits, mrcnn_probs, mrcnn_bbox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------#</span></span><br><span class="line"><span class="comment">#   建立mask模型</span></span><br><span class="line"><span class="comment">#   这个模型会利用预测框对特征层进行ROIAlign</span></span><br><span class="line"><span class="comment">#   根据截取下来的特征层进行语义分割</span></span><br><span class="line"><span class="comment">#----------------------------------------------#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_fpn_mask_graph</span>(<span class="params">rois, feature_maps, image_meta,</span></span><br><span class="line"><span class="params">                         pool_size, num_classes, train_bn=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   ROI Pooling，利用预测框在特征层上进行截取</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, channels</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = PyramidROIAlign([pool_size, pool_size], name=<span class="string">&quot;roi_align_mask&quot;</span>)([rois, image_meta] + feature_maps)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv1&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn1&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv2&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn2&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv3&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn3&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, MASK_POOL_SIZE, MASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(<span class="number">256</span>, (<span class="number">3</span>, <span class="number">3</span>), padding=<span class="string">&quot;same&quot;</span>), name=<span class="string">&quot;mrcnn_mask_conv4&quot;</span>)(x)</span><br><span class="line">    x = TimeDistributed(BatchNormalization(), name=<span class="string">&#x27;mrcnn_mask_bn4&#x27;</span>)(x, training=train_bn)</span><br><span class="line">    x = Activation(<span class="string">&#x27;relu&#x27;</span>)(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, 2xMASK_POOL_SIZE, 2xMASK_POOL_SIZE, 256</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2DTranspose(<span class="number">256</span>, (<span class="number">2</span>, <span class="number">2</span>), strides=<span class="number">2</span>, activation=<span class="string">&quot;relu&quot;</span>), name=<span class="string">&quot;mrcnn_mask_deconv&quot;</span>)(x)</span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    <span class="comment">#   反卷积后再次进行一个1x1卷积调整通道，</span></span><br><span class="line">    <span class="comment">#   使其最终数量为numclasses，代表分的类</span></span><br><span class="line">    <span class="comment">#   x   : batch, num_rois, 2xMASK_POOL_SIZE, 2xMASK_POOL_SIZE, numclasses</span></span><br><span class="line">    <span class="comment">#--------------------------------------------------------------------#</span></span><br><span class="line">    x = TimeDistributed(Conv2D(num_classes, (<span class="number">1</span>, <span class="number">1</span>), strides=<span class="number">1</span>, activation=<span class="string">&quot;sigmoid&quot;</span>), name=<span class="string">&quot;mrcnn_mask&quot;</span>)(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="2-8-建议框调整获得预测框">2.8 建议框调整获得预测框</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#------------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   detections          : Batch_size, num_detections, 6</span></span><br><span class="line"><span class="comment">#   detection_boxes     : Batch_size, num_detections, 4</span></span><br><span class="line"><span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">detections = DetectionLayer(config, name=<span class="string">&quot;mrcnn_detection&quot;</span>)([rpn_rois, mrcnn_class, mrcnn_bbox, input_image_meta])</span><br><span class="line">detection_boxes = Lambda(<span class="keyword">lambda</span> x: x[..., :<span class="number">4</span>])(detections)</span><br></pre></td></tr></table></figure><p>我们的工作都发生在<code>DetectionLayer</code>四个参数分别是rpn_rois建议框、mrcnn_class建议内部物体的置信度、mrcnn_bbox建议框的调整参数、input_image_meta输入图片的基本信息。</p><p>其中<code>DetectionLayer</code>的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="comment">#   Detection Layer</span></span><br><span class="line"><span class="comment">#   利用classifier的预测结果对建议框进行调整获得预测框</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DetectionLayer</span>(<span class="title class_ inherited__">Layer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(DetectionLayer, self).__init__(**kwargs)</span><br><span class="line">        self.config = config</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   获得的inputs</span></span><br><span class="line">        <span class="comment">#   rpn_rois            : Batch_size, proposal_count, 4</span></span><br><span class="line">        <span class="comment">#   mrcnn_class         : Batch_size, num_rois, num_classes</span></span><br><span class="line">        <span class="comment">#   mrcnn_bbox          : Batch_size, num_rois, num_classes, </span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        rois = inputs[<span class="number">0</span>]</span><br><span class="line">        mrcnn_class = inputs[<span class="number">1</span>]</span><br><span class="line">        mrcnn_bbox = inputs[<span class="number">2</span>]</span><br><span class="line">        image_meta = inputs[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   找到window的小数形式，指出原始的图片在调整后（加灰条）图片中的位置</span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        m = parse_image_meta_graph(image_meta)</span><br><span class="line">        image_shape = m[<span class="string">&#x27;image_shape&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        window = norm_boxes_graph(m[<span class="string">&#x27;window&#x27;</span>], image_shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   对每一张图的结果进行解码</span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------------#</span></span><br><span class="line">        detections_batch = batch_slice(</span><br><span class="line">            [rois, mrcnn_class, mrcnn_bbox, window],</span><br><span class="line">            <span class="keyword">lambda</span> x, y, w, z: refine_detections_graph(x, y, w, z, self.config),</span><br><span class="line">            self.config.IMAGES_PER_GPU)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">        <span class="comment">#   最终输出的shape为</span></span><br><span class="line">        <span class="comment">#   Batch_size, num_detections, 6] </span></span><br><span class="line">        <span class="comment">#------------------------------------------------------------#</span></span><br><span class="line">        <span class="keyword">return</span> tf.reshape(</span><br><span class="line">            detections_batch,</span><br><span class="line">            [self.config.BATCH_SIZE, self.config.DETECTION_MAX_INSTANCES, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><h1>三、创建自己的数据集</h1><h2 id="3-1-安装labelme">3.1 安装labelme</h2><p>打开cmd窗口，输入<code>activate tensorflow2</code>激活自己的anaconda环境。</p><p>然后安装labelme</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme</span><br></pre></td></tr></table></figure><p>安装完成后直接在命令行输入<code>labelme</code>即可打开。</p><p>使用label进行标注，将生成的json文件和原始图像jpg，放入同一个文件夹中。</p><h2 id="3-2-转换coco格式">3.2 转换coco格式</h2><p>参考<a href="https://pypi.org/project/labelme2coco/">pypi的labelme2coco包</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install labelme2coco</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者使用清华源</span></span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple labelme2coco</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelme2coco path/to/labelme/dir --train_split_rate 0.85</span><br></pre></td></tr></table></figure><h2 id="3-2-或者转换成mask掩码图，再数据增广，再转换coco格式">3.2 或者转换成mask掩码图，再数据增广，再转换coco格式</h2><p><strong>（1）labelme结果转mask掩码图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从./images文件夹中读取图片和json文件</span></span><br><span class="line"><span class="string">生成01_my0003.png和对应的01_my0003.png</span></span><br><span class="line"><span class="string">分别保存在./images/rgb和./images/label文件夹下（先新建）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">obj_dic = &#123;<span class="number">1</span>: <span class="string">&#x27;ammeter&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;realsensebox&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;coffeebox&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;sucker&#x27;</span>&#125;</span><br><span class="line">obj_list = <span class="built_in">list</span>(obj_dic.values())</span><br><span class="line"></span><br><span class="line">dataset_dir = <span class="string">&quot;./MaskRCNN&quot;</span></span><br><span class="line">file_list = os.listdir(dataset_dir)</span><br><span class="line">file_list.sort()</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> file_list:</span><br><span class="line">    <span class="keyword">if</span> filename[-<span class="number">4</span>:] != <span class="string">&#x27;json&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    img = cv2.imread(os.path.join(dataset_dir, filename[:-<span class="number">5</span>] + <span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">    json_path = os.path.join(dataset_dir, filename)</span><br><span class="line">    <span class="comment"># 读取标注数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.load(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 针对每个标注，将其表示为掩码图像</span></span><br><span class="line">    <span class="keyword">for</span> shape <span class="keyword">in</span> data[<span class="string">&#x27;shapes&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 新建空白图像</span></span><br><span class="line">        mask_img = Image.new(<span class="string">&#x27;L&#x27;</span>, (<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>)    <span class="comment"># 注意！修改成自己图片的分辨率</span></span><br><span class="line">        <span class="comment"># 读取标签点</span></span><br><span class="line">        label_name = shape[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">        label_index = <span class="string">&quot;%02d&quot;</span> % (obj_list.index(label_name) + <span class="number">1</span>)</span><br><span class="line">        polygon_points = shape[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line">        <span class="comment"># 绘制区域</span></span><br><span class="line">        mask_img_draw = ImageDraw.Draw(mask_img)</span><br><span class="line">        <span class="comment"># mask_img_draw.polygon(polygon_points, outline=1, fill=1)</span></span><br><span class="line">        mask_img_draw.polygon(<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, polygon_points)), outline=<span class="number">1</span>, fill=<span class="number">1</span>)</span><br><span class="line">        mask_img = cv2.cvtColor(np.array(mask_img)*<span class="number">255</span>, cv2.COLOR_GRAY2BGR)</span><br><span class="line">        <span class="comment"># 将掩码图像保存为PNG文件</span></span><br><span class="line">        mask_path = os.path.join(dataset_dir + <span class="string">&quot;/label&quot;</span>, label_index + <span class="string">&quot;_&quot;</span> + filename)[:-<span class="number">5</span>] + <span class="string">&quot;.png&quot;</span></span><br><span class="line">        img_path = os.path.join(dataset_dir + <span class="string">&quot;/rgb&quot;</span>, label_index + <span class="string">&quot;_&quot;</span> + filename)[:-<span class="number">5</span>] + <span class="string">&quot;.png&quot;</span></span><br><span class="line">        cv2.imwrite(mask_path, mask_img)</span><br><span class="line">        cv2.imwrite(img_path, img)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>（2）数据增广</strong></p><p>将rgb图和mask掩码图做同样的变换，得到数据增广的rgb和mask掩码图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imgaug.augmenters <span class="keyword">as</span> iaa</span><br><span class="line"><span class="keyword">from</span> imgaug.augmentables.segmaps <span class="keyword">import</span> SegmentationMapsOnImage</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从./MaskRCNN/rgb中读取rgb图像，从./MaskRCNN/label中读取mask图像</span></span><br><span class="line"><span class="string">生成数据增广的rgb图像保存在./MaskRCNN/rgb_aug中，mask掩码图保存在./MaskRCNN/label_aug中（先新建）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像数据增强</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_augmentation</span>(<span class="params">images_folder_path, output_folder_path, augment_times=<span class="number">3</span></span>):</span><br><span class="line">    <span class="comment"># 定义数据增强操作</span></span><br><span class="line">    seq = iaa.Sequential([</span><br><span class="line">        iaa.Sometimes(<span class="number">0.5</span>, iaa.GaussianBlur(sigma=(<span class="number">0</span>, <span class="number">0.5</span>))),</span><br><span class="line">        iaa.Affine(</span><br><span class="line">            scale=&#123;<span class="string">&quot;x&quot;</span>: (<span class="number">0.8</span>, <span class="number">1.2</span>), <span class="string">&quot;y&quot;</span>: (<span class="number">0.8</span>, <span class="number">1.2</span>)&#125;,</span><br><span class="line">            translate_percent=&#123;<span class="string">&quot;x&quot;</span>: (-<span class="number">0.2</span>, <span class="number">0.2</span>), <span class="string">&quot;y&quot;</span>: (-<span class="number">0.2</span>, <span class="number">0.2</span>)&#125;,</span><br><span class="line">            rotate=(-<span class="number">45</span>, <span class="number">45</span>),</span><br><span class="line">            shear=(-<span class="number">16</span>, <span class="number">16</span>)</span><br><span class="line">        ),</span><br><span class="line">        iaa.SomeOf((<span class="number">0</span>, <span class="number">5</span>), [</span><br><span class="line">            iaa.OneOf([</span><br><span class="line">                iaa.Dropout(p=(<span class="number">0</span>, <span class="number">0.1</span>)),</span><br><span class="line">                iaa.CoarseDropout(p=(<span class="number">0</span>, <span class="number">0.1</span>), size_percent=(<span class="number">0.02</span>, <span class="number">0.05</span>)),</span><br><span class="line">            ]),</span><br><span class="line">            iaa.AddToHueAndSaturation(value=(-<span class="number">10</span>, <span class="number">10</span>), per_channel=<span class="literal">True</span>),</span><br><span class="line">            iaa.LinearContrast(alpha=(<span class="number">0.95</span>, <span class="number">1.05</span>), per_channel=<span class="literal">True</span>),</span><br><span class="line">            iaa.AdditiveGaussianNoise(scale=(<span class="number">0</span>, <span class="number">0.05</span> * <span class="number">255</span>), per_channel=<span class="literal">True</span>),</span><br><span class="line">            iaa.Multiply((<span class="number">0.8</span>, <span class="number">1.2</span>), per_channel=<span class="number">0.2</span>),</span><br><span class="line">        ], random_order=<span class="literal">True</span>)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图片列表</span></span><br><span class="line">    img_list = os.listdir(images_folder_path)</span><br><span class="line">    <span class="comment"># 对每张图片进行增强</span></span><br><span class="line">    <span class="keyword">for</span> img_name <span class="keyword">in</span> img_list:</span><br><span class="line">        img_path = os.path.join(images_folder_path, img_name)</span><br><span class="line">        mask_path = img_path.replace(<span class="string">&quot;.png&quot;</span>, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">        mask_path = mask_path.replace(<span class="string">&quot;rgb&quot;</span>, <span class="string">&quot;label&quot;</span>)</span><br><span class="line">        img = cv2.imread(img_path)</span><br><span class="line">        mask = cv2.imread(mask_path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(augment_times):</span><br><span class="line">            segmap_mask = SegmentationMapsOnImage(mask, shape=img.shape)</span><br><span class="line">            <span class="comment"># 对 RGB 图像和 mask 掩码图同时进行增强</span></span><br><span class="line">            aug_det = seq.to_deterministic()</span><br><span class="line">            aug_img = aug_det.augment_image(img)</span><br><span class="line">            segmap_aug  = aug_det.augment_segmentation_maps(segmap_mask)</span><br><span class="line"></span><br><span class="line">            aug_mask = segmap_aug .get_arr()</span><br><span class="line">            aug_mask = np.array(aug_mask, dtype=np.uint8)</span><br><span class="line">            thresh, aug_mask_bin = cv2.threshold(aug_mask, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">            <span class="comment"># 定义结构元素</span></span><br><span class="line">            kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>), np.uint8)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对掩码图像进行腐蚀操作</span></span><br><span class="line">            aug_mask_bin = cv2.erode(aug_mask_bin, kernel, iterations=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 保存增强后的图像</span></span><br><span class="line">            output_name = os.path.splitext(img_name)[<span class="number">0</span>] + <span class="string">&#x27;_aug_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) + os.path.splitext(img_name)[<span class="number">1</span>]</span><br><span class="line">            output_path = os.path.join(output_folder_path, output_name)</span><br><span class="line">            output_mask_name = os.path.splitext(img_name)[<span class="number">0</span>]  + <span class="string">&#x27;_aug_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) + os.path.splitext(img_name)[<span class="number">1</span>]</span><br><span class="line">            output_mask_path = os.path.join(output_folder_path.replace(<span class="string">&quot;rgb&quot;</span>, <span class="string">&quot;label&quot;</span>), output_mask_name)</span><br><span class="line">            cv2.imwrite(output_path, aug_img)</span><br><span class="line">            cv2.imwrite(output_mask_path, aug_mask_bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    images_folder_path = <span class="string">&#x27;./MaskRCNN/rgb&#x27;</span></span><br><span class="line">    output_folder_path = <span class="string">&#x27;./MaskRCNN/rgb_aug&#x27;</span></span><br><span class="line">    data_augmentation(images_folder_path, output_folder_path)</span><br></pre></td></tr></table></figure><p><strong>（3）从rgb和mask图生成coco数据</strong></p><h1>四、开始训练</h1><p>运行<code>json_to_dataset.py</code>将标注的json图像转换为数据集。</p><p>在<code>dataset.py</code>中的<code>load_shapes</code>中添加自己的分类，同时在最后的循环中也添加自己的分类。</p><p>在<code>train.py</code>的<code>ShapesConfig</code>修改图片大小，<code>IMAGE_MIN_DIM</code>和<code>IMAGE_MAX_DIM</code>两个图片大小可以一样，<code>NUM_CLASSES</code>后面的数字是分的类</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 2D视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 实例分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习笔记01】神经网络与深度学习</title>
      <link href="/post/3845f1da.html"/>
      <url>/post/3845f1da.html</url>
      
        <content type="html"><![CDATA[<h1>一、深度学习概论</h1><h2 id="1-1-神经网络">1.1 神经网络</h2><p>激活函数ReLU（基本修正单元Rectified linear unit），一开始是零，后面沿直线上升。</p><p>一个神经网络中每一个单元都可能是ReLU或者其他非线性单元。</p><h2 id="1-2-监督学习">1.2 监督学习</h2><p><strong>（1）深度学习的应用领域</strong></p><p>在监督学习中，先输入X，然后学习到一个函数，映射输出到Y。</p><p>目前深度学习在线上广告投放、图像处理、语音识别、机器翻译、无人驾驶等领域已经发挥了重要的作用。但每一项应用都需要我们合理选择x和y，才能解决特定问题。</p><p><strong>（2）一些常用框架</strong></p><p>价格预测，<strong>通用标准的神经网络框（Standard NN）</strong><br>图像处理，<strong>卷积神经网络CNN（Convolutional NN）</strong><br>序列处理，如音频，<strong>循环神经网络RNN（Recurrent NN）</strong><br>语言处理，使用更复杂的<strong>RNNs</strong><br>无人驾驶中使用图像和雷达，会使用更复杂的<strong>混合的神经网络结构</strong></p><p><strong>（3）结构化数据与非结构化数据</strong></p><p>结构化数据，是数据的数据库，例如价格预测时会有标准的数据库，广告投放时会有用户信息，广告信息等数据库。</p><p>非结构化数据指语音、图像、视频、文本等，相比较结构化数据，更难以让计算机理解。</p><h2 id="1-3-关于深度学习">1.3 关于深度学习</h2><p>深度学习近年强势发展的主要因素。</p><p>以前的算法，比如传统机器学习向量机等，随着数据量的增大，算法的表现基本没有提高。早期数据很少，随着数据的增多，算法有了一些提高，但后期人们进入数据化时代，每个人每天都在产生大量数据，数据量越来越大，但以前的算法却并没有得到更好的结果。</p><p>这时如果使用数据训练一个小型的神经网络，算法表现会比以前好很多，如果训练一个更复杂的大型神经网络，那么得到的结果会更好。虽然数据量增大会使训练时间增高，但如今大型神经网络已经帮著人类取得了很多很多成果。</p><p>另一方面，以前的SVM向量机的训练好坏更却决于认为手动设计，二现在神经网络更加通用。</p><p>其次是计算能力，CPU和GPU运算能力的提升也是深度学习发展的基础。</p><p>算法方面的创新也极大地促进了深度学习，许多算法的提出都是为了改善神经网络的性能，增加计算速度。</p><h1>二、神经网络编程基础</h1><h2 id="2-1-符号定义">2.1 符号定义</h2><p>对于想要遍历数据集的情况，尽量不要使用for循环。</p><p>例如识别一张猫的图片是否是猫。</p><p>首先我们获取一张图片，其由3个矩阵（RGB）组成，我们可以将每一个矩阵所有像素值提取出来列成一个特征向量。这样输入的矩阵维度就是3xheightxwidth。</p><p>输入就是特征向量，输出就是标签0/1代表有猫还是没猫。</p><p>用数字符号表示为如下：</p><p>输入与输出：$(x,y)$</p><p>数据集：$m:{(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),…,(x^{(m)},y^{(m)})}$</p><p>通常会将输入数据$x^{(n)}$以列向量的形式构建为一个输入矩阵</p><p>$X=[x^{(1)},x^{(2)},…,x^{(m)}]$</p><p>输入矩阵$X\in{R^{n_x\times{m}}}$，其行列数为$X.shape=(nx,m)$。</p><p>同样输出数据$y^{(n)}$也会构建为一个输出矩阵</p><p>$Y=[y^{(1)},y^{(2)},…,y^{(m)}]$</p><p>输入矩阵$Y\in{R^{1\times{m}}}$，其行列数为$Y.shape=(1,m)$。</p><h2 id="2-2-二元分类问题——logistic回归方法">2.2 二元分类问题——logistic回归方法</h2><p><strong>（1）二元分类问题</strong></p><p>对于一个神经网络的问题，比如图像目标识别，输出的结果$y\in(0,1)$，即图片要么是目标，要么不是。</p><p>我们给定了图片输入$x$特征向量，期望得到一个预测值$\hat{y}$，判断图片是不是我们想要的目标，预测的过程相当于求一个概率：</p><p>$\hat{y}=P(y=1|x)$</p><p><strong>（2）logistic方法</strong></p><p>由于二元分类问题，预测结果应为[0,1]，因此线性方式一般不使用，因为线性表达，Y可以无穷大也。常用的方法是在线性的基础上再使用sigmoid函数。</p><p>$\textcolor{red}{\hat{y}=\sigma(w^Tx+b)}$</p><p>其中$w^T\in{R^{n_x}}$是$x$的系数向量，$b\in{R}$是常数，是一个拦截器，$\sigma(z)=\frac{1}{1+e^{-z}}$是sigmoid函数。利用$\sigma(z)$就可以将直线输出转换为[0,1]输出。</p><p><strong>（3）损失函数Loss</strong></p><p><strong>损失函数Loss是单个样本的预测值与实际值之差</strong></p><p>为了训练$w$和$b$，我们需要定义一个损失函数，用来描述$\hat{y}$与$y$的接近程度。再logistic方法中我们使用下面的函数作为损失函数Loss。</p><p>$\textcolor{red}{L({\hat{y},y})=-(y\log\hat{y}+(1-y)\log(1-\hat{y}))}$</p><p>对于损失函数，我们希望它越小越好。</p><p>当$y=1$时，$L(\hat{y},y)=-\log\hat{y}$，可以看出来$\hat{y}$越大($\hat{y}\rightarrow1$)，Loss越小。</p><p>同理$y=0$时，$L(\hat{y},y)=-\log{(1-\hat{y})}$，可以看出来$\hat{y}$越小($\hat{y}\rightarrow0$)，Loss越小。</p><p>（再其他方法中可能会用方差作为Loss函数，这里不用是因为方差得到的结果是凹凸的，也就是会有多个局部最优解，不便于后续梯度下降求全局最优解，而上面的Loss函数则解决了这个问题）</p><p><strong>（4）成本函数</strong></p><p><strong>成本函数是全体样本的预测值与实际值之差</strong></p><p>$\textcolor{red}{J(w,b)=\frac{1}{m}\sum^m_{i=1}{L(\hat{y}^{(i)},y^{(i)})}=-\frac{1}{m}(y\log\hat{y}+(1-y)\log(1-\hat{y}))}$</p><h2 id="2-3-梯度下降法">2.3 梯度下降法</h2><p>成本函数衡量了训练集的预测效果，我们想要的时找到合适的 $w,b$ 使得成本函数 $J(w,b)$ 尽可能小，这就用到了梯度下降法。</p><p>由于成本函数 $J(w,b)$ 是凸函数，因此函数形状是如下图这样的，这也是我们为什么定义损失函数那样形式的原因。</p><p><strong>我们要做的是初始化一个 $w,b$ 的值，然后让其向梯度下降的方向走，直到找到梯度最低的点。</strong></p><p>以 $w$ 为例，我们将重复以下过程：$w=w-\alpha\frac{dJ(w)}{dw}$，来更新 $w$ ，其中 $\alpha$ 是学习率参数，可以看出如果斜率越大，那么每次迭代w变化也越大。</p><p>实际中我们会使用下面的方程进行梯度下降求解 $w,b$</p><p>$w=w-\alpha\frac{\partial{J(w,b)}}{\partial{w}}$</p><p>$b=b-\alpha\frac{\partial{J(w,b)}}{\partial{b}}$</p><p><img src="https://img.mahaofei.com/img/20220426114017.png" alt=""></p><h2 id="2-4-计算图">2.4 计算图</h2><p><strong>计算图</strong>是从左到右的计算，来计算成本函数 $J$。</p><p>对于一个流程图，可以很容易的看出 $J$ 的导数。<strong>反向传播</strong>，就是从最终输出反推 $J$ 对各个中间变量以及输入的导数。</p><p>在程序里，通常约定编程时使用<code>dvar</code>代表最终输出变量对于变量<code>var</code>的导数</p><p>代码大致过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">J = <span class="number">0</span></span><br><span class="line">dw1 = <span class="number">0</span></span><br><span class="line">dw2 = <span class="number">0</span></span><br><span class="line">db = <span class="number">0</span></span><br><span class="line"><span class="comment"># 遍历数据集</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line"><span class="comment"># 计算损失函数与成本函数</span></span><br><span class="line">zi = w1 * x1 + w2 * x2 +b</span><br><span class="line">ai = <span class="number">1</span>/(<span class="number">1</span>+exp(-zi))</span><br><span class="line">J += -[yi * log(ai) + (<span class="number">1</span> - yi) * log(<span class="number">1</span>-ai)]</span><br><span class="line"><span class="comment"># 求导</span></span><br><span class="line">dzi = ai -yi</span><br><span class="line">dw1 += x1 * dzi</span><br><span class="line">dw2 += x2 * dzi</span><br><span class="line">db += dzi</span><br><span class="line"><span class="comment"># 解出各参数优化后的值</span></span><br><span class="line">J/=m</span><br><span class="line">dw1/=m</span><br><span class="line">dw2/=m</span><br><span class="line">db/=m</span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line">w1=w1-a*dw1</span><br><span class="line">w2=w2-a*dw2</span><br><span class="line">b=b-a*db</span><br></pre></td></tr></table></figure><h2 id="2-5-向量化">2.5 向量化</h2><p><strong>（1）什么是向量化</strong></p><p>由于输入数据$x$和系数$w$都是列向量，对于这两个向量相乘，如果使用非向量化的方法即for循环实现，运算速度非常慢，而如果使用向量化的方法，例如在numpy中使用<code>z=np.dot(w,x)</code>实现两个向量的点乘，运算速度会快的多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量化</span></span><br><span class="line">a = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">tic = time.time()</span><br><span class="line">c = np.dot(a,b)</span><br><span class="line">toc = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Vectorized:&quot;</span> + <span class="built_in">str</span>(<span class="number">1000</span>*(toc-tic))+<span class="string">&quot;ms&quot;</span>)</span><br><span class="line"><span class="comment"># 非向量化</span></span><br><span class="line">a = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">tic = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">c += a[i]*b[i]</span><br><span class="line">toc = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;For Loop:&quot;</span> + <span class="built_in">str</span>(<span class="number">1000</span>*(toc-tic))+<span class="string">&quot;ms&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果向量化的方法用时1.5ms，for循环方法500ms</span></span><br></pre></td></tr></table></figure><p>对于这个小算法区分还不明显，但如果你训练一个神经网络使用非向量化方法需要300小时，向量化方法只需要1个小时，那样差距就非常明显了。</p><p><strong>（2）前向传播的向量化</strong></p><p>前向传播的目的是计算$z^{(i)}$和$a^{(i)}$</p><p>$z^{(i)}=w^Tx^{(i)}+b$<br>$a^{(i)}=\sigma(z^{(i)})$</p><p>可以通过以下方式实现向量化：<br>$Z=[z^{(1)}\ z^{(2)}\ \cdots\ z^{(m)}]=w^T\cdot{X}+[b\ b\ \cdots\ b]=[w^Tx^{(1)}+b\ w^Tx^{(2)}+b\ \cdots\ w^Tx^{(m)}+b]$<br>其中$X$是输入矩阵，每列是每一个样本的所有特征，共有m列即共m个样本；$w^T$是参数$w^{(i)}\rightarrow w^{(nx)}$组成的行向量。</p><p>以<code>python</code>程序表示上述过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z=np.dot(w.T, X) + b</span><br></pre></td></tr></table></figure><p><strong>（3）梯度计算的向量化</strong></p><p>梯度计算就是计算$dz^{(i)}$、$dw^{(i)}$和$db^{(i)}$</p><p>$dz^{(i)}=a^{(i)}-y^{(i)}$<br>$dw^{(i)}=x^{(i)}dz^{(i)}$<br>$db^{(i)}=dz^{(i)}$</p><p>可以通过以下方式实现向量化：</p><p>将$dz^{(i)}$, $dw^{(i)}$和$db^{(i)}$向量化：</p><p>$dw=[dw^{(1)}\ dw^{(2)}\ \cdots\ dw^{(m)}]$<br>$db=[db^{(1)}\ db^{(2)}\ \cdots\ db^{(m)}]$<br>$dz=[dz^{(1)}\ dz^{(2)}\ \cdots\ dz^{(m)}]$</p><p>则$db=\frac{1}{m}\sum^{m}_{i=1}dz^{(i)}$, $dw=\frac{1}{m}Xdz^T$</p><p>以<code>python</code>表达</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z=np.dot(w.T,x)+b</span><br><span class="line">A=sigmod(Z)</span><br><span class="line">dZ=A-Y</span><br><span class="line">db=np.<span class="built_in">sum</span>(dZ)/m</span><br><span class="line">dw=np.dot(X,dZ^T)/m</span><br><span class="line">w=w-a1*dw</span><br><span class="line">b=b-a2*db</span><br></pre></td></tr></table></figure><p><strong>（4）总结</strong><br>为了加快代码计算速度，我们使用了向量化的手段，即尽量使用numpy计算数据集而不是用for循环。</p><p>输入矩阵 $X.shape = (nx,m)$，$m$个样本，每个样本$nx$个特征</p><p>$X=[x^{(1)}\ x^{(2)}\ \cdots\ x^{(m)}]$，其中 $x^{(i)}=[x^{(i)}_1\ x^{(i)}<em>2\ \cdots\ x^{(i)}</em>{nx}]^T$</p><p>参数矩阵 $W.shape=(nx,1)$，每个特征对应一个参数$w$</p><p>$W=[w_1\ w_2\ \cdots\ w_{nx}]^T$</p><p>参数 $B.shape=(1,m)$ ，每个特征对应一个参数$b$</p><p>$B=[b\ b\ \cdots\ b]$</p><p>线性值 $Z.shape=(1,m)$，相当于简化版 $\hat y$ ，每个样本都会计算得到一个计算值</p><p>$Z=W^TX+b=[W^Tx^{(1)}+b\ \ \ \ W^Tx^{(2)}+b\ \ \cdots\ \ W^Tx^{(m)}+b]$</p><p>预测值 $A.shape=(1,m)$，每个样本一个预测值</p><p>$A=\hat Y=\sigma{(Z)}$</p><p>损失函数 $L.shape=(1,m)$，每个样本的预测值与标定值距离</p><p>$L=-Y\log{A}-(1-Y)\log{(1-A)}$</p><p>成本函数 $J.spape=(1,1)$，所有损失函数平均值</p><p>$J=\frac{1}{m}L.sum()$</p><p>导数 $dZ.shape=(1,m)$</p><p>$dZ=\frac{dJ}{dZ}=A-Y$</p><p>导数 $dW.shape=(nx,1)$</p><p>$dW=\frac{1}{m}X\cdot dZ=[\frac{1}{m}dw^{(1)}\ \frac{1}{m}dw^{(2)}\ \cdots\ \frac{1}{m}dw^{(nx)}]^T$</p><p>导数 $dB.shape=(1,1)$</p><p>$db=\frac{1}{m}dZ.sum()$</p><h2 id="2-6-关于numpy与常用函数">2.6 关于numpy与常用函数</h2><p>最好不要使用秩为1的数组<code>a=np.random.randn(5)</code>，而要使用$(m,1)$或$(1,n)$的矩阵。也就是直接定义成行列向量<code>a=np.random.randn(5,1)</code>，或者使用<code>reshape</code>改变形状。</p><p>如果不确定某个向量的维度，可以使用assert声明来判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(a.shape==(<span class="number">5</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><strong>（1）sigmod函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    x -- 任意形状的numpy数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    s -- sigmoid(x)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    s=<span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><strong>（2）梯度计算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid_derivative</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    x -- numpy数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    ds -- 计算的梯度值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">    ds = s*(<span class="number">1</span>-s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ds</span><br></pre></td></tr></table></figure><p>**（3）输入图片变形为[width x height x 3, 1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">image2vector</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    image -- 特定形状的numpy数组 shape(length, height, depth)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    v -- 向量形式的数组 shape(length*height*depth, 1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    v = image.reshape(image.shape[<span class="number">0</span>]*image.shape[<span class="number">1</span>]*image.shape[<span class="number">2</span>],<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><p><strong>（4）归一化处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">normalizeRows</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    x -- 一个二维numpy数组 shape(n, m)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    x -- 按行归一化后的numpy矩阵</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算x数组的模</span></span><br><span class="line">    x_norm = np.linalg.norm(x,<span class="built_in">ord</span>=<span class="number">2</span>,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 用x除以它的模</span></span><br><span class="line">    x=x/x_norm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th><th>计算方法</th></tr></thead><tbody><tr><td>ord=默认</td><td>二范数：$l_2$</td><td>$\sqrt{x_1^2+x_2^2+\dots+x_n^2}$</td></tr><tr><td>ord=2</td><td>二范数：$l_2$</td><td>同上</td></tr><tr><td>ord=1</td><td>一范数：$l_1$</td><td>$\lvert x_1\rvert+\lvert x_2\rvert+\dots+\lvert x_n\rvert$</td></tr><tr><td>ord=np.inf</td><td>无穷范数：$l_{\infty}$</td><td>$MAX\lvert x_i\rvert$</td></tr><tr><td>axis=1</td><td>按行向量处理</td><td></td></tr><tr><td>axis=0</td><td>按列向量处理</td><td></td></tr><tr><td>axis=None</td><td>矩阵范数</td><td></td></tr></tbody></table><p><strong>（5）softmax函数</strong></p><p>softmax函数是一个规范化函数，用于算法需要分类两个或多个类的情况。</p><p>$$softmax(x) = softmax\begin{bmatrix}<br>x_{11} &amp; x_{12} &amp; x_{13} &amp; \dots  &amp; x_{1n} \<br>x_{21} &amp; x_{22} &amp; x_{23} &amp; \dots  &amp; x_{2n} \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>x_{m1} &amp; x_{m2} &amp; x_{m3} &amp; \dots  &amp; x_{mn}<br>\end{bmatrix} = \begin{bmatrix}<br>\frac{e^{x_{11}}}{\sum_{j}e^{x_{1j}}} &amp; \frac{e^{x_{12}}}{\sum_{j}e^{x_{1j}}} &amp; \frac{e^{x_{13}}}{\sum_{j}e^{x_{1j}}} &amp; \dots  &amp; \frac{e^{x_{1n}}}{\sum_{j}e^{x_{1j}}} \<br>\frac{e^{x_{21}}}{\sum_{j}e^{x_{2j}}} &amp; \frac{e^{x_{22}}}{\sum_{j}e^{x_{2j}}} &amp; \frac{e^{x_{23}}}{\sum_{j}e^{x_{2j}}} &amp; \dots  &amp; \frac{e^{x_{2n}}}{\sum_{j}e^{x_{2j}}} \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{e^{x_{m1}}}{\sum_{j}e^{x_{mj}}} &amp; \frac{e^{x_{m2}}}{\sum_{j}e^{x_{mj}}} &amp; \frac{e^{x_{m3}}}{\sum_{j}e^{x_{mj}}} &amp; \dots  &amp; \frac{e^{x_{mn}}}{\sum_{j}e^{x_{mj}}}<br>\end{bmatrix} = \begin{pmatrix}<br>softmax\text{(first row of x)}  \<br>softmax\text{(second row of x)} \<br>…  \<br>softmax\text{(last row of x)} \<br>\end{pmatrix} $$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    x -- 一个二维numpy数组 shape(n, m)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    x -- softmax后的numpy矩阵</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算exp(x)</span></span><br><span class="line">    x_exp = np.exp(x)</span><br><span class="line">    <span class="comment"># 创建向量x_sum对x_exp的每一行求和</span></span><br><span class="line">    x_sum = np.<span class="built_in">sum</span>(x_exp, axis = <span class="number">1</span>, keepdims = <span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 两者相除计算softmax</span></span><br><span class="line">    s = x_exp / x_sum</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p><strong>（6）Loss函数</strong></p><p>L1 Loss函数，用于评价模型的表现，loss越大，说明预测值和真实值的偏差预约。</p><p>$$\begin{align*} &amp; L_1(\hat{y}, y) = \sum_{i=0}^m|y^{(i)} - \hat{y}^{(i)}| \end{align*}\tag{6}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">L1</span>(<span class="params">yhat, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    yhat -- 长度m的向量（预测值）</span></span><br><span class="line"><span class="string">    y -- 长度m的向量（真实值）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    loss -- 上面定义的L1 Loss值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    loss = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(y-yhat))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><p>L2 Loss函数。</p><p>$$\begin{align*} &amp; L_2(\hat{y},y) = \sum_{i=0}^m(y^{(i)} - \hat{y}^{(i)})^2 \end{align*}\tag{7}$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">L2</span>(<span class="params">yhat, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    yhat -- 长度m的向量（预测值）</span></span><br><span class="line"><span class="string">    y -- 长度m的向量（真实值）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    loss -- 上面定义的L2 Loss值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    loss = np.<span class="built_in">sum</span>(np.dot(y-yhat,y-yhat))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><h2 id="2-7-总结">2.7 总结</h2><p><strong>（1）数学过程</strong></p><p>二分神经网络目的是给定一个输入 $x$（可以是图片等），输出预测值 $\hat y$，并尽可能让预测值 $\hat y$ 接近实际值 $y$，即：</p><p>$\hat{y}=P(y=1|x)$</p><p>而输出预测值 $\hat y$ 与输入 $x$ 之间的函数关系可以表示为（在线性表达的基础上加上sigmod函数，保证输出位于[0,1]区间）</p><p>$$\hat y=\sigma{(wx+b)}$$</p><p>其中定义 $z=wx+b$，$\sigma(z)=\frac{1}{1+e^{-z}}$</p><p>这其中我们需要做的就是找到最合适的 $w$ 和 $b$ ，使输出 $\hat y$ 尽可能接近 $y$。</p><p>因此为了衡量 $\hat y$ 与 $y$ 的接近程度，我们定义了一个损失函数Loss，只要让损失函数足够小，就能保证 $\hat y$ 与 $y$ 足够接近。</p><p>$$L(\hat y,y)=-y\log{\hat y}-(1-y)\log{(1-\hat y)}$$</p><p>当 $y=1$ 时， $L(\hat y,y)=-\log{\hat y}$，我们想要 $L(\hat y,y)$ 足够小，就要让 $\hat y$ 足够大即 $\hat y\rightarrow y=1$（由于时二分问题，$y\in [0,1]$）<br>当 $y=0$ 时， $L(\hat y,y)=-\log{(1-\hat y)}$，我们想要 $L(\hat y,y)$ 足够小，就要让 $\hat y$ 足够小即 $\hat y\rightarrow y=0$。</p><p>以上就说明了为什么这个损失函数能够描述 $\hat y$ 与 $y$ 的接近程度。</p><p>而上面只是一个样本 $x$ 的损失函数，而对于一个问题一般会输入大量的样本，假设有 $m$ 个，对于每一个样本都需要按照上述方法计算一个损失函数，而所有损失函数的平均值就是我们的输入的整体成本函数。</p><p>$$J(w,b)=\frac{1}{m}\sum^{n_x}_{i=1}L(\hat y^{(i)},y^{(i)})$$</p><p>因此训练的目的就变成了找到让 $J(w,b)$ 的极小值时的 $w$ 和 $b$。</p><p>因此每次训练迭代，都需要对成本函数求导 $\frac{\partial J}{\partial w}$ 和 $\frac{\partial J}{\partial b}$，然后根据求导结果更新 $w=w-\alpha \frac{\partial J}{\partial w}$ 和 $b=b-\frac{\partial J}{\partial w}$，直到找到 $J_{min}$ 对应的 $w$ 和 $b$，此时训练就完成了。</p><p><strong>（2）代码过程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> h5py                     <span class="comment"># 常用数据集交互工具，数据集被保存为H5文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy                    <span class="comment"># 用于图片测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image          </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集加载函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_dataset</span>():</span><br><span class="line"></span><br><span class="line">    train_dataset = h5py.File(<span class="string">&#x27;datasets/train_catvnoncat.h5&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">    train_set_x_orig = np.array(train_dataset[<span class="string">&quot;train_set_x&quot;</span>][:]) <span class="comment"># your train set features</span></span><br><span class="line"></span><br><span class="line">    train_set_y_orig = np.array(train_dataset[<span class="string">&quot;train_set_y&quot;</span>][:]) <span class="comment"># your train set labels</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    test_dataset = h5py.File(<span class="string">&#x27;datasets/test_catvnoncat.h5&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">    test_set_x_orig = np.array(test_dataset[<span class="string">&quot;test_set_x&quot;</span>][:]) <span class="comment"># your test set features</span></span><br><span class="line"></span><br><span class="line">    test_set_y_orig = np.array(test_dataset[<span class="string">&quot;test_set_y&quot;</span>][:]) <span class="comment"># your test set labels</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    classes = np.array(test_dataset[<span class="string">&quot;list_classes&quot;</span>][:]) <span class="comment"># the list of classes</span></span><br><span class="line"></span><br><span class="line">    train_set_y_orig = train_set_y_orig.reshape((<span class="number">1</span>, train_set_y_orig.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    test_set_y_orig = test_set_y_orig.reshape((<span class="number">1</span>, test_set_y_orig.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># sigmoid函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    x -- numpy数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    s -- 计算的sigmoid值,sigmoid(z)=1/(1+e^(-z))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    s = <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数，为w, b创建0向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_with_zeros</span>(<span class="params">dim</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    dim -- w向量的长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    w -- 初始化的向量, w.shape() -&gt; (dim, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    b -- 初始化的标量, 偏置值b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    w = np.zeros([dim,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(w.shape == (dim, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">isinstance</span>(b, <span class="built_in">float</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(b, <span class="built_in">int</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w, b</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向和后向传播函数，计算成本函数和梯度值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">propagate</span>(<span class="params">w, b, X, Y</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    w -- weights权重, numpy数组 w.shape -&gt; (num_px * num_px * 3, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    b -- bias偏置, 标量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    X -- 数据 X.shape -&gt; (num_px * num_px * 3, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Y -- 标签向量 (0非猫; 1猫) Y.shape -&gt; (1, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    cost -- 成本函数(逻辑回归的负对数)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    dw -- 损失函数对w的梯度,与w维度相同</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    db -- 损失函数对b的梯度,与b维度相同</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播(从数据X获得成本函数cost)</span></span><br><span class="line"></span><br><span class="line">    A = sigmoid(np.dot(w.T,X) + b)</span><br><span class="line"></span><br><span class="line">    cost = - <span class="number">1</span>/m * np.<span class="built_in">sum</span>(Y*np.log(A) + (<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-A))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 后向传播(计算梯度)</span></span><br><span class="line"></span><br><span class="line">    dw = <span class="number">1</span>/m * np.dot(X, (A-Y).T)</span><br><span class="line"></span><br><span class="line">    db = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(A-Y)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(dw.shape == w.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(db.dtype == <span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    cost = np.squeeze(cost)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(cost.shape == ())</span><br><span class="line"></span><br><span class="line">    grads = &#123;<span class="string">&quot;dw&quot;</span>: dw,</span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;db&quot;</span>: db&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grads, cost</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化函数，通过梯度下降算法优化w和b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">optimize</span>(<span class="params">w, b, X, Y, num_iterations, learning_rate, print_cost = <span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    w -- weights权重, numpy数组 w.shape -&gt; (num_px * num_px * 3, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    b -- bias偏置, 标量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    X -- 数据 X.shape -&gt; (num_px * num_px * 3, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Y -- 标签向量 (0非猫; 1猫) Y.shape -&gt; (1, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    num_iterations -- 优化循环的迭代次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    learning_rate -- 学习率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print_cost -- True则每100次打印1次成本函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    params -- 包括 权重w和偏置b 的字典</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    grads -- 包括 成本函数对w和b梯度 的字典</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    costs -- 优化过程中所有的成本函数列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    costs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 成本函数和梯度计算</span></span><br><span class="line"></span><br><span class="line">        grads, cost = propagate(w, b, X, Y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从grads字典中获取梯度dw和db</span></span><br><span class="line"></span><br><span class="line">        dw = grads[<span class="string">&quot;dw&quot;</span>]</span><br><span class="line"></span><br><span class="line">        db = grads[<span class="string">&quot;db&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新w和b</span></span><br><span class="line"></span><br><span class="line">        w = w - learning_rate * dw</span><br><span class="line"></span><br><span class="line">        b = b - learning_rate * db</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录成本函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            costs.append(cost)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每100个训练样本打印1次成本函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;Cost after iteration %i: %f&quot;</span> %(i, cost))</span><br><span class="line"></span><br><span class="line">    params = &#123;<span class="string">&quot;w&quot;</span>: w,</span><br><span class="line"></span><br><span class="line">              <span class="string">&quot;b&quot;</span>: b&#125;</span><br><span class="line"></span><br><span class="line">    grads = &#123;<span class="string">&quot;dw&quot;</span>: dw,</span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;db&quot;</span>: db&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> params, grads, costs</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测函数，利用学习到的逻辑回归w和b预测标签</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">w, b, X</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    w -- weights权重, numpy数组 w.shape -&gt; (num_px * num_px * 3, 1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    b -- bias偏置, 标量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    X -- 数据 X.shape -&gt; (num_px * num_px * 3, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Y_prediction -- numpy向量包含对所有X样本的预测值 (0/1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    Y_prediction = np.zeros((<span class="number">1</span>,m))</span><br><span class="line"></span><br><span class="line">    w = w.reshape(X.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测值A，预测图片中的是否是猫</span></span><br><span class="line"></span><br><span class="line">    A = sigmoid(np.dot(w.T, X) + b)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(A.shape[<span class="number">1</span>]):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换概率 A[0,i] 到真实的概率 p[0,i]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>,i] &lt; <span class="number">0.5</span>:</span><br><span class="line"></span><br><span class="line">            Y_prediction[<span class="number">0</span>,i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            Y_prediction[<span class="number">0</span>,i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(Y_prediction.shape == (<span class="number">1</span>, m))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Y_prediction</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 综合以上函数，构建逻辑回归模型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">X_train, Y_train, X_test, Y_test, num_iterations = <span class="number">2000</span>, learning_rate = <span class="number">0.5</span>, print_cost = <span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    X_train -- 训练数据 (num_px * num_px * 3, m_train)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Y_train -- 训练数据标签 (1, m_train)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    X_test -- 测试数据 (num_px * num_px * 3, m_test)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Y_test -- 测试数据标签 (1, m_test)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    num_iterations -- 迭代次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    learning_rate -- 学习率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    print_cost -- 是否打印成本函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    d -- 包含模型信息的字典</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line"></span><br><span class="line">    w, b = initialize_with_zeros(X_train.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 梯度下降</span></span><br><span class="line"></span><br><span class="line">    params, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从params中获得w和b</span></span><br><span class="line"></span><br><span class="line">    w, b = params[<span class="string">&quot;w&quot;</span>], params[<span class="string">&quot;b&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测训练和测试样本</span></span><br><span class="line"></span><br><span class="line">    Y_prediction_train = predict(w, b, X_train);</span><br><span class="line"></span><br><span class="line">    Y_prediction_test = predict(w, b, X_test)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印训练和测试的准确率</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;train accuracy: &#123;&#125; %&quot;</span>.<span class="built_in">format</span>(<span class="number">100</span> - np.mean(np.<span class="built_in">abs</span>(Y_prediction_train - Y_train)) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test accuracy: &#123;&#125; %&quot;</span>.<span class="built_in">format</span>(<span class="number">100</span> - np.mean(np.<span class="built_in">abs</span>(Y_prediction_test - Y_test)) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    d = &#123;<span class="string">&quot;costs&quot;</span>: costs,</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Y_prediction_test&quot;</span>: Y_prediction_test,</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Y_prediction_train&quot;</span> : Y_prediction_train,</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;w&quot;</span> : w,</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;b&quot;</span> : b,</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;learning_rate&quot;</span> : learning_rate,</span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;num_iterations&quot;</span>: num_iterations&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_set_x_orig是训练图片数据，train_set_y是训练标签数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个图像都是正方形(num_px, num_px, 3)</span></span><br><span class="line"></span><br><span class="line">train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据集基本参数</span></span><br><span class="line"></span><br><span class="line">m_train = train_set_x_orig.shape[<span class="number">0</span>] <span class="comment"># 训练数据数量</span></span><br><span class="line"></span><br><span class="line">m_test = test_set_x_orig.shape[<span class="number">0</span>]   <span class="comment"># 测试数据数量</span></span><br><span class="line"></span><br><span class="line">num_px = train_set_x_orig.shape[<span class="number">1</span>]  <span class="comment"># 图片长宽</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 展开训练数据集为一维</span></span><br><span class="line"></span><br><span class="line">train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>],-<span class="number">1</span>).T</span><br><span class="line"></span><br><span class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>],-<span class="number">1</span>).T</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集标准化处理（将所有像素值[0, 255]映射到[0, 1]）</span></span><br><span class="line"></span><br><span class="line">train_set_x = train_set_x_flatten/<span class="number">255</span></span><br><span class="line"></span><br><span class="line">test_set_x = test_set_x_flatten/<span class="number">255</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行model进行训练</span></span><br><span class="line"></span><br><span class="line">d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = <span class="number">20000</span>, learning_rate = <span class="number">0.005</span>, print_cost = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某张图片的预测结果</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.imshow(test_set_x[:,index].reshape((num_px, num_px, <span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;y = &quot;</span> + <span class="built_in">str</span>(test_set_y[<span class="number">0</span>,index]) + <span class="string">&quot;, you predicted that it is a \&quot;&quot;</span> + classes[<span class="built_in">int</span>(d[<span class="string">&quot;Y_prediction_test&quot;</span>][<span class="number">0</span>,index])].decode(<span class="string">&quot;utf-8&quot;</span>) +  <span class="string">&quot;\&quot; picture.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出学习曲线</span></span><br><span class="line"></span><br><span class="line">costs = np.squeeze(d[<span class="string">&#x27;costs&#x27;</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(costs)</span><br><span class="line"></span><br><span class="line">plt.ylabel(<span class="string">&#x27;cost&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;iterations (per hundreds)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Learning rate =&quot;</span> + <span class="built_in">str</span>(d[<span class="string">&quot;learning_rate&quot;</span>]))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1>三、神经网络</h1><h2 id="3-1-神经网络的表示">3.1 神经网络的表示</h2><p>一般的神经网络包括：输入层、隐藏层、输出层、输出值。</p><blockquote><p>隐藏层：在训练集中，这些节点的数值我们不知道，我们能看到输入值、输出值，但是中间值我们在训练是看不到的，所以叫隐藏层。</p></blockquote><p><img src="https://img.mahaofei.com/img/20220705151527.png" alt=""></p><p>上图就是标准的二层神经网络（输入层不算是标准的层），或者称为单隐层神经网络。</p><p>上面的网络中，输入层也可以用$a^{[0]}$表示，$a^{[0]}=X$，中间层可以用$a^{[1]}$表示，$a^{[1]}=[a^{[1]}_1 a^{[1]}_2 \cdots a^{[1]}_n]$，输出层可以用$a^{[2]}$表示。我们用方括号表示神经网络的层数。其中隐藏层和输出层有着各自的参数，分别记作$w^{[1]}, b^{[1]}$和$w{[2]}, b{[2]}$。</p><h2 id="3-2-神经网络的计算">3.2 神经网络的计算</h2><p>神经网络的计算过程，就是上一节中的回归计算的多次叠加。下图为上一节所说的逻辑回归的流程。</p><p><img src="https://img.mahaofei.com/img/20220705153535.png" alt=""></p><p>对应于二层神经网络中是如下图的部分（隐藏层与输入层之间），每一个隐层单元的计算过程都是同样的。</p><p><img src="https://img.mahaofei.com/img/20220705153640.png" alt=""></p><p>输出层与隐藏层之间的计算，也和隐藏层与输入层类似。只不过将隐藏层计算的$a^{[1]}$看作输入来进行回归运算。</p><p>用数学公式表示二层神经网络的计算过程：</p><p>$$z^{[1]}=W^{[1]}x+b^{[1]}$$<br>$$a^{[1]}=\sigma (z^{[1]})$$<br>$$z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}$$<br>$$a^{[2]}=\sigma (z^{[2]})$$</p><h2 id="3-3-激活函数">3.3 激活函数</h2><p><strong>（1）$\sigma$函数</strong></p><p>前面我们提到激活函数，都是使用的$\sigma$函数[0, 1]，但实际中几乎不使用该函数。</p><p><img src="https://img-blog.csdnimg.cn/20200306204205328.png" alt=""></p><p><strong>（2）tanh函数</strong></p><p>更一般的情况下，我们会使用其他非线性函数例如$tanh = \frac{e^z-e^{-z}}{e^z+e^{-z}}$函数[-1, 1]。事实证明，对于隐藏层的激活函数，如果使用tanh效果几乎总比$\sigma$好。对于输出层，由于$\hat y \in [0, 1]$，因此使用$\sigma$函数效果更好。</p><p><img src="https://pic4.zhimg.com/v2-9c23cf5defb43ca3a45639a04885d603_b.jpg" alt=""></p><p><strong>（3）ReLU函数</strong></p><p>但是无论是$\sigma$还是tanh，我们都可以看出在z非常大或非常小时，激活函数的斜率都很小，这会严重影响梯度下降找到最优解的速度。因此人们提出了线性修正单元ReLU。</p><p><img src="https://img-blog.csdnimg.cn/20200306215243190.png" alt=""></p><p>还有一种带泄露的线性修正单元 Leaky ReLU，在z&lt;0时a不为0。</p><p><img src="https://img-blog.csdnimg.cn/20210511133100300.png" alt=""></p><p><strong>（4）为什么需要非线性激活函数</strong></p><p>如果不使用机器学习，那么之前所说的二层神经网络的前向计算过程：</p><p>$$z^{[1]}=W^{[1]}x+b^{[1]}$$<br>$$a^{[1]}=\sigma (z^{[1]})$$<br>$$z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}$$<br>$$a^{[2]}=\sigma (z^{[2]})$$<br>令$a^{[1]}=z^{[1]}$，那么计算过程就可以写成下面的形式：</p><p>$$z^{[2]}=W^{[2]}z^{[1]}+b^{[2]}=W^{[2]}(W^{[1]}x+b^{[1]})+b^{[2]}=W’x+b’$$</p><p>化简出来$z^{[2]}$与x之间可以线性表示，那么也就是说无论网络有多少层，都可以将输出和输入用一个线性函数表示，那么神经网络的作用就没法体现了。因此激活函数是十分必要的。</p><p>从另一个角度来说，神经网络模拟的就是神经元的信号传递过程，ReLU等激活函数，模拟的就是神经元的放电阈值，当电刺激达到一定阈值才会向下一神经元发送信号，如果激活函数达到阈值才会输出，否则就是0，也是为了去掉某些不重要的样本特征，防止出现过拟合等现象。</p><p><strong>（5）激活函数的导数</strong></p><p>如果是sigmod函数，即$g(z)=\frac{1}{1+e^{-z}}$，则容易计算得到$\frac{d}{dz}g(z)=\frac{1}{1+e^{-z}}] (1-\frac{1}{1+e^{-z}})=g(z)(1-g(z))$。</p><ul><li>z-&gt;+∞时，g(z)-&gt;1，g’(z)-&gt;0；</li><li>z-&gt;-∞时，g(z)-&gt;0，g’(z)-&gt;0</li><li>z=0是，g(z)=0.5，g’(z)=0.25</li></ul><p>如果是tanh函数，即$g(z)=\frac{e^z-e^{-z}}{e^z+e^{-z}}$，则容易计算得到$\frac{d}{dz}g(z)=1-(tanh(z))^2$。</p><ul><li>z-&gt;+∞时，g(z)-&gt;1，g’(z)-&gt;0；</li><li>z-&gt;-∞时，g(z)-&gt;-1，g’(z)-&gt;0</li><li>z=0是，g(z)=0，g’(z)=1</li></ul><p>如果是ReLU函数，即$g(z)=max(0,z)$，则容易计算得到<br>$g’(z)=0, if z&lt;0$<br>$g’(z)=1, if z&gt;=0$<br>（其中z=0时可以在程序中设置导数为1，避免不可导问题）</p><h2 id="3-4-神经网络的梯度下降">3.4 神经网络的梯度下降</h2><p>对于一个神经网络，我们有以下参数：$w^{[1]}, b^{[1]}, w^{[2]}, b^{[2]}$</p><p>我们计算的损失函数：</p><p>$J(w^{[1]}, b^{[1]}, w^{[2]}, b^{[2]})=\frac{1}{m} \sum^n_{i=1}l(\hat y, y)$</p><p>梯度下降过程重复以下步骤：</p><ol><li>计算预测值$\hat y$</li><li>计算导数：$d(w^{[1]})=\frac{\partial J}{\partial w^{[1]}}$，$d(b^{[1]})=\frac{\partial J}{\partial b^{[1]}}$</li><li>更新参数：$w^{[1]}=w^{[1]}-\alpha \frac{\partial J}{\partial w^{[1]}}$，$b^{[1]}=b^{[1]}-\alpha \frac{\partial J}{\partial b^{[1]}}$</li></ol><p>向量化之后反向传播的计算方法如下：</p><p>$$dZ^{[2]}=A^{[2]}-Y$$<br>$$dW^{[2]}=\frac{1}{m}dZ^{[2]}A^{[1]T}$$<br>$$db^{[2]}=dZ^{[2]}$$<br>$$dZ^{[1]}=W^{[2]T}dZ^{[2]}*g^{[1]'}(Z^{[1]})$$<br>$$dW^{[1]}=\frac{1}{m}dZ^{[1]}X^T$$<br>$$db^{[1]}=dZ^{[1]}$$</p><h2 id="3-5-参数初始化">3.5 参数初始化</h2><p>对于神经网络的各层权重参数，我们都需要进行初始化，但是如果只是初始化为0，那么神经网络将完全无效，因此我们需要进行随机初始化。</p><p>可以令<br>W[1]=np.random.randn((2,2))*0.01<br>b[1]=np.zero((2,1))<br>W[1]=np.random.randn((1,2))*0.01<br>b[1]=0</p><p>乘0.01是因为我们比较喜欢让权重尽可能小，这样z也将会比较小，更容易落在激活函数斜率大的区域，让神经网络回归的更快。</p><h2 id="3-6-代码实现">3.6 代码实现</h2><p><strong>（1）安装包</strong></p><p>在实现神经网络过程中需要导入一些必要的包</p><ul><li>numpy：基础的科学计算包</li><li>sklearn：提供了数据挖掘和数据分析的简单有效的工具</li><li>matplotlib：画图工具</li></ul><p><strong>（2）神经网络</strong></p><p>建立神经网络的方法</p><ol><li><p>定义神经网络结构（输入单元数，隐藏单元数等）</p></li><li><p>初始化模型的参数</p></li><li><p>循环：</p><ul><li>实现前向传播</li><li>计算损失函数</li><li>后向传播获得梯度</li><li>梯度下降更新参数</li></ul></li><li><p>定义神经网络结构</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GRADED FUNCTION: layer_sizes</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">layer_sizes</span>(<span class="params">X, Y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入数据集，shape(input size, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 标签，shape(output size, number of examples)</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    n_x -- 输入层的大小</span></span><br><span class="line"><span class="string">    n_h -- 隐藏层的大小</span></span><br><span class="line"><span class="string">    n_y -- 输出层的大小</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    n_x = X.shape[<span class="number">0</span>]</span><br><span class="line">    n_h = <span class="number">4</span></span><br><span class="line">    n_y = Y.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n_x, n_h, n_y)</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化模型参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_parameters</span>(<span class="params">n_x, n_h, n_y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    n_x -- 输入层的大小</span></span><br><span class="line"><span class="string">    n_h -- 隐藏层的大小</span></span><br><span class="line"><span class="string">    n_y -- 输出层的大小</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    params -- python字典包含以下参数:</span></span><br><span class="line"><span class="string">W1 -- 权重矩阵，shape (n_h, n_x)</span></span><br><span class="line"><span class="string">b1 -- 偏置向量，shape (n_h, 1)</span></span><br><span class="line"><span class="string">W2 -- 权重矩阵，shape (n_y, n_h)</span></span><br><span class="line"><span class="string">b2 -- 偏置向量，shape (n_y, 1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    np.random.seed(<span class="number">2</span>) </span><br><span class="line">    W1 = np.random.randn(n_h, n_x)</span><br><span class="line">    b1 = np.zeros((n_h, <span class="number">1</span>))</span><br><span class="line">    W2 = np.random.randn(n_y, n_h)</span><br><span class="line">    b2 = np.zeros((n_y, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> (W1.shape == (n_h, n_x))</span><br><span class="line">    <span class="keyword">assert</span> (b1.shape == (n_h, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">assert</span> (W2.shape == (n_y, n_h))</span><br><span class="line">    <span class="keyword">assert</span> (b2.shape == (n_y, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1,</span><br><span class="line">                  <span class="string">&quot;b1&quot;</span>: b1,</span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2,</span><br><span class="line">                  <span class="string">&quot;b2&quot;</span>: b2&#125;</span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><ol start="3"><li>前向传播计算</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward_propagation</span>(<span class="params">X, parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入数据，size (n_x, m)</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的字典 (上面初始化函数的输出)</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    A2 -- 第二次激活后的输出</span></span><br><span class="line"><span class="string">    cache -- 包含 &quot;Z1&quot;, &quot;A1&quot;, &quot;Z2&quot;, &quot;A2&quot; 的字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从字典 &quot;parameters&quot; 中获取各参数</span></span><br><span class="line">    W1 = parameters[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&quot;W2&quot;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&quot;b2&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播计算A2</span></span><br><span class="line">    Z1 = np.dot(W1, X) + b1</span><br><span class="line">    A1 = np.tanh(Z1)</span><br><span class="line">    Z2 = np.dot(W2, A1) + b2</span><br><span class="line">    A2 = np.tanh(Z2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(A2.shape == (<span class="number">1</span>, X.shape[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    cache = &#123;<span class="string">&quot;Z1&quot;</span>: Z1,</span><br><span class="line">             <span class="string">&quot;A1&quot;</span>: A1,</span><br><span class="line">             <span class="string">&quot;Z2&quot;</span>: Z2,</span><br><span class="line">             <span class="string">&quot;A2&quot;</span>: A2&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A2, cache</span><br></pre></td></tr></table></figure><ol start="4"><li>计算损失函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">A2, Y, parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A2 -- 第二次激活函数的输出，shape (1, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 真值向量，shape (1, number of examples)</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的字典</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    cost -- 损失函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    m = Y.shape[<span class="number">1</span>] <span class="comment"># 样本的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算损失函数</span></span><br><span class="line">    logprobs = np.multiply(np.log(A2), Y) + np.multiply((<span class="number">1</span> - Y), np.log(<span class="number">1</span> - A2))</span><br><span class="line">    cost = - np.<span class="built_in">sum</span>(logprobs) / m </span><br><span class="line">    cost = np.squeeze(cost)     <span class="comment"># 保证损失函数的维度是我们想要的，例如把[[6]]变成6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">isinstance</span>(cost, <span class="built_in">float</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><ol start="5"><li>反向传播</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward_propagation</span>(<span class="params">parameters, cache, X, Y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的字典</span></span><br><span class="line"><span class="string">    cache -- 包含 &quot;Z1&quot;, &quot;A1&quot;, &quot;Z2&quot;, &quot;A2&quot; 的字典</span></span><br><span class="line"><span class="string">    X -- 输入数据，shape (2, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 真值向量，shape (1, number of examples)</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    grads -- 包含所有参数的梯度值的字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从字典 &quot;parameters&quot; 中获取 W1, W2</span></span><br><span class="line">    W1 = parameters[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&quot;W2&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从字典 &quot;cache&quot; 中获取 A1, A2</span></span><br><span class="line">    A1 = cache[<span class="string">&quot;A1&quot;</span>]</span><br><span class="line">    A2 = cache[<span class="string">&quot;A2&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播: 计算 dW1, db1, dW2, db2.</span></span><br><span class="line">    dZ2 = A2 - Y</span><br><span class="line">    dW2 = <span class="number">1</span>/m * np.dot(dZ2, A2.T)</span><br><span class="line">    db2 = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ2, axis = <span class="number">1</span>, keepdims = <span class="literal">True</span>)</span><br><span class="line">    dZ1 = np.multiply(np.dot(W2.T, dZ2), (<span class="number">1</span> - np.power(A1, <span class="number">2</span>)))</span><br><span class="line">    dW1 = <span class="number">1</span>/m * np.dot(dZ1, X.T)</span><br><span class="line">    db1 = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ1, axis = <span class="number">1</span>, keepdims = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    grads = &#123;<span class="string">&quot;dW1&quot;</span>: dW1,</span><br><span class="line">             <span class="string">&quot;db1&quot;</span>: db1,</span><br><span class="line">             <span class="string">&quot;dW2&quot;</span>: dW2,</span><br><span class="line">             <span class="string">&quot;db2&quot;</span>: db2&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure><ol start="6"><li>更新参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters</span>(<span class="params">parameters, grads, learning_rate = <span class="number">1.2</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的字典</span></span><br><span class="line"><span class="string">    grads -- 包含所有梯度的字典</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有更新后的参数的字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从字典 &quot;parameters&quot; 中获取 W1, W2, b1, b2</span></span><br><span class="line">    W1 = parameters[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&quot;W2&quot;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&quot;b2&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从字典 &quot;grads&quot; 中获取梯度值 dW1, dW2, db1, db2</span></span><br><span class="line">    dW1 = grads[<span class="string">&quot;dW1&quot;</span>]</span><br><span class="line">    db1 = grads[<span class="string">&quot;db1&quot;</span>]</span><br><span class="line">    dW2 = grads[<span class="string">&quot;dW2&quot;</span>]</span><br><span class="line">    db2 = grads[<span class="string">&quot;db2&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新每个参数</span></span><br><span class="line">    W1 = W1 - learning_rate * dW1</span><br><span class="line">    b1 = b1 - learning_rate * db1</span><br><span class="line">    W2 = W2 - learning_rate * dW2</span><br><span class="line">    b2 = b2 - learning_rate * db2    </span><br><span class="line"></span><br><span class="line">    parameters = &#123;<span class="string">&quot;W1&quot;</span>: W1,</span><br><span class="line">                  <span class="string">&quot;b1&quot;</span>: b1,</span><br><span class="line">                  <span class="string">&quot;W2&quot;</span>: W2,</span><br><span class="line">                  <span class="string">&quot;b2&quot;</span>: b2&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><ol start="7"><li>函数整合</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nn_model</span>(<span class="params">X, Y, n_h, num_iterations = <span class="number">10000</span>, print_cost=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 数据集，shape (2, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 标签，shape (1, number of examples)</span></span><br><span class="line"><span class="string">    n_h -- 隐藏层的大小</span></span><br><span class="line"><span class="string">    num_iterations -- 梯度下降循环的迭代次数</span></span><br><span class="line"><span class="string">    print_cost -- True则每1000次迭代打印cost</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 模型学习到的参数，可以被用来预测</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    np.random.seed(<span class="number">3</span>)</span><br><span class="line">    n_x = layer_sizes(X, Y)[<span class="number">0</span>]</span><br><span class="line">    n_y = layer_sizes(X, Y)[<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化参数, 获取 W1, b1, W2, b2</span></span><br><span class="line">    <span class="comment"># Inputs: &quot;n_x, n_h, n_y&quot;. Outputs = &quot;W1, b1, W2, b2, parameters&quot;.</span></span><br><span class="line">    parameters = initialize_parameters(n_x, n_h, n_y)</span><br><span class="line">    W1 = parameters[<span class="string">&quot;W1&quot;</span>]</span><br><span class="line">    b1 = parameters[<span class="string">&quot;b1&quot;</span>]</span><br><span class="line">    W2 = parameters[<span class="string">&quot;W2&quot;</span>]</span><br><span class="line">    b2 = parameters[<span class="string">&quot;b2&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 梯度下降循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_iterations):</span><br><span class="line">        <span class="comment"># 前向计算</span></span><br><span class="line">        <span class="comment"># Inputs: &quot;X, parameters&quot;. Outputs: &quot;A2, cache&quot;.</span></span><br><span class="line">        A2, cache = forward_propagation(X, parameters)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 损失函数</span></span><br><span class="line">        <span class="comment"># Inputs: &quot;A2, Y, parameters&quot;. Outputs: &quot;cost&quot;.</span></span><br><span class="line">        cost = compute_cost(A2, Y, parameters)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        <span class="comment"># Inputs: &quot;parameters, cache, X, Y&quot;. Outputs: &quot;grads&quot;.</span></span><br><span class="line">        grads = backward_propagation(parameters, cache, X, Y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 梯度下降参数更新</span></span><br><span class="line">        <span class="comment"># Inputs: &quot;parameters, grads&quot;. Outputs: &quot;parameters&quot;.</span></span><br><span class="line">        parameters = update_parameters(parameters, grads)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每1000次迭代打印cost</span></span><br><span class="line">        <span class="keyword">if</span> print_cost <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;Cost after iteration %i: %f&quot;</span> %(i, cost))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><ol start="8"><li>预测</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">parameters, X</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含训练好的参数的字典</span></span><br><span class="line"><span class="string">    X -- 输入数据，size (n_x, m)</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    predictions -- 模型的预测结果向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算前向传播的概率，并按概率0.5为界限进行二分分类</span></span><br><span class="line">    A2, cache = forward_propagation(X, parameters)</span><br><span class="line">    predictions = np.<span class="built_in">round</span>(A2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> predictions</span><br></pre></td></tr></table></figure><h1>四、深层神经网络</h1><h2 id="4-1-前向传播">4.1 前向传播</h2><p><strong>（1）数学计算</strong><br>$$z^{[1]}=W^{[1]}x+b^{[1]}$$<br>$$a^{[1]}=g(z^{[1]})$$<br>$$z^{[2]}=W^{[2]}a^{[1]}+b^{[2]}$$<br>$$a^{[2]}=g(z^{[2]})$$<br>$$\cdots$$<br>$$z^{[l]}=W^{[l]}a^{[l-1]}+b^{[l]}$$<br>$$a^{[l]}=g(z^{[l]})$$</p><p><strong>（2）向量化</strong></p><p>$$Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}$$<br>$$A^{[l]}=g(Z^{[l]})$$</p><h2 id="4-2-核对矩阵维数">4.2 核对矩阵维数</h2><p><strong>（1）推导过程</strong></p><p>对于计算过程：<br>$$Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}$$<br>由于$Z^{[l]}$的行数等于每一层神经元单元数$n^{l}$，列数等于样本数$m$，因此其中的$Z^{[l]}$的维数为$(n^{[l]}, m)$。<br>$A^{[l-1]}$是由$Z^{[l-1]}$经过激活函数计算而得，因此维数与$Z^{[l-1]}$相同为$(n^{[l-1]},1)$。</p><p>根据矩阵计算的规则，可以知道$W^{[l]}$的维数为$(n^{[l]}, n^{[l-1]})$，$b$的维数应该与$Z^{[l]}$相同$(n^{[l]}, m)$，但是由于python的广播规则，因此程序中$b$的维数通常是$(n^{[l]}, 1)$</p><p><strong>（2）维数总结</strong></p><p>$$W^{[l]}:(n^{[l]}, n^{[l-1]})$$<br>$$b^{[l]}:(n^{[l]}, 1)$$<br>$$dW^{[l]}:(n^{[l]}, n^{[l-1]})$$<br>$$db^{[l]}:(n^{[l]}, 1)$$</p><h2 id="4-3-参数和超参数">4.3 参数和超参数</h2><p>深度学习中我们用到的参数有：</p><ul><li>权值：$W^{[l]}$</li><li>偏置：$b^{[b]}$</li></ul><p>超参数包括：</p><ul><li>学习率：$\alpha$</li><li>迭代次数</li><li>隐藏层层数：L</li><li>隐藏层单元数：$n^{[l]}$</li><li>激活函数的选择</li></ul><p>所有的超参数都可以一定程度上决定最终得到的参数W和b。我们可以通过设定不同的超参数通过观察成本函数变化来判断当前超参数是否是最合适的，通常情况下超参数需要不断尝试检验才能找到对于当前问题最好的一个值。</p><h2 id="4-4-关键步骤编程实现">4.4 关键步骤编程实现</h2><p><strong>（1）初始化参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_parameters_deep</span>(<span class="params">layer_dims</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    layer_dims -- 包含每一层维度的列表</span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含 &quot;W1&quot;, &quot;b1&quot;, ..., &quot;WL&quot;, &quot;bL&quot; 的字典</span></span><br><span class="line"><span class="string">       Wl -- 权值矩阵，shape (layer_dims[l], layer_dims[l-1])</span></span><br><span class="line"><span class="string">       bl -- 偏置向量，shape (layer_dims[l], 1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    np.random.seed(<span class="number">3</span>)</span><br><span class="line">    parameters = &#123;&#125;</span><br><span class="line">    L = <span class="built_in">len</span>(layer_dims)            <span class="comment"># 神经网络的层数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">        parameters[<span class="string">&quot;W&quot;</span> + <span class="built_in">str</span>(l)] = np.random.randn(layer_dims[l], layer_dims[l - <span class="number">1</span>]) * <span class="number">0.01</span></span><br><span class="line">        parameters[<span class="string">&quot;b&quot;</span> + <span class="built_in">str</span>(l)] = np.zeros((layer_dims[l], <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">assert</span>(parameters[<span class="string">&#x27;W&#x27;</span> + <span class="built_in">str</span>(l)].shape == (layer_dims[l], layer_dims[l-<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">assert</span>(parameters[<span class="string">&#x27;b&#x27;</span> + <span class="built_in">str</span>(l)].shape == (layer_dims[l], <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><p><strong>（2）前向传播线性激活模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_activation_forward</span>(<span class="params">A_prev, W, b, activation</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    A_prev -- 上一层激活后的结果 (或输入数据)，shape(上一层单元数, 样本数)</span></span><br><span class="line"><span class="string">    W -- 权值矩阵，shape (当前层单元数, 上一层单元数)</span></span><br><span class="line"><span class="string">    b -- 偏置向量，shape (当前层单元数, 1)</span></span><br><span class="line"><span class="string">    activation -- 本层使用的激活函数, 字符串格式: &quot;sigmoid&quot; or &quot;relu&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    A -- 激活函数后的输出</span></span><br><span class="line"><span class="string">    cache -- 包含 &quot;linear_cache&quot; and &quot;activation_cache&quot; 的字典，便于反向传播的计算</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> activation == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        <span class="comment"># Inputs: &quot;A_prev, W, b&quot;. Outputs: &quot;A, activation_cache&quot;.</span></span><br><span class="line">        <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">        Z = np.dot(W, A_prev) + b</span><br><span class="line">        A, activation_cache = sigmoid(Z)</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="keyword">elif</span> activation == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        <span class="comment"># Inputs: &quot;A_prev, W, b&quot;. Outputs: &quot;A, activation_cache&quot;.</span></span><br><span class="line">        <span class="comment">### START CODE HERE ### (≈ 2 lines of code)</span></span><br><span class="line">        Z = np.dot(W, A_prev) + b</span><br><span class="line">        A, activation_cache = relu(Z)</span><br><span class="line">        <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    <span class="keyword">assert</span> (A.shape == (W.shape[<span class="number">0</span>], A_prev.shape[<span class="number">1</span>]))</span><br><span class="line">    cache = (linear_cache, activation_cache)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A, cache</span><br></pre></td></tr></table></figure><p><strong>（3）L层神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">L_model_forward</span>(<span class="params">X, parameters</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    X -- 输入数据，shape (input size, number of examples)</span></span><br><span class="line"><span class="string">    parameters -- 初始化参数，initialize_parameters_deep()的输出</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    AL -- 激活函数的输出</span></span><br><span class="line"><span class="string">    caches -- 包括</span></span><br><span class="line"><span class="string">                每层linear_relu_forward()的cache (一共L-1个, 索引从0到L-2)</span></span><br><span class="line"><span class="string">                linear_sigmoid_forward()的cache (只有一个, 索引为L-1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    caches = []</span><br><span class="line">    A = X</span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span>                  <span class="comment"># 神经网络的层数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实现 [LINEAR -&gt; RELU]*(L-1). 添加 &quot;cache&quot; 到 &quot;caches&quot; 列表.</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, L):</span><br><span class="line">        A_prev = A</span><br><span class="line">        A, cache = linear_activation_forward(A_prev, parameters[<span class="string">&quot;W&quot;</span> + <span class="built_in">str</span>(l)], parameters[<span class="string">&quot;b&quot;</span> + <span class="built_in">str</span>(l)], <span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        caches.append(cache)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 实现 LINEAR -&gt; SIGMOID. 添加 &quot;cache&quot; 到 &quot;caches&quot; 列表.</span></span><br><span class="line">    AL, cache = linear_activation_forward(A, parameters[<span class="string">&quot;W&quot;</span> + <span class="built_in">str</span>(L)], parameters[<span class="string">&quot;b&quot;</span> + <span class="built_in">str</span>(L)], <span class="string">&quot;sigmoid&quot;</span>)</span><br><span class="line">    caches.append(cache)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(AL.shape == (<span class="number">1</span>,X.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> AL, caches</span><br></pre></td></tr></table></figure><p><strong>（4）成本函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">AL, Y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    AL -- 与输入的标签匹配的预测值向量, shape(1, number of examples)</span></span><br><span class="line"><span class="string">    Y -- 真值标签向量 (例如: 不是猫为0，猫为1), shape (1, number of examples)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    cost -- 成本函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    m = Y.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据al, y计算成本函数</span></span><br><span class="line">    cost = -<span class="number">1</span> / m * np.<span class="built_in">sum</span>(Y * np.log(AL) + (<span class="number">1</span>-Y) * np.log(<span class="number">1</span>-AL),axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    cost = np.squeeze(cost)      <span class="comment"># 保证成本函数的向量是我们想要的，例如[[17]]变成17</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(cost.shape == ())</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><p><strong>（5）线性部分反向传播</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_backward</span>(<span class="params">dZ, cache</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    dZ -- 第L层的线性输出的梯度</span></span><br><span class="line"><span class="string">    cache -- (A_prev, W, b)组成的元组，来自当前层的前向传播</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    dA_prev -- 上一层激活函数后的梯度</span></span><br><span class="line"><span class="string">    dW -- W的梯度</span></span><br><span class="line"><span class="string">    db -- b的梯度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    A_prev, W, b = cache</span><br><span class="line">    m = A_prev.shape[<span class="number">1</span>]</span><br><span class="line">    dW = <span class="number">1</span>/m * np.dot(dZ, A_prev.T)</span><br><span class="line">    db = <span class="number">1</span>/m * np.<span class="built_in">sum</span>(dZ,axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    dA_prev = np.dot(W.T, dZ)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> (dA_prev.shape == A_prev.shape)</span><br><span class="line">    <span class="keyword">assert</span> (dW.shape == W.shape)</span><br><span class="line">    <span class="keyword">assert</span> (db.shape == b.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dA_prev, dW, db</span><br></pre></td></tr></table></figure><p><strong>（6）线性激活部分反向传播</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_activation_backward</span>(<span class="params">dA, cache, activation</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    dA -- 当前层激活后的梯度</span></span><br><span class="line"><span class="string">    cache -- (linear_cache, activation_cache)组成的元组，为了反向传播计算更快</span></span><br><span class="line"><span class="string">    activation -- 当前层所用的激活函数, 以字符串格式存储: &quot;sigmoid&quot; or &quot;relu&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    dA_prev -- 上一层激活后的梯度</span></span><br><span class="line"><span class="string">    dW -- W的梯度</span></span><br><span class="line"><span class="string">    db -- b的梯度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    linear_cache, activation_cache = cache</span><br><span class="line">    <span class="keyword">if</span> activation == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        dZ = relu_backward(dA, activation_cache)</span><br><span class="line">        dA_prev, dW, db = linear_backward(dZ, linear_cache)</span><br><span class="line">    <span class="keyword">elif</span> activation == <span class="string">&quot;sigmoid&quot;</span>:</span><br><span class="line">        dZ = sigmoid_backward(dA, activation_cache)</span><br><span class="line">        dA_prev, dW, db = linear_backward(dZ, linear_cache)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dA_prev, dW, db</span><br></pre></td></tr></table></figure><p><strong>（7）线性模型反向传播</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">L_model_backward</span>(<span class="params">AL, Y, caches</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    AL -- 概率向量, 前向传播的输出(L_model_forward())</span></span><br><span class="line"><span class="string">    Y -- 数据集真值向量</span></span><br><span class="line"><span class="string">    caches -- 列表包括</span></span><br><span class="line"><span class="string">linear_activation_forward() 函数的cache (是caches[l], for l in range(L-1) i.e l = 0...L-2)</span></span><br><span class="line"><span class="string">linear_activation_forward() 函数的cache (是caches[L-1])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    grads -- 梯度的字典</span></span><br><span class="line"><span class="string">grads[&quot;dA&quot; + str(l)] = ...</span></span><br><span class="line"><span class="string">grads[&quot;dW&quot; + str(l)] = ...</span></span><br><span class="line"><span class="string">grads[&quot;db&quot; + str(l)] = ...</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    grads = &#123;&#125;</span><br><span class="line">    L = <span class="built_in">len</span>(caches) <span class="comment"># 层数</span></span><br><span class="line">    m = AL.shape[<span class="number">1</span>]</span><br><span class="line">    Y = Y.reshape(AL.shape) <span class="comment"># 此行后，Y与YL相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化反向传播</span></span><br><span class="line">    dAL = - (np.divide(Y, AL) - np.divide(<span class="number">1</span> - Y, <span class="number">1</span> - AL))</span><br><span class="line">    <span class="comment"># 第L层梯度 (SIGMOID -&gt; LINEAR). 输入: &quot;AL, Y, caches&quot;. 输出: &quot;grads[&quot;dAL&quot;], grads[&quot;dWL&quot;], grads[&quot;dbL&quot;]</span></span><br><span class="line">    current_cache = caches[L-<span class="number">1</span>]</span><br><span class="line">    grads[<span class="string">&quot;dA&quot;</span> + <span class="built_in">str</span>(L)], grads[<span class="string">&quot;dW&quot;</span> + <span class="built_in">str</span>(L)], grads[<span class="string">&quot;db&quot;</span> + <span class="built_in">str</span>(L)] = linear_activation_backward(dAL, current_cache, activation = <span class="string">&quot;sigmoid&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(L - <span class="number">1</span>)):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># l层梯度 (RELU -&gt; LINEAR)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入: &quot;grads[&quot;dA&quot; + str(l + 2)], caches&quot;. 输出: &quot;grads[&quot;dA&quot; + str(l + 1)] , grads[&quot;dW&quot; + str(l + 1)] , grads[&quot;db&quot; + str(l + 1)]</span></span><br><span class="line">        current_cache = caches[l]</span><br><span class="line">        dA_prev_temp, dW_temp, db_temp = linear_activation_backward(grads[<span class="string">&quot;dA&quot;</span> + <span class="built_in">str</span>(l+<span class="number">2</span>)], current_cache, activation = <span class="string">&quot;relu&quot;</span>)</span><br><span class="line">        grads[<span class="string">&quot;dA&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] = dA_prev_temp</span><br><span class="line">        grads[<span class="string">&quot;dW&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] = dW_temp</span><br><span class="line">        grads[<span class="string">&quot;db&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] = db_temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure><p><strong>（8）参数更新</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters</span>(<span class="params">parameters, grads, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有参数的python字典</span></span><br><span class="line"><span class="string">    grads -- 包含所有梯度的字典, L_model_backward 函数的输出</span></span><br><span class="line"><span class="string">    learning_rate -- 学习率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值:</span></span><br><span class="line"><span class="string">    parameters -- 包含所有更新后参数的字典</span></span><br><span class="line"><span class="string">parameters[&quot;W&quot; + str(l)] = parameters[&quot;W&quot; + str(l)] - learning_rate * grads[&quot;dW&quot; + str(l + 1)]</span></span><br><span class="line"><span class="string">parameters[&quot;b&quot; + str(l)] = parameters[&quot;b&quot; + str(l)] - learning_rate * grads[&quot;db&quot; + str(l + 1)] </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span> <span class="comment"># 神经网络的层数</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数更新</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        parameters[<span class="string">&quot;W&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] -= learning_rate * grads[<span class="string">&quot;dW&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)]</span><br><span class="line">        parameters[<span class="string">&quot;b&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)] -= learning_rate * grads[<span class="string">&quot;db&quot;</span> + <span class="built_in">str</span>(l + <span class="number">1</span>)]    </span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解卷积神经网络中的通道channel</title>
      <link href="/post/e8acb40e.html"/>
      <url>/post/e8acb40e.html</url>
      
        <content type="html"><![CDATA[<h1>深度学习常说的train、test、eval都代表什么</h1><ol><li><p>Train：模型训练是指使用训练数据对模型进行调整，使其可以从数据中学到有价值的模式。在训练过程中，模型接收输入数据，计算它的预测，并与真实数据进行比较，以评估其准确性。然后，根据其误差，通过一个优化算法更新模型的参数，以提高其准确性。这个过程会不断重复，直到训练数据上的误差达到一个可接受的阈值为止。</p></li><li><p>Test：测试是指使用独立的数据集评估模型的准确性。这些数据是模型在训练中没有见过的，因此用于评估模型的泛化能力。测试数据的输入被用来生成预测，并与真实数据进行比较，以评估模型的准确性。</p></li><li><p>Eval：Evaluation（评估）类似于测试，但可能有所不同。评估可能更加细致，并且可以涵盖更多的评估指标，如精确度、召回率、F1 分数等。评估过程用于评估模型的性能。</p></li></ol><h1>为什么要使用dataloader</h1><p>参考程序如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataloader = torch.utils.data.DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>, num_workers=opt.workers)</span><br></pre></td></tr></table></figure><p>使用dataloader创建数据加载器（数据集对象、每次读取数据的数量、是否对数据进行随机打乱、读取数据时使用的线程数）。</p><p>可以将数据分成小批次、方便模型的训练，并且减少内存占用，方便多线程并行处理。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何理解卷积神经网络中的通道channel</title>
      <link href="/post/e8acb40e.html"/>
      <url>/post/e8acb40e.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是通道channel">什么是通道channel</h2><blockquote><p><a href="https://blog.csdn.net/sscc_learning/article/details/79814146">【CNN】理解卷积神经网络中的通道 channel</a></p></blockquote><p>首先，是 <a href="https://www.tensorflow.org/tutorials/layers">tensorflow</a> 中给出的，对于输入样本中 <code>channels</code> 的含义。一般的RGB图片，<code>channels</code> 数量是 3 （红、绿、蓝）；而monochrome图片，<code>channels</code> 数量是 1 。</p><p>其次，<a href="http://mxnet.incubator.apache.org/api/python/gluon/nn.html#mxnet.gluon.nn.Conv2D">mxnet</a> 中提到的，一般 <code>channels</code> 的含义是，<strong>每个卷积层中卷积核的数量</strong>。</p><p>举例：假设现有一个为 6×6×3 的图片样本，使用 3×3×3 的卷积核（filter）进行卷积操作。此时输入图片的 channels 为 3 ，而卷积核中的 in_channels 与 需要进行卷积操作的数据的 channels 一致（这里就是图片样本，为3）。</p><p>接下来，进行卷积操作，卷积核中的27个数字与分别与样本对应相乘后，再进行求和，得到第一个结果。依次进行，最终得到 4×4 的结果。</p><p><img src="https://img.mahaofei.com/img/20220624185902.png" alt=""></p><p>上面步骤完成后，由于只有一个卷积核，所以最终得到的结果为 4×4×1 ， out_channels 为 1 。</p><p>在实际应用中，都会使用多个卷积核。这里如果再加一个卷积核，就会得到 4×4×2 的结果。</p><p><img src="https://img.mahaofei.com/img/20220624185923.png" alt=""></p><p><strong>总结</strong></p><ul><li>最初输入的图片样本的 <code>channels</code> ，取决于图片类型，比如RGB；</li><li>卷积操作完成后输出的 <code>out_channels</code> ，取决于卷积核的数量。此时的 <code>out_channels</code> 也会作为下一次卷积时的卷积核的 <code>in_channels</code>；</li><li>卷积核中的 <code>in_channels</code> ，就是上一次卷积的 <code>out_channels</code> ，如果是第一次做卷积，就是1中样本图片的 <code>channels</code> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积是如何计算的</title>
      <link href="/post/9c39ef87.html"/>
      <url>/post/9c39ef87.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是多卷积核">1 什么是多卷积核</h2><h3 id="1-1-卷积">1.1 卷积</h3><p>从本质上讲，卷积的计算过程其实同全连接一样，也是各个神经元之间的线性组合。只是卷积操作在进行线性组合时选择的是特定位置上的神经元。下面我们首先通过一张动图来直观感受一下卷积的过程。</p><p><img src="https://pic2.zhimg.com/v2-5efbada1d4bb599e6195ce819aa7ebd9_b.webp" alt=""></p><p>如图所示，**卷积操作其实就是每次取一个特定大小的矩阵F（蓝色矩阵中的阴影部分），然后将其对输入X（图中蓝色矩阵）依次扫描并进行内积的运算过程。可以看到，阴影部分每移动一个位置就会计算得到一个卷积值（绿色矩阵中的阴影部分），当F扫描完成后就得到了整个卷积后的结果Y（绿色矩阵）。</p><p>同时，我们将这个特定大小的矩阵F称为<strong>卷积核</strong>，即convolutional kernel或kernel或filter或detector，它可以是一个也可以是多个；将卷积后的结果Y称为<strong>特征图</strong>，即feature map，并且每一个卷积核卷积后都会得到一个对应的特征图；最后，对于输入X)的形状，都会用三个维度来进行表示，即宽（width），高（high）和通道（channel）。例如图中输入X的形状为<code>[7,7,1]</code>。</p><h3 id="2-2-多卷积核"><strong>2.2 多卷积核</strong></h3><p>注意，在上面笔者提到了卷积核的个数还可以是多个，那我们为什么需要多个卷积核进行卷积呢？在<strong>上一篇文章</strong>中我们介绍到：<strong>对于一个卷积核，可以认为其具有识别某一类元素（特征）的能力</strong>；而对于一些复杂的数据来说，仅仅只是通过一类特征来进行辨识往往是不够的。因此，通常来说我们都会通过多个不同的卷积核来对输入进行特征提取得到多个特征图，然再输入到后续的网络中。</p><p><img src="https://vdn1.vzuu.com/SD/d64a45c6-ec4a-11ea-acfd-5ab503a75443.mp4?disable_local_cache=1&amp;bu=078babd7&amp;c=avc.0.0&amp;f=mp4&amp;expiration=1653035766&amp;auth_key=1653035766-0-0-efb78e5addfa03be68c1bf73f4a28bd9&amp;v=hw&amp;pu=078babd7" alt=""></p><p>对于同一个输入，通过两个不同的卷积核对其进行卷积特征提取，最后便能得到两个不同的特征图。从图右边的特征图可以发现，上面的特征图在锐利度方面明显会强于下面的特征图。当然，这也是使用多卷积核进行卷积的意义，探测到多种特征属性以有利于后续的下游任务。</p><h2 id="3-卷积的计算"><strong>3 卷积的计算</strong></h2><p>到此为止， 对于卷积的原理和意义就算是交待完了，并且通过这些动态图片的展示，我们也有了更为直观的了解。但所谓数无形时少直觉，形少数时难入微。因此，下面我们就以单通道（灰度图）和三通道的输入来实际计算一下整个卷积的过程。</p><h3 id="3-1-单通道单卷积核"><strong>3.1 单通道单卷积核</strong></h3><p>如下图所示，现在有一张形状为<code>[5,5,1]</code>的灰度图，我们需要用图3右边的卷积核对其进行卷积处理，同时再考虑到偏置的作用。那么其计算过程是怎么样的呢？</p><p><img src="https://pic3.zhimg.com/80/v2-41ea774397ab503144f2e410e3b91846_720w.jpg" alt=""></p><p>如下图所示，右边为卷积后的特征图（feature map），左边为卷积核对输入图片左上放进行卷积时的示意图。因此，对于这个部分的计算过程有：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cunderbrace%7B1%5Ccdot0%2B2%5Ccdot0%2B0%5Ccdot1-1%5Ccdot0%2B1%5Ccdot1%2B0%5Ccdot1%2B2%5Ccdot1-1%5Ccdot0-2%5Ccdot1%7D_%7Bkernel%7D%5Cunderbrace%7B%5C%3B%5C%3B%2B1%5C%3B%5C%3B%7D_%7Bbias%7D%3D2%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%281%29+%5C%5C" alt=""></p><p><img src="https://pic1.zhimg.com/80/v2-f3cbc9092253d32f9faef27431094794_720w.jpg" alt=""></p><p>同理，对于最右下角部分卷积计算过程有：</p><p><img src="https://www.zhihu.com/equation?tex=2%5Ccdot0%2B1%5Ccdot0%2B0%5Ccdot1%2B0%5Ccdot0%2B0%5Ccdot1%2B0%5Ccdot1-1%5Ccdot1%2B0%5Ccdot0-0%5Ccdot1%2B1%3D0%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%282%29+%5C%5C" alt=""></p><p><img src="https://pic4.zhimg.com/80/v2-34b0159c662de8c287e47afa4e05351b_720w.jpg" alt=""></p><p>因此，对于最后卷积的结果，我们得到的将是一个如上图右边所示形状为<code>[3,3,1]</code>的特征图。到此我们就把单通道单卷积的计算过程介绍完了。下面我们再来看单通道多卷积核的例子。</p><h3 id="3-2-单通道多卷积核"><strong>3.2 单通道多卷积核</strong></h3><p>如下图所示，左边依旧为输入矩阵，我们现在要用右边所示的两个卷积核对其进行卷积处理。</p><p><img src="https://pic1.zhimg.com/80/v2-28512602aa1cc0d5cbbd3728f1b71bd0_720w.jpg" alt=""></p><p>以右侧的卷积核为例，其计算过程如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-8d78e0ca38adc64c36aa4a8bb4c605b0_720w.jpg" alt=""></p><p>最后我们便能得到如下右边所示的，形状为<code>[3,3,2]</code>的卷积特征图，其中2表示两个特征通道。</p><p><img src="https://pic2.zhimg.com/80/v2-867e4addafd9d5146d7be731cd94a8d5_720w.jpg" alt=""></p><p>到此，对于单通道的卷积计算过程就介绍完了。但通常情况下，我们遇到得更多的就是对多通道的输入进行卷积处理，例如包含有RGB三个通道的彩色图片等。接下来，笔者就开始介绍多通道的卷积计算过程。</p><h3 id="3-3-多通道单卷积核"><strong>3.3 多通道单卷积核</strong></h3><p>对于多通道的卷积过程，总体上还是还是同之前的一样，都是每次选取特定位置上的神经元进行卷积，然后依次移动直到卷积结束。下面我们先来看看多通道单卷积核的计算过程。</p><p><img src="https://pic3.zhimg.com/80/v2-74b6e3cb4f6f1714e05325c068ece3e6_720w.jpg" alt=""></p><p>如图所示，左边为包含有三个通道的输入，右边为一个卷积核和一个偏置。<strong>注意，强调一下右边的仅仅只是一个卷积核，不是三个</strong>。笔者看到不少人在这个地方都会搞错。因为输入是三个通道，所以在进行卷积的时候，对应的每一个卷积核都必须要有三个通道才能进行卷积。下面我们就来看看具体的计算过程。</p><p><img src="https://pic1.zhimg.com/80/v2-b9b793a795f06aa1830a784ad82ccf14_720w.jpg" alt=""></p><p>如图所示，右边为卷积后的特征图（feature map），左边为一个三通道的卷积核对输入图片左上放进行卷积时的示意图。因此，对于这个部分的计算过程有：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%26%5Cunderbrace%7B%280%5Ccdot2%2B2%5Ccdot0%2B0%5Ccdot0%2B0%5Ccdot1%2B2%5Ccdot0%2B0%5Ccdot1%2B2%5Ccdot0%2B1%5Ccdot3%2B2%5Ccdot0%29%7D_%7Bchannel+%5C%3B1%7D%5C%5C+%2B%26+%5Cunderbrace%7B%280%5Ccdot1%2B0%5Ccdot0%2B0%5Ccdot1%2B1%5Ccdot0%2B0%5Ccdot0%2B0%5Ccdot0%2B1%5Ccdot1%2B0%5Ccdot1%2B0%5Ccdot1%29%7D_%7Bchannel%5C%3B2%7D%5C%5C+%2B%26+%5Cunderbrace%7B%281%5Ccdot0%2B1%5Ccdot0%2B0%5Ccdot1%2B0%5Ccdot1%2B1%5Ccdot1%2B0%5Ccdot1%2B0%5Ccdot1%2B1%5Ccdot1%2B1%5Ccdot0%29%7D_%7Bchannel+3%7D%5C%5C+%2B%26%5Cunderbrace%7B%5C%3B%5C%3B1%5C%3B%5C%3B%7D_%7B%5C%3B%5C%3Bbias%5C%3B%5C%3B%7D%5C%5C+%3D%263%2B1%2B2%2B1%3D7+%5Cend%7Baligned%7D%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%283%29+%5C%5C" alt=""></p><p>同理，对于其它部分的卷积计算过程也类似于上述计算步骤。由此我们便能得到如图10右边所示卷积后的形状为<code>[3,3,1]</code>的特征图。</p><h3 id="3-4-多通道多卷积核"><strong>3.4 多通道多卷积核</strong></h3><p>在介绍完多通道单卷积核的计算过程后，我们再来看看多通道多卷积核的计算过程。</p><p><img src="https://pic2.zhimg.com/80/v2-a49ca8fccf9423b68350a2948c58df69_720w.jpg" alt=""></p><p>如图所示，左边依旧为输入矩阵，我们现在要用右边所示的<strong>两个卷积核</strong>对其进行卷积处理。对于第二个卷积核，其计算过程也和式子(3)类似，都是将每个通道上的卷积结果进行相加，最后再加上偏置。因此，最后我们便能得到如图12右边所示的，形状为<code>[3,3,2]</code>的卷积特征图，其中2表示两个特征通道。</p><p><img src="https://pic2.zhimg.com/80/v2-1ba1b27de724a353656802d32d41c891_720w.jpg" alt=""></p><p>同时，从上面单通道卷积核多通道卷积的计算过程可以发现：</p><p>（1）原始输入有多少个通道，其对应的<strong>一个卷积核</strong>就必须要有多少个通道，这样才能与输入进行匹配，也才能完成卷积操作。换句话说，如果输入数据的形状为<code>[n,n,c]</code>，那么对应每个卷积核的通道数也必须为<code>c</code>。</p><p>（2）用<code>k</code>个卷积核对输入进行卷积处理，那么最后得到的特征图一定就会包含有<code>k</code>个通道。例如，输入为<code>[n,n,c]</code>，且用<code>k</code>个卷积核对其进行卷积，则卷积核的形状必定为<code>[w1,w2,c,k]</code>，最终得到的特征图形状必定为<code>[h1,h2,k]</code>；其中<code>w1,w2</code>为卷积核的宽度，<code>h1,h2</code>为卷积后特征图的宽度。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习环境配置Pytorch</title>
      <link href="/post/20d30e4e.html"/>
      <url>/post/20d30e4e.html</url>
      
        <content type="html"><![CDATA[<h1>Anaconda</h1><p>Anaconda是管理各个python包的工具，这里我们主要使用的是numpy，以及其他的一些常用包。</p><p>Anaconda官网链接：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p><p>各个系统版本的Anaconda安装程序都可以直接下载安装即可，相关使用方法可以参考<a href="https://www.mahaofei.com/post/8543c9d.html">该文章</a></p><h1>CUDA</h1><ol><li>首先<strong>查看自己电脑GPU对应的cuda版本</strong>，如图所示<strong>打开 NVIDIA控制面板-&gt;帮助-&gt;系统信息-&gt;组件</strong>（可在控制中心或右下角通知栏打开），我这里GPU对应的cuda版本是11.6.106，所以安装的cuda不能超过这个版本。</li></ol><p><img src="https://img.mahaofei.com/img/20220515111335.png" alt=""></p><p>或者在cmd命令行输入<code>nvidia-smi</code>也可以查看CUDA版本。</p><ol start="2"><li><strong>进入<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a>网站</strong>选择低于刚才查到的版本的cudatoolkit，本文选择CUDA Toolkit 11.0 Update 3，<strong>下载安装包</strong>约2.7G。</li></ol><blockquote><p>注意：这里选择的cuda版本会决定后面安装cudnn和tensorflow-gpu的版本，三者是相关的，如果版本不匹配将无法使用，具体匹配版本参考<a href="https://tensorflow.google.cn/install/source_windows">https://tensorflow.google.cn/install/source_windows</a>，下表为节选。</p></blockquote><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">Python 版本</th><th style="text-align:left">编译器</th><th style="text-align:left">构建工具</th><th style="text-align:left">cuDNN</th><th style="text-align:left">CUDA</th></tr></thead><tbody><tr><td style="text-align:left">tensorflow_gpu-2.6.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.5.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.4.0</td><td style="text-align:left">3.6-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">8.0</td><td style="text-align:left">11.0</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.3.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.2.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 2.0.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.1.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 0.27.1-0.29.1</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.0.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.15.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.14.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.24.1-0.25.2</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.13.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2015 update 3</td><td style="text-align:left">Bazel 0.19.0-0.21.0</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/20220515141105.png" alt=""></p><ol start="3"><li>双击下载的<strong>exe安装包</strong>，选择<strong>临时解压</strong>位置，然后点击ok，解压时间两分钟左右。</li></ol><p><img src="https://img.mahaofei.com/img/20220515140740.png" alt=""></p><ol start="4"><li><strong>同意许可协议</strong>，然后选择<strong>自定义安装</strong>选项，然后点击<strong>下一步</strong></li></ol><p><img src="https://img.mahaofei.com/img/20220515141240.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220515141310.png" alt=""></p><ol start="5"><li>选择驱动程序组件，一定要<strong>勾选CUDA</strong>，然后点击<strong>下一步</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141348.png" alt=""></p><ol start="6"><li>选择自己电脑上的一个安装位置，然后<strong>开始安装</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141701.png" alt=""></p><ol start="7"><li><p><strong>等待安装结束</strong>，本电脑18年笔记本机械硬盘安装<strong>耗时约5分钟</strong></p></li><li><p><strong>检查环境变量</strong>，一般安装完成后会自动配置好环境变量，打开<strong>设置-系统-系统信息-高级系统设置-环境变量</strong>进行检查，如果没有则需要自行添加（注意添加时修改成自己的安装路径）</p></li></ol><ul><li>系统变量中是否有<strong>CUDA</strong>和<strong>NVCUDASAMPLES</strong>两组环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142616.png" alt=""></p><ul><li>打开系统变量的Path，查看是否有以下环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142701.png" alt=""></p><ol start="9"><li>CUDA安装完成</li></ol><h1>Pytorch</h1><p><strong>（1）创建Pytorch环境</strong></p><p>使用anaconda创建一个pytorch的虚拟环境，主要是为了区分不同的项目，比如tensorflow和pytorch使用的各种包环境等都是不同的，新建一个环境可以处理项目之间不兼容的问题。</p><ol><li><p>打开<code>Anaconda Prompt</code></p></li><li><p>新建一个虚拟环境</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=3.8</span><br></pre></td></tr></table></figure><p>这里创建一个pytorch环境，语句中pytorch是环境名，叫什么都可以，python版本这里3.8和3.9都可以。</p><p>使用<code>conda info --envs</code>命令可以看到所有环境，使用<code>conda activate pytorch</code>可以激活刚才创建的pytorch环境。</p><p>前面从（base）变为（pytorch）时表示此时已经切换到pytorch环境。</p><p><img src="https://img.mahaofei.com/img/20220705182340.png" alt=""></p><p><strong>（2）安装pytorch</strong></p><p>进入PyTorch官网：<a href="https://pytorch.org/">https://pytorch.org/</a>，可以看到pytorch安装页面。</p><p>这里默认已经根据你的电脑情况选择了一部分信息，只需要选择CUDA版本即可，刚才查看了我的电脑cuda版本是11.6.106，所以这里选择CUDA 11.6。</p><p><img src="https://img.mahaofei.com/img/20220705182724.png" alt=""></p><p>这里提示了安装前电脑需要安装cudatoolkit，上一节我们已经安装了，所以直接在conda的pytorch环境中运行下面给出的安装代码即可。</p><p>进入虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></table></figure><p>安装pytorch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=11.6 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure><blockquote><p>如果下载报错，注意关掉自己的科学上网工具，然后到<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">清华大学镜像站</a>按步骤添加一下索引。<br>如果仍报错且自己能够科学上网，那么可以使用命令<code>conda config --remove-key channels</code>删除清华源，并删除<code>C:/用户/xxx/.condarc</code>文件，使用科学上网+默认源下载。</p></blockquote><h1>测试</h1><p>打开Anaconda Prompt命令行，进入pytorch环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate pytorch</span><br></pre></td></tr></table></figure><p>输入<code>python</code>，进入python交互界面</p><p>输入下面命令进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="built_in">print</span>(torch.__version__) <span class="comment"># pytorch版本</span></span><br><span class="line"><span class="built_in">print</span>(torch.version.cuda) <span class="comment"># cuda版本</span></span><br><span class="line"><span class="built_in">print</span>(torch.cuda.is_available()) <span class="comment"># 查看cuda是否可用</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220705205436.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习环境配置CUDA+TensorFlow2+Keras</title>
      <link href="/post/a858b698.html"/>
      <url>/post/a858b698.html</url>
      
        <content type="html"><![CDATA[<h1>Anaconda</h1><p>Anaconda是管理各个python包的工具，这里我们主要使用的是numpy，以及其他的一些常用包。</p><p>Anaconda官网链接：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p><p>各个系统版本的Anaconda安装程序都可以直接下载安装即可，相关使用方法可以参考<a href="https://www.mahaofei.com/post/8543c9d.html">该文章</a></p><h1>CUDA</h1><ol><li>首先<strong>查看自己电脑GPU对应的cuda版本</strong>，如图所示<strong>打开 NVIDIA控制面板-&gt;帮助-&gt;系统信息-&gt;组件</strong>（可在控制中心或右下角通知栏打开），我这里GPU对应的cuda版本是11.6.106，所以安装的cuda不能超过这个版本。</li></ol><p><img src="https://img.mahaofei.com/img/20220515111335.png" alt=""></p><p>或者在cmd命令行输入<code>nvidia-smi</code>也可以查看CUDA版本。</p><ol start="2"><li><strong>进入<a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA Toolkit Archive</a>网站</strong>选择低于刚才查到的版本的cudatoolkit，本文选择CUDA Toolkit 11.0 Update 3，<strong>下载安装包</strong>约2.7G。</li></ol><blockquote><p>注意：这里选择的cuda版本会决定后面安装cudnn和tensorflow-gpu的版本，三者是相关的，如果版本不匹配将无法使用，具体匹配版本参考<a href="https://tensorflow.google.cn/install/source_windows">https://tensorflow.google.cn/install/source_windows</a>，下表为节选。</p></blockquote><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">Python 版本</th><th style="text-align:left">编译器</th><th style="text-align:left">构建工具</th><th style="text-align:left">cuDNN</th><th style="text-align:left">CUDA</th></tr></thead><tbody><tr><td style="text-align:left">tensorflow_gpu-2.6.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.5.0</td><td style="text-align:left">3.6-3.9</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.7.2</td><td style="text-align:left">8.1</td><td style="text-align:left">11.2</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.4.0</td><td style="text-align:left">3.6-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">8.0</td><td style="text-align:left">11.0</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.3.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 3.1.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.2.0</td><td style="text-align:left">3.5-3.8</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 2.0.0</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.1.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2019</td><td style="text-align:left">Bazel 0.27.1-0.29.1</td><td style="text-align:left">7.6</td><td style="text-align:left">10.1</td></tr><tr><td style="text-align:left">tensorflow_gpu-2.0.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.15.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.26.1</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.14.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2017</td><td style="text-align:left">Bazel 0.24.1-0.25.2</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">tensorflow_gpu-1.13.0</td><td style="text-align:left">3.5-3.7</td><td style="text-align:left">MSVC 2015 update 3</td><td style="text-align:left">Bazel 0.19.0-0.21.0</td><td style="text-align:left">7.4</td><td style="text-align:left">10</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/20220515141105.png" alt=""></p><ol start="3"><li>双击下载的<strong>exe安装包</strong>，选择<strong>临时解压</strong>位置，然后点击ok，解压时间两分钟左右。</li></ol><p><img src="https://img.mahaofei.com/img/20220515140740.png" alt=""></p><ol start="4"><li><strong>同意许可协议</strong>，然后选择<strong>自定义安装</strong>选项，然后点击<strong>下一步</strong></li></ol><p><img src="https://img.mahaofei.com/img/20220515141240.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220515141310.png" alt=""></p><ol start="5"><li>选择驱动程序组件，一定要<strong>勾选CUDA</strong>，然后点击<strong>下一步</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141348.png" alt=""></p><ol start="6"><li>选择自己电脑上的一个安装位置，然后<strong>开始安装</strong>。</li></ol><p><img src="https://img.mahaofei.com/img/20220515141701.png" alt=""></p><ol start="7"><li><p><strong>等待安装结束</strong>，本电脑18年笔记本机械硬盘安装<strong>耗时约5分钟</strong></p></li><li><p><strong>检查环境变量</strong>，一般安装完成后会自动配置好环境变量，打开<strong>设置-系统-系统信息-高级系统设置-环境变量</strong>进行检查，如果没有则需要自行添加（注意添加时修改成自己的安装路径）</p></li></ol><ul><li>系统变量中是否有<strong>CUDA</strong>和<strong>NVCUDASAMPLES</strong>两组环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142616.png" alt=""></p><ul><li>打开系统变量的Path，查看是否有以下环境变量。</li></ul><p><img src="https://img.mahaofei.com/img/20220515142701.png" alt=""></p><ol start="9"><li>CUDA安装完成</li></ol><h1>cnDNN</h1><ol><li>打开<a href="https://developer.nvidia.com/rdp/cudnn-archive">cudnn官网</a>，根据上面的表格查看自己应该下载的cuDNN版本，我的CUDA版本为11.0，对应cuDNN版本为8.0，注意看清cuDNN后面有对应的CUDA版本，一个cuDNN可能对应多个版本的CUDA，下载时会要求先注册NVIDIA账号。</li></ol><p><img src="https://img.mahaofei.com/img/20220515140956.png" alt=""></p><ol start="2"><li>解压文件，将解压后的文件移动到CUDA对应的安装目录中</li></ol><p><img src="https://img.mahaofei.com/img/20220515143854.png" alt=""></p><ol start="3"><li>cuDNN安装完成</li></ol><h1>安装TensorFlow</h1><ol><li>打开cmd命令行界面（建议以管理员身份打开），切换opentuna的pip镜像源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://opentuna.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><ol start="2"><li>创建虚拟环境，后面跟的是电脑安装的python版本，注意是否与</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow2 python=3.8</span><br></pre></td></tr></table></figure><ol start="3"><li>激活虚拟环境</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate tensorflow2</span><br></pre></td></tr></table></figure><ol start="4"><li>安装tensorflow，具体版本号根据上面的表格对应。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow-gpu==2.3.0</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220515145711.png" alt=""></p><ol start="5"><li>验证安装是否成功，打开cmd界面，输入以下命令，查看输出是否Successfly</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220515154240.png" alt=""></p><p>如果出现<code>Could not load dynamic library 'cudart64_110.dll'</code>不要慌，说明安装完成之后没有重启电脑，重启再运行就好了。</p><h1>Keras</h1><ol><li>TensorFlow与Keras版本对应参考下表</li></ol><table><thead><tr><th>Tensorflow</th><th>Keras</th></tr></thead><tbody><tr><td>TensorFlow 2.0.0</td><td>Keras 2.3.1</td></tr><tr><td>TensorFlow 2.1.0</td><td>Keras 2.3.1</td></tr><tr><td>TensorFlow 2.2.0</td><td>Keras 2.3.1</td></tr><tr><td>TensorFlow 2.4.0</td><td>Keras 2.4.3</td></tr><tr><td>TensorFlow 2.6.0</td><td>Keras 2.6.0</td></tr></tbody></table><ol start="2"><li>运行仍然在Anaconda的<strong>tensorflow2环境中运行下面的指令</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras==2.4.3</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220515151729.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex基础</title>
      <link href="/post/f22aab63.html"/>
      <url>/post/f22aab63.html</url>
      
        <content type="html"><![CDATA[<h1>一、Latex文件结构</h1><h2 id="1-1-源文件基本结构">1.1 源文件基本结构</h2><p>一个Latex文档分为导言区和正文区。</p><p><strong>（1）导言区</strong></p><p>导言区主要进行全局设置。</p><ul><li>使用<code>\documentclass&#123;&#125;</code>引入文档类，如<code>book, article, report, letter</code>类等，不同的类的格式不同，例如book和letter有封面，letter类没有title等。</li><li>使用<code>\title&#123;&#125;</code>命令定义文档的标题</li><li>使用<code>\author&#123;&#125;</code>命令定义文档的作者</li><li>使用<code>\date&#123;&#125;</code>命令定义文档的创作时间</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125; <span class="comment">% book, report, letter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;My Latex Tutorial&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Haofei Ma&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125; <span class="comment">% \today指今天</span></span><br></pre></td></tr></table></figure><p><strong>（2）正文区</strong></p><p>正文区撰写文档的内容。</p><ul><li>使用<code>\begin&#123;&#125;</code>和<code>\end&#123;&#125;</code>输入一个环境，<code>&#123;&#125;</code>内是环境的名称，一个latex文件只能有一个ducument环境</li><li>使用<code>\maketitle</code>输出标题</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 正文区  </span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125; <span class="comment">% document为环境名称</span></span><br><span class="line"><span class="keyword">\maketitile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 内容(可以直接输入，空行代表段落)</span></span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">Let <span class="built_in">$</span>F(x)<span class="built_in">$</span> be defined by formula <span class="built_in">$</span><span class="built_in">$</span>f(x)=3x<span class="built_in">^</span>2-x+1<span class="built_in">$</span><span class="built_in">$</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-中文处理方法">1.2 中文处理方法</h2><p>保证文档的编码为<code>UTF-8</code>格式，在导言区使用<code>\usepackage&#123;ctex&#125;</code>命令引入ctex宏包。</p><p>撰写中文时可以使用<code>\heiti</code>, <code>\kaishu</code>等命令指定字体为黑体、楷书等等。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%导言区  </span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\heiti</span> Latex基础&#125;<span class="comment">%指定黑体字体  </span></span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\kaishu</span> 马浩飞&#125;<span class="comment">%指定楷书字体  </span></span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;<span class="comment">%显示中文需要添加该指令</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-字体字号设置">1.3 字体字号设置</h2><p>字体字号的设置都是在正文区进行设置（因为字体设置仅针对某一段文字）。</p><p><strong>（1）字体族设置</strong></p><p>使用<code>\textrm, \textsf, \textttt</code>设置字体族。</p><p>或使用<code>\rmfamily Roman Family</code>声明后续的字体为罗马字体。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">%字体族设置(罗马字体、无衬线字体、打字机字体)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%\textrm等是字体命令，大括号里是作用到的文字</span></span><br><span class="line"><span class="keyword">\textrm</span>&#123;Roman Family&#125;</span><br><span class="line"><span class="keyword">\textsf</span>&#123;Scan Serif Family&#125;</span><br><span class="line"><span class="keyword">\texttt</span>&#123;Typewriter Family&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%\rmfamily是字体声明，后面紧跟的文字是作用到的文字</span></span><br><span class="line">&#123;<span class="keyword">\rmfamily</span> Roman Family&#125;</span><br><span class="line">&#123;<span class="keyword">\sffamily</span> Scan Serif Family&#125;</span><br><span class="line">&#123;<span class="keyword">\ttfamily</span> Typewriter Family&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>括号可以限定字体声明的限定范围。</p><ul><li>如果加括号，代表设置括号内的字体为指定字体；</li><li>如果无括号，代表后续所有段落字体为指定字体。</li></ul><p>遇到另一个字体声明时，会结束当前字体声明，并启用新的字体声明。</p><p><strong>（2）字体系列（粗细、宽度）</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%字体系列设置(粗细、宽度)</span></span><br><span class="line"><span class="keyword">\textmd</span>&#123;Medium Series&#125;<span class="comment">%\设置字体宽度，大括号里是作用到的文字</span></span><br><span class="line"><span class="keyword">\textbf</span>&#123;Boldface Series&#125;<span class="comment">% \textbf可以对字体加粗</span></span><br><span class="line">&#123;<span class="keyword">\mdseries</span> Medium Series&#125;<span class="comment">%\设置字体宽度，大括号里是作用到的文字</span></span><br><span class="line">&#123;<span class="keyword">\bfseries</span> Boldface Series&#125;<span class="comment">%字体声明</span></span><br></pre></td></tr></table></figure><p><strong>（3）字体形状（直立、斜体、伪斜体、小型大写）</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%字体形状(直立、斜体、伪斜体、小型大写)</span></span><br><span class="line"><span class="keyword">\textup</span>&#123;Upright Shape&#125; <span class="keyword">\textit</span>&#123;Italic Shape&#125; <span class="comment">%字体命令</span></span><br><span class="line"><span class="keyword">\textsl</span>&#123;Slanted Shape&#125; <span class="keyword">\textsc</span>&#123;Small Caps Shape&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\upshape</span> Upright Shape&#125; &#123;<span class="keyword">\itshape</span> Italic Shape &#125;<span class="comment">%字体声明</span></span><br><span class="line">&#123;<span class="keyword">\slshape</span> Slanted Shape&#125;</span><br><span class="line">&#123;<span class="keyword">\scshape</span> Small Caps Shape&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）中文字体设置</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">\songti</span> 宋体&#125; <span class="keyword">\quad</span>&#123;heiti 黑体&#125;<span class="keyword">\quad</span>&#123;<span class="keyword">\fangsong</span> 仿宋&#125;<span class="keyword">\quad</span> &#123;<span class="keyword">\kaishu</span> 楷书&#125;<span class="comment">%\quad表示空格</span></span><br><span class="line">中文字体的<span class="keyword">\textbf</span>&#123;粗体表现为黑体&#125;与<span class="keyword">\textit</span>&#123;斜体表现为楷体&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）字体大小</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">\tiny</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\scriptsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\footnotesize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\small</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\normalsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\Large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\LARGE</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\huge</span>  Hello &#125;<span class="keyword">\\</span> </span><br></pre></td></tr></table></figure><h2 id="1-4-文档基本结构">1.4 文档基本结构</h2><p>Latex使用<code>\section&#123;&#125;, \subsection&#123;&#125;, \subsubsection&#123;&#125;</code>等命令构建文章的提纲。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span> <span class="comment">%使得导言区的设置生效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;引言&#125; <span class="comment">% 1 引言</span></span><br><span class="line"></span><br><span class="line">引言的内容第一段。</span><br><span class="line"></span><br><span class="line">使用空行来实现分段，这里是引言内容的第二段。</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;实验方法&#125; <span class="comment">% 2 实验方法</span></span><br><span class="line"><span class="keyword">\section</span>&#123;实验过程&#125; <span class="comment">% 3 实验过程</span></span><br><span class="line"><span class="keyword">\subsection</span>&#123;实验过程1&#125; <span class="comment">% 3.1 实验过程1</span></span><br><span class="line"><span class="keyword">\subsection</span>&#123;实验过程2&#125; <span class="comment">% 3.2 实验过程2</span></span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;实验数据&#125; <span class="comment">% 3.2.1 实验数据</span></span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;实验图表&#125; <span class="comment">% 3.2.2 实验图表</span></span><br><span class="line"><span class="keyword">\subsection</span>&#123;结果分析&#125;  <span class="comment">% 3.3 结果分析</span></span><br><span class="line"><span class="keyword">\section</span>&#123;结论&#125; <span class="comment">% 4 结论</span></span><br><span class="line"><span class="keyword">\section</span>&#123;致谢&#125; <span class="comment">% 5 致谢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h1>二、Latex中的特殊字符</h1><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\section</span>&#123;空白符号&#125;</span><br><span class="line"><span class="comment">% 空行分段，多个空行等同1个</span></span><br><span class="line"><span class="comment">% 自动缩进，绝对不能使用空格代替</span></span><br><span class="line"><span class="comment">% 英文中多个空格处理为1个空格，中文中空格将被忽略</span></span><br><span class="line"><span class="comment">% 汉字与其它字符的间距会自动被处理</span></span><br><span class="line"><span class="comment">% 禁止使用中文全角空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 1em（当前字体中M的宽度）</span></span><br><span class="line">a<span class="keyword">\quad</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 2em</span></span><br><span class="line">a<span class="keyword">\qquad</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 1/6em</span></span><br><span class="line">a<span class="keyword">\,</span>b a<span class="keyword">\thinspace</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 0.5em</span></span><br><span class="line">a<span class="keyword">\enspace</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 空格</span></span><br><span class="line">a<span class="keyword">\ </span>b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 硬空格（不能分割的空格）</span></span><br><span class="line">a~b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 指定宽度的空格</span></span><br><span class="line">a<span class="keyword">\kern</span> 1em b</span><br><span class="line">a<span class="keyword">\hspace</span>&#123;35pt&#125;b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 占位宽度（&#123;&#125;中的字符宽度）</span></span><br><span class="line">a<span class="keyword">\hphantom</span>&#123;xyz&#125;b</span><br><span class="line"></span><br><span class="line"><span class="comment">% 弹性长度（撑满整个空间）</span></span><br><span class="line">a<span class="keyword">\hfill</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;<span class="keyword">\ </span>LaTex 控制符&#125; <span class="comment">% 相当于转义字符，`\`使用\textbackslash产生</span></span><br><span class="line"><span class="keyword">\#</span> <span class="keyword">\$</span> <span class="keyword">\&#123;</span>  <span class="keyword">\&#125;</span> <span class="keyword">\~</span>&#123;&#125; <span class="keyword">\_</span>&#123;&#125; <span class="keyword">\^</span>&#123;&#125; <span class="keyword">\textbackslash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;排版符号&#125;</span><br><span class="line"><span class="keyword">\S</span> <span class="keyword">\P</span> <span class="keyword">\dag</span> <span class="keyword">\ddag</span> <span class="keyword">\copyright</span> <span class="keyword">\pounds</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;<span class="keyword">\ </span>Tex 标志符号&#125;</span><br><span class="line"><span class="keyword">\ </span>TeX&#123;&#125; <span class="keyword">\ </span>LaTeX&#123;&#125;  <span class="keyword">\ </span>LaTeXe&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;引号&#125;</span><br><span class="line">`&#x27;  <span class="comment">%  `表示单引号的左边，&#x27;表示单引号的右边</span></span><br><span class="line">`` &#x27;&#x27;   <span class="comment">%  ``表示双引号的左边，&#x27;&#x27;表示双引号的右边</span></span><br><span class="line">``被引号包裹&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;连字符&#125;</span><br><span class="line">- -- ---</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;非英文字符&#125;</span><br><span class="line"><span class="keyword">\oe</span> <span class="keyword">\OE</span> <span class="keyword">\AE</span> <span class="keyword">\aa</span> <span class="keyword">\AA</span> <span class="keyword">\o</span> <span class="keyword">\O</span> <span class="keyword">\l</span> <span class="keyword">\L</span> <span class="keyword">\ss</span> <span class="keyword">\SS</span> !` ?`</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;重音符号&#125;</span><br><span class="line"><span class="keyword">\`</span>o <span class="keyword">\&#x27;</span>o <span class="keyword">\^</span>o <span class="keyword">\&#x27;</span>&#x27;o <span class="keyword">\~</span>o <span class="keyword">\=</span>o <span class="keyword">\.</span>o <span class="keyword">\u</span>&#123;o&#125; <span class="keyword">\v</span>&#123;o&#125; <span class="keyword">\H</span>&#123;o&#125; <span class="keyword">\r</span>&#123;o&#125; <span class="keyword">\t</span>&#123;o&#125; <span class="keyword">\b</span>&#123;o&#125; <span class="keyword">\c</span>&#123;o&#125; <span class="keyword">\d</span>&#123;o&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h1>三、Latex中的图表</h1><h2 id="3-1-图">3.1 图</h2><p>在导言区使用<code>\usepackage&#123;grahpicx&#125;</code>命令引入graphicx宏包。</p><p>语法：<code>\includegraphics[选项]&#123;文件名&#125;</code>，选项用于设置缩放比例、旋转等</p><p>格式：<code>EPS, PDF, PNG, JPEG, BMP</code></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%导言区 </span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;  </span><br><span class="line"><span class="keyword">\title</span>&#123;My Latex Tutorial&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Haofei Ma&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;  </span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;  </span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;  </span><br><span class="line"><span class="keyword">\graphicspath</span>&#123;&#123;figures/&#125;,&#123;pics/&#125;&#125;<span class="comment">%表示图片在当前目录下的figures目录或pics/目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区  </span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;  </span><br><span class="line"><span class="comment">% 插入图片</span></span><br><span class="line"><span class="keyword">\includegraphics</span>&#123;filename&#125;  </span><br><span class="line"><span class="keyword">\includegraphics</span>&#123;filename2&#125;  </span><br><span class="line"><span class="keyword">\includegraphics</span>&#123;filename3&#125;<span class="comment">%two是figures文件夹下的文件(图像)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置缩放比例</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[scale=0.3]&#123;filename&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">% 高度设置</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[height=0.1<span class="keyword">\textheight</span>]&#123;filename&#125;  <span class="comment">%文档高度0.1倍高度</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[height=2cm]&#123;filename&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 宽度设置</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=0.1<span class="keyword">\textwidth</span>]&#123;filename&#125;  <span class="comment">% 文档宽度0.1倍宽度</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=2cm]&#123;filename&#125;  <span class="comment">% 文档宽度0.1倍宽度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 旋转角度</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[angle=-45,width=2cm]&#123;filename&#125;  </span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-表">3.2 表</h2><p>使用<code>\begin&#123;tabular&#125;</code>环境生成表格，生成环境时指定列数和每一列的对齐方式</p><p>语法：<code>\begin&#123;tabular&#125;[垂直对齐方式]&#123;列格式说明&#125;</code></p><ul><li><code>l</code>: 本列左对齐</li><li><code>c</code>: 本列居中对齐</li><li><code>r</code>: 本列右对齐</li><li><code>p&#123;宽度&#125;</code>: 本列宽度固定，内容超过宽度时会自动换行</li><li><code>\\</code>: 表示换行</li><li><code>&amp;</code>: 表示不同的列</li><li><code>|</code>: 是否在列间添加竖线（<code>||</code>双竖线）</li><li><code>\hline</code>: 在行间添加横线（<code>\hline \hline</code>双横线）</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l| c| c| c|  r|&#125;<span class="comment">%会有5列，指定每列的居中形式,|表示每列中间有竖线分开</span></span><br><span class="line"><span class="keyword">\hline</span><span class="comment">%每行之间由横线分开</span></span><br><span class="line">姓名<span class="built_in">&amp;</span>语文<span class="built_in">&amp;</span>数学<span class="built_in">&amp;</span>外语<span class="built_in">&amp;</span>政治<span class="keyword">\\</span><span class="comment">%\\表示换行</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">张三<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">张1<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">张2<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h1>四、Latax中的浮动体</h1><h1>五、Latex中的数学公式</h1><p>使用<code>\equation&#123;&#125;</code>命令产生带编号的行间公式。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125; <span class="comment">%表示带编号的行间公式  </span></span><br><span class="line">AB<span class="built_in">^</span>2=BC<span class="built_in">^</span>2+AC<span class="built_in">^</span>2  </span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h1>六、Latex中的参考文献</h1><h1>七、Latex中的自定义命令和环境</h1>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 科研基础 </category>
          
          <category> 论文撰写规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex常用公式</title>
      <link href="/post/79db849f.html"/>
      <url>/post/79db849f.html</url>
      
        <content type="html"><![CDATA[<h1>1. 公式插入</h1><h2 id="行内公式">行内公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>f(x)=x<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$f(x)=x$</p><h2 id="行间公式">行间公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>f(x)=x<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$f(x)=x$$</p><h1>2. 数学运算符号</h1><h2 id="乘法除法">乘法除法</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>a <span class="keyword">\times</span> b<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span>a <span class="keyword">\div</span> b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$a \times b$<br>$a \div b$</p><h2 id="除法分式">除法分式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\frac{a}{b}$</p><h2 id="根号开方">根号开方</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>[m]&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\sqrt{3}$<br>$\sqrt[m]{n}$</p><h2 id="求导导数偏导">求导导数偏导</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x&#125;<span class="built_in">$</span> <span class="comment">%求导</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> f&#125;&#123;<span class="keyword">\partial</span> x&#125;<span class="built_in">$</span>   <span class="comment">%偏导</span></span><br><span class="line"><span class="built_in">$</span>f<span class="built_in">^</span>&#123;&#x27;&#125;(x)<span class="built_in">$</span>     <span class="comment">%求导撇</span></span><br><span class="line"><span class="built_in">$</span>f<span class="built_in">^</span>&#123;&#x27;&#x27;&#125;(x)<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;y&#125;<span class="built_in">$</span>      <span class="comment">%求导点</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\ddot</span>&#123;y&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\dddot</span>&#123;y&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\nabla</span>&#123;f&#125;<span class="built_in">$</span>    <span class="comment">%全微分</span></span><br></pre></td></tr></table></figure><p>$\frac{\mathrm{d}y}{\mathrm{d}x}$</p><p>$\frac{\partial f}{\partial x}$</p><p>$f^{‘}(x)$<br>$f^{’'}(x)$</p><p>$\dot{y}$<br>$\ddot{y}$<br>$\dddot{y}$</p><p>$\nabla{f}$</p><h2 id="绝对值">绝对值</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>|x<span class="built_in">_</span>n|<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\lvert</span> x<span class="built_in">_</span>n<span class="keyword">\rvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$|x_n|$<br>$\lvert x_n\rvert$</p><h2 id="累计求和">累计求和</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\sum_{i=1}^{n}$</p><h2 id="累计求积">累计求积</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\prod_{i=1}^{n}$</p><h2 id="积分">积分</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\int_{i=1}^{n}$</p><h2 id="矩阵">矩阵</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">P=<span class="keyword">\begin</span>&#123;bmatrix&#125;&#123;&#125;</span><br><span class="line">p<span class="built_in">_</span>&#123;1,1&#125; <span class="built_in">&amp;</span> p<span class="built_in">_</span>&#123;1,2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> p<span class="built_in">_</span>&#123;1,|S|&#125;<span class="keyword">\\</span></span><br><span class="line">p<span class="built_in">_</span>&#123;2,1&#125; <span class="built_in">&amp;</span> p<span class="built_in">_</span>&#123;2,2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> p<span class="built_in">_</span>&#123;2,|S|&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cdots</span> <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> <span class="keyword">\cdots</span><span class="keyword">\\</span></span><br><span class="line">p<span class="built_in">_</span>&#123;|S|,1&#125; <span class="built_in">&amp;</span> p<span class="built_in">_</span>&#123;|S|,2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> p<span class="built_in">_</span>&#123;|S|,|S|&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$<br>P=\begin{bmatrix}{}<br>p_{1,1} &amp; p_{1,2} &amp; \cdots &amp; p_{1,|S|}\<br>p_{2,1} &amp; p_{2,2} &amp; \cdots &amp; p_{2,|S|}\<br>\cdots &amp; \cdots &amp; \cdots &amp; \cdots\<br>p_{|S|,1} &amp; p_{|S|,2} &amp; \cdots &amp; p_{|S|,|S|}<br>\end{bmatrix}<br>$$</p><h1>3. 字母附加符号</h1><h2 id="上下标">上下标</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">^</span>&#123;&#125; <span class="comment">%上标$x^&#123;2&#125;$</span></span><br><span class="line"><span class="built_in">_</span>&#123;&#125; <span class="comment">%下标$x_&#123;1&#125;$</span></span><br></pre></td></tr></table></figure><p>$x^{2}$<br>$x_{1}$</p><h2 id="向量">向量</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;a&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\overrightarrow</span>&#123;AB&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$\vec{a}$<br>$\overrightarrow{AB}$</p><h2 id="省略号">省略号</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cdots</span><span class="built_in">$</span>   <span class="comment">%省略号...$1,2,3,\cdots,n$</span></span><br></pre></td></tr></table></figure><p>$1,2,3,\cdots,n$</p><h2 id="大括号">大括号</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underbrace</span>&#123;n&#125;<span class="built_in">_</span>&#123;m&#125;<span class="built_in">$</span> <span class="comment">% 大括号 \underbrace&#123;1,2,3,\cdots,n&#125;_&#123;m&#125;</span></span><br></pre></td></tr></table></figure><p>$\underbrace{1,2,3,\cdots,n}_{m}$</p><h2 id="横线">横线</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overline</span>&#123;m+n&#125;<span class="built_in">$</span> <span class="comment">%m+n公式上面加上横杠 </span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\underline</span>&#123;m+n&#125;<span class="built_in">$</span><span class="comment">%m+n公式下面加上横杠</span></span><br></pre></td></tr></table></figure><p>$\overline{m+n}$</p><p>$\underline{m+n}$</p><h1>4. 特殊字母</h1><h2 id="希腊字母表">希腊字母表</h2><table><thead><tr><th>小写希腊字母</th><th>代码</th><th>大写希腊字母</th><th>代码</th></tr></thead><tbody><tr><td>$\alpha$</td><td>\alpha</td><td></td><td></td></tr><tr><td>$\beta$</td><td>\beta</td><td></td><td></td></tr><tr><td>$\gamma$</td><td>\gamma</td><td>$\Gamma$</td><td>\Gamma</td></tr><tr><td>$\delta$</td><td>\delta</td><td>$\Delta$</td><td>\Delta</td></tr><tr><td>$\epsilon$</td><td>\epsilon</td><td></td><td></td></tr><tr><td>$\varepsilon$</td><td>\varepsilon</td><td></td><td></td></tr><tr><td>$\zeta$</td><td>\zeta</td><td></td><td></td></tr><tr><td>$\eta$</td><td>\eta</td><td></td><td></td></tr><tr><td>$\theta$</td><td>\theta</td><td>$\Theta$</td><td>\Theta</td></tr><tr><td>$\vartheta$</td><td>\vartheta</td><td></td><td></td></tr><tr><td>$\iota$</td><td>\iota</td><td></td><td></td></tr><tr><td>$\kappa$</td><td>\kappa</td><td></td><td></td></tr><tr><td>$\lambda$</td><td>\lambda</td><td>$\Lambda$</td><td>\Lambda</td></tr><tr><td>$\mu$</td><td>\mu</td><td></td><td></td></tr><tr><td>$\nu$</td><td>\nu</td><td></td><td></td></tr><tr><td>$\xi$</td><td>\xi</td><td>$\Xi$</td><td>\Xi</td></tr><tr><td>$\pi$</td><td>\pi</td><td>$\Pi$</td><td>\Pi</td></tr><tr><td>$\varpi$</td><td>\varpi</td><td></td><td></td></tr><tr><td>$\rho$</td><td>\rho</td><td></td><td></td></tr><tr><td>$\varrho$</td><td>\varrho</td><td></td><td></td></tr><tr><td>$\sigma$</td><td>\sigma</td><td>$\Sigma$</td><td>\Sigma</td></tr><tr><td>$\varsigma$</td><td>\varsigma</td><td></td><td></td></tr><tr><td>$\tau$</td><td>\tau</td><td></td><td></td></tr><tr><td>$\upsilon$</td><td>\upsilon</td><td></td><td></td></tr><tr><td>$\phi$</td><td>\phi</td><td>$\Phi$</td><td>\Phi</td></tr><tr><td>$\varphi$</td><td>\varphi</td><td></td><td></td></tr><tr><td>$\chi$</td><td>\chi</td><td></td><td></td></tr><tr><td>$\psi$</td><td>\psi</td><td>$\Psi$</td><td>\Psi</td></tr><tr><td>$\omega$</td><td>\omega</td><td>$\Omega$</td><td>\Omega</td></tr></tbody></table><h2 id="常用关系符">常用关系符</h2><p>关系符都可以前加<code>\not</code>表示否定形式</p><table><thead><tr><th>符号</th><th>代码</th></tr></thead><tbody><tr><td>$\neq$</td><td>\neq or \not=</td></tr><tr><td>$\leq$</td><td>\leq or \le</td></tr><tr><td>$\geq$</td><td>\geq or \ge</td></tr><tr><td>$\ll$</td><td>\ll</td></tr><tr><td>$\gg$</td><td>\gg</td></tr><tr><td>$\subset$</td><td>\subset</td></tr><tr><td>$\supset$</td><td>\supset</td></tr><tr><td>$\subseteq$</td><td>\subseteq</td></tr><tr><td>$\supseteq$</td><td>\supseteq</td></tr><tr><td>$\in$</td><td>\in</td></tr><tr><td>$\ni$</td><td>\ni</td></tr><tr><td>$\bigcup$</td><td>\bigcup</td></tr><tr><td>$\bigcap$</td><td>\bigcap</td></tr><tr><td>$\propto$</td><td>\propto</td></tr><tr><td>$\infty$</td><td>\infty</td></tr></tbody></table><h2 id="特殊符号">特殊符号</h2><table><thead><tr><th>符号</th><th>代码</th></tr></thead><tbody><tr><td>$\leftarrow$</td><td>\leftarrow</td></tr><tr><td>$\Leftarrow$</td><td>\Leftarrow</td></tr><tr><td>$\rightarrow$</td><td>\rightarrow</td></tr><tr><td>$\Rightarrow$</td><td>\Rightarrow</td></tr><tr><td>$\leftrightarrow$</td><td>\leftrightarrow</td></tr><tr><td>$\Leftrightarrow$</td><td>\Leftrightarrow</td></tr><tr><td>$\leftharpoonup$</td><td>\leftharpoonup</td></tr><tr><td>$\leftharpoondown$</td><td>\leftharpoondown</td></tr><tr><td>$\rightharpoondown$</td><td>\rightharpoonup</td></tr><tr><td>$\rightharpoondown$</td><td>\rightharpoondown</td></tr><tr><td>$\leftrightharpoons$</td><td>\leftrightharpoons</td></tr></tbody></table><h2 id="特殊字体">特殊字体</h2><table><thead><tr><th>字体样式</th><th>代码</th></tr></thead><tbody><tr><td>$\mathrm{ABCdef}$</td><td>\mathrm{ABCdef}</td></tr><tr><td>$\mathit{ABCdef}$</td><td>\mathit{ABCdef}</td></tr><tr><td>$\mathnormal{ABCdef}$</td><td>\mathnormal{ABCdef}</td></tr><tr><td>$\mathcal{ABC}$</td><td>\mathcal{ABC}</td></tr><tr><td>$\mathscr{ABC}$</td><td>\mathscr{ABC}</td></tr><tr><td>$\mathfrak{ABCdef}$</td><td>\mathfrak{ABCdef}</td></tr><tr><td>$\mathbb{ABC}$</td><td>\mathbb{ABC}</td></tr></tbody></table><h1>5. 文字样式</h1><h2 id="文字颜色">文字颜色</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\color</span>&#123;blue&#125;&#123;文字&#125;<span class="built_in">$</span>             <span class="comment">%文字颜色</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\color</span>[rgb]&#123;0.9,0.1,0.2&#125;&#123;文字&#125;<span class="built_in">$</span><span class="comment">%rgb三个参数取值[0,1]</span></span><br></pre></td></tr></table></figure><p>$\color{blue}{文字}$<br>$\color[rgb]{0.9,0.1,0.2}{文字}$</p><h2 id="文字高亮">文字高亮</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\colorbox</span>&#123;green&#125;&#123;文字&#125;<span class="built_in">$</span>              <span class="comment">%文字颜色</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\colorbox</span>&#123;yellow&#125;&#123;<span class="keyword">\color</span>&#123;red&#125;&#123;文字&#125;&#125;<span class="built_in">$</span><span class="comment">%复合用法</span></span><br></pre></td></tr></table></figure><p>$\colorbox{green}{文字}$<br>$\colorbox{yellow}{\color{red}{文字}}$</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 科研基础 </category>
          
          <category> 论文撰写规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex论文撰写规范</title>
      <link href="/post/788bc007.html"/>
      <url>/post/788bc007.html</url>
      
        <content type="html"><![CDATA[<h1>总体要求</h1><p>在官方提供的模板上进行修改，或者使用官方提供的模板作为指令集。</p><h1>标题摘要关键词</h1><h2 id="论文标题">论文标题</h2><ul><li>论文标题应该使用大写和小写字母书写，不能全是大写</li><li>避免在标题中写带下标的公式</li></ul><h2 id="作者">作者</h2><ul><li>作者最好写作者的全名</li><li>作者首字母之间留一个空格</li></ul><h2 id="摘要">摘要</h2><ul><li>是对文章内容简短而全面的反应</li><li>摘要不能有有缩写、脚注、参考文献、数学方程、表格</li><li>字数控制在150-250词，必须写成一段</li></ul><h2 id="关键词">关键词</h2><ul><li>三到四个不同的关键词</li><li>关键词可以参考：<a href="https://www.ieee.org/publications/services/thesaurus-thank-you.html">IEEE - IEEE Thesaurus and IEEE Taxonomy Access</a></li></ul><h1>正文</h1><h2 id="缩写">缩写</h2><ul><li>第一次使用缩写要定义它们</li><li>尽量不要在标题中使用缩写</li></ul><h2 id="文字规范">文字规范</h2><ul><li>在句点和冒号后使用一个空格</li><li>使用连字符复合修饰语，例如<code>zero-field-cooled magnetization</code></li><li>表示连续一系列数值使用<code>7 to 9</code>或<code>7-9</code>，不能使用<code>7~9</code></li><li>句末的括号语句，在右括号外加标点<code>(like this).</code></li><li>避免缩写，例如使用<code>do not</code>代替<code>don't</code></li><li>推荐使用连续的逗号，例如<code>A, B, and C</code>好于<code>A, B and C.</code></li></ul><h2 id="等式">等式</h2><p><strong>基本规范</strong></p><ul><li>对方程进行编号</li><li>如果方程式是句子的一部分，记得加句号，不管行间公式还是行内公式。</li><li>方程式出现之前或之后，要定义方程式中的符号。</li><li>引用方程使用<code>(1)</code>，不要用<code>Eq. (1)</code>或<code>equation (1)</code>，除非在句子开头说<code>Equation (1) is ...</code></li></ul><p><strong>Latex建议</strong></p><ul><li>使用<code>\eqref&#123;Eq&#125;</code>这种软交叉引用，而不要使用<code>(1)</code>这种硬引用，这样当修改公式顺序时可以自动更改。</li><li>不要使用<code>&#123;eqnarray&#125;</code>方程环境，使用<code>&#123;align&#125;</code>或<code>&#123;IEEEeqnarray&#125;</code></li><li>注意<code>&#123;subequations&#125;</code>也会增加方程计数器，虽然它没有显示方程编号</li><li><code>\label</code>交叉引用时不要放在图和表的前面</li></ul><h2 id="单位">单位</h2><ul><li>小数点前使用0，即<code>0.25</code>而不是<code>.25</code></li><li>单位使用<code>0.1 cm ×  0.2 cm</code>而不是<code>0.1 × 0.2 cm2</code></li><li>使用<code>SI</code>国际单位制作为主要单位</li></ul><h2 id="常见语法问题">常见语法问题</h2><ul><li>一个图中的插图叫<code>inset</code>，不是<code>insert</code></li><li>使用<code>which</code>而不是<code>while</code>，除非两件事真的是同时发生</li><li>不要用<code>essentially</code>表示<code>approximately</code>或<code>effectively</code></li><li>不要用<code>issue</code>代表<code>problem</code></li><li>注意同音词<code>affect</code>和<code>effect</code>, <code>complement</code>和<code>compliment</code>, <code>discreet</code>和<code>discrete</code>， <code>principal</code>和<code>principle</code>的使用</li><li>不要混淆<code>imply</code>暗示和<code>infer</code>推断</li><li>前缀例如<code>non</code>, <code>sub</code>, <code>micro</code>, <code>multi</code>, <code>ultra</code>等词不是独立词，应该连到修饰的词上且通常不加连字符</li><li>缩写<code>i.e.</code>代表<code>that is</code>即，缩写<code>e.g.</code>代表<code>for example</code>例如</li></ul><h2 id="图表">图表</h2><ul><li>多个子图组合成的图，应该并排或堆叠排列</li><li>图片格式支持：<code>.ps</code>, <code>eps</code>, <code>.tiff</code>, <code>.pdf</code>, <code>.png</code>, <code>.mps</code>，文献提交时图片应该一起提交</li><li>大多数图表都是一列宽（3.5英寸/88mm），或一页宽（8.5英寸/216mm）</li><li>作者的照片、彩色图、灰度图的分辨率至少为300dpi；线条、表格等至少为600dpi</li><li>图片中的字体应该为<code>Times New Roman</code>, <code>Helvetica</code>, <code>Arial</code>, <code>Cambria</code>, <code>Symbol</code>中的一种</li><li>子图应该以(a)(b)©格式标记</li><li>图片文件的命名应该从作者姓氏的前五个字母开始，然后接图片序号，例如<code>ma1.png</code></li><li>如果有表的图片文件，也是用类似的命名方法，例如<code>ma.t1.png</code></li><li>作者照片使用姓氏的前五个字符命名，例如<code>ma.png</code>, <code>wang.png</code></li><li>如果有两个作者有相同的姓氏，可以使用名字的第一（多）个首字母替换姓氏的末尾字母，例如<code>San Zhang</code>和<code>Si Zhang</code>，图片命名为<code>zhasa.png</code>和<code>zhasi.png</code></li><li>引用图表时，即使在句子开头也要使用<code>Fig.</code>和<code>Table.</code>，不要缩写为<code>Tab.</code></li><li>IEEE会将论文进行格式化，因此不用刻意将图表放在每列的顶部和底部</li></ul><h2 id="结论">结论</h2><ul><li>不要将摘要作为结论，结论应该详细说明工作的重要性，或提出应用和改进建议</li></ul><h1>参考文献</h1><ul><li>文中引用参考文献使用方括号<code>[1]</code></li><li>多个参考文献使用单独的括号编号</li><li>正文不要使用<code>Ref.</code>或<code>reference</code>等单词</li><li>参考文献中参考号左对齐，并自己形成一列，在参考文件正文之外</li><li>所有参考文献中，作者或编辑的名字缩写为首字母，并在姓氏之前，没有给出名字的使用<code>et al.</code></li><li>使用<code>,</code>分割人名</li><li>缩写会议标题</li><li>当引用IEEE transaction时，提供issue number，页面范围，卷号，年份，月号（如果有的话）</li><li>除了书籍，论文标题中只有第一个单词大写，专有名词和元素符号除外</li></ul><p>常用格式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">期刊</span><br><span class="line">J. K. Author, “Name of paper,” Abbrev. Title of Periodical,  </span><br><span class="line">vol. x, no. x,pp. xxx–xxx, Abbrev. Month, year, DOI.  </span><br><span class="line">10.1109.XXX.123456.  </span><br><span class="line"></span><br><span class="line">参考如下：</span><br><span class="line">[3] J. U. Duncombe, “Infrared navigation—Part I: An assessment of fea-  </span><br><span class="line">sibility,” IEEE Trans. Electron Devices, vol. ED-11, no. 1, pp. 34–39,  </span><br><span class="line">Jan. 1959, 10.1109/TED.2016.2628402.  </span><br><span class="line">[4] E. P. Wigner, “Theory of traveling-wave optical laser,” Phys. Rev., vol. 134, pp. A635–A646, Dec. 1965.  </span><br><span class="line">[5] E. H. Miller, “A note on reflector arrays,” IEEE Trans. Antennas  </span><br><span class="line">Propagat., to be published</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">期刊（可以在线获取）</span><br><span class="line">J. K. Author, “Name of paper,” Abbrev. Title of Periodical,  </span><br><span class="line">vol. x, no. x, pp. xxx–xxx, Abbrev. Month, year. Accessed  </span><br><span class="line">on: Month, Day, year, DOI: 10.1109.XXX.123456, [On-  </span><br><span class="line">line].</span><br><span class="line"></span><br><span class="line">参考如下：</span><br><span class="line">[14] J. S. Turner, “New directions in communications,” IEEE J. Sel. Areas Commun., vol. 13, no. 1, pp. 11-23, Jan. 1995.  </span><br><span class="line">[15] W. P. Risk, G. S. Kino, and H. J. Shaw, “Fiber-optic frequency shifter using a surface acoustic wave incident at an oblique angle,” Opt. Lett., vol. 11, no. 2, pp. 115–117, Feb. 1986.  </span><br><span class="line">[16] P. Kopyt et al., “Electric properties of graphene-based conductive layers from DC up to terahertz range,” IEEE THz Sci. Technol., to be published. DOI: 10.1109/TTHZ.2016.25441</span><br></pre></td></tr></table></figure><h1>论文提交</h1><ul><li>发送稿件文件，以<code>zip</code>的格式</li><li>发送一张包含所有作者完整联系信息的paper或pdf，包括完整邮寄地址、电话号码、电子邮件地址。用于向每位作者发送论文期刊副本。</li><li>指定一位作者为通讯作者，论文校对将发送个通讯作者</li><li>按步骤完成所有提交后，会收到一封电子邮件确认</li><li>此外需要提交电子版权表格eCF（在稿件提交系统中）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 科研基础 </category>
          
          <category> 论文撰写规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>❤最全ButterFly主题配置教程</title>
      <link href="/post/a33e3ec.html"/>
      <url>/post/a33e3ec.html</url>
      
        <content type="html"><![CDATA[<h1>ButterFly主题配置</h1><h2 id="一、主页设置">一、主页设置</h2><h3 id="1-1-导航菜单">1.1 导航菜单</h3><p><strong>导航菜单</strong></p><p>设置如下<code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">时光轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br><span class="line">  <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>必须是<code>/xxx/</code>，后面<code>||</code>分开，然后写图标名。</p><p>默认子目录是展开的，如果你想要隐藏，在子目录里添加hide</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">List||fas</span>  <span class="string">fa-list||hide:</span> <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="attr">fas fa-music Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br></pre></td></tr></table></figure><p><strong>标签页</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span>/tags/index.md</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--- </span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-01-05 00:00:00</span> </span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p><strong>分类页</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span>/categories/index.md</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--- </span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-01-05 00:00:00</span> </span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p><strong>友情链接</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page link</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">source</span>/link/index.md</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--- </span></span><br><span class="line"><span class="attr">title:</span> <span class="string">友情链接</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-06-07 22:17:49</span> </span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;link&quot;</span> </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>在Hexo博客目录中的<code>source/_data</code>（如果没有_data 文件夹，请自行创建），创建一个文件<code>link.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span>  <span class="attr">class_name:</span> <span class="string">网站class_desc:值得推荐的网站link_list:</span> <span class="bullet">-</span> <span class="attr">name: Youtube link: https://www.youtube.com/ avatar:</span> <span class="string">https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span> <span class="string">descr:视频网站-</span> <span class="attr">name: Weibo link: https://www.weibo.com/ avatar:</span> <span class="string">https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span> <span class="string">descr:中国最大社交分享平台-</span> <span class="attr">name: Twitter link: https://twitter.com/ avatar:</span> <span class="string">https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span> <span class="string">descr:社交分享平台</span></span><br></pre></td></tr></table></figure><p>class_name和 class_desc 支持html 格式书写，如不需要，也可以留空。</p><p>友情链接界面可以由用户自己自定义，只需要在友情链接的md档设置就行，以普通的Markdown格式书写。</p><p><strong>搜索系统</strong></p><p>记得运行hexo clean</p><p><a href="https://github.com/PaicHyperionDev/hexo-generator-search">hexo-generator-search</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="1-2-社交图标">1.2 社交图标</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># social settings (社交圖標設置)</span></span><br><span class="line"><span class="comment"># formal:</span></span><br><span class="line"><span class="comment">#   icon: link || the description</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/weixin_44543463</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-cuttlefish</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/HuffieMa</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:haofei_ma@163.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="string">知乎:</span> <span class="string">https://www.zhihu.com/people/ma-hao-fei-2</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-zhihu</span></span><br></pre></td></tr></table></figure><h3 id="1-3-网站图像">1.3 网站图像</h3><p><strong>网站图标与头像</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Favicon（網站圖標）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">/img/avatar.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>顶部图</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disable_top_img:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>设置顶部图</strong></p><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>index_img</td><td>主页的top_img</td></tr><tr><td>default_top_img</td><td>默认的top_img，当页面的top_img 没有配置时，会显示default_top_img</td></tr><tr><td>archive_img</td><td>归档页面的top_img</td></tr><tr><td>tag_imgtag</td><td>子页面的默认top_img</td></tr><tr><td>tag_per_img</td><td>tag 子页面的top_img，可配置每个tag 的top_img</td></tr><tr><td>category_img</td><td>category 子页面的默认top_img</td></tr><tr><td>category_per_img</td><td>category 子页面的top_img，可配置每个category 的top_img</td></tr></tbody></table><p>并不推荐为每个tag 和每个category 都配置不同的顶部图，因为配置太多会拖慢生成速度</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tag_per_img</span></span><br><span class="line">  <span class="attr">aplayer:</span> <span class="string">https://xxxxxx.png</span></span><br><span class="line">  <span class="attr">android:</span> <span class="string">ddddddd.png</span></span><br><span class="line"><span class="string">category_per_img</span></span><br><span class="line"><span class="string">随想:</span> <span class="string">hdhdh.png</span></span><br><span class="line"><span class="string">推荐:</span> <span class="string">ddjdjdjd.png</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主页设置</span></span><br><span class="line"><span class="comment"># 默认top_img全屏，site_info在中间</span></span><br><span class="line"><span class="comment"># 使用默认, 都无需填写（建议默认）</span></span><br><span class="line"><span class="attr">index_site_info_top:</span>  <span class="comment"># 主页标题距离顶部距离例如300px/300em/300rem/10% </span></span><br><span class="line"><span class="attr">index_top_img_height:</span>   <span class="comment">#主页top_img高度例如300px/300em/300rem 不能使用百分比</span></span><br></pre></td></tr></table></figure><h3 id="1-4-主页文章设置">1.4 主页文章设置</h3><p><strong>文章信息</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span> <span class="comment"># Home Page</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># created or updated or both 主頁文章日期是創建日或者更新日或都顯示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 顯示日期還是相對日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否顯示分類</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主頁是否顯示標籤</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 顯示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 文章頁日期是創建日或者更新日或都顯示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">date</span> <span class="comment"># date/relative 顯示日期還是相對日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否顯示分類</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章頁是否顯示標籤</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 顯示描述性文字</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-page-meta.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-post-info.png" alt=""></p><p><strong>文章简介</strong></p><p>在butterfly里，有四种可供选择</p><ul><li>description：只显示description</li><li><strong>both</strong>：优先选择description，如果没有配置description，则显示自动节选的内容</li><li>auto_excerpt：只显示自动节选</li><li>false：不显示文章内容</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display the article introduction on homepage</span></span><br><span class="line"><span class="comment"># 1: description</span></span><br><span class="line"><span class="comment"># 2: both (if the description exists, it will show description, or show the auto_excerpt)</span></span><br><span class="line"><span class="comment"># 3: auto_excerpt (default)</span></span><br><span class="line"><span class="comment"># false: do not show the article introduction</span></span><br><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>文章封面</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># display the cover or not (是否顯示文章封面)</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># the position of cover in home page (封面顯示的位置)</span></span><br><span class="line">  <span class="comment"># left/right/both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)</span></span><br><span class="line">  <span class="attr">default_cover:</span> <span class="string">https://img.mahaofei.com/img/linux_debian.jpg</span></span><br></pre></td></tr></table></figure><h3 id="1-5-字数统计">1.5 字数统计</h3><p><code>npm install hexo-wordcount --save</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-wordcount-totalcount.png" alt=""></p><h3 id="1-6-页脚设置">1.6 页脚设置</h3><p><strong>博客年份</strong></p><p>展示你站点起始时间的选项。它位于页面的最底部。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Footer Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2021</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&lt;a</span>  <span class="string">href=&quot;https://beian.miit.gov.cn&quot;&gt;&lt;img</span>  <span class="string">class=&quot;icp-icon&quot;</span>  <span class="string">src=&quot;/img/icp.png&quot;&gt;&lt;span&gt;津ICP备2021000769号-2&lt;/span&gt;&lt;/a&gt;</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>百度统计</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Baidu Analytics</span></span><br><span class="line"><span class="comment"># https://tongji.baidu.com/web/welcome/login</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="string">439a0d0abeb31dd8f338efd8266c999b</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-footer-text.png" alt=""></p><p><strong>页脚背景</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># footer是否显示图片背景(与top_img一致) </span></span><br><span class="line"><span class="attr">footer_bg:</span>  <span class="literal">true</span></span><br><span class="line"><span class="comment"># 留空/false显示默认的颜色</span></span><br><span class="line"><span class="comment"># img链接图片的链接，显示所配置的图片</span></span><br><span class="line"><span class="comment"># 颜色(HEX值- #0000FF; RGB值- rgb(0,0,255);颜色单词- orange;渐变色- linear-gradient( 135deg, #E2B0FF 10%, #9F44D3 100%)） 对应的颜色</span></span><br><span class="line"><span class="comment"># true显示跟top_img 一样</span></span><br></pre></td></tr></table></figure><h3 id="1-7-侧边栏设置">1.7 侧边栏设置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aside (側邊欄)</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-cuttlefish</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">CSDN欢迎关注</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://blog.csdn.net/weixin_44543463</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">毕设ing！！</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br></pre></td></tr></table></figure><h2 id="二、文章设置">二、文章设置</h2><h3 id="2-1-代码设置">2.1 代码设置</h3><p><strong>代码高亮</strong></p><p>Butterfly支持6种代码高亮样式：</p><ul><li>darker</li><li>pale night</li><li><strong>light</strong></li><li>ocean</li><li>mac</li><li><strong>mac light</strong></li></ul><p>具体样式参考<a href="https://butterfly.js.org/posts/4aa8abbe/#%E4%BB%A3%E7%A2%BC%E9%AB%98%E4%BA%AE%E4%B8%BB%E9%A1%8C">官方文档</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span>  <span class="string">light</span></span><br></pre></td></tr></table></figure><p><strong>代码复制</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_copy:</span>  <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>代码展开关闭</strong></p><p>在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击&gt;可展开代码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_shrink:</span>  <span class="literal">true</span>  </span><br><span class="line"><span class="comment"># true 代码框不展开，需点击&gt;打开; </span></span><br><span class="line"><span class="comment"># false 代码框展开，有&gt;点击按钮</span></span><br><span class="line"><span class="comment"># none 不显示&gt;按钮</span></span><br></pre></td></tr></table></figure><p><strong>代码高度限制</strong></p><p>可配置代码高度限制，超出的部分会隐藏，并显示展开按钮。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_height_limit:</span>  <span class="literal">false</span>  <span class="comment"># unit: px 直接添加数字，如200</span></span><br></pre></td></tr></table></figure><h3 id="2-2-文章复制设置">2.2 文章复制设置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy settings </span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (复制的内容后面加上版权信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>enable</td><td>是否开启网站复制权限</td></tr><tr><td>copyright</td><td>复制的内容后面加上版权信息</td></tr><tr><td>enable</td><td>是否开启复制版权信息添加</td></tr><tr><td>limit_count</td><td>字数限制，当复制文字大于这个字数限制时，将在复制的内容后面加上版权信息</td></tr></tbody></table><h3 id="2-3-文章目录">2.3 文章目录</h3><p>在文章页，会有一个目录，用于显示TOC。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span> <span class="comment"># 文章页是否显示TOC</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">false</span> <span class="comment"># 普通页面是否显示TOC</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span> <span class="comment"># 是否显示章节数</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">false</span> <span class="comment"># 是否展开TOC</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> <span class="comment"># 简洁模式（侧边栏只显示TOC, 只对文章页有效）</span></span><br></pre></td></tr></table></figure><p>主题会优先判断文章Markdown的Front-matter是否有配置，如有，则以Front-matter的配置为准。否则，以主题配置文件中的配置为准</p><h3 id="2-4-文章打赏">2.4 文章打赏</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sponsor/reward</span></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/wechatpay.png</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">微信支付</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure><h3 id="2-5-下一篇文章">2.5 下一篇文章</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post_pagination (分頁)</span></span><br><span class="line"><span class="comment"># value: 1 || 2 || false</span></span><br><span class="line"><span class="comment"># 1: The &#x27;next post&#x27; will link to old post</span></span><br><span class="line"><span class="comment"># 2: The &#x27;next post&#x27; will link to new post</span></span><br><span class="line"><span class="comment"># false: disable pagination</span></span><br><span class="line"><span class="attr">post_pagination:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="2-6-文章分享">2.6 文章分享</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Share.js</span></span><br><span class="line"><span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line"><span class="attr">sharejs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sites:</span> <span class="string">qq,wechat,weibo,facebook,twitter</span></span><br></pre></td></tr></table></figure><p>在 head 里添加一些meta资料，例如缩略图、标题、时间等。当分享网页到一些平台时，平台会读取 Open Graph 的内容，展示缩略图，标题信息等等</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Open graph meta tags</span></span><br><span class="line"><span class="comment"># https://developers.facebook.com/docs/sharing/webmasters/</span></span><br><span class="line"><span class="attr">Open_Graph_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="2-7-数学公式MathJax">2.7 数学公式MathJax</h3><p>mathjax 是一个开源的 web 数学公式渲染器，由 JS 编写而成，它提供的书写方式和 LaTeX 的书写方式一样。</p><p><strong>（1）更换渲染插件</strong></p><p>Hexo 默认的渲染引擎是 marked，但 marked 不支持 mathjax，所以需要更换渲染引擎为 hexo-renderer-kramed，主要步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save # 卸载 marked  </span><br><span class="line">npm install hexo-renderer-kramed --save # 安装 kramed</span><br></pre></td></tr></table></figure><p>停用 hexo-math 并安装 mathjax</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save # 卸载 hexo-math  </span><br><span class="line">npm install hexo-renderer-mathjax --save # 安装 mathjax</span><br></pre></td></tr></table></figure><p>打开 <code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，进行如下修改：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Change inline math rule  </span><br><span class="line">function formatText(text) &#123;  </span><br><span class="line">    // Fit kramed&#x27;s rule: $$ + \1 + $$  </span><br><span class="line"><span class="deletion">-   return text.replace(/`\$(.*?)\$`/g, &#x27;$$$$$1$$$$&#x27;); </span></span><br><span class="line"><span class="addition">+   return text;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新 Mathjax 配置文件，打开 <code>/node_modules/hexo-renderer-mathjax/mathjax.html</code>，将最后一行的 <code>&lt;script&gt;</code> 改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>更改默认转义规则，因为 LaTeX 与 markdown 语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，我们需要对默认的规则进行修改。打开 <code>\node_modules\kramed\lib\rules\inline.js</code> ，将<code>var inline = &#123;&#125;</code> 中的属性 <code>escape</code> 和 <code>em</code> 参数更改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>开启 mathjax，打开主题的 <code>_config.butterfly.yml</code> ，检索 <code>MathJax</code>，将 <code>enable</code> 参数设置为 <code>true</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax  </span></span><br><span class="line"><span class="attr">mathjax:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>配置成功后，需要渲染的文章开头，添加参数 <code>mathjax: true</code> 即可。</p><h2 id="三、博客美化">三、博客美化</h2><h3 id="3-1-背景canvas-nest">3.1 背景canvas_nest</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).( <span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5.</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines,default: 99.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># false 手机端不显示true 手机端显示</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-canvas_nest.gif" alt=""></p><h3 id="3-2-打字烟花特效">3.2 打字烟花特效</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Typewriter Effect (打字效果) </span></span><br><span class="line"><span class="comment"># https://github.com/disjukr/activate-power-mode </span></span><br><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment"># open shake (抖动特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-type-animation.gif" alt=""></p><h3 id="3-3-页面美化">3.3 页面美化</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 美化页面显示</span></span><br><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f0c1&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&quot;#F47466&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-网站副标题打字效果">3.4 网站副标题打字效果</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主頁subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循環打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  調用一句網（簡體） http://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br></pre></td></tr></table></figure><h3 id="3-5-访问人数busuanzi">3.5 访问人数busuanzi</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-busuanzi-site-pv.png" alt=""></p><h3 id="3-6-运行时间">3.6 运行时间</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time difference between publish date and now (網頁運行時間)</span></span><br><span class="line"><span class="comment"># Formal: Month/Day/Year Time or Year/Month/Day Time</span></span><br><span class="line"><span class="attr">runtimeshow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">publish_date:</span> <span class="number">2021</span><span class="string">/01/16</span> <span class="number">23</span><span class="string">:30:32</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-7-夜间模式">3.7 夜间模式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dark mode </span></span><br><span class="line"><span class="attr">darkmode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># dark mode和light mode切换按钮</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">autoChangeMode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>autoChangeMode: 1</td><td>跟随系统而变化，不支持的浏览器/系统将按照时间晚上6点到早上6点之间切换为dark mode</td></tr><tr><td>autoChangeMode: 2</td><td>只按照时间晚上6点到早上6点之间切换为dark mode,其余时间为light mode</td></tr><tr><td>autoChangeMode: false</td><td>取消自动切换</td></tr></tbody></table><h3 id="3-8-阅读模式">3.8 阅读模式</h3><p>阅读模式下会去掉除文章外的内容，避免干扰阅读。</p><p>只会出现在文章页面，右下角会有阅读模式按钮。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readmode:</span>  <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-9-页脚添加Github-badge标签">3.9 页脚添加Github-badge标签</h3><p><img src="https://img.mahaofei.com/img/20220411223909.png" alt=""></p><ol><li>首先到<a href="https://shields.io/">https://shields.io/</a>这个徽标生成网站生成Github-badge徽标。</li></ol><p><img src="https://img.mahaofei.com/img/20220411120309.png" alt=""></p><p>具体方法见网页，标签中用到的图标可以从<a href="https://simpleicons.org/">simpleicons</a>查询。</p><p>生成的链接都是这样的 → <a href="https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&amp;logo=GitHub">https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&amp;logo=GitHub</a><br>然后简单写一下html代码，为每个标签添加链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&amp;logo=GitHub&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站项目由Gtihub托管&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo&quot;</span> <span class="attr">title</span>=<span class="string">&quot;博客框架为Hexo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://butterfly.js.org/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Theme-Butterfly-6513df?logoColor=white&amp;style=flat&amp;logo=buefy&quot;</span> <span class="attr">title</span>=<span class="string">&quot;主题采用butterfly&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://aliyun.com/product/cdn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/CDN-%E9%98%BF%E9%87%8C%E4%BA%91-orange?style=flat&amp;logo=alibabacloud&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站使用阿里云为静态资源提供CDN加速&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://beian.miit.gov.cn/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/%E6%B4%A5ICP%E5%A4%87-2021000769%E5%8F%B7--2-red?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==&quot;</span> <span class="attr">title</span>=<span class="string">&quot;备案号:津ICP备-2021000769号--2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://tongji.baidu.com/web/10000399748/overview/index?siteId=17522448&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/%E7%99%BE%E5%BA%A6-%E7%BB%9F%E8%AE%A1-blue?style=flat&amp;logo=baidu&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站采用百度统计进行网站管理与维护&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>到<a href="http://tool.ggo.net/htmlpack/">HTML压缩网站</a>将代码压缩成一行，复制到footer属性中就完成Github-badge效果了</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Footer Settings</span></span><br><span class="line"><span class="comment"># --------------------------------------</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2021</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&lt;p&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;https://github.com/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Hosted-Github-brightgreen?style=flat&amp;logo=GitHub&quot;title=&quot;本站项目由Gtihub托管&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;https://hexo.io/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo&quot;title=&quot;博客框架为Hexo&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;https://butterfly.js.org/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Theme-Butterfly-6513df?logoColor=white&amp;style=flat&amp;logo=buefy&quot;title=&quot;主题采用butterfly&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;https://aliyun.com/product/cdn&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/CDN-%E9%98%BF%E9%87%8C%E4%BA%91-orange?style=flat&amp;logo=alibabacloud&quot;title=&quot;本站使用阿里云为静态资源提供CDN加速&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;https://beian.miit.gov.cn/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/%E6%B4%A5ICP%E5%A4%87-2021000769%E5%8F%B7--2-red?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==&quot;title=&quot;备案号:津ICP备-2021000769号-2&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;https://tongji.baidu.com/web/10000399748/overview/index?siteId=17522448&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/%E7%99%BE%E5%BA%A6-%E7%BB%9F%E8%AE%A1-blue?style=flat&amp;logo=baidu&quot;title=&quot;本站采用百度统计进行网站管理与维护&quot;&gt;&lt;/a&gt;&lt;a</span> <span class="string">style=&quot;margin-inline:5px&quot;target=&quot;_blank&quot;href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img</span> <span class="string">src=&quot;https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris&quot;title=&quot;本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可&quot;&gt;&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">false</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure><h3 id="3-10-评论系统valine（已停止使用）">3.10 评论系统valine（已停止使用）</h3><p><strong>开启评论</strong></p><p>在主题配置文件的<code>comments</code>中填写需要用的评论</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Valine</span> <span class="comment"># Valine,Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>use</td><td>使用的评论（请注意，最多支持两个，如果不需要请留空）</td></tr><tr><td>text</td><td>是否显示评论服务商的名字</td></tr><tr><td>lazyload</td><td>是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示）</td></tr><tr><td>count</td><td>是否在文章顶部显示评论数(livere、Giscus 和utterances 不支持评论数显示)</td></tr><tr><td>card_post_count</td><td>是否在首页文章卡片显示评论数(gitalk、livere 、Giscus 和utterances 不支持评论数显示)</td></tr></tbody></table><p><strong>配置Valine</strong></p><p>参考<a href="https://valine.js.org/quickstart.html">Valine文档</a>与<a href="https://github.com/xCss/Valine">Github项目</a></p><ol><li>注册LeanCloud：<a href="https://leancloud.cn/dashboard/login.html#/signup">国内版</a>注册使用需要域名备案，如果域名没有备案请使用<a href="https://console.leancloud.app/register">国际版</a>。</li><li>进入控制台，点击左下角创建应用</li></ol><p><img src="https://img.mahaofei.com/img/20220410162655.png" alt=""></p><ol start="3"><li>应用创建好后，进入应用界面，点击左下角的【设置-应用凭证】，可以看到APPID</li></ol><p><img src="https://img.mahaofei.com/img/20220410162923.png" alt=""></p><ol start="4"><li><p>将APPID和APPKey复制到主题配置文件的<code>valine</code>下</p></li><li><p>重新部署自己的网站，就可以看到评论系统了</p></li><li><p>在LeanCloud中：<code>登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment</code>，然后就可以管理评论了</p></li></ol><p><strong>Valine高级配置</strong></p><ol><li>头像配置</li></ol><table><thead><tr><th>参数值</th><th>表现形式</th><th>备注</th></tr></thead><tbody><tr><td>空字符串<code>''</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40" alt="Gravatar官方图形"></td><td>Gravatar官方图形</td></tr><tr><td><code>mp</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&amp;d=mp" alt="神秘人(一个灰白头像)"></td><td>神秘人(一个灰白头像)</td></tr><tr><td><code>identicon</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&amp;d=identicon" alt="抽象几何图形"></td><td>抽象几何图形</td></tr><tr><td><code>monsterid</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&amp;d=monsterid" alt="小怪物"></td><td>小怪物</td></tr><tr><td><code>wavatar</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&amp;d=wavatar" alt="用不同面孔和背景组合生成的头像"></td><td>用不同面孔和背景组合生成的头像</td></tr><tr><td><code>retro</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&amp;d=retro" alt="八位像素复古头像"></td><td>八位像素复古头像</td></tr><tr><td><code>robohash</code></td><td><img src="https://gravatar.loli.net/avatar/d41d8cd98f00b204e9800998ecf8427e?s=40&amp;d=robohash" alt="机器人"></td><td>一种具有不同颜色、面部等的机器人</td></tr><tr><td><code>hide</code></td><td></td><td>不显示头像</td></tr></tbody></table><ol start="2"><li>自定义表情</li></ol><p>在Hexo根目录下的<code>source/_data/</code>下创建一个<code>valine.json</code>文件，文件内容为自定义表情，比如我们要用<code>Bilibili</code>的表情包(效果可以在评论区查看):</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"><span class="attr">&quot;tv_doge&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_亲亲&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;a8111ad55953ef5e3be3327ef94eb4a39d535d06.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_偷笑&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;bb690d4107620f1c15cff29509db529a73aee261.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_再见&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_冷漠&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_发怒&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_发财&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;34db290afd2963723c6eb3c4560667db7253a21a.png&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_可爱&quot;</span> <span class="punctuation">:</span><span class="string">&quot;9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_吐血&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;09dd16a7aa59b77baa1155d47484409624470c77.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_呆&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_呕吐&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;9f996894a39e282ccf5e66856af49483f81870f3.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_困&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;241ee304e44c0af029adceb294399391e4737ef2.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_坏笑&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;1f0b87f731a671079842116e0991c91c2c88645a.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_大佬&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;093c1e2c490161aca397afc45573c877cdead616.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_大哭&quot;</span> <span class="punctuation">:</span><span class="string">&quot;23269aeb35f99daee28dda129676f6e9ea87934f.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_委屈&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_害羞&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_尴尬&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_微笑&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_思考&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;90cf159733e558137ed20aa04d09964436f618a1.png&quot;</span> <span class="punctuation">,</span> </span><br><span class="line"><span class="attr">&quot;tv_惊吓&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0d15c7e2ee58e935adc6a7193ee042388adc22af.png&quot;</span></span><br><span class="line"><span class="comment">// 更多表情</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>主页显示最近评论</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Aside widget - Newest Comments </span></span><br><span class="line"><span class="attr">newest_comments :</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sort_order :</span> <span class="comment"># Don &#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span></span><br><span class="line">  <span class="attr">storage:</span> <span class="number">10</span> <span class="comment"># unit: mins, save data to localStorage</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-newest-comments.png" alt=""></p><h3 id="3-11-评论系统twikoo">3.11 评论系统twikoo</h3><blockquote><p>原本的腾讯云部署已经不适用了，切换为Vercel+MongoDB，具体方法参考<a href="https://twikoo.js.org/backend.html">官方文档</a></p></blockquote><p><img src="https://img.mahaofei.com/img/20220412094538.png" alt=""></p><p><strong>（2）添加自定义表情</strong></p><p>在<a href="https://emotion.xiaokang.me/#/">小康的表情速查</a>查找想要的表情，找到其中的twikoo的json代码复制下来，在本地新建一个<code>json</code>文件，将json代码复制进去。</p><p>然后将该json文件上传至服务器，或者保存例如<code>butterfly/source/json/qq.json</code>，这样就可以通过<code>www.mahaofei.com/json/qq.json</code>访问到该文件了。</p><p>到twikoo的控制面板【插件-SHOW_EMOTION】设置为true，【插件-EMOTION_CDN】填写自己的json文件链接，如果有多个文件使用英文逗号<code>,</code>分开，保存。</p><p>刷新网页，即可完成。</p><h3 id="3-12-Artitalk说说">3.12 Artitalk说说</h3><ol><li>前往 <a href="https://leancloud.app/">LeanCloud 国际版</a>，注册账号。</li><li>注册完成之后根据 LeanCloud 的提示绑定手机号和邮箱。</li><li>绑定完成之后点击<code>创建应用</code>，应用名称随意，接着在<code>结构化数据</code>中创建 <code>class</code>，命名为 <code>shuoshuo</code>。</li><li>在你新建的应用中找到<code>结构化数据</code>下的<code>用户</code>。点击<code>添加用户</code>，输入想用的用户名及密码。</li><li>回到<code>结构化数据</code>中，点击 <code>class</code> 下的 <code>shuoshuo</code>。找到权限，在 <code>Class 访问权限</code>中将 <code>add_fields</code> 以及 <code>create</code> 权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将 <code>delete</code> 和 <code>update</code> 也设置为跟它们一样的权限。</li><li>然后新建一个名为<code>atComment</code>的class，权限什么的使用默认的即可。</li><li>点击 <code>class</code> 下的 <code>_User</code> 添加列，列名称为 <code>img</code>，默认值填上你这个账号想要用的发布说说的头像url，这一项不进行配置，说说头像会显示为默认头像 —— Artitalk 的 logo。</li><li>在最菜单栏中找到设置-&gt; 应用 keys，记下来 <code>AppID</code> 和 <code>AppKey</code> ，一会会用。</li><li>最后将 <code>_User</code> 中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据以达到强制发布说说。</li><li>安装<code>hexo-butterfly-artitalk</code>插件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-artitalk</span><br></pre></td></tr></table></figure><ol start="11"><li>在主题配置文件中添加如下配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Artitalk</span></span><br><span class="line"><span class="comment"># see https://artitalk.js.org/</span></span><br><span class="line"><span class="attr">artitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appId:</span>  <span class="comment"># 【必须】LeanCloud 创建应用中的 AppID</span></span><br><span class="line">  <span class="attr">appKey:</span>  <span class="comment"># 【必须】LeanCloud 创建应用中的 AppKEY</span></span><br><span class="line">  <span class="attr">path:</span>  <span class="comment"># 【任选】Artitalk的路径名称（默认为artitalk，生成的页面为artitalk/index.html）</span></span><br><span class="line">  <span class="attr">js:</span>  <span class="comment"># 【任选】更换Artitalk的js CDN（默认为https://cdn.jsdelivr.net/npm/artitalk）</span></span><br><span class="line">  <span class="attr">option:</span>  <span class="comment"># 【任选】Artitalk 需要的额外配置</span></span><br><span class="line">  <span class="attr">front_matter:</span>  <span class="comment"># 【任选】Arttalk页面的front_matter配置</span></span><br></pre></td></tr></table></figure><ol start="12"><li>默认的访问网址：<code>/artitalk/index.html</code></li></ol><p><img src="https://img.mahaofei.com/img/20220412165755.png" alt=""></p><h3 id="3-13-动态分类条">3.13 动态分类条</h3><p>参考<a href="https://blog.zhheo.com/p/bc61964d.html">【张洪老师的博客】</a>，分类的添加使用纯手工的方式。</p><p><img src="https://img.mahaofei.com/img/20220427195336.png" alt=""></p><p><strong>新建文件</strong></p><p>新建一个文件：<code>themes/butterfly/layout/includes/categoryBar.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#category-bar</span><br><span class="line">    .category-bar-items#category-bar-items</span><br><span class="line">        .category-bar-item(id=&#x27;首页&#x27;)</span><br><span class="line">            a(href=&quot;/&quot;) 首页</span><br><span class="line">        .category-bar-item(id=&#x27;程序设计&#x27;)</span><br><span class="line">            a(href=&quot;/categories/程序设计/&quot;) 程序设计</span><br><span class="line">        .category-bar-item(id=&#x27;机器人&#x27;)</span><br><span class="line">            a(href=&quot;/categories/机器人/&quot;) 机器人</span><br><span class="line">        .category-bar-item(id=&#x27;嵌入式&#x27;)</span><br><span class="line">            a(href=&quot;/categories/嵌入式/&quot;) 嵌入式</span><br><span class="line">        .category-bar-item(id=&#x27;经验分享&#x27;)</span><br><span class="line">            a(href=&quot;/categories/经验分享/&quot;) 经验分享</span><br><span class="line">        .category-bar-item(id=&#x27;随笔&#x27;)</span><br><span class="line">            a(href=&quot;/categories/随笔/&quot;) 随笔</span><br><span class="line">    a.category-bar-more(href=&quot;/categories/&quot;) 更多</span><br></pre></td></tr></table></figure><p><strong>引用文件</strong></p><p>编辑<code>themes/butterfly/layout/index.pug</code></p><p>在<code>+postUI</code>上一行添加<code>include includes/categoryBar.pug</code>，并保持缩进相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  include ./includes/mixins/post-ui.pug</span><br><span class="line">  #recent-posts.recent-posts</span><br><span class="line">include includes/categoryBar.pug</span><br><span class="line">    +postUI</span><br><span class="line">    include includes/pagination.pug</span><br></pre></td></tr></table></figure><p>编辑<code>themes/butterfly/layout/category.pug</code>，在<code>#category</code>下方添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#category  </span><br><span class="line">  .category-in-bar  </span><br><span class="line">    .category-in-bar-tips  </span><br><span class="line">      | 分类  </span><br><span class="line">    include includes/categoryBar.pug</span><br></pre></td></tr></table></figure><p><strong>引用CSS和JS</strong></p><p>链接: <a href="https://pan.baidu.com/s/13iOkTwWDbtzlFzRLTdQl9Q?pwd=9e32">https://pan.baidu.com/s/13iOkTwWDbtzlFzRLTdQl9Q?pwd=9e32</a><br>提取码: 9e32</p><p>将其中的<code>MainColor.css</code>, <code>categoryBar.css</code>两个文件复制到<code>themes/butterfly/source/css</code>目录下，将<code>categoryBar.js</code>复制到<code>themes/butterfly/source/js</code>目录下，然后在主题配置文件<code>_config.yml</code>中引用这三个文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/categoryBar.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/MainColor.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/categoryBar.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-14-Butterfly首页隐藏文章">3.14 Butterfly首页隐藏文章</h3><p>打开文件：<code>themes/butterfly/layout/includes/mixins/post-ui.pug</code></p><p>注意，主要是添加了<code>if article.hide !== true</code>这一行，然后这一行后全部需要按下tab缩进一层。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mixin postUI(posts)  </span><br><span class="line">  each article , index in page.posts.data  </span><br><span class="line">    if article.hide !== true  </span><br><span class="line">      .recent-post-item</span><br></pre></td></tr></table></figure><p>在md文件的头部信息中添加<code>hide: true</code></p><h3 id="3-15-相关推荐侧边栏化">3.15 相关推荐侧边栏化</h3><p>参考文章：<a href="https://akilar.top/posts/194e1534/">《Butterfly 布局调整 ——— 相关推荐版块侧栏卡片化》</a></p><p><img src="https://img.mahaofei.com/img/20220428112259.png" alt=""></p><p>修改 <code>[Blogroot]\themes\butterfly\scripts\helpers\related_post.js</code>, 从大概 47 行开始到 70 行的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (relatedPosts.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    result += <span class="string">&#x27;&lt;div class=&quot;card-widget card-recommend-post&quot;&gt;&#x27;</span>  </span><br><span class="line">    result += <span class="string">`&lt;div class=&quot;item-headline&quot;&gt;&lt;i class=&quot;fas fa-dharmachakra&quot;&gt;&lt;/i&gt;&lt;span&gt;<span class="subst">$&#123;headlineLang&#125;</span>&lt;/span&gt;&lt;/div&gt;`</span>  </span><br><span class="line">    result += <span class="string">&#x27;&lt;div class=&quot;aside-list&quot;&gt;&#x27;</span>  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="title class_">Math</span>.<span class="title function_">min</span>(relatedPosts.<span class="property">length</span>, limitNum); i++) &#123;  </span><br><span class="line">      <span class="keyword">const</span> cover =  </span><br><span class="line">        relatedPosts[i].<span class="property">cover</span> === <span class="literal">false</span>  </span><br><span class="line">          ? relatedPosts[i].<span class="property">randomcover</span>  </span><br><span class="line">          : relatedPosts[i].<span class="property">cover</span>  </span><br><span class="line">      result += <span class="string">`&lt;div class=&quot;aside-list-item&quot;&gt;`</span>  </span><br><span class="line">      result += <span class="string">`&lt;a class=&quot;thumbnail&quot; href=&quot;<span class="subst">$&#123;<span class="variable language_">this</span>.url_for(relatedPosts[i].path)&#125;</span>&quot; title=&quot;<span class="subst">$&#123;relatedPosts[i].title&#125;</span>&quot;&gt;&lt;img src=&quot;<span class="subst">$&#123;<span class="variable language_">this</span>.url_for(cover)&#125;</span>&quot; alt=&quot;<span class="subst">$&#123;relatedPosts[i].title&#125;</span>&quot;&gt;&lt;/a&gt;`</span>  </span><br><span class="line">      result += <span class="string">`&lt;div class=&quot;content&quot;&gt;`</span>  </span><br><span class="line">      result += <span class="string">`&lt;a class=&quot;title&quot; href=&quot;<span class="subst">$&#123;<span class="variable language_">this</span>.url_for(relatedPosts[i].path)&#125;</span>&quot; title=&quot;<span class="subst">$&#123;relatedPosts[i].title&#125;</span>&quot;&gt;<span class="subst">$&#123;relatedPosts[i].title&#125;</span>&lt;/a&gt;`</span>  </span><br><span class="line">      <span class="keyword">if</span> (dateType === <span class="string">&#x27;created&#x27;</span>) &#123;  </span><br><span class="line">        result += <span class="string">`&lt;time datetime=&quot;<span class="subst">$&#123;<span class="variable language_">this</span>.date(relatedPosts[i].created, hexoConfig.date_format)&#125;</span>&quot; title=&quot;发表于 <span class="subst">$&#123;<span class="variable language_">this</span>.date(relatedPosts[i].created, hexoConfig.date_format)&#125;</span>&quot;&gt;<span class="subst">$&#123;<span class="variable language_">this</span>.date(relatedPosts[i].created, hexoConfig.date_format)&#125;</span>&lt;/time&gt;`</span>  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        result += <span class="string">`&lt;time datetime=&quot;<span class="subst">$&#123;<span class="variable language_">this</span>.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;</span>&quot; title=&quot;发表于 <span class="subst">$&#123;<span class="variable language_">this</span>.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;</span>&quot;&gt;<span class="subst">$&#123;<span class="variable language_">this</span>.date(relatedPosts[i].updated, hexoConfig.date_format)&#125;</span>&lt;/time&gt;`</span>  </span><br><span class="line">      &#125;  </span><br><span class="line">      result += <span class="string">`&lt;/div&gt;&lt;/div&gt;`</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    result += <span class="string">&#x27;&lt;/div&gt;&lt;/div&gt;&#x27;</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为原本的版块是在文章下方，而现在我们需要把它改到侧栏。所以需要修改 <code>[Blogroot]\themes\butterfly\layout\post.pug</code> 大约 26 行的位置先移除在文章底部的推荐版块。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  if theme.post_pagination  </span><br><span class="line">    include includes/pagination.pug  </span><br><span class="line"><span class="deletion">- if theme.related_post &amp;&amp; theme.related_post.enable  </span></span><br><span class="line"><span class="deletion">-   != related_posts(page,site.posts)  </span></span><br><span class="line">  </span><br><span class="line">  if page.comments !== false &amp;&amp; theme.comments &amp;&amp; theme.comments.use</span><br></pre></td></tr></table></figure><p>然后修改 <code>[Blogroot]\themes\butterfly\layout\includes\widget\index.pug</code>, 这个文件每个版本都长得不太一样，这里仅供参考。因为感觉文章也最新文章和推荐文章同时存在，最新文章就显得有点多余了，所以我把最新文章的侧栏卡片注释了。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#aside-content.aside-content  </span><br><span class="line">  //- post  </span><br><span class="line">  if is_post()  </span><br><span class="line">    if showToc &amp;&amp; theme.toc.style_simple  </span><br><span class="line">      .sticky_layout  </span><br><span class="line">        include ./card_post_toc.pug  </span><br><span class="line">    else  </span><br><span class="line">      !=partial(&#x27;includes/custom/SAO_card_player&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)  </span><br><span class="line">      !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)  </span><br><span class="line">      !=partial(&#x27;includes/widget/card_top_self&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)    </span><br><span class="line">      .sticky_layout  </span><br><span class="line">        if showToc  </span><br><span class="line">          include ./card_post_toc.pug  </span><br><span class="line"><span class="addition">+       if theme.related_post &amp;&amp; theme.related_post.enable  </span></span><br><span class="line"><span class="addition">+         != related_posts(page,site.posts)  </span></span><br><span class="line"><span class="deletion">-       - !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)  </span></span><br><span class="line"><span class="addition">+       //- !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)  </span></span><br><span class="line">        !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>改动完成后运行 <code>hexo clean</code>,<code>hexo generate</code>,<code>hexo server</code> 三件套就能看到完成效果了。</p><h3 id="3-16-侧边栏添加历史上的今天">3.16 侧边栏添加历史上的今天</h3><p>在<code>[Blogroot]\themes\butterfly\layout\includes\widget\</code> 中新建一个<code>card_history.pug</code>文件，内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-history</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">       i.fas.fa-clock.fa-spin</span><br><span class="line">       span= _p(&#x27;那年今日&#x27;)</span><br><span class="line">    #history-baidu(style=&#x27;height: 60px;overflow: hidden;&#x27;)</span><br><span class="line">      #history-container.history_swiper-container(style=&quot;width: 100%;height: 100%;&quot;)</span><br><span class="line">          #history_container_wrapper.swiper-wrapper(style=&quot;height:20px&quot; )</span><br></pre></td></tr></table></figure><p>修改位于 <code>[Blogroot]\themes\butterfly\layout\includes\widget\</code> 中的<code>index.pug</code>。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#aside-content.aside-content</span><br><span class="line">  //- post</span><br><span class="line">  if is_post()</span><br><span class="line">    - const tocStyle = page.toc_style_simple</span><br><span class="line">    - const tocStyleVal = tocStyle <span class="comment">=== true || tocStyle === false ? tocStyle : theme.toc.style_simple</span></span><br><span class="line">    if showToc &amp;&amp; tocStyleVal</span><br><span class="line">      .sticky_layout</span><br><span class="line">        include ./card_post_toc.pug</span><br><span class="line">    else</span><br><span class="line">      !=partial(&#x27;includes/widget/card_author&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_top_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      .sticky_layout</span><br><span class="line">        if showToc</span><br><span class="line">          include ./card_post_toc.pug</span><br><span class="line">        if theme.related_post &amp;&amp; theme.related_post.enable</span><br><span class="line"><span class="addition">+         !=partial(&#x27;includes/widget/card_history&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span></span><br><span class="line">          !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br><span class="line">        !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  else</span><br><span class="line">    //- page</span><br><span class="line">    !=partial(&#x27;includes/widget/card_author&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    !=partial(&#x27;includes/widget/card_announcement&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    !=partial(&#x27;includes/widget/card_top_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)      </span><br><span class="line"></span><br><span class="line">    .sticky_layout</span><br><span class="line">      if showToc</span><br><span class="line">        include ./card_post_toc.pug</span><br><span class="line"><span class="addition">+     !=partial(&#x27;includes/widget/card_history&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span></span><br><span class="line">      !=partial(&#x27;includes/widget/card_recent_post&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_ad&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_newest_comment&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_categories&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_tags&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_archives&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_webinfo&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      !=partial(&#x27;includes/widget/card_bottom_self&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p>打开 主题配置文件<code>_config.yml</code> 搜索到 <code>aside:</code> 处，添加开关：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile  </span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># left or right  </span></span><br><span class="line">  <span class="attr">card_history:</span> <span class="comment"># 添加开关名称  </span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 打开card_history开关  </span></span><br><span class="line">  <span class="attr">card_author:</span>  </span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后搜索<code>inject:</code>，进行如下修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span>  </span><br><span class="line">  <span class="attr">head:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://unpkg.com/swiper/swiper-bundle.min.css&quot;&gt;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css&quot;&gt;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="attr">bottom:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://unpkg.com/swiper/swiper-bundle.min.js&quot;&gt;&lt;/script&gt;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-17-白天-黑夜模式切换动画">3.17 白天/黑夜模式切换动画</h3><p>参考<a href="https://akilar.top/posts/d9550c81/">《Akilarの糖果屋-添加白天夜间模式转换动画》</a></p><p>新建 <code>[Blogroot]\themes\butterfly\layout\includes\custom\light_dark.pug</code>, 这部分其实实质上就是一个 svg 文件，通过 js 操作它的旋转显隐，淡入淡出实现动画效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svg(aria-hidden=&#x27;true&#x27;, style=&#x27;position:absolute; overflow:hidden; width:0; height:0&#x27;)  </span><br><span class="line">  symbol#icon-sun(viewBox=&#x27;0 0 1024 1024&#x27;)  </span><br><span class="line">    path(d=&#x27;M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z&#x27;, fill=&#x27;#FFD878&#x27;, p-id=&#x27;8420&#x27;)  </span><br><span class="line">    path(d=&#x27;M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z&#x27;, fill=&#x27;#FFE4A9&#x27;, p-id=&#x27;8421&#x27;)  </span><br><span class="line">    path(d=&#x27;M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z&#x27;, fill=&#x27;#4D5152&#x27;, p-id=&#x27;8422&#x27;)  </span><br><span class="line">    path(d=&#x27;M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z&#x27;, fill=&#x27;#4D5152&#x27;, p-id=&#x27;8423&#x27;)  </span><br><span class="line">  symbol#icon-moon(viewBox=&#x27;0 0 1024 1024&#x27;)  </span><br><span class="line">    path(d=&#x27;M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z&#x27;, fill=&#x27;#FFB531&#x27;, p-id=&#x27;11345&#x27;)  </span><br><span class="line">    path(d=&#x27;M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z&#x27;, fill=&#x27;#030835&#x27;, p-id=&#x27;11346&#x27;)</span><br></pre></td></tr></table></figure><p>新建 <code>[Blogroot]\themes\butterfly\source\css\_layout\light_dark.styl</code></p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.Cuteen_DarkSky</span>,  </span><br><span class="line"><span class="selector-class">.Cuteen_DarkSky</span><span class="selector-pseudo">:before</span>  </span><br><span class="line">  <span class="attribute">content</span> <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">  <span class="attribute">position</span> fixed  </span><br><span class="line">  <span class="attribute">left</span> <span class="number">0</span>  </span><br><span class="line">  <span class="attribute">right</span> <span class="number">0</span>  </span><br><span class="line">  <span class="attribute">top</span> <span class="number">0</span>  </span><br><span class="line">  <span class="attribute">bottom</span> <span class="number">0</span>  </span><br><span class="line">  <span class="attribute">z-index</span> <span class="number">88888888</span>  </span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.Cuteen_DarkSky</span>  </span><br><span class="line">  <span class="attribute">background</span> linear-gradient(<span class="number">#feb8b0</span>, <span class="number">#fef9db</span>)  </span><br><span class="line">  <span class="selector-pseudo">&amp;:before</span>  </span><br><span class="line">    <span class="attribute">transition</span> <span class="number">2s</span> ease all  </span><br><span class="line">    <span class="attribute">opacity</span> <span class="number">0</span>  </span><br><span class="line">    <span class="attribute">background</span> linear-gradient(<span class="number">#4c3f6d</span>, <span class="number">#6c62bb</span>, <span class="number">#93b1ed</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.DarkMode</span>  </span><br><span class="line">  <span class="selector-class">.Cuteen_DarkSky</span>  </span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span>  </span><br><span class="line">      <span class="attribute">opacity</span> <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.Cuteen_DarkPlanet</span>  </span><br><span class="line">  <span class="attribute">z-index</span> <span class="number">99999999</span>  </span><br><span class="line">  <span class="attribute">position</span> fixed  </span><br><span class="line">  <span class="attribute">left</span> -<span class="number">50%</span>  </span><br><span class="line">  <span class="attribute">top</span> -<span class="number">50%</span>  </span><br><span class="line">  <span class="attribute">width</span> <span class="number">200%</span>  </span><br><span class="line">  <span class="attribute">height</span> <span class="number">200%</span>  </span><br><span class="line">  -webkit-<span class="attribute">animation</span> CuteenPlanetMove <span class="number">2s</span> cubic-bezier(<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)  </span><br><span class="line">  <span class="attribute">animation</span> CuteenPlanetMove <span class="number">2s</span> cubic-bezier(<span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)  </span><br><span class="line">  <span class="attribute">transform-origin</span> center bottom  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> CuteenPlanetMove &#123;  </span><br><span class="line">  <span class="number">0%</span> &#123;  </span><br><span class="line">    <span class="attribute">transform</span>: rotate(<span class="number">0</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  to &#123;  </span><br><span class="line">    <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@keyframes</span> CuteenPlanetMove &#123;  </span><br><span class="line">  <span class="number">0%</span> &#123;  </span><br><span class="line">    <span class="attribute">transform</span>: rotate(<span class="number">0</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  to &#123;  </span><br><span class="line">    <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.Cuteen_DarkPlanet</span>  </span><br><span class="line">  <span class="selector-pseudo">&amp;:after</span>  </span><br><span class="line">    <span class="attribute">position</span> absolute  </span><br><span class="line">    <span class="attribute">left</span> <span class="number">35%</span>  </span><br><span class="line">    <span class="attribute">top</span> <span class="number">40%</span>  </span><br><span class="line">    <span class="attribute">width</span> <span class="number">9.375rem</span>  </span><br><span class="line">    <span class="attribute">height</span> <span class="number">9.375rem</span>  </span><br><span class="line">    <span class="attribute">border-radius</span> <span class="number">50%</span>  </span><br><span class="line">    <span class="attribute">content</span> <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">    <span class="attribute">background</span> linear-gradient(<span class="number">#fefefe</span>, <span class="number">#fffbe8</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.search</span>  </span><br><span class="line">  <span class="selector-tag">span</span>  </span><br><span class="line">    <span class="attribute">display</span> none  </span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.menus_item</span>  </span><br><span class="line">  <span class="selector-tag">a</span>  </span><br><span class="line">    <span class="attribute">text-decoration</span> none<span class="meta">!important</span>  </span><br></pre></td></tr></table></figure><p>新建 <code>[Blogroot]\themes\butterfly\source\js\sun_moon.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">switchNightMode</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;beforeend&#x27;</span>, <span class="string">&#x27;&lt;div class=&quot;Cuteen_DarkSky&quot;&gt;&lt;div class=&quot;Cuteen_DarkPlanet&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>),  </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;DarkMode&#x27;</span>) ? (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;isDark&#x27;</span>, <span class="string">&#x27;0&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-moon&#x27;</span>)) : (<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;isDark&#x27;</span>, <span class="string">&#x27;1&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-sun&#x27;</span>)),  </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">transition</span> = <span class="string">&#x27;opacity 3s&#x27;</span>;  </span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;0&#x27;</span>;  </span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;Cuteen_DarkSky&#x27;</span>)[<span class="number">0</span>].<span class="title function_">remove</span>();  </span><br><span class="line">          &#125;, <span class="number">1e3</span>);  </span><br><span class="line">        &#125;, <span class="number">2e3</span>)  </span><br><span class="line">    &#125;)  </span><br><span class="line">  <span class="keyword">const</span> nowMode = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>) === <span class="string">&#x27;dark&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>  </span><br><span class="line">  <span class="keyword">if</span> (nowMode === <span class="string">&#x27;light&#x27;</span>) &#123;  </span><br><span class="line">    <span class="title function_">activateDarkMode</span>()  </span><br><span class="line">    saveToLocal.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>, <span class="number">2</span>)  </span><br><span class="line">    <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span> !== <span class="literal">undefined</span> &amp;&amp; btf.<span class="title function_">snackbarShow</span>(<span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span>.<span class="property">day_to_night</span>)  </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-sun&#x27;</span>)  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="title function_">activateLightMode</span>()  </span><br><span class="line">    saveToLocal.<span class="title function_">set</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;light&#x27;</span>, <span class="number">2</span>)  </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;DarkMode&#x27;</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;modeicon&#x27;</span>).<span class="title function_">setAttribute</span>(<span class="string">&#x27;xlink:href&#x27;</span>, <span class="string">&#x27;#icon-moon&#x27;</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// handle some cases  </span></span><br><span class="line">  <span class="keyword">typeof</span> utterancesTheme === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="title function_">utterancesTheme</span>()  </span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable constant_">FB</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title function_">loadFBComment</span>()  </span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">DISQUS</span> &amp;&amp; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disqus_thread&#x27;</span>).<span class="property">children</span>.<span class="property">length</span> &amp;&amp; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">disqusReset</span>(), <span class="number">200</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>[Blogroot]\themes\butterfly\layout\includes\rightside.pug</code>, 把原本的昼夜切换按钮替换掉</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  when &#x27;translate&#x27;  </span><br><span class="line">    if translate.enable  </span><br><span class="line">      button#translateLink(type=&quot;button&quot; title=_p(&#x27;rightside.translate_title&#x27;))= translate.default  </span><br><span class="line">  when &#x27;darkmode&#x27;  </span><br><span class="line">    if darkmode.enable &amp;&amp; darkmode.button  </span><br><span class="line"><span class="deletion">-     button#darkmode(type=&quot;button&quot; title=_p(&#x27;rightside.night_mode_title&#x27;))  </span></span><br><span class="line"><span class="deletion">-       i.fas.fa-adjust  </span></span><br><span class="line"><span class="addition">+     a.hidden(onclick=&#x27;switchNightMode()&#x27;,  title=_p(&#x27;rightside.night_mode_title&#x27;))  </span></span><br><span class="line"><span class="addition">+       i.fas.fa-adjust  </span></span><br><span class="line"><span class="addition">+         use#modeicon(xlink:href=&#x27;#icon-moon&#x27;)</span></span><br></pre></td></tr></table></figure><p>修改 <code>[Blogroot]\_config.butterfly.yml</code>, 引入一下 js</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span>  </span><br><span class="line">  <span class="attr">head:</span>  </span><br><span class="line">  <span class="attr">bottome:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/sun_moon.js&quot;</span> <span class="string">async&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-18-twikoo评论气泡风格">3.18 twikoo评论气泡风格</h3><p>参考<a href="https://akilar.top/posts/d99b5f01/">《Akilarの糖果屋-twikoo 评论块气泡风格魔改美化》</a></p><p>新建 <code>[Blogroot]\themes\butterfly\source\css\custom\twikoo_beautify.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 调整表情大小 */</span></span><br><span class="line"><span class="selector-class">.OwO</span> <span class="selector-class">.OwO-body</span> <span class="selector-class">.OwO-items-image</span> <span class="selector-class">.OwO-item</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="built_in">calc</span>(<span class="number">25%</span> - <span class="number">10px</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整表情位置 */</span></span><br><span class="line"><span class="selector-class">.tk-content</span> <span class="selector-tag">img</span><span class="selector-class">.tk-owo-emotion</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义twikoo评论输入框高度 */</span></span><br><span class="line"><span class="selector-class">.tk-input</span><span class="selector-attr">[data-v-619b4c52]</span> <span class="selector-class">.el-textarea__inner</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">130px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入评论时自动隐藏输入框背景图片 */</span></span><br><span class="line"><span class="selector-class">.tk-input</span><span class="selector-attr">[data-v-619b4c52]</span> <span class="selector-class">.el-textarea__inner</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整楼中楼样式 ，整体左移，贴合气泡化效果 */</span></span><br><span class="line"><span class="selector-class">.tk-replies</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> + <span class="number">70px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 头像宽度调整 rem单位与全局字体大小挂钩，需配合自己情况调整大小以保证头像显示完整 */</span></span><br><span class="line"><span class="selector-class">.tk-avatar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">3rem</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3rem</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-avatar</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">3rem</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">3rem</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回复框左移，避免窄屏时出框 */</span></span><br><span class="line"><span class="selector-class">.tk-comments-container</span> <span class="selector-class">.tk-submit</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">110%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 评论块气泡化修改 */</span></span><br><span class="line"><span class="selector-class">.tk-content</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#00a6ff</span>; <span class="comment">/* 默认模式访客气泡配色 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white; <span class="comment">/* 默认模式访客气泡字体配色 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: fit-content;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: visible <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修复图片出框 */</span></span><br><span class="line"><span class="selector-class">.tk-content</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修复过长文本出框 */</span></span><br><span class="line"><span class="selector-class">.tk-content</span> pre &#123;</span><br><span class="line">    <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-content</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#eeecaa</span>; <span class="comment">/* 默认模式超链接配色 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">2px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">15px</span> solid <span class="number">#00a6ff</span>; <span class="comment">/* 默认模式访客气泡小三角配色 */</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ff8080</span>; <span class="comment">/* 默认模式博主气泡配色 */</span></span><br><span class="line">    <span class="attribute">color</span>: white; <span class="comment">/* 默认模式博主气泡字体配色 */</span></span><br><span class="line">    <span class="attribute">width</span>: fit-content;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">9px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#eeecaa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">2px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">15px</span> solid <span class="number">#ff8080</span>; <span class="comment">/* 默认模式博主气泡小三角配色 */</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-row</span><span class="selector-attr">[data-v-d82ce9a0]</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: fit-content;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-avatar</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-master</span> <span class="selector-class">.tk-avatar</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 夜间模式配色，具体比照上方默认模式class */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-content</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#1d1d1f</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-content</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#dfa036</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">15px</span> solid <span class="number">#1d1d1f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#1c1c1e</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#dfa036</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">2px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">15px</span> solid <span class="number">#1c1c1e</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自适应内容 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 设置宽度上限，避免挤压博主头像 */</span></span><br><span class="line">    <span class="selector-class">.tk-content</span> &#123;</span><br><span class="line">        <span class="attribute">max-width</span>: <span class="number">75%</span>;</span><br><span class="line">        <span class="attribute">width</span>: fit-content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">80px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">border-left</span>: <span class="number">15px</span> solid <span class="number">#ff8080</span>;</span><br><span class="line">        <span class="attribute">border-right</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-avatar</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">75%</span> + <span class="number">120px</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-row</span><span class="selector-attr">[data-v-d82ce9a0]</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">55%</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.tk-master</span> <span class="selector-class">.tk-content</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">border-left</span>: <span class="number">15px</span> solid <span class="number">#1c1c1e</span>;</span><br><span class="line">        <span class="attribute">border-right</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备名称常态隐藏，悬停评论时显示 */</span></span><br><span class="line"><span class="selector-class">.tk-extras</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    -ms-<span class="attribute">filter</span>: <span class="string">&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=0)&quot;</span>;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tk-content</span><span class="selector-pseudo">:hover</span> + <span class="selector-class">.tk-extras</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">animation</span>: tk-extras-fadeIn <span class="number">0.5s</span> linear;</span><br><span class="line">    -moz-<span class="attribute">animation</span>: tk-extras-fadeIn <span class="number">0.5s</span> linear;</span><br><span class="line">    -o-<span class="attribute">animation</span>: tk-extras-fadeIn <span class="number">0.5s</span> linear;</span><br><span class="line">    -ms-<span class="attribute">animation</span>: tk-extras-fadeIn <span class="number">0.5s</span> linear;</span><br><span class="line">    <span class="attribute">animation</span>: tk-extras-fadeIn <span class="number">0.5s</span> linear;</span><br><span class="line">    -webkit-<span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">    -moz-<span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">    -o-<span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">    -ms-<span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> tk-extras-fadeIn &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: <span class="string">&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=0)&quot;</span>;</span><br><span class="line">        <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: none;</span><br><span class="line">        <span class="attribute">filter</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> tk-extras-fadeIn &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: <span class="string">&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=0)&quot;</span>;</span><br><span class="line">        <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: none;</span><br><span class="line">        <span class="attribute">filter</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> tk-extras-fadeIn &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: <span class="string">&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=0)&quot;</span>;</span><br><span class="line">        <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: none;</span><br><span class="line">        <span class="attribute">filter</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> tk-extras-fadeIn &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: <span class="string">&quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=0)&quot;</span>;</span><br><span class="line">        <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">        -ms-<span class="attribute">filter</span>: none;</span><br><span class="line">        <span class="attribute">filter</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>[Blogroot]\_config.butterfly.yml</code> 的 <code>inject</code> 配置项</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  inject:  </span><br><span class="line">    head:  </span><br><span class="line"><span class="addition">+     - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom/twikoo_beautify.css&quot;  media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-19-留言板">3.19 留言板</h3><p>参考<a href="https://akilar.top/posts/e2d3c450/">《Akilarの糖果屋-信笺样式留言板》</a></p><p>安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-envelope --save</span><br></pre></td></tr></table></figure><p>在站点配置文件或者主题配置文件添加配置项（对，两者任一均可。但不要都写）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># envelope_comment  </span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/58900a8/  </span></span><br><span class="line"><span class="attr">envelope_comment:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#开关  </span></span><br><span class="line">  <span class="attr">cover:</span> <span class="string">https://ae01.alicdn.com/kf/U5bb04af32be544c4b41206d9a42fcacfd.jpg</span> <span class="comment">#信笺封面图  </span></span><br><span class="line">  <span class="attr">message:</span> <span class="comment">#信笺内容，支持多行  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想问的？</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想说的？</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">有什么想吐槽的？</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">哪怕是有什么想吃的，都可以告诉我哦~</span>  </span><br><span class="line">  <span class="attr">bottom:</span> <span class="string">自动书记人偶竭诚为您服务！</span> <span class="comment">#信笺结束语，只能单行  </span></span><br><span class="line">  <span class="attr">height:</span> <span class="comment">#调整信笺划出高度，默认1050px  </span></span><br><span class="line">  <span class="attr">path:</span> <span class="comment">#【可选】comments 的路径名称。默认为 comments，生成的页面为 comments/index.html  </span></span><br><span class="line">  <span class="attr">front_matter:</span> <span class="comment">#【可选】comments页面的 front_matter 配置  </span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">留言板</span>  </span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>修改留言页：打开<code>[Blogroot]\node_modules\hexo-butterfly-envelope\lib\html.pug</code>，在文件末尾添加自己想要的内容。</p><blockquote><p>HTML转PUG在线工具：<a href="http://www.html2jade.org/">http://www.html2jade.org/</a></p></blockquote><h3 id="3-20-GitCalendar提交日历">3.20 GitCalendar提交日历</h3><p>项目地址：<a href="https://github.com/Zfour/hexo-github-calendar">https://github.com/Zfour/hexo-github-calendar</a></p><p><strong>（1）安装插件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-githubcalendar --save  </span><br></pre></td></tr></table></figure><p><strong>（2）新增网站根目录_config 配置项 (不是主题的)</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-filter-gitcalendar</span></span><br><span class="line"><span class="comment"># see https://akilar.top/posts/1f9c68c9/</span></span><br><span class="line"><span class="attr">gitcalendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 开关</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">5</span> <span class="comment">#过滤器优先权</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">/</span> <span class="comment"># 应用页面</span></span><br><span class="line">  <span class="comment"># butterfly挂载容器</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="comment"># 挂载容器类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment"># volantis挂载容器</span></span><br><span class="line">  <span class="comment"># layout:</span></span><br><span class="line">  <span class="comment">#   type: class</span></span><br><span class="line">  <span class="comment">#   name: l_main</span></span><br><span class="line">  <span class="comment">#   index: 0</span></span><br><span class="line">  <span class="comment"># matery挂载容器</span></span><br><span class="line">  <span class="comment"># layout:</span></span><br><span class="line">  <span class="comment">#   type: id</span></span><br><span class="line">  <span class="comment">#   name: indexCard</span></span><br><span class="line">  <span class="comment">#   index: 0</span></span><br><span class="line">  <span class="comment"># mengd挂载容器</span></span><br><span class="line">  <span class="comment"># layout:</span></span><br><span class="line">  <span class="comment">#   type: class</span></span><br><span class="line">  <span class="comment">#   name: content</span></span><br><span class="line">  <span class="comment">#   index: 0</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">HuffieMa</span> <span class="comment">#git用户名</span></span><br><span class="line">  <span class="attr">apiurl:</span> <span class="string">&#x27;https://githubapi.ryanchristian.dev/user/&#x27;</span></span><br><span class="line">  <span class="attr">minheight:</span></span><br><span class="line">    <span class="attr">pc:</span> <span class="string">280px</span> <span class="comment">#桌面端最小高度</span></span><br><span class="line">    <span class="attr">mibile:</span> <span class="string">0px</span> <span class="comment">#移动端最小高度</span></span><br><span class="line">  <span class="comment"># color: &quot;[&#x27;#e4dfd7&#x27;, &#x27;#f9f4dc&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f7e8aa&#x27;, &#x27;#f8df72&#x27;, &#x27;#fcd217&#x27;, &#x27;#fcc515&#x27;, &#x27;#f28e16&#x27;, &#x27;#fb8b05&#x27;, &#x27;#d85916&#x27;, &#x27;#f43e06&#x27;]&quot; #橘黄色调</span></span><br><span class="line">  <span class="comment"># color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#fdcdec&#x27;, &#x27;#fc9bd9&#x27;, &#x27;#fa6ac5&#x27;, &#x27;#f838b2&#x27;, &#x27;#f5089f&#x27;, &#x27;#c4067e&#x27;, &#x27;#92055e&#x27;, &#x27;#540336&#x27;, &#x27;#48022f&#x27;, &#x27;#30021f&#x27;]&quot; #浅紫色调</span></span><br><span class="line">  <span class="comment"># color: &quot;[&#x27;#ebedf0&#x27;, &#x27;#f0fff4&#x27;, &#x27;#dcffe4&#x27;, &#x27;#bef5cb&#x27;, &#x27;#85e89d&#x27;, &#x27;#34d058&#x27;, &#x27;#28a745&#x27;, &#x27;#22863a&#x27;, &#x27;#176f2c&#x27;, &#x27;#165c26&#x27;, &#x27;#144620&#x27;]&quot; #翠绿色调</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;[&#x27;#ebedf0&#x27;, &#x27;#f1f8ff&#x27;, &#x27;#dbedff&#x27;, &#x27;#c8e1ff&#x27;, &#x27;#79b8ff&#x27;, &#x27;#2188ff&#x27;, &#x27;#0366d6&#x27;, &#x27;#005cc5&#x27;, &#x27;#044289&#x27;, &#x27;#032f62&#x27;, &#x27;#05264c&#x27;]&quot;</span> <span class="comment">#天青色调</span></span><br><span class="line">  <span class="attr">container:</span> <span class="string">.recent-post-item(style=&#x27;width:100%;height:auto;padding:10px;&#x27;)</span> <span class="comment">#父元素容器，需要使用pug语法</span></span><br><span class="line">  <span class="attr">gitcalendar_css:</span> <span class="string">https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.css</span></span><br><span class="line">  <span class="attr">gitcalendar_js:</span> <span class="string">https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.js</span></span><br></pre></td></tr></table></figure><p>更多配置项含义请到<a href="https://zfe.space/post/hexo-githubcalendar.html">https://zfe.space/post/hexo-githubcalendar.html</a>查看。</p><p>重新<code>hexo clean</code>,<code>hexo g</code>, <code>hexo s</code>即可看到效果</p><p><strong>ps.官方api被墙了，可以参考<a href="https://github.com/zkeq/python_github_calendar_api">https://github.com/zkeq/python_github_calendar_api</a>在Vercel部署自己的API，然后绑定自己的域名</strong></p><h3 id="3-21-版权声明页美化">3.21 版权声明页美化</h3><p>编辑<code>butterfly/layout/includes/post/post-copyright.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">if theme.post_copyright.enable &amp;&amp; page.copyright !== false</span><br><span class="line">  - let author = page.copyright_author ? page.copyright_author : config.author</span><br><span class="line">  - let url = page.copyright_url ? page.copyright_url : page.permalink</span><br><span class="line">  - let license = page.license ? page.license : theme.post_copyright.license</span><br><span class="line">  - let license_url = page.license_url ? page.license_url : theme.post_copyright.license_url</span><br><span class="line">  .post-copyright</span><br><span class="line">    .post-copyright__title</span><br><span class="line">      span.post-copyright-info</span><br><span class="line">        h #[=page.title]</span><br><span class="line">    .post-copyright__type</span><br><span class="line">      span.post-copyright-info</span><br><span class="line">        a(href=url_for(url))= theme.post_copyright.decode ? decodeURI(url) : url</span><br><span class="line">    .post-copyright-m</span><br><span class="line">      .post-copyright-m-info</span><br><span class="line">        .post-copyright-a</span><br><span class="line">            h 作者</span><br><span class="line">            .post-copyright-cc-info</span><br><span class="line">                h=author</span><br><span class="line">        .post-copyright-c</span><br><span class="line">            h 发布于</span><br><span class="line">            .post-copyright-cc-info</span><br><span class="line">                h=date(page.date, config.date_format)</span><br><span class="line">        .post-copyright-u</span><br><span class="line">            h 更新于</span><br><span class="line">            .post-copyright-cc-info</span><br><span class="line">                h=date(page.updated, config.date_format)</span><br><span class="line">        .post-copyright-c</span><br><span class="line">            h 许可协议</span><br><span class="line">            .post-copyright-cc-info</span><br><span class="line">                a.icon(rel=&#x27;noopener&#x27; target=&#x27;_blank&#x27; title=&#x27;Creative Commons&#x27; href=&#x27;https://creativecommons.org/&#x27;)</span><br><span class="line">                  i.fab.fa-creative-commons</span><br><span class="line">                a(rel=&#x27;noopener&#x27; target=&#x27;_blank&#x27; title=license href=url_for(license_url))=license</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编辑<code>butterfly/source/css/_layout/post.styl</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line">beautify()</span><br><span class="line">  headStyle(fontsize)</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="built_in">unit</span>(fontsize + .<span class="number">4</span>, <span class="string">&#x27;rem&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    code</span><br><span class="line">      font-size: <span class="built_in">unit</span>(fontsize, <span class="string">&#x27;rem&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &amp;:before</span><br><span class="line">      margin-left: <span class="built_in">unit</span>((<span class="built_in">-</span>(fontsize + .<span class="number">2</span>)), <span class="string">&#x27;rem&#x27;</span>)</span><br><span class="line">      font-size: <span class="built_in">unit</span>(fontsize, <span class="string">&#x27;rem&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      padding-left: <span class="built_in">unit</span>(fontsize + .<span class="number">6</span>, <span class="string">&#x27;rem&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  h1,</span><br><span class="line">  h2,</span><br><span class="line">  h3,</span><br><span class="line">  h4,</span><br><span class="line">  h5,</span><br><span class="line">  h6</span><br><span class="line">    transition: all .<span class="number">2s</span> ease-out</span><br><span class="line"></span><br><span class="line">    &amp;:before</span><br><span class="line">      position: absolute</span><br><span class="line">      top: <span class="built_in">calc</span>(<span class="number">50%</span> - .<span class="number">35rem</span>)</span><br><span class="line">      color: $title-prefix-icon-color</span><br><span class="line">      content: $title-prefix-icon</span><br><span class="line">      line-height: <span class="number">1</span></span><br><span class="line">      transition: all .<span class="number">2s</span> ease-out</span><br><span class="line">      @extend .fontawesomeIcon</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      &amp;:before</span><br><span class="line">        color: $light-blue</span><br><span class="line"></span><br><span class="line">  h1</span><br><span class="line">    <span class="built_in">headStyle</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  h2</span><br><span class="line">    <span class="built_in">headStyle</span>(.<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">  h3</span><br><span class="line">    <span class="built_in">headStyle</span>(.<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  h4</span><br><span class="line">    <span class="built_in">headStyle</span>(.<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">  h5</span><br><span class="line">    <span class="built_in">headStyle</span>(.<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  h6</span><br><span class="line">    <span class="built_in">headStyle</span>(.<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  ol,</span><br><span class="line">  ul</span><br><span class="line">    margin-top: .<span class="number">4rem</span></span><br><span class="line">    padding: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> .<span class="number">8rem</span></span><br><span class="line">    list-style: none</span><br><span class="line">    counter-reset: li</span><br><span class="line"></span><br><span class="line">    +<span class="built_in">maxWidth768</span>()</span><br><span class="line">      padding: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> .<span class="number">4rem</span></span><br><span class="line"></span><br><span class="line">    p</span><br><span class="line">      margin: <span class="number">0</span> <span class="number">0</span> .<span class="number">5rem</span></span><br><span class="line"></span><br><span class="line">    ol,</span><br><span class="line">    ul</span><br><span class="line">      padding-left: .<span class="number">6rem</span></span><br><span class="line"></span><br><span class="line">      +<span class="built_in">maxWidth768</span>()</span><br><span class="line">        padding-left: .<span class="number">2rem</span></span><br><span class="line"></span><br><span class="line">    li</span><br><span class="line">      &amp;:<span class="built_in">not</span>(.tab)</span><br><span class="line">        position: relative</span><br><span class="line">        margin: .<span class="number">2rem</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      &amp;:hover</span><br><span class="line">        &amp;:before</span><br><span class="line">          transform: <span class="built_in">rotate</span>(<span class="number">360deg</span>)</span><br><span class="line"></span><br><span class="line">      &amp;:before</span><br><span class="line">        position: absolute</span><br><span class="line">        top: <span class="number">0</span></span><br><span class="line">        left: <span class="number">0</span></span><br><span class="line">        background: $light-blue</span><br><span class="line">        color: $white</span><br><span class="line">        cursor: pointer</span><br><span class="line">        transition: all .<span class="number">3s</span> ease-out</span><br><span class="line"></span><br><span class="line">  ol</span><br><span class="line">    &gt; li</span><br><span class="line">      &amp;:<span class="built_in">not</span>(.tab)</span><br><span class="line">        padding: .<span class="number">2em</span> .<span class="number">2em</span> .<span class="number">2em</span> <span class="number">1.8em</span></span><br><span class="line"></span><br><span class="line">      &amp;:before</span><br><span class="line">        margin-top: .<span class="number">65em</span></span><br><span class="line">        width: w = <span class="number">1.45em</span></span><br><span class="line">        height: h = w</span><br><span class="line">        border-radius: .<span class="number">5</span> * w</span><br><span class="line">        content: <span class="built_in">counter</span>(li)</span><br><span class="line">        counter-increment: li</span><br><span class="line">        text-align: center</span><br><span class="line">        font-size: .<span class="number">85em</span></span><br><span class="line">        line-height: h</span><br><span class="line"></span><br><span class="line">  ul</span><br><span class="line">    &gt; li:<span class="built_in">not</span>(.tab)</span><br><span class="line">      padding: .<span class="number">2em</span> .<span class="number">2em</span> .<span class="number">2em</span> <span class="number">1.4em</span></span><br><span class="line"></span><br><span class="line">      &amp;:hover</span><br><span class="line">        &amp;:before</span><br><span class="line">          border-color: $pseudo-hover</span><br><span class="line"></span><br><span class="line">      &amp;:before</span><br><span class="line">        $w = .<span class="number">42em</span></span><br><span class="line">        top: .<span class="number">78em</span></span><br><span class="line">        width: w = $w</span><br><span class="line">        height: h = w</span><br><span class="line">        border: .<span class="number">5</span> * w solid $light-blue</span><br><span class="line">        border-radius: w</span><br><span class="line">        background: transparent</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        line-height: h</span><br><span class="line"></span><br><span class="line"><span class="built_in">no-beautify</span>()</span><br><span class="line">  ol,</span><br><span class="line">  ul</span><br><span class="line">    margin-top: .<span class="number">4rem</span></span><br><span class="line"></span><br><span class="line">    p</span><br><span class="line">      margin: <span class="number">0</span> <span class="number">0</span> .<span class="number">5rem</span></span><br><span class="line"></span><br><span class="line">    ol,</span><br><span class="line">    ul</span><br><span class="line">      padding-left: .<span class="number">5rem</span></span><br><span class="line"></span><br><span class="line">    li</span><br><span class="line">      position: relative</span><br><span class="line">      margin: .<span class="number">3rem</span> <span class="number">0</span></span><br><span class="line">      padding-left: .<span class="number">3rem</span></span><br><span class="line"></span><br><span class="line">#article-container</span><br><span class="line">  word-wrap: break-word</span><br><span class="line">  overflow-wrap: break-word</span><br><span class="line"></span><br><span class="line">  a</span><br><span class="line">    color: $theme-link-color</span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      text-decoration: underline</span><br><span class="line"></span><br><span class="line">  img</span><br><span class="line">    display: block</span><br><span class="line">    margin: <span class="number">0</span> auto .<span class="number">8rem</span></span><br><span class="line"></span><br><span class="line">  p</span><br><span class="line">    margin: <span class="number">0</span> <span class="number">0</span> .<span class="number">8rem</span></span><br><span class="line"></span><br><span class="line">  iframe</span><br><span class="line">    margin: <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span></span><br><span class="line"></span><br><span class="line">  if <span class="built_in">hexo-config</span>(<span class="string">&#x27;beautify.enable&#x27;</span>) &amp;&amp; <span class="built_in">hexo-config</span>(<span class="string">&#x27;beautify.field&#x27;</span>) == <span class="string">&#x27;site&#x27;</span></span><br><span class="line">    <span class="built_in">beautify</span>()</span><br><span class="line">  else if <span class="built_in">hexo-config</span>(<span class="string">&#x27;beautify.enable&#x27;</span>) &amp;&amp; <span class="built_in">hexo-config</span>(<span class="string">&#x27;beautify.field&#x27;</span>) == <span class="string">&#x27;post&#x27;</span></span><br><span class="line">    <span class="built_in">no-beautify</span>()</span><br><span class="line"></span><br><span class="line">    &amp;.post-content</span><br><span class="line">      <span class="built_in">beautify</span>()</span><br><span class="line">  else</span><br><span class="line">    <span class="built_in">no-beautify</span>()</span><br><span class="line"></span><br><span class="line">#post</span><br><span class="line">  .tag_share</span><br><span class="line">    .post-meta</span><br><span class="line">      &amp;__tag-list</span><br><span class="line">        display: inline-block</span><br><span class="line"></span><br><span class="line">      &amp;__tags</span><br><span class="line">        display: inline-block</span><br><span class="line">        margin: .<span class="number">4rem</span> .<span class="number">4rem</span> .<span class="number">4rem</span> <span class="number">0</span></span><br><span class="line">        padding: <span class="number">0</span> .<span class="number">6rem</span></span><br><span class="line">        width: fit-content</span><br><span class="line">        border: <span class="number">1px</span> solid $light-blue</span><br><span class="line">        border-radius: .<span class="number">6rem</span></span><br><span class="line">        color: $light-blue</span><br><span class="line">        font-size: .<span class="number">85em</span></span><br><span class="line">        transition: all .<span class="number">2s</span> ease-in-out</span><br><span class="line"></span><br><span class="line">        &amp;:hover</span><br><span class="line">          background: $light-blue</span><br><span class="line">          color: <span class="built_in">var</span>(--white)</span><br><span class="line"></span><br><span class="line">    .post_share</span><br><span class="line">      display: inline-block</span><br><span class="line">      float: right</span><br><span class="line">      margin: .<span class="number">4rem</span> <span class="number">0</span></span><br><span class="line">      width: fit-content</span><br><span class="line"></span><br><span class="line">      .social-share</span><br><span class="line">        font-size: .<span class="number">85em</span></span><br><span class="line"></span><br><span class="line">        .social-share-icon</span><br><span class="line">          margin: <span class="number">0</span> <span class="number">4px</span></span><br><span class="line">          width: w = <span class="number">1.85em</span></span><br><span class="line">          height: w</span><br><span class="line">          font-size: <span class="number">1.2em</span></span><br><span class="line">          line-height: w</span><br><span class="line"></span><br><span class="line">  .post-copyright</span><br><span class="line">    position: relative</span><br><span class="line">    margin: <span class="number">2rem</span> <span class="number">0</span> .<span class="number">5rem</span></span><br><span class="line">    padding: .<span class="number">5rem</span> .<span class="number">8rem</span></span><br><span class="line">    border: <span class="number">1px</span> solid <span class="built_in">var</span>(--light-grey)</span><br><span class="line">    transition: box-shadow .<span class="number">3s</span> ease-in-out</span><br><span class="line">    overflow: hidden</span><br><span class="line">    border-radius: <span class="number">12px</span><span class="meta">!important</span></span><br><span class="line">    background-color: <span class="built_in">rgb</span>(<span class="number">239</span> <span class="number">241</span> <span class="number">243</span>)</span><br><span class="line"></span><br><span class="line">    &amp;:before</span><br><span class="line">      background <span class="built_in">var</span>(--heo-post-blockquote-bg)</span><br><span class="line">      position absolute</span><br><span class="line">      right -<span class="number">26px</span></span><br><span class="line">      top -<span class="number">120px</span></span><br><span class="line">      content <span class="string">&#x27;\f25e&#x27;</span></span><br><span class="line">      font-size <span class="number">200px</span></span><br><span class="line">      font-family <span class="string">&#x27;Font Awesome 5 Brands&#x27;</span></span><br><span class="line">      opacity .<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    &amp;:hover</span><br><span class="line">      box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">232</span>, <span class="number">237</span>, <span class="number">250</span>, .<span class="number">6</span>), <span class="number">0</span> <span class="number">2px</span> <span class="number">4px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">232</span>, <span class="number">237</span>, <span class="number">250</span>, .<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    .post-copyright</span><br><span class="line">      &amp;-meta</span><br><span class="line">        color: $light-blue</span><br><span class="line">        font-weight: bold</span><br><span class="line"></span><br><span class="line">      &amp;-info</span><br><span class="line">        padding-left: .<span class="number">3rem</span></span><br><span class="line"></span><br><span class="line">        a</span><br><span class="line">          text-decoration: none</span><br><span class="line">          word-break: break-word</span><br><span class="line"></span><br><span class="line">          &amp;:hover</span><br><span class="line">            text-decoration: none</span><br><span class="line"></span><br><span class="line">  .post-copyright-cc-info</span><br><span class="line">    color: $theme-color;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.post-outdate-notice</span></span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">    margin: <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span></span><br><span class="line">    padding: .<span class="number">5em</span> <span class="number">1.2em</span></span><br><span class="line">    border-radius: <span class="number">15px</span></span><br><span class="line">    background-color: $noticeOutdate-bg</span><br><span class="line">    color: $noticeOutdate-color</span><br><span class="line"></span><br><span class="line">    if <span class="built_in">hexo-config</span>(<span class="string">&#x27;noticeOutdate.style&#x27;</span>) == <span class="string">&#x27;flat&#x27;</span></span><br><span class="line">      padding: .<span class="number">5em</span> <span class="number">1em</span> .<span class="number">5em</span> <span class="number">2.6em</span></span><br><span class="line">      border-left: <span class="number">5px</span> solid $noticeOutdate-border</span><br><span class="line"></span><br><span class="line">      &amp;:before</span><br><span class="line">        @extend .fontawesomeIcon</span><br><span class="line">        position: absolute</span><br><span class="line">        top: <span class="number">50%</span></span><br><span class="line">        left: .<span class="number">9em</span></span><br><span class="line">        color: $noticeOutdate-border</span><br><span class="line">        content: <span class="string">&#x27;\f071&#x27;</span></span><br><span class="line">        transform: <span class="built_in">translateY</span>(-<span class="number">50%</span>)</span><br><span class="line"></span><br><span class="line">  .ads-wrap</span><br><span class="line">    margin: <span class="number">2rem</span> <span class="number">0</span></span><br><span class="line">.post-copyright-m-info</span><br><span class="line">  .post-copyright-a,</span><br><span class="line">  .post-copyright-c,</span><br><span class="line">  .post-copyright-u</span><br><span class="line">    display inline-block</span><br><span class="line">    width fit-content</span><br><span class="line">    padding <span class="number">2px</span> <span class="number">5px</span></span><br><span class="line">[data-theme=<span class="string">&quot;dark&quot;</span>]</span><br><span class="line">  #post</span><br><span class="line">    .post-copyright</span><br><span class="line">      background-color <span class="number">#07080a</span></span><br><span class="line">      text-shadow <span class="number">#bfbeb8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span></span><br><span class="line">      border <span class="number">1px</span> solid <span class="built_in">rgb</span>(<span class="number">19</span> <span class="number">18</span> <span class="number">18</span> / <span class="number">35%</span>)</span><br><span class="line">      box-shadow <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgb</span>(<span class="number">20</span>, <span class="number">120</span>, <span class="number">210</span>)</span><br><span class="line">      animation flashlight <span class="number">1s</span> linear infinite alternate</span><br><span class="line">  .post-copyright-info</span><br><span class="line">    color <span class="number">#e0e0e4</span></span><br><span class="line"></span><br><span class="line">#post</span><br><span class="line">  .post-copyright__title</span><br><span class="line">    font-size <span class="number">22px</span></span><br><span class="line">  .post-copyright__notice</span><br><span class="line">    font-size <span class="number">15px</span></span><br><span class="line">  .post-copyright</span><br><span class="line">    box-shadow <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span></span><br><span class="line"></span><br><span class="line">@keyframes flashlight</span><br><span class="line">  from</span><br><span class="line">    box-shadow <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgb</span>(<span class="number">20</span>, <span class="number">120</span>, <span class="number">210</span>)</span><br><span class="line">  to</span><br><span class="line">    box-shadow <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="built_in">rgb</span>(<span class="number">20</span>, <span class="number">120</span>, <span class="number">210</span>)</span><br></pre></td></tr></table></figure><h3 id="3-22-滚动条美化">3.22 滚动条美化</h3><p>效果见右侧滚动条</p><p>新建 <code>Hexo\themes\butterfly\source\css\custom.css</code>(css 文件名自定义)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滚动条 */</span></span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49B1F5</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>( <span class="number">45deg</span>, <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>, transparent <span class="number">25%</span>, transparent <span class="number">50%</span>, <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>, <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>, transparent <span class="number">75%</span>, transparent);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49B1F5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件中引入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># 自定义样式（滚动条）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom/custom.css&quot;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-23-个性化浏览器标题">3.23 个性化浏览器标题</h3><p>实现浏览器切到别的网页时显示特定文字，切回自己博客时显示特定文字2s。</p><p>新建 <code>Hexo\themes\butterfly\source\js\custom.js</code>(js 文件名自定义)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 个性化Title</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OriginTitle</span> = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="title function_">attr</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;/img/favicon.ico&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;HalfA博客&#x27;</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="title function_">attr</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;/img/favicon.ico&quot;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;欢迎回来~~&#x27;</span> + <span class="title class_">OriginTitle</span>;</span><br><span class="line">        titleTime = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">title</span> = <span class="title class_">OriginTitle</span>;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在主题配置文件中引入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># 自定义JS（个性化标题）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/custom/custom.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-24-导航栏美化">3.24 导航栏美化</h3><p>参考：<a href="https://yisous.xyz/posts/895003b5/">关于Butterfly的导航栏的一些教程 | Ariasakaの小窝 (yisous.xyz)</a></p><p><strong>（1）分离搜索栏与菜单栏</strong></p><p>修改[blogRoot]\themes\Butterfly\layout\includes\header\nav.pug:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  span#blog_name</span><br><span class="line">    a#site-name(href=url_for(&#x27;/&#x27;)) #[=config.title]</span><br><span class="line">    </span><br><span class="line">  #menus</span><br><span class="line">-    if (theme.algolia_search.enable || theme.local_search.enable)</span><br><span class="line">-      #search-button</span><br><span class="line">-        a.site-page.social-icon.search</span><br><span class="line">-          i.fas.fa-search.fa-fw</span><br><span class="line">-          span=&#x27; &#x27;+_p(&#x27;search.title&#x27;)</span><br><span class="line">  !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">  #nav-right</span><br><span class="line">+    if (theme.algolia_search.enable || theme.local_search.enable)</span><br><span class="line">+      #search-button</span><br><span class="line">+        a.site-page.social-icon.search</span><br><span class="line">+          i.fas.fa-search.fa-fw</span><br><span class="line">-    #toggle-menu</span><br><span class="line">-      a.site-page</span><br><span class="line">-        i.fas.fa-bars.fa-fw</span><br><span class="line">+      #toggle-menu</span><br><span class="line">+        a.site-page</span><br><span class="line">+          i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><p><strong>（2）导航栏居中</strong></p><p>在你的自定义css里面添加下面几句CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav-right</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>:<span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>:nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）去除导航栏底部的蓝条</strong></p><p>添加如下的css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> *<span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）子菜单横向布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menus_item_child</span> <span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#sidebar-menus</span> <span class="selector-tag">li</span>)&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span><span class="meta">!important</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">6px</span><span class="meta">!important</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">6px</span><span class="meta">!important</span>;</span><br><span class="line">    -ms-<span class="attribute">border-radius</span>: <span class="number">6px</span><span class="meta">!important</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">6px</span><span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menus_item_child</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#sidebar-menus</span> <span class="selector-tag">ul</span>)&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    left:calc(-150%)!important;这是估算值，为了保持元素居中的，如果不合适可以自己调</span></span><br><span class="line"><span class="comment">  改为：*/</span></span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  translate:-<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）鼠标移动到左上角网站名称的悬浮动画</strong></p><p>添加css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#site-name</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--lyx-theme)<span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    -ms-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">transition</span>: .<span class="number">3s</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: .<span class="number">3s</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: .<span class="number">3s</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: .<span class="number">3s</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: .<span class="number">3s</span>;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\f015&quot;</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">var</span>(--lyx-theme);</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Font Awesome 6 Free&quot;</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">34px</span>;<span class="comment">/*如果有溢出或者垂直不居中的现象微调一下这个参数*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;<span class="comment">/*根据个人喜好*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#site-name</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    scale:<span class="number">1.03</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#site-name</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>; <span class="comment">/*一定要把字体调大点，否则效果惨不忍睹！*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attr">--lyx-theme</span>:<span class="number">#ed709b</span> <span class="comment">/*我的主题色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（6）导航栏顶栏常驻</strong></p><p>添加css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav-fixed</span> <span class="selector-id">#nav</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">58px</span>)<span class="meta">!important</span>;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">58px</span>)<span class="meta">!important</span>;</span><br><span class="line">    -moz-<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">58px</span>)<span class="meta">!important</span>;</span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">58px</span>)<span class="meta">!important</span>;</span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">58px</span>)<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: none<span class="meta">!important</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: none<span class="meta">!important</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: none<span class="meta">!important</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: none<span class="meta">!important</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: none<span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（7）向上滑动显示导航栏，向下滑动显示文章名</strong></p><p>修改<code>[blogRoot]\themes\Butterfly\layout\includes\header\nav.pug</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span><span class="selector-id">#nav</span></span><br><span class="line">  <span class="selector-tag">span</span><span class="selector-id">#blog_name</span></span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-id">#site-name</span>(href=url_for(&#x27;/&#x27;)) #<span class="selector-attr">[=config.title]</span></span><br><span class="line">    </span><br><span class="line">  <span class="selector-id">#menus</span></span><br><span class="line">    !=partial(&#x27;includes/<span class="selector-tag">header</span>/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">+    center(id=&quot;name-container&quot;)</span><br><span class="line">+      <span class="selector-tag">a</span>(id=&quot;page-name&quot; href=&quot;javascript:<span class="built_in">scrollToTop</span>()<span class="string">&quot;) PAGE_NAME</span></span><br><span class="line"><span class="string">  ...</span></span><br></pre></td></tr></table></figure><p>添加<code>nav.js</code>，记得在主题配置文件中引用这个js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js有一个小问题：就是只要鼠标滚动不论哪里都会响应，即便你滚动的是子元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2022.9.11 已修复，需要jq，请自行引入</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;display:none&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> position = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line"></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">scroll</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scroll = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (scroll &gt; position) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;display:none!important&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;display:none&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  position = scroll;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollToTop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;display:none&quot;</span>);</span><br><span class="line">    btf.<span class="title function_">scrollToDest</span>(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复没有弄右键菜单的童鞋无法回顶部的问题</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;page-name&quot;</span>).<span class="property">innerText</span> = <span class="variable language_">document</span>.<span class="property">title</span>.<span class="title function_">split</span>(<span class="string">&quot;|&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/*这里是去掉你的网站全局名称的设置，如果你不需要去掉，你可以写成：</span></span><br><span class="line"><span class="comment">document.getElementById(&quot;page-name&quot;).innerText=document.title</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">或者把你的网站的分隔符和全局网站名称加上去*/</span></span><br></pre></td></tr></table></figure><p>最后添加如下css，按照注释修改参数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022.10.4更新：</span></span><br><span class="line"><span class="comment">根据我发现的没有自适应，间距不合理问题进行调整，如果用了这个的朋友们建议改一改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-id">#page-name</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">color</span>:white<span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&#x27;回到顶部&#x27;</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--lyx-theme);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="built_in">var</span>(--lyx-theme);</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">45px</span>; <span class="comment">/*如果垂直位置不居中可以微调此值，也可以删了*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#page-name</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">900px</span>)&#123;</span><br><span class="line">    <span class="selector-id">#page-name</span>,<span class="selector-id">#menus</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>:none<span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#name-container</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">    -o-<span class="attribute">transition</span>: all .<span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#name-container</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    scale:<span class="number">1.03</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#page-name</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">30px</span><span class="comment">/*如果文字间隔不合理可以微调修改，第二个是水平方向的padding，第一个是垂直的*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-25-使用algolia搜索系统">3.25 使用algolia搜索系统</h3><blockquote><p>参考：<a href="https://blog.csdn.net/qq_45173404/article/details/122861321">CSDN, Baret-H, Hexo集成Algolia实现搜索功能</a></p></blockquote><p><strong>（1）创建Algolia帐号并进行基本设置</strong></p><p>进入<a href="https://www.algolia.com/users/sign_in">Algolia官网</a>，进入左下角Datasources，选择Indices，新建一个名为hexo的索引。</p><p><img src="https://img.mahaofei.com/img/202311261521671.png" alt="image.png"></p><p>点击Setting-APIKeys，可以看到自己的API Key。</p><p><img src="https://img.mahaofei.com/img/202311261546171.png" alt=""></p><p><strong>（2）hexo设置</strong></p><p>安装algolia插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure><p>修改 hexo 站点根目录下的 <code>_config.yml</code>，最下方增加以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  appId: &#x27;对应Application ID&#x27;</span><br><span class="line">  apiKey: &#x27;对应Search-Only API Key&#x27;</span><br><span class="line">  adminApiKey: &quot;对应Admin API Key&quot;</span><br><span class="line">  chunkSize: 5000</span><br><span class="line">  indexName: &#x27;hexo&#x27;</span><br><span class="line">  fields:</span><br><span class="line">    - content:strip:truncate,0,500</span><br><span class="line">    - excerpt:strip</span><br><span class="line">    - gallery</span><br><span class="line">    - permalink</span><br><span class="line">    - photos</span><br><span class="line">    - slug</span><br><span class="line">    - tags</span><br><span class="line">    - title</span><br></pre></td></tr></table></figure><p>修改主题下的<code>_config.yml</code>，找到Algolia Search配置部分，将enable改为true（记得把local search改为false）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Algolia search</span></span><br><span class="line">algolia_search:</span><br><span class="line">  enable: true</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 4</span><br><span class="line">  labels:</span><br><span class="line">    # input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot;</span><br><span class="line">    hits_stats: &quot;找到$&#123;hits&#125;条结果（用时$&#123;time&#125; ms）&quot;</span><br></pre></td></tr></table></figure><p>在hexo 站点根目录下执行<code>hexo algolia</code> 来搜集数据更新到我们刚创建的 Index 中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo algolia</span><br></pre></td></tr></table></figure><p>查看效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><strong>（3）修改algolia样式</strong></p><p>部署完成后，发现algolia没有滚动条，整个搜索结果直接延伸到屏幕最下方。</p><p>打开<code>themes\butterfly\source\css\_search\algolia.styl</code>，替换为如下内容：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#algolia-search</span></span><br><span class="line">  <span class="selector-class">.search-dialog</span></span><br><span class="line">    <span class="selector-class">.ais-SearchBox</span></span><br><span class="line">      <span class="selector-tag">input</span></span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">14px</span></span><br><span class="line">        width: <span class="number">100%</span></span><br><span class="line">        outline: none</span><br><span class="line">        border: <span class="number">2px</span> solid $search-color</span><br><span class="line">        border-radius: <span class="number">40px</span></span><br><span class="line">        background: <span class="built_in">var</span>(--search-bg)</span><br><span class="line">        color: <span class="built_in">var</span>(--search-input-color)</span><br><span class="line"></span><br><span class="line">    .ais-Hits-list</span><br><span class="line">      margin: <span class="number">0</span></span><br><span class="line">      padding: <span class="number">0</span></span><br><span class="line">      @extend .list-beauty</span><br><span class="line"></span><br><span class="line">      a</span><br><span class="line">        color: <span class="built_in">var</span>(--search-result-title)</span><br><span class="line">        font-weight: bold</span><br><span class="line"></span><br><span class="line">        &amp;:hover</span><br><span class="line">          color: $search-color</span><br><span class="line"></span><br><span class="line">      mark</span><br><span class="line">        background: transparent</span><br><span class="line">        color: $search-keyword-highlight</span><br><span class="line">        font-weight: bold</span><br><span class="line"></span><br><span class="line">    .algolia-hit-item-content</span><br><span class="line">      margin: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span></span><br><span class="line">      word-break: break-all</span><br><span class="line"></span><br><span class="line">    .ais-Pagination</span><br><span class="line">      margin: <span class="number">10px</span> <span class="number">0</span></span><br><span class="line">      height: <span class="number">35px</span></span><br><span class="line">      padding: <span class="number">0</span></span><br><span class="line">      text-align: center</span><br><span class="line"></span><br><span class="line">      .ais-Pagination-list</span><br><span class="line">        margin: <span class="number">0</span></span><br><span class="line">        padding: <span class="number">0</span></span><br><span class="line">        list-style: none</span><br><span class="line"></span><br><span class="line">      .ais-Pagination-item</span><br><span class="line">        display: inline</span><br><span class="line">        margin: <span class="number">0</span> <span class="number">4px</span></span><br><span class="line">        padding: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        .ais-Pagination-link</span><br><span class="line">          display: inline-block</span><br><span class="line">          min-width: <span class="number">24px</span></span><br><span class="line">          height: <span class="number">24px</span></span><br><span class="line">          text-align: center</span><br><span class="line">          line-height: <span class="number">24px</span></span><br><span class="line"></span><br><span class="line">      .ais-Pagination-item--selected</span><br><span class="line">        a</span><br><span class="line">          background: <span class="built_in">var</span>(--leonus-main)</span><br><span class="line">          color: <span class="number">#eee</span></span><br><span class="line">          cursor: default</span><br><span class="line">          border-radius: <span class="number">5px</span></span><br><span class="line"></span><br><span class="line">      .ais-Pagination-item--disabled</span><br><span class="line">        visibility: hidden</span><br><span class="line"></span><br><span class="line">    .algolia-logo</span><br><span class="line">      padding-top: <span class="number">2px</span></span><br><span class="line">      width: <span class="number">80px</span></span><br><span class="line">      height: <span class="number">30px</span></span><br><span class="line"></span><br><span class="line">    #algolia-hits</span><br><span class="line">      &gt; div</span><br><span class="line">        overflow-y: scroll</span><br><span class="line">        </span><br><span class="line">        +<span class="built_in">minWidth768</span>()</span><br><span class="line">          max-height: <span class="built_in">calc</span>(<span class="number">80vh</span> - <span class="number">240px</span>)</span><br><span class="line"></span><br><span class="line">        +<span class="built_in">maxWidth768</span>()</span><br><span class="line">          max-height: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">260px</span>)</span><br><span class="line">          max-height: <span class="built_in">calc</span>(<span class="number">100</span>dvh - <span class="number">200px</span>)</span><br><span class="line"></span><br><span class="line">    #algolia-info</span><br><span class="line">      display: flex</span><br><span class="line">      justify-content: space-between</span><br><span class="line">      align-items: center</span><br><span class="line">      height: <span class="number">30px</span></span><br><span class="line"></span><br><span class="line">      .algolia-stats</span><br><span class="line">        font-size: <span class="number">14px</span></span><br><span class="line"></span><br><span class="line">      .algolia-poweredBy </span><br><span class="line">        display: flex;</span><br><span class="line">        <span class="attribute">justify-content</span>: right;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">90px</span></span><br><span class="line">        overflow: hidden;</span><br><span class="line">        <span class="selector-class">.ais-PoweredBy</span> <span class="selector-tag">a</span></span><br><span class="line">          <span class="attribute">display</span>:flex</span><br><span class="line">          justify-content: space-between</span><br><span class="line">          align-items: center</span><br><span class="line"></span><br><span class="line">      .ais-PoweredBy-logo path:first-child </span><br><span class="line">        display: none</span><br><span class="line"></span><br><span class="line">      .ais-PoweredBy-logo path:<span class="built_in">nth-child</span>(<span class="number">2</span>),</span><br><span class="line">      .ais-PoweredBy-logo path:<span class="built_in">nth-child</span>(<span class="number">4</span>)</span><br><span class="line">        fill: <span class="built_in">var</span>(--leonus-main)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202311261612401.png" alt="image.png"></p><h3 id="3-26-高德地图">3.26 高德地图</h3><p>在关于页面添加高德地图。</p><p><strong>（1）Key申请</strong></p><p>进入<a href="https://console.amap.com/dev/key/app">高德控制台</a>，填创建一个应用，应用名称随便。</p><p>再在该应用下面创建一个Key，Key的名称也随便。</p><p><img src="https://img.mahaofei.com/img/202311261618817.png" alt="image.png"></p><p><strong>（2）获取地图代码</strong></p><p>打开<a href="https://lbs.amap.com/tools/creater">高德开放平台</a>，输入自己想要定位的位置。快速生成代码。</p><p><img src="https://img.mahaofei.com/img/202311261624065.png" alt="image.png"></p><p><strong>（2）添加地图</strong></p><p>在你想要添加的页面中（html、md文件中都行）的位置，加入刚才获得的代码，注意修改安全密钥和Key。</p><p>以下是我的格式参考，设置了固定高度和宽度自适应。增加了一个标记点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:300px; margin: 0 auto;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">_AMapSecurityConfig</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">securityJsCode</span>:<span class="string">&#x27;你的安全密钥&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=你的Key&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//初始化地图插件</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">AMap</span>.<span class="title class_">Map</span>(<span class="string">&quot;container&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">zoom</span>: <span class="number">16</span>, <span class="comment">//设置地图显示的缩放级别</span></span></span><br><span class="line"><span class="language-javascript"><span class="attr">center</span>: [<span class="number">126.631012</span>,<span class="number">45.728771</span>] <span class="comment">//设置地图中心点坐标X：</span></span></span><br><span class="line"><span class="language-javascript"> &#125;);</span></span><br><span class="line"><span class="language-javascript"> <span class="comment">// 创建一个 Marker 实例：（标记点）</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> marker = <span class="keyword">new</span> <span class="title class_">AMap</span>.<span class="title class_">Marker</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">position</span>: <span class="keyword">new</span> <span class="title class_">AMap</span>.<span class="title class_">LngLat</span>(<span class="number">126.63101189821958</span>, <span class="number">45.72887148273063</span>), <span class="comment">// 经纬度对象，也可以是经纬度构成的一维数组[116.39, 39.9]</span></span></span><br><span class="line"><span class="language-javascript">   <span class="attr">title</span>: <span class="string">&quot;机器人技术与系统国家重点实验室&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 将创建的点标记添加到已有的地图实例：</span></span></span><br><span class="line"><span class="language-javascript">   map.<span class="title function_">add</span>(marker);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 设置label标签</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// label默认蓝框白底左上角显示，样式className为：amap-marker-label</span></span></span><br><span class="line"><span class="language-javascript">    marker.<span class="title function_">setLabel</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">offset</span>: <span class="keyword">new</span> <span class="title class_">AMap</span>.<span class="title class_">Pixel</span>(<span class="number">0</span>, <span class="number">15</span>),  <span class="comment">//设置文本标注偏移量</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">content</span>: <span class="string">&quot;&lt;div class=&#x27;info&#x27;&gt;机器人技术与系统国家重点实验室&lt;/div&gt;&quot;</span>, <span class="comment">//设置文本标注内容</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">direction</span>: <span class="string">&#x27;right&#x27;</span> <span class="comment">//设置文本标注方位</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202311261626017.png" alt="image.png"></p><h2 id="四、网站优化">四、网站优化</h2><h3 id="4-1-链接预加载">4.1 链接预加载</h3><p>当鼠标悬停到链接上超过65毫秒时，instantpage会对该链接进行预加载，提升访问速度。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://instant.page/</span></span><br><span class="line"><span class="comment"># prefetch (預加載)</span></span><br><span class="line"><span class="attr">instantpage:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="4-2-SEO优化">4.2 SEO优化</h3><p><strong>优化链接</strong></p><p>采用<code>hexo-abbrlink</code>插件实现链接，后期不管怎么修改永久链接都不会变，不用考虑分类中文化的问题，并且更利于SEO。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>配置站点文件<code>config.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p><strong>生成新的站点地图</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p><strong>百度资源平台管理站点</strong></p><p>打开<a href="https://ziyuan.baidu.com/">百度搜索资源平台</a>，进入【用户中心-站点管理-添加网站】，按照流程添加网站。</p><p>在验证阶段选择<strong>HTML标签验证</strong>，将<code>content</code>内容填入主题配置文件<code>site_verification</code>处部署后点击完成验证。</p><p>验证成功后，点击普通提交，首先提交<code>sitemap</code></p><p><img src="https://img.mahaofei.com/img/20220410152709.png" alt=""></p><p>然后如果想百度收录的更加及时，可以再配置API提交，首先需要安装额外的插件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>修改站点配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com//xxx.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><p>添加站点配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment"># 提交最新的100个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://www.mahaofei.com</span> <span class="comment"># 站点管理中添加的网站域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">xR6nigjGWFHyybFO</span> <span class="comment"># token可以在API提交页面找到</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址，新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>此后每次 <code>hexo d</code>都会进行API提交</p><p><strong>谷歌收录</strong></p><p>进入<a href="https://search.google.com/search-console/welcome">Google Search Console</a>，进行网站验证</p><p><img src="https://img.mahaofei.com/img/20220410154319.png" alt=""></p><p>验证成功后，进入配置页面，点击<strong>Sitemaps</strong>，提交自己的Sitemap文件就可以了。</p><p><img src="https://img.mahaofei.com/img/20220410154520.png" alt=""></p><h2 id="五、博客撰写">五、博客撰写</h2><h3 id="3-1-页面配置Page-Front-matter">3.1 页面配置Page Front-matter</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">type:</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标签、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏(默认true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音樂 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h3 id="3-2-文章页配置">3.2 文章页配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">--- </span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">date:</span> </span><br><span class="line"><span class="attr">updated:</span> </span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="attr">keywords:</span> </span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="attr">top _img:</span> </span><br><span class="line"><span class="attr">comments:</span> </span><br><span class="line"><span class="attr">cover:</span> </span><br><span class="line"><span class="attr">toc:</span> </span><br><span class="line"><span class="attr">toc_ number:</span> </span><br><span class="line"><span class="attr">toc _style_ simple:</span> </span><br><span class="line"><span class="attr">copyright:</span> </span><br><span class="line"><span class="attr">copyright _author:</span> </span><br><span class="line"><span class="attr">copyright_ author _href:</span> </span><br><span class="line"><span class="attr">copyright_ url:</span> </span><br><span class="line"><span class="attr">copyright _info:</span> </span><br><span class="line"><span class="attr">mathjax:</span> </span><br><span class="line"><span class="attr">katex:</span> </span><br><span class="line"><span class="attr">aplayer:</span> </span><br><span class="line"><span class="attr">highlight_ shrink:</span> </span><br><span class="line"><span class="attr">aside:</span> </span><br><span class="line"><span class="attr">stick:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章連結链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版權聲明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音樂 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏(默认true)</td></tr><tr><td>stick</td><td>【可选】文章置顶(默认0不置顶，设置1时置顶)</td></tr></tbody></table><h3 id="3-3-Butterfly主题可用功能">3.3 Butterfly主题可用功能</h3><p><strong>Tag Inline</strong></p><p>类似于查题网站，点击查看答案按钮，显示答案</p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#tag-hide">https://butterfly.js.org/posts/4aa8abbe/#tag-hide</a></p><p><strong>mermail</strong></p><p>使用mermaid标签可以绘制Flowchart（流程图）、Sequence diagram（时序图）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图）</p><p><a href="https://butterfly.js.org/posts/4aa8abbe/#mermaid">https://butterfly.js.org/posts/4aa8abbe/#mermaid</a></p><p><strong>Tabs</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125; </span><br><span class="line">&lt;!-- tab 第一个Tab --&gt; </span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line"> &lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt; </span><br><span class="line"><span class="strong">**只有图标没有Tab名字**</span></span><br><span class="line"> &lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt; </span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line"> &lt;!-- endtab --&gt; </span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p><strong>Button</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br><span class="line"></span><br><span class="line">[url] : 链接</span><br><span class="line">[text] : 按钮文字</span><br><span class="line">[icon] : [可选] 图标</span><br><span class="line">[color] : [可选] 按钮背景颜色(默认style时）</span><br><span class="line"><span class="code">                      按钮字体和边框颜色(outline时) </span></span><br><span class="line"><span class="code">                      default/blue/pink/red/purple/orange/green </span></span><br><span class="line"><span class="code">[style] : [可选] 按钮样式默认实心</span></span><br><span class="line"><span class="code">                      outline/留空</span></span><br><span class="line"><span class="code">[layout] : [可选] 按钮布局默认为line </span></span><br><span class="line"><span class="code">                      block/留空</span></span><br><span class="line"><span class="code">[position] : [可选] 按钮位置前提是设置了layout为block 默认为左边</span></span><br><span class="line"><span class="code">                      center/right/留空</span></span><br><span class="line"><span class="code">[size] : [可选] 按钮大小</span></span><br><span class="line"><span class="code">                      larger/留空</span></span><br></pre></td></tr></table></figure><p><strong>inlineImg</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineImg [src] [height] %&#125;</span><br><span class="line"></span><br><span class="line">[src] : 图片链接</span><br><span class="line">[height] ： 图片高度限制【可选】</span><br></pre></td></tr></table></figure><p><strong>label</strong></p><p>高亮所需的文字</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br><span class="line">[text] : 文字</span><br><span class="line">[color] : 【可选】背景颜色，默认为default</span><br><span class="line">default/blue/pink/red/purple/orange/green</span><br></pre></td></tr></table></figure><p><strong>timeline</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline title,color %&#125; </span><br><span class="line">&lt;!-- timeline title --&gt; </span><br><span class="line">xxxxx </span><br><span class="line">&lt;!-- endtimeline --&gt; </span><br><span class="line">&lt;!-- timeline title --&gt; </span><br><span class="line">xxxxx </span><br><span class="line">&lt;!-- endtimeline --&gt; </span><br><span class="line">&#123;% endtimeline %&#125;</span><br><span class="line"></span><br><span class="line">[title] : 标题/时间线</span><br><span class="line">[color]: timeline 颜色</span><br><span class="line">default(留空) / blue / pink / red / purple / orange / green</span><br></pre></td></tr></table></figure><p><strong>flink</strong></p><p>可在任何界面插入类似友情链接列表效果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;% flink %&#125; </span><br><span class="line"><span class="bullet">-</span> class <span class="emphasis">_name: 友情链接</span></span><br><span class="line"><span class="emphasis">  class_</span> desc: 那些人，那些事</span><br><span class="line">  link <span class="emphasis">_list: </span></span><br><span class="line"><span class="emphasis">    - name: JerryC </span></span><br><span class="line"><span class="emphasis">      link: https://jerryc.me/ </span></span><br><span class="line"><span class="emphasis">      avatar: https://jerryc.me/img/avatar.png </span></span><br><span class="line"><span class="emphasis">      descr: 今日事,今日毕</span></span><br><span class="line"><span class="emphasis">    - name: Hexo </span></span><br><span class="line"><span class="emphasis">      link: https://hexo.io/zh-tw/ </span></span><br><span class="line"><span class="emphasis">      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg </span></span><br><span class="line"><span class="emphasis">      descr: 快速、简单且强大的网志框架</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- class_</span> name: 网站</span><br><span class="line">  class <span class="emphasis">_desc: 值得推荐的网站</span></span><br><span class="line"><span class="emphasis">  link_</span> list: </span><br><span class="line"><span class="bullet">    -</span> name: Youtube </span><br><span class="line"><span class="code">      link: https://www.youtube.com/ </span></span><br><span class="line"><span class="code">      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png </span></span><br><span class="line"><span class="code">      descr: 视频网站</span></span><br><span class="line"><span class="code">    - name: Weibo </span></span><br><span class="line"><span class="code">      link: https://www.weibo.com/ </span></span><br><span class="line"><span class="code">      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png </span></span><br><span class="line"><span class="code">      descr: 中国最大社交分享平台</span></span><br><span class="line"><span class="code">    - name: Twitter </span></span><br><span class="line"><span class="code">      link: https://twitter.com/ </span></span><br><span class="line"><span class="code">      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png </span></span><br><span class="line"><span class="code">      descr: 社交分享平台</span></span><br><span class="line"><span class="code">&#123;% endflink %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="六、部分bug">六、部分bug</h2><h3 id="6-1-文章图片过大超出页面">6.1 文章图片过大超出页面</h3><p>直接截屏以<code>![]()</code>格式插入的图片，在文章页面会超出边框。</p><p><img src="https://img.mahaofei.com/img/C98R3LI2~FHRMP9UK0J6NAV.png" alt=""></p><p>解决方法：找到<code>butterfly\source\css\_layout\post.styl</code>，找到其中的<code>#article-container</code>样式，修改其中的img为如下</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span></span><br><span class="line">  <span class="attribute">display</span>: block</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto .<span class="number">8rem</span></span><br><span class="line">  <span class="attribute">height</span>: auto</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220627222530.png" alt=""></p><h2 id="七、自定义页面">七、自定义页面</h2><h3 id="7-1-如何创建自定义页面">7.1 如何创建自定义页面</h3><ol><li>在站点目录下的/source目录下新建一个custom文件夹（文件夹名字可以自定义），在其中添加写好的index.html文件（关于js、css文件的位置可以在同一目录，也可以放于其他位置，只要保证index.html引用到就好）</li><li>找到主题配置文件_config.butterfly.yml，在menu位置中添加页面的连接<code>自定义: /custom/ || fas fa-gift</code></li><li>找到主题配置文件_config.yml，在skip_render位置添加属性</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">custom/**</span> <span class="comment"># 表示custom文件里面的内容不会被站点渲染</span></span><br></pre></td></tr></table></figure><h1>博客备份</h1><p>==不建议在通过这种方式备份博客了，因为会将所有博客源代码开源==</p><h2 id="创建新分支">创建新分支</h2><p>不过在建立新分支前请确保仓库内<strong>已有master分支</strong>（Hexo本地建站后第一次上传时会自动生成）。<br>然后创建一个用来备份的分支hexo，并且将其设置为默认分支。</p><h2 id="获取-git文件夹">获取 .git文件夹</h2><p>原始的博客文件夹只有<code>.deploy_git</code>文件夹，是没有.git文件夹的，于是我们先去桌面或者哪里随便一个地方，把刚刚的hexo分支给clone下来。然后复制出里面的.git文件夹，复制到现在的博客文件夹中。</p><p>在博客文件夹中检查是否有<code>.gitignore</code>文件，如果没有最好手动添加一个，用于上传时忽略一些不必要的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p></blockquote><h2 id="备份博客">备份博客</h2><p>通过如下命令将本地文件备份到Github上。</p><p>在hexo博客的根目录下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Backup&quot;</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><h2 id="恢复博客">恢复博客</h2><p>目前假设本地Hexo博客基础环境已经搭好：比如安装git<br>、nodejs、hexo安装等等。</p><p>输入下列命令克隆博客必须文件(hexo分支)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yourgithubname/yourgithubname.github.io</span><br></pre></td></tr></table></figure><p>在clone下来的那个文件夹里面执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>不需要执行<code>hexo init</code>，直接继续安装原来安装的一些插件，然后就完成了</p><h1>博客搭建</h1><h2 id="安装必备组件">安装必备组件</h2><p><strong>（1）NodeJS</strong></p><p>在官网下载安装：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p><strong>（2）Git</strong></p><p>在官网下载安装：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>检测Git是否安装成功，打开CMD窗口，输入下面的命令看是否有信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="安装Hexo">安装Hexo</h2><p><strong>（1）安装Hexo</strong></p><p>新建一个文件夹，重命名为Blog，博客相关的文件将存储在这个文件夹下。</p><p>空白区域右键，点击<code>Git Bash Here</code>，输入下面的命令安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g  </span><br><span class="line">npm install hexo-deployer-git --save  </span><br></pre></td></tr></table></figure><p><strong>（2）初始化Hexo</strong></p><p>将自己的Hexo文件夹复制过来。</p><p>或者在该文件夹下再新建一个文件夹名为<code>Hexo</code>，进入该文件夹后右键点击<code>Git bash here</code>，输入<code>hexo init</code>完成初始化。</p><p>完成后可以使用<code>hexo g &amp;&amp; hexo s</code>查看效果。</p><h2 id="配置Git">配置Git</h2><p><strong>（1）生成SSH密钥</strong></p><p>在<code>Blog</code>文件夹下右键<code>Git bash here</code>，输入下面的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your email@example.com&quot;</span><br></pre></td></tr></table></figure><p>使用下面的命令将密钥复制到剪切板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><strong>（2）在Github上添加公钥</strong></p><p>打开Github，找到【右上角个人头像 -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key】，Title随便填，Key填刚复制的密钥。</p><p>使用下面的命令测试密钥是否配置成功：（注意<code>git@github.com</code>不要更改，就是这个）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><strong>（3）配置Git个人信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;此处填你的用户名&quot;  </span><br><span class="line">git config --global user.email  &quot;此处填你的邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>（4）本地配置</strong></p><p>复制Github上的博客项目的SSH链接，添加到<code>Hexo\_config.yml</code>中的deploy处。</p><p>然后使用下面的命令部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h1>博客自动部署</h1><p><strong>（1）创建一个.bat文件</strong></p><p>在任意一个目录创建一个<code>.bat</code>批处理程序，用于执行自动部署命令。内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">del /s /q &quot;D:\Documents\Blog\Hexo\source\_posts\&quot;</span><br><span class="line">xcopy /e /y &quot;D:\Documents\OneDrive\Documents\Obsidian\HUFFIE NOTES\01 博客&quot; &quot;D:\Documents\Blog\Hexo\source\_posts\&quot;</span><br><span class="line">start &quot;&quot; &quot;D:\Software\Programming\Git\git-bash.exe&quot; -c &quot;cd D:/Documents/Blog/Hexo;hexo clean;hexo g;hexo d;bash&quot;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>命令实现的功能为：</p><ol><li>删除博客内的所有文章</li><li>从OneDrive的目录中将博客文章复制过来（因为我一般都用OneDrive编辑和同步我的文件，所以每次上传需要从OneDrive中复制最新的内容过来）</li><li>运行git bash，并执行命令<code>cd</code>和<code>hexo</code>三件套</li></ol><blockquote><p>注意，如果路径中存在中文，需要将<code>.bat</code>文件另存为ANSI格式。</p></blockquote><p><strong>（2）创建任务计划程序</strong></p><p>打开Windows的任务计划程序，右键任务计划程序库，创建任务</p><p><img src="https://img.mahaofei.com/img/202305091519347.png" alt="image.png"></p><p><img src="https://img.mahaofei.com/img/202305091523504.png" alt="image.png"></p><p><img src="https://img.mahaofei.com/img/202305091522651.png" alt="image.png"></p><h1>Github/Gitee双部署</h1><p><strong>（1）新建仓库</strong></p><p>新建一个宇自己的用户名相同的仓库，例如我的用户名为<code>@HaofeiMa</code>，那么就新建一个名为<code>HaofeiMa</code>的仓库，新建后仓库的地址应该为<code>https://gitee.com/HaofeiMa/HaofeiMa</code>，这样部署好之后就可以用<code>haofeima.gitee.io</code>进行访问。</p><p>在仓库设置页面</p><p><strong>（2）配置SSH-Key</strong></p><p>找到自己之前生成的sshkey，目录为<code>C:\Users\用户名\.ssh\id_rsa.pub</code></p><p>到<a href="https://gitee.com/profile/sshkeys">Gitee的SSH keys页面</a>添加一个 key。</p><p><strong>（3）配置_config.yml</strong></p><p>在hexo根目录的<code>_config.yml</code>中进行配置仓库地址，如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> </span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:HaofeiMa/HaofeiMa.github.io.git</span></span><br><span class="line">      <span class="attr">gitee:</span> <span class="string">git@gitee.com:HaofeiMa/HaofeiMa.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><strong>（4）首次推送并配置Gitee Pages</strong></p><p>执行<code>hexo g -d</code>将博客推送至Github和Gitee。</p><p>在Gitee仓库页面点击<code>服务 -&gt; Gitee Pages -&gt; 勾选'强制使用HTTPS' -&gt; 启动</code></p><p><strong>（5）设置自动部署</strong></p><p>Gitee Pages 无法实现自动部署，只能在Gitee Pages 页面手动点击更新。除非购买￥99的 Gitee Pages Pro。</p><p>考虑使用Github的workflows实现自动部署。</p><p>在自己的Github的Hexo仓库中新建<code>.github/workflows/sync.yml</code>文件，内容填写如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Sync</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Gitee</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">yanglbme/gitee-pages-action@main</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 用户名</span></span><br><span class="line">          <span class="attr">gitee-username:</span> <span class="string">HaofeiMa</span></span><br><span class="line">          <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD</span></span><br><span class="line">          <span class="attr">gitee-password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错</span></span><br><span class="line">          <span class="attr">gitee-repo:</span> <span class="string">HaofeiMa/HaofeiMa</span></span><br><span class="line">          <span class="comment"># 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>在该仓库的<code>Setting -&gt; Secrets and variables -&gt; Actions</code>在最下方添加一个<code>Repository secrets</code>。</p><ul><li>Name: GITEE_PASSWORD</li><li>Secret: 自己的Gitee密码</li></ul><p>完成后等待Github Action自动部署即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据处理Numpy的基本使用方法</title>
      <link href="/post/55ccd68.html"/>
      <url>/post/55ccd68.html</url>
      
        <content type="html"><![CDATA[<p><strong>Numpy的安装</strong></p><p>建议使用Anaconda管理这些包，Anaconda的具体教程参考上一篇笔记【Anaconda的基本使用与在Pycharm中调用】</p><p>安装好Anaconda后可以在Anaconda Prompt使用<code>activate 环境名</code>进入自己创建的环境。</p><p>使用下面指令安装Numpy和Pandas</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy</span><br><span class="line">conda install pandas</span><br></pre></td></tr></table></figure><p><strong>导入numpy</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h1>1. 数组创建</h1><h2 id="（1）从已有数据创建数组">（1）从已有数据创建数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># object  数组或嵌套的数列</span></span><br><span class="line"><span class="comment"># dtype   数组元素的数据类型，可选</span></span><br><span class="line"><span class="comment"># copy    对象是否需要复制，可选</span></span><br><span class="line"><span class="comment"># order   创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</span></span><br><span class="line"><span class="comment"># subok   默认返回一个与基类类型一致的数组</span></span><br><span class="line"><span class="comment"># ndmin   指定生成数组的最小维度</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.array([[1, 2], [3, 4]])<br>print (a)<br>[ [1  2]<br>[3  4] ]</p><p>a = np.array([1, 2, 3, 4, 5], ndmin = 2)<br>print (a)<br>[ [1 2 3 4 5] ]</p></blockquote><h2 id="（2）从数值范围创建数组">（2）从数值范围创建数组</h2><p>numpy.arange：使用 arange 函数创建数值范围并返回 ndarray 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br></pre></td></tr></table></figure><p>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># num       要生成的等步长的样本数量，默认为50</span></span><br><span class="line"><span class="comment"># endpoint  该值为True时，数列中包含stop值，反之不包含，默认是True。</span></span><br><span class="line"><span class="comment"># retstep   如果为True时，生成的数组中会显示间距，反之不显示，默认是False</span></span><br></pre></td></tr></table></figure><p>numpy.logspace 函数用于创建一个于等比数列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.logspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, base=<span class="number">10.0</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># base  对数 log 的底数</span></span><br></pre></td></tr></table></figure><h2 id="（3）创建全0数组">（3）创建全0数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="（4）创建全1数组">（4）创建全1数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="（5）创建指定形状、指定数据类型、但未初始化的数组">（5）创建指定形状、指定数据类型、但未初始化的数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>2. 数组的基本属性</h1><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">ndarray.ndim</td><td style="text-align:left">秩，即轴的数量或维度的数量</td></tr><tr><td style="text-align:left">ndarray.shape</td><td style="text-align:left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td style="text-align:left">ndarray.reshape</td><td style="text-align:left">调整数组的大小</td></tr><tr><td style="text-align:left">ndarray.size</td><td style="text-align:left">数组元素的总个数，相当于 .shape 中 n·m 的值</td></tr><tr><td style="text-align:left">ndarray.dtype</td><td style="text-align:left">ndarray 对象的元素类型</td></tr><tr><td style="text-align:left">ndarray.itemsize</td><td style="text-align:left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td style="text-align:left">ndarray.flags</td><td style="text-align:left">ndarray 对象的内存信息</td></tr><tr><td style="text-align:left">ndarray.real</td><td style="text-align:left">ndarray元素的实部</td></tr><tr><td style="text-align:left">ndarray.imag</td><td style="text-align:left">ndarray 元素的虚部</td></tr><tr><td style="text-align:left">ndarray.data</td><td style="text-align:left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><blockquote><p>例如：<br>a = np.array([[1,2,3],[4,5,6]])   # (2, 3)</p><p>a = np.array([[1,2,3],[4,5,6]])<br>b = a.reshape(3,2)<br>print (b)<br>[[1, 2]<br>[3, 4]<br>[5, 6]]</p></blockquote><h1>3. 数组的切片与索引</h1><h2 id="（1）slice函数切片">（1）slice函数切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">slice</span>(start, stop[, step])</span><br><span class="line"><span class="comment"># start  起始位置</span></span><br><span class="line"><span class="comment"># stop   结束位置</span></span><br><span class="line"><span class="comment"># step   间距</span></span><br></pre></td></tr></table></figure><h2 id="（2）冒号-分割切片-start-stop-step">（2）冒号<code>:</code>分割切片[start:stop:step]</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(10) # [0 1 2 3 4 5 6 7 8 9]</span><br><span class="line">b = a[2:7:2]</span><br><span class="line">b = a[5]</span><br><span class="line">b = a[2:]</span><br></pre></td></tr></table></figure><blockquote><p>冒号 : 的解释：如果只放置一个参数，如 <strong>[2]</strong>，将返回与该索引相对应的单个元素。如果为 <strong>[2:]</strong>，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 <strong>[2:7]</strong>，那么则提取两个索引(不包括停止索引)之间的项。</p></blockquote><h2 id="（3）split方法">（3）split方法</h2><p>numpy.split 函数沿特定的轴将数组分割为子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.split(ary, indices_or_sections, axis)</span><br><span class="line"><span class="comment"># ary：被分割的数组</span></span><br><span class="line"><span class="comment"># indices_or_sections：如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</span></span><br><span class="line"><span class="comment"># axis：设置沿着哪个方向进行切分，默认为 0，横向切分，即水平方向。为 1 时，纵向切分，即竖直方向</span></span><br></pre></td></tr></table></figure><h1>4. 数组基本操作</h1><h2 id="（1）数组展开">（1）数组展开</h2><p>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">a.flatten()             <span class="comment"># [0 1 2 3 4 5 6 7]</span></span><br><span class="line">a.flatten(order = <span class="string">&#x27;F&#x27;</span>)  <span class="comment"># [0 4 1 5 2 6 3 7]</span></span><br><span class="line"><span class="comment"># order：&#x27;C&#x27;按行，&#x27;F&#x27;按列，&#x27;A&#x27;原顺序，&#x27;K&#x27;元素在内存中的出现顺序</span></span><br></pre></td></tr></table></figure><p>numpy.ravel() 展平的数组元素，顺序通常是&quot;C风格&quot;，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">a.ravel()              <span class="comment"># [0 1 2 3 4 5 6 7]</span></span><br><span class="line">a.ravel(order = <span class="string">&#x27;F&#x27;</span>)  <span class="comment"># [0 4 1 5 2 6 3 7]</span></span><br></pre></td></tr></table></figure><h2 id="（2）数组转置">（2）数组转置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.transpose(arr, axes)</span><br><span class="line"><span class="comment"># arr ：要操作的数组</span></span><br><span class="line"><span class="comment"># axes：整数列表，对应维度，通常所有维度都会对换</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.T</span><br><span class="line"><span class="comment"># 数组全部转置</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.arange(12).reshape(3,4)<br>print (np.transpose(a))<br>print (a.T)</p></blockquote><h2 id="（3）数组轴的移动与交换">（3）数组轴的移动与交换</h2><p>numpy.rollaxis 函数移动特定的轴到一个特定位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.rollaxis(arr, axis, start)</span><br><span class="line"><span class="comment"># arr   ：数组</span></span><br><span class="line"><span class="comment"># axis  ：要移动的轴，其它轴的相对位置不会改变</span></span><br><span class="line"><span class="comment"># start ：默认为零，表示完整的滚动。会滚动到特定位置</span></span><br></pre></td></tr></table></figure><p>numpy.swapaxes 函数用于交换数组的两个轴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.swapaxes(arr, axis1, axis2)</span><br><span class="line"><span class="comment"># arr   ：数组</span></span><br><span class="line"><span class="comment"># axis1 ：对应第一个轴的整数</span></span><br><span class="line"><span class="comment"># axis2 ：对应第二个轴的整数</span></span><br></pre></td></tr></table></figure><h2 id="（4）连接数组">（4）连接数组</h2><p><strong>数组连接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.concatenate((a1, a2, ...), axis)</span><br><span class="line"><span class="comment"># a1, a2, ... ：相同类型的数组</span></span><br><span class="line"><span class="comment"># axis：沿着它连接数组的轴，默认为 0</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.array([[1,2],[3,4]])<br>b = np.array([[5,6],[7,8]])<br>print (np.concatenate((a,b)))<br>[[1 2]<br>[3 4]<br>[5 6]<br>[7 8]]<br>print (np.concatenate((a,b),axis = 1))<br>[[1 2 5 6]<br>[3 4 7 8]]</p></blockquote><p><strong>数组堆叠</strong></p><p>numpy.stack 函数用于沿新轴连接数组序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.stack(arrays, axis)</span><br><span class="line"><span class="comment"># arrays : 相同形状的数组序列</span></span><br><span class="line"><span class="comment"># axis   : 返回数组中的轴，输入数组沿着它来堆叠</span></span><br></pre></td></tr></table></figure><blockquote><p>例如：<br>a = np.array([[1,2],[3,4]])<br>b = np.array([[5,6],[7,8]])<br>print (np.stack((a,b),0))<br>[[[1 2]<br>[3 4]]<br>[[5 6]<br>[7 8]]]<br>print (np.stack((a,b),1))<br>[[[1 2]<br>[5 6]]<br>[[3 4]<br>[7 8]]]</p></blockquote><p>具体的数组堆叠方式，参考此文章：<a href="https://blog.csdn.net/weixin_44330492/article/details/100126774">【Python中numpy.stack()函数最形象易懂的理解】</a></p><h2 id="（5）数组形状改变">（5）数组形状改变</h2><p><strong>numpy.resize</strong></p><p>numpy.resize 函数返回指定大小的新数组。如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.resize(arr, shape)</span><br><span class="line"><span class="comment"># arr   : 要修改大小的数组</span></span><br><span class="line"><span class="comment"># shape : 返回数组的新形状</span></span><br></pre></td></tr></table></figure><h2 id="（6）数组元素的操作">（6）数组元素的操作</h2><p><strong>numpy.append</strong></p><p>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.append(arr, values, axis=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># arr   ：输入数组</span></span><br><span class="line"><span class="comment"># values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</span></span><br><span class="line"><span class="comment"># axis  ：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</span></span><br></pre></td></tr></table></figure><p><strong>numpy.insert</strong></p><p>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.insert(arr, obj, values, axis)</span><br><span class="line"><span class="comment"># arr   ：输入数组</span></span><br><span class="line"><span class="comment"># obj   ：在其之前插入值的索引</span></span><br><span class="line"><span class="comment"># values：要插入的值</span></span><br><span class="line"><span class="comment"># axis  ：沿着它插入的轴，如果未提供，则输入数组会被展开</span></span><br></pre></td></tr></table></figure><p><strong>numpy.delete</strong></p><p>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.delete(arr, obj, axis)</span><br><span class="line"><span class="comment"># arr ：输入数组</span></span><br><span class="line"><span class="comment"># obj ：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</span></span><br><span class="line"><span class="comment"># axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</span></span><br></pre></td></tr></table></figure><p><strong>numpy.unique</strong></p><p>numpy.unique 函数用于去除数组中的重复元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.unique(arr, return_index, return_inverse, return_counts)</span><br><span class="line"><span class="comment"># arr：输入数组，如果不是一维数组则会展开</span></span><br><span class="line"><span class="comment"># return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</span></span><br><span class="line"><span class="comment"># return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</span></span><br></pre></td></tr></table></figure><h2 id="（7）数组排序">（7）数组排序</h2><table><thead><tr><th style="text-align:left">种类</th><th style="text-align:left">速度</th><th style="text-align:left">最坏情况</th><th style="text-align:left">工作空间</th><th style="text-align:left">稳定性</th></tr></thead><tbody><tr><td style="text-align:left"><code>'quicksort'</code>（快速排序）</td><td style="text-align:left">1</td><td style="text-align:left"><code>O(n^2)</code></td><td style="text-align:left">0</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left"><code>'mergesort'</code>（归并排序）</td><td style="text-align:left">2</td><td style="text-align:left"><code>O(n*log(n))</code></td><td style="text-align:left">~n/2</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left"><code>'heapsort'</code>（堆排序）</td><td style="text-align:left">3</td><td style="text-align:left"><code>O(n*log(n))</code></td><td style="text-align:left">0</td><td style="text-align:left">否</td></tr></tbody></table><p><strong>numpy.sort()</strong></p><p>numpy.sort() 函数返回输入数组的排序副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numpy.sort(a, axis, kind, order)</span><br><span class="line"><span class="comment"># a: 要排序的数组</span></span><br><span class="line"><span class="comment"># axis: 沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序</span></span><br><span class="line"><span class="comment"># kind: 默认为&#x27;quicksort&#x27;（快速排序）</span></span><br><span class="line"><span class="comment"># order: 如果数组包含字段，则是要排序的字段</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.sort(a))  <span class="comment"># [[3 7],[1 9]]</span></span><br><span class="line"><span class="built_in">print</span> (np.sort(a, axis = <span class="number">0</span>))  <span class="comment"># [[3 1],[9 7]]</span></span><br></pre></td></tr></table></figure><p><strong>numpy.argsort()</strong></p><p>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argsort([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># [1 2 0]</span></span><br></pre></td></tr></table></figure><h3 id="（8）数组乘法">（8）数组乘法</h3><p><strong>numpy.dot()</strong></p><p>numpy.dot(a, b, out=None)：对于二维数组，它相当于矩阵的乘法；对于一维数组，则是向量的内积；而对于n维，它是a的最后一个轴向和b的倒数第二个轴向的乘积和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot([<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(a, b)</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><p><strong>numpy.outer()</strong></p><p>numpy.outer(a, b, out=None)：计算两个向量的外积。输入a,b如果不是一维数组，则先将其变成一维数组，即可得a(M,)和b(N,)这种形式，可得输出为(M,N)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[a0*b0 a0*b1 ... a0*bN ]</span><br><span class="line"> [a1*b0 .               ]</span><br><span class="line"> [ ... .                ]</span><br><span class="line"> [aM*b0           aM*bN ]]</span><br></pre></td></tr></table></figure><p><strong>numpy.multiply()</strong></p><p>numpy.multiply(a, b)：为对应元素的乘积。维度相等时才能使用，当<strong>数组</strong>或者<strong>矩阵</strong>的维度不相同时，会根据一定的广播规则将维数扩充到一致的形式</p><p><strong>*</strong></p><p>*：当是两个数组相乘时和np.multiply用法相同，为对应元素的乘积；但是如果相乘的元素是矩阵时，则和np.dot用处相同，表示矩阵相乘。</p><h1>5. Broadcast广播规则</h1><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p><strong>具体广播规则如下：</strong></p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p><strong>举例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt=""></p><h1>6. 数组基本运算</h1><h2 id="（1）算数函数">（1）算数函数</h2><p><strong>加减乘除</strong></p><p>NumPy 算术函数包含简单的加减乘除: <strong>add()</strong>，<strong>subtract()</strong>，<strong>multiply()</strong> 和 <strong>divide()</strong>。数组必须具有相同的形状或符合数组广播规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">9</span>, dtype = np.float_).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">b = np.array([<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span> (np.add(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.subtract(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.multiply(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.divide(a,b))</span><br></pre></td></tr></table></figure><p><strong>倒数</strong></p><p>numpy.reciprocal() 函数返回参数逐元素的倒数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">0.25</span>, <span class="number">1.33</span>, <span class="number">1</span>, <span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span> (np.reciprocal(a))</span><br></pre></td></tr></table></figure><p><strong>指数</strong></p><p>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span> (np.power(a,b))</span><br></pre></td></tr></table></figure><p><strong>模与余数</strong></p><p>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line">b = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span> (np.mod(a,b))</span><br><span class="line"><span class="built_in">print</span> (np.remainder(a,b))</span><br></pre></td></tr></table></figure><h2 id="（2）统计函数">（2）统计函数</h2><p><strong>最大值与最小值</strong></p><p>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。<br>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。<br>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.amin(a,<span class="number">1</span>))    <span class="comment"># [3 3 2]</span></span><br><span class="line"><span class="built_in">print</span> (np.amin(a,<span class="number">0</span>))    <span class="comment"># [2 4 3]</span></span><br><span class="line"><span class="built_in">print</span> (np.amax(a))      <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">print</span> (np.amax(a, axis = <span class="number">0</span>))   <span class="comment"># [8 7 9]</span></span><br><span class="line"><span class="built_in">print</span> (np.argmax(a))    <span class="comment"># 8</span></span><br><span class="line"><span class="built_in">print</span> (np.argmax(a, axis = <span class="number">0</span>)) <span class="comment"># [1 0 2]</span></span><br><span class="line"><span class="built_in">print</span> (np.argmin(a))    <span class="comment"># 6</span></span><br><span class="line"><span class="built_in">print</span> (np.argmin(a, axis = <span class="number">1</span>)) <span class="comment"># [0 2 0]</span></span><br></pre></td></tr></table></figure><p><strong>最值差（最大值-最小值）</strong></p><p>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.ptp(a))    <span class="comment"># 7</span></span><br><span class="line"><span class="built_in">print</span> (np.ptp(a, axis = <span class="number">1</span>))    <span class="comment"># [4 5 7]</span></span><br><span class="line"><span class="built_in">print</span> (np.ptp(a, axis = <span class="number">0</span>))    <span class="comment"># [6 3 6]</span></span><br></pre></td></tr></table></figure><p><strong>算数平均值</strong></p><p>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.mean(a))    <span class="comment"># 3.6666666666666665</span></span><br><span class="line"><span class="built_in">print</span> (np.mean(a, axis = <span class="number">0</span>))  <span class="comment"># [2.66666667 3.66666667 4.66666667]</span></span><br><span class="line"><span class="built_in">print</span> (np.mean(a, axis = <span class="number">1</span>))  <span class="comment"># [2. 4. 5.]</span></span><br></pre></td></tr></table></figure><p><strong>加权平均值</strong></p><p>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (np.average(a))  <span class="comment"># 2.5</span></span><br><span class="line">wts = np.array([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span> (np.average(a,weights = wts))  <span class="comment"># 2.0</span></span><br></pre></td></tr></table></figure><p><strong>中位数</strong></p><p>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">30</span>,<span class="number">65</span>,<span class="number">70</span>],[<span class="number">80</span>,<span class="number">95</span>,<span class="number">10</span>],[<span class="number">50</span>,<span class="number">90</span>,<span class="number">60</span>]])</span><br><span class="line"><span class="built_in">print</span> (np.median(a))  <span class="comment"># 65.0</span></span><br><span class="line"><span class="built_in">print</span> (np.median(a, axis = <span class="number">0</span>))  <span class="comment"># [50. 90. 60.]</span></span><br><span class="line"><span class="built_in">print</span> (np.median(a, axis = <span class="number">1</span>))  <span class="comment"># [65. 80. 60.]</span></span><br></pre></td></tr></table></figure><p><strong>方差</strong></p><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.var([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># 1.25</span></span><br></pre></td></tr></table></figure><p><strong>标准差</strong></p><p>标准差是一组数据平均值分散程度的一种度量，是方差的算术平方根。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.std([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># 1.1180339887498949</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda的基本使用与在Pycharm中调用</title>
      <link href="/post/8543c9d.html"/>
      <url>/post/8543c9d.html</url>
      
        <content type="html"><![CDATA[<h1>一、关于Anaconda</h1><p>环境 = “好比一栋楼，在楼里面分配一间屋给各种‘包’放，每间房里面的‘包’互不影响”</p><p>激活环境 = “告诉电脑，我现在要用这个屋子里面的‘包’来做东西了所以要进这间屋子”</p><p>移除环境 = “现在这个屋子里面我原来要用的东西现在不需要了把它赶出去节省电脑空间”</p><p>Conda创建环境相当于创建一个虚拟的空间将这些包都装在这个位置，我不需要了可以直接打包放入垃圾箱，同时也可以针对不同程序的运行环境选择不同的conda虚拟环境进行运行。</p><p>例如：</p><p>我的某个程序需要使用python3.8以及一堆其他的包，另一个程序需要python2.7加其它的一些包，这就需要我为这两个程序分别创建虚拟环境。</p><p>这样就可以在一台电脑上实现<strong>多个版本的python程序编写</strong>，同时想<strong>打包程序为exe</strong>的时候，也不会打包进其它没用到的包。</p><h1>二、Anaconda的安装</h1><p>Anaconda官网链接：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p><p>各个系统版本的Anaconda安装程序都可以直接下载安装即可。</p><h1>三、Anaconda的使用</h1><h2 id="3-1-配置Anaconda源">3.1 配置Anaconda源</h2><p>通常anaconda的默认源在境外，下载速度会非常慢甚至导致网络错误下载包失败，打开<code>Anaconda Prompt</code>使用以下方法将清华镜像添加到<code>Anaconda</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ </span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>使用如下命令查看当前channel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure><h2 id="3-2-Anaconda常用命令">3.2 Anaconda常用命令</h2><p><strong>conda版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><p><strong>列出所有虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p><strong>创建虚拟环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n 环境名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda create --name python39 python=3.9</span></span><br></pre></td></tr></table></figure><p><strong>删除已有的环境及其安装包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name 环境名 --all</span><br></pre></td></tr></table></figure><p><strong>克隆环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name 新环境名 --clone 原环境名</span><br></pre></td></tr></table></figure><p><strong>激活某个环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate 环境名</span><br></pre></td></tr></table></figure><p><strong>退出当前环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><strong>查看环境中现有的包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><p><strong>用conda或者pip安装包到当前环境</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install 包名称</span><br></pre></td></tr></table></figure><p><strong>包更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update numpy</span><br></pre></td></tr></table></figure><h2 id="3-3-Anaconda-Navigtor">3.3 Anaconda Navigtor</h2><p>用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。</p><h1>Pycharm中使用</h1><p><strong>1. 新建工程后，选择使用现有的解释器</strong></p><p><img src="https://img.mahaofei.com/img/20220422191328.png" alt=""></p><p><strong>2. 选择自己新建的虚拟环境</strong></p><p><img src="https://img.mahaofei.com/img/20220422191623.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业设计论文写作格式规范</title>
      <link href="/post/16785ea7.html"/>
      <url>/post/16785ea7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://pan.baidu.com/s/1n-1xqn3rarwiLiwlTYCNLA?pwd=p5tg">河北工业大学毕业设计中期报告模板.docx</a></p></blockquote><h1>重要要求</h1><p><strong>文档内所有文字（标题、正文、图、表、参考文献等）都应该使用模板规定的样式</strong></p><h1>标题</h1><ol><li><p>每个一级标题（一、二、三……）前应空一行。</p></li><li><p>一级、二级、三级标题不应该作为某页的最后一行（即所谓孤行控制）</p></li><li><p>页面最后由于插图导致的空白行最多允许1~2行的宽度。</p></li><li><p>正文多级标题格式顺序</p></li></ol><blockquote><p><strong>（1）这个可以加粗</strong><br>1）再下级的都与正文同格式<br>a.</p></blockquote><h1>图、表</h1><h2 id="图片插图">图片插图</h2><ol><li><p>表格和插图不能直接出现在正文段落的首行，必须先有文字说明。</p></li><li><p>图题、表头的编制要简洁明了，具有自明性，不能太笼统：图的序号编制只允许到二级，例如图1.1，图1.2，图4.5这样的二级图号，禁止出现图2.1.1这样的三级图号。</p></li><li><p>图片与图题、表头与表格，必须保证在同一页上。</p></li><li><p>图片尺寸尽量调小，能表达清楚图片内容即可。</p></li><li><p>图片中的上下空白尽可能小，通过裁剪剪去图片中的上下空白部分。</p></li><li><p>图中所标注文字大小，要比正文字号小1号。</p></li><li><p>流程图、框图等尽量使用Visio绘制，Visio打开状态下，可直接将visio文件插入word中。</p></li><li><p>图片标注格式</p></li></ol><p><img src="https://img.mahaofei.com/img/20220412112135.png" alt=""></p><p align="center" >图1.1 Web of Science网站图标（图题在下）<p align="center" >Fig.1.1 Web of Science favicon</p>## 表格<ol><li><p>表格一律采用三线表：表的序号编制只允许到二级，例如表1.1，表1.2，表4.5这样的二级图号，禁止出现表2.1.1这样的三级表号</p></li><li><p>表格标注格式</p></li></ol><p align="center" >表1.1 表格的标题（表头在上）<p align="center" >Table.1.1 Title of the table</p><p><img src="https://img.mahaofei.com/img/20220412112135.png" alt=""></p><h1>公式编辑</h1><ol><li>公式使用word中的公式插件（alt =），符号使用斜体、单位使用正体</li></ol><h1>参考文献</h1><p>[1]     袁庆龙, 候文义. Ni-P合金镀层组织形貌及显微硬度研究[J]. 太原理工大学学报, 2001, (1): 51-53.（期刊类）</p><p>[2]     金显贺, 王昌长, 王忠东, 等. 一种用于在线检测局部放电的数字滤波技术[J]. 清华大学学报（自然科学版）, 1993, 33(4): 62–67.</p><p>[3]     Khorasani K. Adaptive control of flexible joint robot[J]. IEEE Trans on Robotics and Automation, 1992, 8(2): 250-267.</p><p>[4]     刘国钧, 陈绍业, 王凤翥. 图书馆目录[M]. 北京: 高等教育出版社, 1957.（专著-参考书）</p><p>[5]     辛希孟. 信息技术与信息服务国际研讨会论文集: A集[C]. 北京: 中国社会科学出版社, 1994.（专著-会议论文集）</p><p>[6]     张筑生. 微分半动力系统的不变集[D]. 北京: 北京大学数学系数学研究所, 1983. （专著-博硕士论文）</p><p>[7]     冯西桥. 核反应堆压力管道与压力容器的LBB分析[R]. 北京: 清华大学核能技术设计研究院, 1997. （报告）</p><p>[8]     GB/T 16159-1996, 汉语拼音正词法基本规则[S]. （标准类）</p><p>[9]     姜锡洲. 一种温热外敷药制备方案[P]. 中国: 881056073,1989-07-26. （专利）</p><p>[10]  王明亮. 关于中国学术期刊标准化数据库系统工程的进展[EB/OL]. http: <a href="//www.cajcd.edu.cn/pub/wml.txt/980810%E2%80%932.html">//www.cajcd.edu.cn/pub/wml.txt/980810–2.html</a>, 1998-08-16/1998-10-04.  （电子文献）</p><p>[11]  Aytekin Çaʇlar, Rezaeitabar Yousef, Dogru Sedat, et al. Railway fastener inspection by real-time machine vision[J]. IEEE Transactions on Systems Man and Cybernetics: Systems, 2015, 45(7): 1101-1107.</p><p>[12]  Stivanello Maurício Edgar, Marcellino Kleber Juan. A Machine Vision System for Online Metal Can-End Rivet Inspection[J]. Journal of Physics: Conference Series, 2019, 1335(1)</p><p>[13]  Zhang Hui, Li Xuanlun, Zhong Hang, et al. Automated machine vision system for liquid particle inspection of pharmaceutical injection[J]. IEEE Transactions on Instrumentation and Measurement, 2018, 67(6): 1278-1297.</p><h1>附录：各样式信息</h1><table><thead><tr><th>样式</th><th>中文字体</th><th>英文字体</th><th>字号</th><th>格式</th><th>行距</th><th>段距</th><th>缩进</th><th>换行与分页</th><th>示例</th></tr></thead><tbody><tr><td>报告标题</td><td>黑体</td><td>Times New Roman</td><td>丝毫</td><td>居中加粗</td><td>1.5倍行距</td><td>段前段后12磅</td><td>无</td><td>孤行控制</td><td>HalfA博客毕业设计论文写作规范</td></tr><tr><td>一级标题</td><td>黑体</td><td>Times New Roman</td><td>小四</td><td></td><td>1.5倍行距</td><td>段前段后6磅</td><td>无</td><td>孤行控制</td><td>一、标题</td></tr><tr><td>二级标题</td><td>黑体</td><td>Times New Roman</td><td>五号</td><td>无</td><td>1.5倍行距</td><td>段前段后3磅</td><td>无</td><td>孤行控制</td><td>1.1 标题</td></tr><tr><td>三级标题</td><td>黑体</td><td>Times New Roman</td><td>五号</td><td>无</td><td>1.5倍行距</td><td>段前段后3磅</td><td>无</td><td>孤行控制</td><td>1.1.1 标题</td></tr><tr><td>正文</td><td>宋体</td><td>Times New Roman</td><td>五号</td><td>无</td><td>1.5倍行距</td><td>无</td><td>首行缩进2字符</td><td>无</td><td>正文</td></tr><tr><td>图题</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中</td><td>1.5倍行距</td><td>无</td><td>无</td><td>无</td><td>图1.1 图题 Fig.1.1 Figure title</td></tr><tr><td>表头</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中</td><td>1.5倍行距</td><td>无</td><td>无</td><td>无</td><td>表1.1 表头 Table.1.1 Table title</td></tr><tr><td>表格标题</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中加粗</td><td>1.25倍行距</td><td>无</td><td>无</td><td>无</td><td>标题</td></tr><tr><td>表格内容</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>居中</td><td>1.5倍行距</td><td>无</td><td>无</td><td>无</td><td>表格内容</td></tr><tr><td>参考标题</td><td>黑体</td><td>Times New Roman</td><td>五号</td><td>居中</td><td>1.5倍行距</td><td>段前段后0.5行</td><td>无</td><td>无</td><td>参考文献</td></tr><tr><td>参考文献</td><td>宋体</td><td>Times New Roman</td><td>小五</td><td>无</td><td>1.5倍行距</td><td>无</td><td>悬挂缩进2字符、首行缩进-2字符</td><td>无</td><td>[1] 马浩飞. 毕业设计论文写作规范[J]. HalfA博客. 2022.</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Solidworks装配体常见问题汇总（随时更新）</title>
      <link href="/post/bc899151.html"/>
      <url>/post/bc899151.html</url>
      
        <content type="html"><![CDATA[<p>问题目录<br>电脑端：左侧列表<br>手机端：右下角【三】按钮</p><h2 id="【置顶】各种标准件和非标件的模型如何下载">【置顶】各种标准件和非标件的模型如何下载</h2><p>大部分模型都可以在ToolBox里面下载到。没有的话，如果是标准件，推荐以下两个工具。</p><p><strong>推荐一个软件【今日制造】</strong>（<a href="http://www.maidiyun.com/download/softInfo.aspx?id=1">http://www.maidiyun.com/download/softInfo.aspx?id=1</a>）</p><p><img src="https://img.mahaofei.com/img/20220510161027.png" alt=""></p><p><strong>推荐一个网站【三益精密】</strong>（<a href="http://www.3g-es.com/">http://www.3g-es.com/</a>）</p><p>可以在官网右侧找到2D/3D模型，然后下载电子相册和模型库。也可以直接使用下面的百度网盘。</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1Wby8zvjswjeNZNGwqe_0Gw">https://pan.baidu.com/s/1Wby8zvjswjeNZNGwqe_0Gw</a><br>提取码: xwsk</p></blockquote><p>下载好后，打开cdstart.exe</p><p><img src="https://img.mahaofei.com/img/20220510161120.png" alt=""></p><p>点击【2D/3D CAD】</p><p><img src="https://img.mahaofei.com/img/20220510161141.png" alt=""></p><p>打开后可以看到有非常多的模型，包括常用机械零部件、电机、传感器等等。</p><p><img src="https://img.mahaofei.com/img/20220510161341.png" alt=""></p><p>下载方式，打开一个想要的零件，点击上面的输出成档，然后选择3D，就可以下载STEP格式了</p><p><img src="https://img.mahaofei.com/img/20220510161536.png" alt=""></p><h2 id="1-修改的标准件在装配体保存后又会还原">1. 修改的标准件在装配体保存后又会还原</h2><p><strong>问题描述：</strong></p><p>修改标准件后插入装配体中，可是当我们保存退出装配体后，再打开时发现修改好的标准件自动被替换成原来的那个标准件。</p><p><strong>解决方法：</strong></p><p>打开【<strong>工具-选项</strong>】，找到【<strong>异性孔向导/Toolbox</strong>】，<strong>取消</strong>勾选【<strong>将此文件夹设为Toolbox零部件的默认搜索位置</strong>】，重新打开装配体，可以看到修改后的零件被正确的装配好了</p><p><img src="https://img.mahaofei.com/img/20220415203208.png" alt=""></p><h2 id="2-调出Toolbox标准件后如何再对其尺寸修改">2. 调出Toolbox标准件后如何再对其尺寸修改</h2><p><strong>问题描述：</strong></p><p>在Solidworks画装配体中，经常会调用标准件，但有的时候装配时会发现标准件尺寸不合适需要修改，不想重新生成零件再重新配合，想要直接修改现有零件。</p><p><strong>解决方法：</strong></p><p>在装配体中，【<strong>右键</strong>】需要修改的标准件，选择【<strong>编辑Toolbox零部件</strong>】即可修改其参数。（需要提前加载Toolbox插件）</p><p><img src="https://img.mahaofei.com/img/20220415203738.png" alt=""></p><h2 id="3-装配体模型灰色-无法修改零件外观-无法调整透明度">3. 装配体模型灰色/无法修改零件外观/无法调整透明度</h2><p><strong>问题描述：</strong></p><p>遇到了一个新bug，当我将装配体导出为工程图后，再回到装配体界面，发现模型颜色全部丢失，整体外观变成灰色，并且无论如何修改模型外观、修改模型透明度，都不起作用。</p><p><strong>解决方法：</strong></p><p>我的问题出在<strong>装配体莫名其妙增加了几十个白色外观</strong>。</p><p>打开界面左侧【DisplayManager -&gt; 外观】，可以看到外观下面有几十个白色（这里我已经全部删除了）。选中第一个，按住shift，再选中最后一个，然后按下delete键，将颜色全部删除，这个时候就就可以更改外观了。</p><p><img src="https://img.mahaofei.com/img/20220504162346.png" alt=""></p><p>如果觉得颜色还是发灰，可以到【布景、光源与相机】中，右键各个光源 选择在solidworks中打开，将所有光源打开后一般颜色就会恢复正常了。</p><p><img src="https://img.mahaofei.com/img/20220504162704.png" alt=""></p><h2 id="4-如何加载Q235等其它材质材料">4. 如何加载Q235等其它材质材料</h2><p><strong>问题描述：</strong></p><p>solidworks中配置零件的指定材质时，会发现有些材料比如Q235，在solidworks标准材质库中找不到。</p><p><strong>解决方法：</strong></p><p>需要我们自己加载GB材质库。下载下面的文件，将文件解压，放在任意一个目录下（建议放在Solidworks安装目录下，方便管理）</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/124gGXvUhpHX3hxiElPC-rw?pwd=ysjp">https://pan.baidu.com/s/124gGXvUhpHX3hxiElPC-rw?pwd=ysjp</a><br>提取码: ysjp</p></blockquote><p><img src="https://img.mahaofei.com/img/20220510160149.png" alt=""></p><p>打开Solidworks选项，找到【文件位置】，添加材质数据库的位置为刚才解压的文件夹。</p><p><img src="https://img.mahaofei.com/img/20220510160254.png" alt=""></p><p>再次打开材料列表，就可以看到新的材质了。</p><p><img src="https://img.mahaofei.com/img/20220510160400.png" alt=""></p><h2 id="5-装配体如何替换零件">5. 装配体如何替换零件</h2><p><img src="https://img.mahaofei.com/img/20220510162046.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220510162120.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220510162014.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> 机械 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> Solirworks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各大视频音频网站资源下载</title>
      <link href="/post/2c340937.html"/>
      <url>/post/2c340937.html</url>
      
        <content type="html"><![CDATA[<h1>介绍</h1><p>使用<a href="https://github.com/soimort/you-get">You-get工具</a>，这是Github上的一个项目，可以下载大多数主流网站的视频，图片、音频。</p><p>支持的网站包括YouTube、Twitter、Facebook、bilibili、AcFun、niconico、网易云音乐、酷狗音乐、qq音乐、爱奇艺、腾讯视频、抖音、快手、知乎等等。</p><blockquote><p>详细文档参见：<a href="https://github.com/soimort/you-get">https://github.com/soimort/you-get</a></p></blockquote><h1>工具准备</h1><h2 id="1-下载安装python3">1. 下载安装python3</h2><p>网上有很多教程，按照教程安装最新版的python即可。</p><h2 id="2-安装you-get">2. 安装you-get</h2><p>按下<code>win+R</code>输入<code>cmd</code>，打开命令行窗口，使用如下指令安装you-get工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure><p>然后输入下方代码，升级you-get工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407190404.png" alt=""></p><h1>使用方法</h1><h2 id="1-查看可以下载的质量和格式">1. 查看可以下载的质量和格式</h2><p>复制想要下载的视频或音频的网页链接。</p><p>使用<code>--info</code>/<code>-i</code>指令即可查看所有可以下载的文件质量和格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407191446.png" alt=""></p><h2 id="2-下载视频-音频-图片">2. 下载视频/音频/图片</h2><p>直接使用<code>you-get</code>指令会下载defalut下面的第一种格式，并下载到命令行当前所在目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p>如果想要下载特定的格式，找到对应格式下面提示的下载指令，使用下载指令下载就行，例如我要下载此视频的mp4版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407193145.png" alt=""></p><p>可以看到速度还是蛮快的。</p><h2 id="3-设置输出文件夹与文件名">3. 设置输出文件夹与文件名</h2><p>使用<code>--output-dir</code>/<code>-o</code>选项设置路径，使用<code>--output-filename</code>/<code>-O</code>设置下载文件的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv -o E:/Windows/VIDEOS -O 夏天 https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407193428.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Staple目标跟踪算法C++代码测试</title>
      <link href="/post/1a6f38d3.html"/>
      <url>/post/1a6f38d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍-3">一、介绍</h2><p>Staple综合了局部特征HOG和全局特征颜色直方图用于目标跟踪的算法。</p><p>首先作者发现颜色分布不足以将目标和背景区分开来。局部特征这样的模板在应对剧烈形变的时候效果往往很差。</p><p>作者针对这两个问题做了一些相关工作得到以下结论。</p><ol><li>卷积滤波器对剧烈形变不鲁棒。</li><li>在线学习可能会带来模型漂移，也就是算法是将预测作为正样本来训练，更新模型。如果一旦预测不对，后面也跟着错。</li><li>颜色直方图是不考虑像素位置的，这在一定程度上可以减少形变的影响。</li><li>相关滤波CF的鲁棒性比较强，在目标颜色和背景颜色区分力度不够时可以发挥作用。</li></ol><p>因此作者结合了这些实现目标跟踪。</p><h2 id="二、理论方法">二、理论方法</h2><h3 id="2-1-总体方法">2.1 总体方法</h3><p>$p_t=argmax_{p{\in}S_t} f(T(x_t,p);{\theta}_{t-1})$</p><p>对于$t$帧，可以通过矩形$p_t$在图像$x_t$中选择一个目标，并令得分函数的值最大。<br>（$f$是矩形窗口$p$的得分函数，得分函数$T$是一种图像变换，$\theta$是模型参数）</p><p>$\theta_t=argmin_{\theta \in Q}{L(\theta;X_t+\lambda R(\theta)}$</p><p>$X_t={(x_i,p_i)}^t_{i=1}$</p><p>可以取一组$\theta$使得整个损失函数最小。<br>（$L$是和前面帧的目标位置有关的函数，$R$是正则项）</p><h3 id="2-2-得分函数">2.2 得分函数</h3><p>$f(x)={\gamma}<em>{tmpl}f</em>{tmpl}(x)+{\gamma}<em>{hist}f</em>{hist}(x)$</p><p>$f_{tmpl}(x;h)=\sum_{u\in{\tau}}h[u]^T\phi_x[u]$</p><p>$\phi_x:\tau\rightarrow\mathbb{R}^K$<br>$\tau:\subset\mathbb{Z}^2$</p><p>f函数是由两项组成，一项是模板的得分，第二项是直方图得分。这个公式代表，假设一张图像x用$Z^2$表示</p><h2 id="三、论文笔记">三、论文笔记</h2><p>STAPLE目标跟踪算法结合了HOG特征和颜色直方图两种方法。由于HOG特征对运动模糊和照度较为鲁棒，但是对形变不够鲁棒，而相对应的颜色直方图对形变非常鲁棒，对光照变化不够鲁棒。因此两种方法可以互补，故同时使用这两种方法，分为两个通道进行处理。</p><p>该算法在第一帧使用矩形框指定目标，然后在视频中跟踪一个不熟悉的物体并对其外观的变化保持鲁棒性。由于一个物体的外观在视频中可能会出现很大变化，因此只从使用第一帧计算的模型估算其他帧不会很有效，通常的做法是将跟踪帧中的预测作为训练数据更新模型。在每一帧图像中搜索目标位置时，考虑先将图像的各个旋转中进行搜索，然后再在比例放缩中进行搜索。</p><h2 id="四、代码测试">四、代码测试</h2><p>论文作者使用MATLAB实现这个算法。而本人使用的是Github上的大神xuduo35<strong>以C++实现的版本</strong>，原Github项目链接如下：</p><p>论文源代码(MATLAB)：<br><a href="https://github.com/bertinetto/staple">https://github.com/bertinetto/staple</a><br>xuduo35(C++)：<br><a href="https://github.com/xuduo35/STAPLE">https://github.com/xuduo35/STAPLE</a></p><p>本文参考<a href="https://github.com/xuduo35/STAPLE">xuduo34</a>的代码，调用了该项目中<code>fhog.cpp</code>、<code>fhog.h</code>、<code>sse.hpp</code>、<code>staple_tracker.cpp</code>、<code>staple_tracker.hpp</code>文件，下面只放出main函数代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数据定义</span></span><br><span class="line">    STAPLE_TRACKER staple;  <span class="comment">//创建staple跟踪对象</span></span><br><span class="line">    std::vector&lt;cv::Rect_&lt;<span class="type">float</span>&gt;&gt; result_rects;     <span class="comment">//创建矩形容器，存储所有算法识别出的跟踪框</span></span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类</span></span><br><span class="line">    cv::Mat image;      <span class="comment">//用来存储每一帧</span></span><br><span class="line">    cv::Mat tempImage;  <span class="comment">//每一帧的临时变量</span></span><br><span class="line">    int64 tic, toc;     <span class="comment">//算法运行时间起始点与终止点</span></span><br><span class="line">    <span class="type">double</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> show_visualization = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> first_image = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置鼠标操作回调函数</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;STAPLE&quot;</span>);</span><br><span class="line">    cv::<span class="built_in">setMouseCallback</span>(<span class="string">&quot;STAPLE&quot;</span>, on_MouseHandle, (<span class="type">void</span>*)&amp;image);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        capture.<span class="built_in">read</span>(image);<span class="comment">//逐帧读取视频</span></span><br><span class="line">        <span class="built_in">flip</span>(image, image, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line">        <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(drawing_finished == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// 鼠标按下drawing_box=true，在视频画面frame上画矩形</span></span><br><span class="line">            <span class="keyword">if</span>( drawing_box )&#123;</span><br><span class="line">                tempImage.<span class="built_in">copyTo</span>(image);</span><br><span class="line">                cv::<span class="built_in">rectangle</span>(image,groundtruth_rect.<span class="built_in">tl</span>(),groundtruth_rect.<span class="built_in">br</span>(),cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));<span class="comment">// 画框</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                image.<span class="built_in">copyTo</span>(tempImage);<span class="comment">//拷贝源图到临时变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果是第一帧图像,则进行staple初始化操作，反之则只更新staple</span></span><br><span class="line">            <span class="keyword">if</span> (first_image)&#123;</span><br><span class="line">                <span class="comment">// staple初始化操作</span></span><br><span class="line">                staple.<span class="built_in">tracker_staple_initialize</span>(image, groundtruth_rect);</span><br><span class="line">                <span class="comment">// staple目标追踪</span></span><br><span class="line">                staple.<span class="built_in">tracker_staple_train</span>(image, <span class="literal">true</span>);</span><br><span class="line">                first_image = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                groundtruth_rect = staple.<span class="built_in">tracker_staple_update</span>(image);</span><br><span class="line">                staple.<span class="built_in">tracker_staple_train</span>(image, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可视化部分</span></span><br><span class="line">        <span class="keyword">if</span> (show_visualization) &#123;</span><br><span class="line">            <span class="comment">// 显示算法识别的跟踪框</span></span><br><span class="line">            cv::<span class="built_in">rectangle</span>(image, groundtruth_rect, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">128</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入测试视频</span></span><br><span class="line">            <span class="comment">// ******************** //</span></span><br><span class="line">            <span class="comment">// video.write(image);</span></span><br><span class="line">            <span class="comment">// ******************** //</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出图像显示结果</span></span><br><span class="line">            cv::<span class="built_in">imshow</span>(<span class="string">&quot;STAPLE&quot;</span>, image);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Center: [&quot;</span> &lt;&lt; groundtruth_rect.<span class="built_in">tl</span>().x +groundtruth_rect.width/<span class="number">2</span> &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; groundtruth_rect.<span class="built_in">tl</span>().y + groundtruth_rect.height/<span class="number">2</span> &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> key = cv::<span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">27</span> || key == <span class="string">&#x27;q&#x27;</span> || key == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cv::<span class="built_in">destroyAllWindows</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************** 函数定义 ********************/</span></span><br><span class="line"><span class="comment">// 使轴对齐</span></span><br><span class="line"><span class="function">cv::Rect_&lt;<span class="type">float</span>&gt; <span class="title">getAxisAlignedBB</span><span class="params">(std::vector&lt;cv::Point2f&gt; polygon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> cx = <span class="built_in">double</span>(polygon[<span class="number">0</span>].x + polygon[<span class="number">1</span>].x + polygon[<span class="number">2</span>].x + polygon[<span class="number">3</span>].x) / <span class="number">4.</span>;</span><br><span class="line">    <span class="type">double</span> cy = <span class="built_in">double</span>(polygon[<span class="number">0</span>].y + polygon[<span class="number">1</span>].y + polygon[<span class="number">2</span>].y + polygon[<span class="number">3</span>].y) / <span class="number">4.</span>;</span><br><span class="line">    <span class="type">double</span> x1 = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(polygon[<span class="number">0</span>].x, polygon[<span class="number">1</span>].x), polygon[<span class="number">2</span>].x), polygon[<span class="number">3</span>].x);</span><br><span class="line">    <span class="type">double</span> x2 = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(polygon[<span class="number">0</span>].x, polygon[<span class="number">1</span>].x), polygon[<span class="number">2</span>].x), polygon[<span class="number">3</span>].x);</span><br><span class="line">    <span class="type">double</span> y1 = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(polygon[<span class="number">0</span>].y, polygon[<span class="number">1</span>].y), polygon[<span class="number">2</span>].y), polygon[<span class="number">3</span>].y);</span><br><span class="line">    <span class="type">double</span> y2 = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(polygon[<span class="number">0</span>].y, polygon[<span class="number">1</span>].y), polygon[<span class="number">2</span>].y), polygon[<span class="number">3</span>].y);</span><br><span class="line">    <span class="type">double</span> A1 = <span class="built_in">norm</span>(polygon[<span class="number">1</span>] - polygon[<span class="number">2</span>])*<span class="built_in">norm</span>(polygon[<span class="number">2</span>] - polygon[<span class="number">3</span>]);</span><br><span class="line">    <span class="type">double</span> A2 = (x2 - x1) * (y2 - y1);</span><br><span class="line">    <span class="type">double</span> s = <span class="built_in">sqrt</span>(A1 / A2);</span><br><span class="line">    <span class="type">double</span> w = s * (x2 - x1) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> h = s * (y2 - y1) + <span class="number">1</span>;</span><br><span class="line">    <span class="function">cv::Rect_&lt;<span class="type">float</span>&gt; <span class="title">rect</span><span class="params">(cx<span class="number">-1</span>-w/<span class="number">2.0</span>, cy<span class="number">-1</span>-h/<span class="number">2.0</span>, w, h)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> rect;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取groundtruth内的矩形坐标</span></span><br><span class="line">std::vector&lt;cv::Rect_&lt;<span class="type">float</span>&gt;&gt; <span class="built_in">getgroundtruth</span>(std::string txt_file)</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;cv::Rect_&lt;<span class="type">float</span>&gt;&gt; rects;</span><br><span class="line">    std::ifstream gt;</span><br><span class="line">    gt.<span class="built_in">open</span>(txt_file.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (!gt.<span class="built_in">is_open</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Ground truth file &quot;</span> &lt;&lt; txt_file</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; can not be read&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="type">float</span> x1, y1, x2, y2, x3, y3, x4, y4;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(gt, line)) &#123;</span><br><span class="line">        std::<span class="built_in">replace</span>(line.<span class="built_in">begin</span>(), line.<span class="built_in">end</span>(), <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss.<span class="built_in">str</span>(line);</span><br><span class="line">        ss &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; x4 &gt;&gt; y4;</span><br><span class="line">        std::vector&lt;cv::Point2f&gt;polygon;</span><br><span class="line">        polygon.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(x1, y1));</span><br><span class="line">        polygon.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(x2, y2));</span><br><span class="line">        polygon.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(x3, y3));</span><br><span class="line">        polygon.<span class="built_in">push_back</span>(cv::<span class="built_in">Point2f</span>(x4, y4));</span><br><span class="line">        rects.<span class="built_in">push_back</span>(<span class="built_in">getAxisAlignedBB</span>(polygon)); <span class="comment">//0-index</span></span><br><span class="line">    &#125;</span><br><span class="line">    gt.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> rects;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一帧画框鼠标响应</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_MouseHandle</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* param )</span></span>&#123;</span><br><span class="line">    cv::Mat&amp; image = *(cv::Mat*) param;</span><br><span class="line">    <span class="keyword">switch</span>( event)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//鼠标移动消息</span></span><br><span class="line">        <span class="keyword">case</span> cv::EVENT_MOUSEMOVE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( drawing_box )<span class="comment">//如果是否进行绘制的标识符为真，则记录下长和宽到RECT型变量中</span></span><br><span class="line">            &#123;</span><br><span class="line">                groundtruth_rect.width = x-groundtruth_rect.x;</span><br><span class="line">                groundtruth_rect.height = y-groundtruth_rect.y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左键按下消息</span></span><br><span class="line">        <span class="keyword">case</span> cv::EVENT_LBUTTONDOWN:</span><br><span class="line">        &#123;</span><br><span class="line">            drawing_box = <span class="literal">true</span>;</span><br><span class="line">            groundtruth_rect = cv::<span class="built_in">Rect</span>( x, y, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">//记录起始点</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左键抬起消息</span></span><br><span class="line">        <span class="keyword">case</span> cv::EVENT_LBUTTONUP:</span><br><span class="line">        &#123;</span><br><span class="line">            drawing_box = <span class="literal">false</span>;<span class="comment">//置标识符为false</span></span><br><span class="line">            drawing_finished = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//对宽和高小于0的处理</span></span><br><span class="line">            <span class="keyword">if</span>( groundtruth_rect.width &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                groundtruth_rect.x += groundtruth_rect.width;</span><br><span class="line">                groundtruth_rect.width *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( groundtruth_rect.height &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                groundtruth_rect.y += groundtruth_rect.height;</span><br><span class="line">                groundtruth_rect.height *= <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用函数进行绘制</span></span><br><span class="line">            cv::<span class="built_in">rectangle</span>(image,groundtruth_rect.<span class="built_in">tl</span>(),groundtruth_rect.<span class="built_in">br</span>(),cv::<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));<span class="comment">// 画框</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为在Staple目标跟踪程序的基础上改编，与Realsense D435i相机的深度图结合的测试程序。</p><p><img src="https://img.mahaofei.com/img/20220405_target_tracking.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 2D视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 目标跟踪 </tag>
            
            <tag> Staple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS与STM32通信</title>
      <link href="/post/7ea7f1cc.html"/>
      <url>/post/7ea7f1cc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>ROS功能包与STM32工程文件：<br>蓝奏云：<a href="https://huffie.lanzouw.com/iN7w602ti37a">https://huffie.lanzouw.com/iN7w602ti37a</a></p></blockquote><h1>1 通信协议</h1><p>STM32和ROS端各有一个数据发送函数和数据接收函数，发送和接受的数据以数据包的形式发送。</p><h2 id="数据包的内容：">数据包的内容：</h2><p>数据头55aa + 数据字节数size + 数据共用体 + 校验crc8 + 数据尾0d0a</p><h1>2 原理</h1><h2 id="2-1-收发数据方法简述">2.1 收发数据方法简述</h2><p>首先，串口收发数据是一个字节一个字节的传输的。一个字节最大表示数据是255，而往往我们需要传递的传感器数据都是int/float类型的。</p><p>传统的串口通信方法是将int/float数据分解成一个个字节发送出去。</p><p>而这里使用共用体，将数据通过共用体转换为数组发送。</p><h2 id="2-2-数据共用体的使用">2.2 数据共用体的使用</h2><p><strong>共用体的规则</strong>：</p><ul><li>共用体是结构体内不同成员共享内存的机制，各成员内存地址一致</li><li>同一时刻只能访问其中的一个成员</li><li>不同成员按照成员类型的性质进行内存访问。</li></ul><p><strong>共用体的创建</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> data;</span><br><span class="line">data.i = <span class="number">10</span>;</span><br><span class="line">data.f = <span class="number">220.5</span>;</span><br><span class="line"><span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后赋给变量的值占用了内存位置，因此同一时间只能用到一个成员。</p><p><strong>如何使用共用体</strong></p><p>在通信两端都定义同样数据结构的共用体，该共用体包含一个short/int/float类型的变量和一个unsigned char类型的数组，数组大小与变量字节大小对应。这样发送和接收数据时，只发送或接收共用体中unsigned char数组的元素。</p><p><img src="https://gitee.com/huffiema/pictures/raw/master/image/202203251701027-stm32-ros-1.png" alt=""></p><h1>3 准备工作</h1><h2 id="3-1-硬件准备">3.1 硬件准备</h2><p>使用STM32串口+TTL转USB模块（CH340）+Linux设备。</p><p><img src="https://gitee.com/huffiema/pictures/raw/master/image/202203251702390-stm32-ros-2.png" alt=""></p><p><strong>注意事项</strong>：</p><ul><li>STM32和ROS的串口波特率必须一致</li><li>STM32串口和USB转TTL模块连接正确，RX-TX，TX-RX</li><li>Linux设备安装好CH340/CH341驱动</li><li>确保串口在Linux系统上有超级用户权限</li><li>将ROS功能包中mbot_linux_serial.cpp文件中的串口设备名字改为自己的设备名</li></ul><h2 id="3-2-串口设置">3.2 串口设置</h2><p><strong>查看串口设备</strong></p><p>Linux设备插上USB转TTL模块后，打开终端，输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/ttyUSB*</span><br></pre></td></tr></table></figure><p>如果终端出现类似下面的输出结果，说明串口设备已经被识别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw-rw---- 1 root dialout 188, 0 3月  25 17:07 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p><strong>设置串口权限</strong></p><p>在终端中输入下面命令：（注意自己的串口设备名）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /dev/ttyUSB0 </span><br><span class="line">source devel/setup.bash</span><br></pre></td></tr></table></figure><p>如果没有任何输出，说明串口设备设置权限成功。（每次重新启动或重新插入串口设备后都需要进行这样的操作）</p><h1>4 程序设计</h1><h2 id="4-1-STM32程序设计">4.1 STM32程序设计</h2><p>工程文件中提供的是STM32F103的程序，也可以在自己板子的串口收发例程的基础上进行修改，添加mbotLinuxUsart.c和mbotLinuxUsart.h到工程中即可。</p><p>函数调用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mbotLinuxUsart.h&quot;</span><span class="comment">//引用该头文件是使用，通信协议的前提</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试发送变量</span></span><br><span class="line"><span class="type">short</span> testSend1   =<span class="number">5000</span>;</span><br><span class="line"><span class="type">short</span> testSend2   =<span class="number">2000</span>;</span><br><span class="line"><span class="type">short</span> testSend3   =<span class="number">1000</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> testSend4 = <span class="number">0x05</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试接收变量</span></span><br><span class="line"><span class="type">int</span> testRece1     =<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> testRece2     =<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> testRece3 = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"><span class="comment">/*************** 硬件初始化 ***************/</span></span><br><span class="line">    <span class="built_in">delay_init</span>();                                   <span class="comment">//延时函数初始化   </span></span><br><span class="line">    <span class="built_in">NVIC_PriorityGroupConfig</span>(NVIC_PriorityGroup_2); <span class="comment">//设置中断优先级分组2</span></span><br><span class="line">    <span class="built_in">uart_init</span>(<span class="number">115200</span>);                              <span class="comment">//串口初始化为115200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************循环程序 ***************/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将需要发送到ROS的数据，从该函数发出，前三个数据范围（-32768 - +32767），第四个数据的范围(0 - 255)</span></span><br><span class="line">        <span class="built_in">usartSendData</span>(testSend1,testSend2,testSend3,testSend4);</span><br><span class="line">        <span class="comment">//必须的延时</span></span><br><span class="line">        <span class="built_in">delay_ms</span>(<span class="number">13</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************** 串口中断服务程序 ***************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">USART1_IRQHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">USART_GetITStatus</span>(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">USART_ClearITPendingBit</span>(USART1,USART_IT_RXNE);<span class="comment">//首先清除中断标志位</span></span><br><span class="line">         <span class="comment">//从ROS接收到的数据，存放到下面三个变量中</span></span><br><span class="line">         <span class="built_in">usartReceiveOneData</span>(&amp;testRece1,&amp;testRece2,&amp;testRece3);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-ROS程序设计">4.2 ROS程序设计</h2><p>[[01-Ubuntu20.04安装ROS Noetic|ROS安装]]过程不再介绍</p><p><strong>第一步</strong></p><p>首先[[13_ROS系统基本功能的使用详解（基本指令、节点、服务、启动文件、动态参数）]]（如果没创建的话）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line">cd catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p><strong>第二步</strong></p><p>将topic_example功能包复制到src目录下，然后回到工作空间目录进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h1>5 测试</h1><p>添加串口设备权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /dev/ttyUSB0</span><br><span class="line">source devel/setup.bash</span><br></pre></td></tr></table></figure><p>打开新终端，启动`ros master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>打开新终端，启动测试功能包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun topic_example publish_node</span><br></pre></td></tr></table></figure><p>可以看到从STM32接收到的数据。</p><p><img src="https://img.mahaofei.com/img/%E9%80%9A%E4%BF%A1STM32%E7%AB%AF.jpg" alt=""></p><p><img src="https://img.mahaofei.com/img/%E9%80%9A%E4%BF%A1%E4%B8%8A%E4%BD%8D%E6%9C%BA%E7%AB%AF.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32控制步进电机</title>
      <link href="/post/1a1a1626.html"/>
      <url>/post/1a1a1626.html</url>
      
        <content type="html"><![CDATA[<p>使用硬件型号为：STM32F103C8T6最小系统板、A4988模块、42步进电机(42BYGH39)</p><h2 id="1-1-A4988介绍">1.1 A4988介绍</h2><p><img src="https://img.mahaofei.com/img/202203301130791.png" alt=""><br><img src="https://img.mahaofei.com/img/202203311723230.png" alt=""></p><table><thead><tr><th>引脚</th><th>功能说明</th><th>接线</th></tr></thead><tbody><tr><td>EN</td><td>使能端，低电平有效</td><td>接GND或单片机IOx1</td></tr><tr><td>MS1/2/3</td><td>步进模式选择</td><td>不接或单片机IOx3</td></tr><tr><td>SLP</td><td>休眠，高电平有效</td><td>短接RST</td></tr><tr><td>STEP</td><td>输入脉冲，一个脉冲转一下</td><td>单片机IOx1</td></tr><tr><td>DIR</td><td>方向位，0/1各代表一方向</td><td>单片机IOx1</td></tr><tr><td>VMOT/GND</td><td>电源接口，直流供电8~35V，最大2A</td><td>12/24V电源</td></tr><tr><td>1A/1B/2A/2B</td><td>步进电机接线</td><td>步进电机</td></tr><tr><td>VDD/GND</td><td>接单片机3.3V和GND</td><td>单片机电源</td></tr></tbody></table><h2 id="1-2-接线方式">1.2 接线方式</h2><p><strong>STM32与USB转TTL</strong></p><table><thead><tr><th>STM32</th><th>USB转TTL</th></tr></thead><tbody><tr><td>3.3V/5V</td><td>3.3/5V</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>PA9</td><td>RXD</td></tr><tr><td>PA10</td><td>TXD</td></tr></tbody></table><p><strong>STM32与A4988</strong></p><table><thead><tr><th>STM32</th><th>A4988</th></tr></thead><tbody><tr><td>3.3V/5V</td><td>VDD</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>PB6</td><td>STEP(motor.h定义)</td></tr><tr><td>PB7</td><td>DIR (motor.h定义)</td></tr><tr><td></td><td>EN接GND</td></tr><tr><td></td><td>SLP接RST</td></tr></tbody></table><p><strong>A4988与步进电机</strong></p><table><thead><tr><th>A4988</th><th>步进电机</th></tr></thead><tbody><tr><td>VMOT</td><td>12V电源+</td></tr><tr><td>GND</td><td>12V电源-</td></tr><tr><td>B2</td><td>B-</td></tr><tr><td>A2</td><td>B+</td></tr><tr><td>A1</td><td>A+</td></tr><tr><td>B1</td><td>A-</td></tr></tbody></table><p><strong>需要注意步进电机接线相序</strong></p><p>A4988标注的1A、1B、2A、2B，数字代表相、ab代表正负。</p><p>步进电机标注的A+、A-、B+、B-，其中AB代表相，±代表正负。</p><p>因此接线对应方式应该是：<strong>A+和A-对应1A和1B、B+和B-对应2A和2B</strong>。比如我的步进电机为黑色A+、绿色A-、红色B+、蓝色B-，那么对应A4988的B2 A2 A1 B1，电机接线顺序就是B- B+ A+ A-（蓝-红-黑-绿）。</p><p>如果接错可能会出现电机反转，或只振动不旋转的现象。</p><h2 id="1-2-程序设计">1.2 程序设计</h2><p>本程序为串口控制步进电机，改编自开发板的串口例程，另外编写了步进电机的驱动函数。</p><p>GPIO中间的延时表示速度，delay_ms(2)约0.8s每圈，delay_ms(1)约0.4s每圈。</p><p>默认情况下（全步进）一个STEP脉冲步进电机转90°。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//motor.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MOTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MOTOR_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//PF0-7,12-15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_GPIO GPIOF<span class="comment">//PF</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor_RCC RCC_APB2Periph_GPIOF</span></span><br><span class="line"><span class="comment">//第一个步进电机A4988的接线</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor1_STEPGPIO_Pin_1<span class="comment">//STEP - PF1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor1_DIRGPIO_Pin_2<span class="comment">//DIR  - PF2</span></span></span><br><span class="line"><span class="comment">//第二个步进电机A4988的接线//PB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor2_STEPGPIO_Pin_3<span class="comment">//STEP - PF3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Motor2_DIRGPIO_Pin_4<span class="comment">//DIR  - PF4</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MOTOR_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">motor</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> motor1_dir, <span class="type">unsigned</span> <span class="type">int</span> motor1_step, <span class="type">unsigned</span> <span class="type">int</span> motor2_dir, <span class="type">unsigned</span> <span class="type">int</span> motor2_step)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//motor.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;motor.h&quot;</span></span></span><br><span class="line"><span class="comment">/*GPIO_motornum和GPIOx用于选择电机，GPIO_direction用于选择电机方向，dir：0为逆1为正，k为90°的倍数*/</span></span><br><span class="line"><span class="comment">// GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MOTOR_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">  RCC_APB2PeriphClockCmd(Motor_RCC,ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Motor初始化</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = Motor1_STEP|Motor1_DIR|Motor2_STEP|Motor2_DIR;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(Motor_GPIO,&amp;GPIO_InitStructure);<span class="comment">// 初始化GPIOB</span></span><br><span class="line">GPIO_ResetBits(Motor_GPIO,Motor1_STEP);<span class="comment">//初始化GPIOB_6输出低电平</span></span><br><span class="line">GPIO_ResetBits(Motor_GPIO,Motor1_DIR);<span class="comment">//初始化GPIOB_7输出低电平</span></span><br><span class="line">GPIO_ResetBits(Motor_GPIO,Motor2_STEP);<span class="comment">//初始化GPIOB_8输出低电平</span></span><br><span class="line">GPIO_ResetBits(Motor_GPIO,Motor2_DIR);<span class="comment">//初始化GPIOB_9输出低电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">motor</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> motor1_dir, <span class="type">unsigned</span> <span class="type">int</span> motor1_step, <span class="type">unsigned</span> <span class="type">int</span> motor2_dir, <span class="type">unsigned</span> <span class="type">int</span> motor2_step)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(motor1_dir)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> : GPIO_SetBits(Motor_GPIO,Motor1_DIR); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> : GPIO_ResetBits(Motor_GPIO,Motor1_DIR); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">default</span> : <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(motor2_dir)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> : GPIO_SetBits(Motor_GPIO,Motor2_DIR); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> : GPIO_ResetBits(Motor_GPIO,Motor2_DIR); <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">default</span> : <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GPIO_SetBits(Motor_GPIO,Motor1_STEP);</span></span><br><span class="line"><span class="comment">GPIO_SetBits(Motor_GPIO,Motor2_STEP);</span></span><br><span class="line"><span class="comment">delay_ms(2);//周期1.3ms</span></span><br><span class="line"><span class="comment">GPIO_ResetBits(Motor_GPIO,Motor1_STEP);</span></span><br><span class="line"><span class="comment">GPIO_ResetBits(Motor_GPIO,Motor2_STEP);</span></span><br><span class="line"><span class="comment">delay_ms(2);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; motor1_step || i &lt; motor2_step; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;motor1_step)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(Motor_GPIO,Motor1_STEP);</span><br><span class="line">delay_ms(<span class="number">2</span>);<span class="comment">//周期1.3ms</span></span><br><span class="line">GPIO_ResetBits(Motor_GPIO,Motor1_STEP);</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;motor2_step)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(Motor_GPIO,Motor2_STEP);</span><br><span class="line">delay_ms(<span class="number">2</span>);<span class="comment">//周期1.3ms</span></span><br><span class="line">GPIO_ResetBits(Motor_GPIO,Motor2_STEP);</span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delay_ms(2);//延时一会</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mbotLinuxUsart.h&quot;</span><span class="comment">//引用该头文件是使用，通信协议的前提</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;motor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_WIDTH640/2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_HEIGHT480/2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试发送变量</span></span><br><span class="line"><span class="type">short</span> testSend1   =<span class="number">1111</span>;</span><br><span class="line"><span class="type">short</span> testSend2   =<span class="number">2222</span>;</span><br><span class="line"><span class="type">short</span> testSend3   =<span class="number">3333</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> testSend4 = <span class="number">0x05</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试接收变量</span></span><br><span class="line"><span class="type">int</span> testRece1     =<span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> testRece2     =<span class="number">300</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> testRece3 = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//=======================================变量定义=====================================================</span></span><br><span class="line">u8 dir1;</span><br><span class="line">u8 dir2;</span><br><span class="line">u16 step1;</span><br><span class="line">u16 step2;</span><br><span class="line"><span class="comment">//======================================硬件初始化====================================================</span></span><br><span class="line">delay_init();                            <span class="comment">//延时函数初始化</span></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">//设置中断优先级分组2</span></span><br><span class="line">uart_init(<span class="number">115200</span>);                            <span class="comment">//串口初始化为115200</span></span><br><span class="line">MOTOR_Init(); <span class="comment">//初始化A4988驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=======================================循环程序=====================================================</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将需要发送到ROS的数据，从该函数发出，前三个数据范围（-32768 - +32767），第四个数据的范围(0 - 255)</span></span><br><span class="line">usartSendData(testSend1,testSend2,testSend3,testSend4);</span><br><span class="line"><span class="keyword">if</span>(testRece1&gt;IMAGE_WIDTH)</span><br><span class="line">&#123;</span><br><span class="line">dir1=<span class="number">1</span>;</span><br><span class="line">step1=testRece1-IMAGE_WIDTH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dir1=<span class="number">0</span>;</span><br><span class="line">step1=IMAGE_WIDTH-testRece1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(testRece2&gt;IMAGE_HEIGHT)</span><br><span class="line">&#123;</span><br><span class="line">dir2=<span class="number">0</span>;</span><br><span class="line">step2=testRece2-IMAGE_HEIGHT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dir2=<span class="number">1</span>;</span><br><span class="line">step2=IMAGE_HEIGHT-testRece2;</span><br><span class="line">&#125;</span><br><span class="line">motor(dir1,step1,dir2,step2);</span><br><span class="line"><span class="comment">//必须的延时</span></span><br><span class="line">delay_ms(<span class="number">13</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//====================================串口中断服务程序=================================================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line"> USART_ClearITPendingBit(USART1,USART_IT_RXNE);<span class="comment">//首先清除中断标志位</span></span><br><span class="line"> <span class="comment">//从ROS接收到的数据，存放到下面三个变量中</span></span><br><span class="line"> usartReceiveOneData(&amp;testRece1,&amp;testRece2,&amp;testRece3);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===========================================END=======================================================</span></span><br></pre></td></tr></table></figure><h2 id="1-3-实验">1.3 实验</h2><p>STM32从ROS系统获取图像中的目标中心坐标。<br>receiveData1存放目标x值，receiveData2存放目标y值。</p><p>由于ROS系统持续发送坐标值，因此STM32实时接受数据进行控制。A4988采用16细分，每次驱动(50循环)步进5.625°，即每个循环0.1°，可考虑根据目标偏移程度设置每次指令步进大小。例如每差1坐标，每次指令加一个循环0.1°。</p><p><img src="https://img.mahaofei.com/img/STM32_Control_StepMotor.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云图床搭建方法</title>
      <link href="/post/d05a7f72.html"/>
      <url>/post/d05a7f72.html</url>
      
        <content type="html"><![CDATA[<p>由于现在一直在CSDN和自己的网站同步写博客记录，可是以前我都是在CSDN编辑器内直接码字上传，但这样的编辑方式很难受，我还是更喜欢像Typora的本地markdown编辑器，这样就需要有一个自己的图床，本地截图粘贴到markdown编辑器内，就会自动上传到自己的图床中。</p><h1>开通阿里云OSS服务</h1><p>首先需要开通<a href="https://www.aliyun.com/product/oss">阿里云OSS服务</a>，登录账号后直接点击立即开通就可以。</p><p>阿里云提供了两种计费方式：</p><ul><li>按量收费：这是默认的计费方式，开通OSS后就是这种方式，不需要提前付款，使用后会直接从账户内扣钱。</li><li>包月包年套餐：点击折扣套餐可以看到各种不同容量和时间的套餐</li></ul><p>由于我在这里只存储写博客用到的图片，每张图片只有几十K，就算是最小的40G套餐我也是远远用不到的，因此我选择按量收费，也就是这里不操作，直接下一步。</p><blockquote><p>2023年2月回来更新，本人小网站，月流量3-5G左右，一年下来充的10块钱只用了两块六，中间那个60多的是续了一下域名。</p></blockquote><p><img src="https://img.mahaofei.com/img/20230227100851.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20230227101229.png" alt=""></p><h1>新建Bucket</h1><p>Bucket相当于存储图片的容器，这里新建Bucket。</p><ul><li>输入Bucket的名称：生成链接后，链接名称的组成部分（*****.oss-cn-beijing.aliyuncs.com）</li><li>区域：选择一个离你最近的就可以</li><li>存储类型：一般选择标准存储</li><li>读写权限：必须选择公共读，否则其他人无法访问图片</li><li>剩余的服务都不需要开启</li></ul><p>打开Bucket列表，在刚创建的bucket下新建一个目录img，用于存放博客图片。</p><p><img src="https://img.mahaofei.com/img/202203260958360.png" alt=""></p><h1>设置自定义域名</h1><p>为Bucket绑定域名</p><p>打开自己的Bucket，进入【传输管理】，点击【域名管理-绑定域名】</p><p>其中的<strong>image</strong>就是以后图片访问时的前缀（例如https://image.mahaofei.com/avatar.jpg）</p><p><img src="https://img.mahaofei.com/img/20220511105137.png" alt=""></p><p>最好可以再申请一个免费SSL证书部署上。</p><h1>获取阿里云AccessKey</h1><p>鼠标移动到阿里云首页右上角个人头像，点击AccessKey管理。</p><p>进入页面后可能会出现安全提示，点击继续使用AccessKey。</p><p>点击创建AccessKey，通过验证后就可以看到AccessKey了。</p><p>这里的AccessKey ID和AccessKey Secret一定要记录好，而且一定不能公开。</p><h1>下载安装Picgo</h1><p>下面是Picgo项目的Github链接，直接在这里下载就可以。<br><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h1>配置Picgo</h1><p>在Picgo设置里勾选显示阿里云OSS图床（默认已经打开了很多常用图床）</p><p>在图床设置-阿里云OSS设置内，填写自己的信息</p><p><img src="https://img.mahaofei.com/img/202203260959238.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博途TIA Portal V15 下载与安装教程</title>
      <link href="/post/bb559113.html"/>
      <url>/post/bb559113.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>下载链接：</p><p>百度网盘： <a href="https://pan.baidu.com/s/1X3hMP5n2DlMXB_wiGztarg?pwd=dpzk">https://pan.baidu.com/s/1X3hMP5n2DlMXB_wiGztarg?pwd=dpzk</a></p><p>提取码: dpzk</p><p>（百度网盘不限速下载方法：<a href="https://www.mahaofei.com/post/e5808c6a.htm">https://www.mahaofei.com/post/e5808c6a.html</a>）</p></blockquote><h2 id="准备工作">准备工作</h2><p>在安装西门子软件的时候，经常提示要重启，而且重启之后依然提示重启，让人莫名烦恼， 按照以下步骤删除注册表则不会再提示重启。<br><font color="red">注意：删除注册表后不要重启，直接继续安装，（删除此文件对电脑没有任何影响）</font></p><ol><li>在windows系统下，按下组合键：WIN+R，输入“regedit”，打开注册表编辑器<br><img src="https://img.mahaofei.com/img/202203261044325.png" alt="">找到 HEEY_LOCAL_MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\SESSION MANAGE\ 下的 PendingFileRemameOpeaations 键，直接删除该键值。不需要重新启动，继续你的软件安装即可。<br><img src="https://img.mahaofei.com/img/202203261044343.png" alt=""></li></ol><blockquote><p>安装前注意：</p><ul><li>V15 支持WIN11 WIN10  WIN8  WIN7, 但必须都是64位系统</li><li>文件下载完成，安装出现安装过程中出错，则重新安装或修复，如果再次安装仍出现此问题则只能重新安装系统后再装软件，之所以出现这种问题，因为博途软件较庞大，所用到的数据库文件非常复查，系统内含有其他第三方软件可能导致博途安装无法正常成功，所以尽量保持系统的纯净再安装，切记，万不能开始各种杀毒软件，尤其360，否在无法保证是否能成功，或者安装完成能否正常使用。</li></ul></blockquote><h2 id="font-color-red-安装前一定要关闭杀毒软件-font"><font color="red">安装前一定要关闭杀毒软件</font></h2><h2 id="开始安装软件">开始安装软件</h2><h3 id="①-安装STEP7-Professional">① 安装STEP7 Professional</h3><ol><li>将安装包解压，进入<strong>01-STEP7+Wincc Profesional V15</strong>文件夹，运行<strong>TIA_Portal_STEP_7_Pro_WINCC_Pro_V15.exe</strong>，首先安装SETP7 Professional（PLC编程软件+WINCC触摸屏和上位机组态软件）<br><img src="https://img.mahaofei.com/img/202203261045172.png" alt=""></li><li>选择要安装的位置（尽量避免解压在C盘），然后点击下一步等待解压，解压过程5分钟左右<br><img src="https://img.mahaofei.com/img/202203261045963.png" alt=""></li><li>开始正式安装，<strong>直接点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045632.png" alt=""></li><li>语言选择默认勾选中文，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045370.png" alt=""></li><li>默认典型安装即可，<strong>浏览选择安装路径</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045522.png" alt=""></li><li><strong>勾选接受两个条款协议</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045996.png" alt=""></li><li><strong>勾选接受</strong>安全和权限设置，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045675.png" alt=""></li><li>确认安装路径没问题后，<strong>点击安装按钮</strong>，开始进行安装，安装过程约40分钟<br><img src="https://img.mahaofei.com/img/202203261045605.png" alt=""></li><li><strong>选择立即重启</strong>，完成安装（这里需要重启电脑，否则无法进行后续安装）</li></ol><h3 id="②-安装STEP7-Simulation">② 安装STEP7_Simulation</h3><ol><li>进入<strong>02-PLCSIM_V15</strong>文件夹，双击运行<strong>SIMATIC_S7PLCSIM_V15.exe</strong>，开始安装STEP7_simulation（PLC的仿真软件）<br><img src="https://img.mahaofei.com/img/202203261046807.png" alt=""></li><li>开始安装，直接<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046519.png" alt=""></li><li>安装语言默认选择中文，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046465.png" alt=""></li><li><strong>选择安装文件解压路径（不要和上一个程序选择同一路径，否则会出现文件覆盖问题）</strong>，然后<strong>点击下一步</strong>，等待解压，此过程约3分钟<br><img src="https://img.mahaofei.com/img/202203261046214.png" alt=""></li><li>进入安装程序，点击下一步开始安装<br><img src="https://img.mahaofei.com/img/202203261046805.png" alt=""></li><li>默认选择中文，<strong>点击下一步</strong>继续<br><img src="https://img.mahaofei.com/img/202203261046058.png" alt=""></li><li>浏览<strong>选择安装路径</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046718.png" alt=""></li><li><strong>接受条款协议</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261047339.png" alt=""></li><li>接受计算机安全和权限设置，点击下一步<br><img src="https://img.mahaofei.com/img/202203261047195.png" alt=""></li><li><strong>检查安装路径</strong>没问题，<strong>点击安装按钮</strong>开始安装软件12<br><img src="https://img.mahaofei.com/img/202203261047722.png" alt=""></li><li>选择稍后重启，完成安装<br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220326104732524.png" alt="image-20220326104732524"></li></ol><h3 id="③-安装驱动（如果只仿真，不需要连接PLC可跳过安装）">③ 安装驱动（如果只仿真，不需要连接PLC可跳过安装）</h3><ol><li>进入<strong>Startdrive</strong>文件夹中，双击运行<strong>Startdrive_V15.exe</strong>，按步骤进行安装<br><img src="https://img.mahaofei.com/img/202203261047076.png" alt=""></li></ol><h3 id="④-授权">④ 授权</h3><ol><li>在授权文件夹下找到<strong>Sim_EKB_Install_2018_11_14.exe</strong>文件，右键<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202203261047455.png" alt=""></li><li>授权Step7 Professional<br><img src="https://img.mahaofei.com/img/202203261047872.png" alt=""></li><li>授权WinCC，找到TIA Portal  --TIA Portal V15 –WINCC Prof v15，按图找到几个选项后点击安装长密钥<br><img src="https://img.mahaofei.com/img/202203261047560.png" alt=""></li><li>然后关闭程序，重启计算机</li></ol><blockquote><p>如果重启后打开软件授权不成功，则在C盘找到AX NF  ZZ文件夹删除（如果找不到，请打开显示隐藏文件夹）<br><img src="https://img.mahaofei.com/img/202203261048361.png" alt=""><br>如果以上步骤操作完毕仍然无法授权，则需要重装Windows纯净系统，不要再安装任何其他软件和杀毒管家等，直接安装博途</p></blockquote><p>在桌面找到TIA Portal V15软件，双击运行，可正常启动<br><img src="https://img.mahaofei.com/img/202203261048756.png" alt=""><br><img src="https://img.mahaofei.com/img/202203261048505.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> PLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河北工业大学机械电子工程专业课程资料（个人整理，请勿外传）</title>
      <link href="/post/21df2adf.html"/>
      <url>/post/21df2adf.html</url>
      
        <content type="html"><![CDATA[<h2 id="公共课">公共课</h2><blockquote><p>阿里云盘（公共课）<br>链接：<a href="https://www.aliyundrive.com/s/C79yBpjasnL">https://www.aliyundrive.com/s/C79yBpjasnL</a><br>提取码：f79h</p></blockquote><h3 id="大二上"><em>大二上</em></h3><table><thead><tr><th>线性代数</th><th>大学物理</th><th>马克思主义基本原理概论</th></tr></thead><tbody><tr><td>PPT</td><td>PPT、习题、测试题</td><td>教材、题库</td></tr></tbody></table><h3 id="大二下"><em>大二下</em></h3><table><thead><tr><th>概率论与数理统计</th><th>毛泽东思想和中国特色社会主义理论体系概论</th><th>       </th></tr></thead><tbody><tr><td>教材、PPT、作业答案</td><td>题库</td><td></td></tr></tbody></table><hr><h2 id="专业课">专业课</h2><h3 id="大二下-2"><em>大二下</em></h3><blockquote><p>阿里云盘（机械原理、材料力学）<br>链接：<a href="https://www.aliyundrive.com/s/ww4YmgGCgaw">https://www.aliyundrive.com/s/ww4YmgGCgaw</a><br>提取码: vc12</p></blockquote><blockquote><p>阿里云盘（电工电子技术、互换性与测量技术）<br>链接：<a href="https://www.aliyundrive.com/s/anzigLq7aL8">https://www.aliyundrive.com/s/anzigLq7aL8</a><br>提取码：g1g1</p></blockquote><table><thead><tr><th>电工电子技术</th><th>机械原理</th><th>材料力学</th></tr></thead><tbody><tr><td>教材、教材习题答案、PPT</td><td>课本PDF、课本同步辅导、PPT、考试重点提纲<br>课设图册、指导视频</td><td>PPT、教材PDF</td></tr><tr><td><strong>互换性与测量技术</strong></td><td></td><td></td></tr><tr><td>教材PDF、复习题库、考试原题、实验报告</td><td></td><td></td></tr></tbody></table><hr><h3 id="大三上"><em>大三上</em></h3><blockquote><p>阿里云盘（大三上）<br>链接：<a href="https://www.aliyundrive.com/s/b5GEhTQSvfn">https://www.aliyundrive.com/s/b5GEhTQSvfn</a><br>提取码：o06e</p></blockquote><table><thead><tr><th>机械设计</th><th>机电传动与控制</th><th>液压传动与控制</th></tr></thead><tbody><tr><td>教材PDF、教材题目答案、个人笔记</td><td>教材PDF、教材答案</td><td>教材PDF、PPT</td></tr><tr><td><strong>自动控制原理</strong></td><td></td><td></td></tr><tr><td>教材PDF、PPT、课外阅读资料</td><td></td><td></td></tr></tbody></table><hr><h3 id="大三下"><em>大三下</em></h3><blockquote><p>阿里云盘（大三下）<br>链接：<a href="https://www.aliyundrive.com/s/avKAipgUyv9">https://www.aliyundrive.com/s/avKAipgUyv9</a><br>提取码：y39p</p></blockquote><table><thead><tr><th>传感与检测技术</th><th>微机原理及应用</th><th>机械制造技术基础</th></tr></thead><tbody><tr><td>PPT、个人笔记</td><td>PPT、个人笔记</td><td>教材PDF、PPT、作业答案、个人笔记</td></tr><tr><td><strong>机械动力学</strong></td><td></td><td></td></tr><tr><td>教材PDF、PPT、个人笔记</td><td></td><td></td></tr></tbody></table><hr><h3 id="大四上"><em>大四上</em></h3><blockquote><p>阿里云盘（大四上）<br>链接：<a href="https://www.aliyundrive.com/s/c5N9CGJXdEX">https://www.aliyundrive.com/s/c5N9CGJXdEX</a><br>提取码：70mq</p></blockquote><table><thead><tr><th>数控技术</th><th>机器人技术及应用</th><th>机电系统建模仿真</th></tr></thead><tbody><tr><td>教材PDF、PPT、个人笔记</td><td>PPT、个人笔记</td><td>复习题库</td></tr><tr><td><strong>机电系统设计</strong></td><td><strong>电气控制与PLC</strong></td><td></td></tr><tr><td>复习笔记</td><td>PPT</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【目标识别】SIFT算法理论部分</title>
      <link href="/post/f8e83802.html"/>
      <url>/post/f8e83802.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍-2">一、介绍</h2><h3 id="1-1-SIFT算法">1.1 SIFT算法</h3><p>SIFT(Scale invariant feature transform)是尺度不变特征变换，是一种用来检测和描述图像局部特征的算法。算法实际上是要在不同尺度空间中寻找极值点，并提取其位置、尺度和旋转不变量，这些关键点不会因光照、仿射变换和噪音而变化。</p><h3 id="1-2-SIFT特征的获取方法">1.2 SIFT特征的获取方法</h3><ol><li><p><strong>尺度空间极值检测</strong></p><p>利用高斯差分函数搜索所有尺度和图像位置，找到对尺度和方向不变的候选关键点。</p></li><li><p><strong>关键点定位</strong></p><p>对每一个候选关键点都需要确定其位置和尺度，并要保证其稳定性。</p></li><li><p><strong>方向分配</strong></p><p>根据局部图像的梯度方向，为每个关键点分配一个或多个方向。</p></li><li><p><strong>关键点描述</strong></p><p>在每个关键点周围区域的选定尺度上测量局部图像的梯度，这些信息表示了允许的局部形状失真和光照变化。</p></li></ol><h3 id="1-3-图像匹配和识别的方法">1.3 图像匹配和识别的方法</h3><ol><li>先从一组目标物体的参考图像中提取SIFT特征并存储在数据库。</li><li>将新图像的每个特征与之前的数据库逐一比较，根据特征向量的欧几里得距离找到匹配特征。</li></ol><h3 id="1-4-如何提高匹配准确率">1.4 如何提高匹配准确率</h3><ol><li><p>利用识别与新图像中对象的位置、比例和方向一致的关键点子集，可以在匹配集中过滤出正确的匹配。几个特征共同作为判断依据匹配出错率远小于单一特征匹配。</p></li><li><p>匹配方法</p><p>①先对物体姿态的放射近似作最小二乘估计，与此姿态一致的其它图像特征被识别出来，异常值被丢弃。</p><p>②给出你和的准确性和可能的错误匹配的数量，对一组特征表明对象存在的概率进行详细计算。</p><p>③通过所有测试的对象匹配可被标为正确且具有高可信度。</p></li></ol><h2 id="二、尺度空间极值检测">二、尺度空间极值检测</h2><p>SIFT算法是在不同的尺度空间上查找关键点，尺度空间的获取需要使用高斯模糊。</p><h3 id="2-1-高斯模糊">2.1 高斯模糊</h3><h4 id="（1）高斯函数">（1）高斯函数</h4><p>高斯模糊使用高斯函数（正态分布）计算模糊模板，并使用该模板与原图像做卷积运算，以此模糊图像。</p><p>N维空间的高斯计算公示：</p><p><img src="https://img.mahaofei.com/img/202112232022082-sift-theory-1.png" alt=""></p><blockquote><ul><li>$\sigma$为正态分布的标准差，$\sigma$越大图像越模糊、越平滑</li><li>$r$为模糊半径，指模板元素到模板中心的距离</li></ul></blockquote><p>二维空间的高斯计算公式：</p><p><img src="https://img.mahaofei.com/img/202112232022463-sift-theory-2.png" alt=""></p><blockquote><ul><li>$\sigma$为正态分布的标准差，$\sigma$越大图像越模糊、越平滑</li><li>m,n为二维模板的大小m*n</li><li>x,y为模板上元素的位置(x,y)</li></ul></blockquote><p>二维高斯函数生成的曲面是从中心开始的正态分布同心圆。每个像素的值都是周围相邻像素的加权平均。原始像素具有最大的权重，边缘像素权重越来越小，因此更高的保留了边缘效果。</p><p>在计算每个像素的离散近似时，$3\sigma$之外的像素都可以视为不起作用，因此图像处理程序只需要计算 $(6\sigma+1)\times(6\sigma+1) $的矩阵就可以了。</p><h4 id="（2）二维高斯模糊">（2）二维高斯模糊</h4><p>根据$\sigma$计算出高斯模板矩阵（大小为$(6\sigma+1)\times(6\sigma+1) $，值根据$G(x,y)$计算）</p><p>对高斯模板矩阵进行归一化处理（确保矩阵元素在$[0,1]$范围内），例如$5\times5$的高斯模板如下图，可以看出高斯模板是中心对称的。</p><p><img src="https://img.mahaofei.com/img/202112232023230-sift-theory-3.png" alt=""></p><p>利用此高斯模板矩阵与原图像做卷积，即可获得原图像的高斯模糊图像。卷积过程示意图如下：</p><p><img src="https://img.mahaofei.com/img/202112232023732-sift-theory-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232024140-sift-theory-5.png" alt=""></p><h4 id="（3）分离高斯模糊">（3）分离高斯模糊</h4><p>二维高斯模糊有两个不足之处：</p><ol><li>使用二维高斯模糊会造成边缘图像缺失，$\sigma$越大，缺失像素越多</li><li>模板变大时，高斯核的卷据运算量会大幅度提高</li></ol><p>解决方法：</p><p>利用高斯函数的可分离性（二维矩阵的变换效果等效于水平方向一维高斯矩阵变换加竖直方向一维高斯矩阵变换）。</p><ol><li>两次一维的高斯卷积将消除二维高斯矩阵所产生的边缘。</li><li>卷积运算只需要O(n×M×N)+O(m×M×N)次计算，而二维矩阵需要O(m×n×M×N)次计算。其中m,n为高斯矩阵的维数。M,N为二维图像的维数。</li></ol><p><img src="https://img.mahaofei.com/img/202112232024414-sift-theory-6.png" alt=""></p><h3 id="2-2-尺度空间">2.2 尺度空间</h3><h4 id="（1）尺度空间的概念">（1）尺度空间的概念</h4><ol><li><p><strong>概念</strong></p><p>在图像信息处理模型中引入一个被视为尺度的参数，通过连续变化尺度参数获得多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为特征向量，实现边缘、角点检测和不同分辨率的特征提取。</p></li><li><p><strong>特点</strong></p><p>将传统的但尺度图像信息处理技术纳入尺度不断变化的动态分析框架中。更容易获取图像的本质特征。尺度空间中各尺度图像的模糊程度逐渐变大，能够模拟人在距离目标由近到远时目标在视网膜上的形成过程。</p></li><li><p><strong>优点</strong></p><p>1）尺度空间算子对图像的分析不受图像的灰度水平和对比度变化的影响，即满足灰度不变性和对比度不变性；</p><p>2）尺度空间算子对图像的分析和图像的位置、大小、角度以及仿射变换无关，即满足平移不变性、尺度不变性、欧几里德不变性以及仿射不变性。</p></li></ol><h4 id="（2）尺度空间的表示">（2）尺度空间的表示</h4><p>尺度空间 $L(x,y,z)$ 定义为变化尺度的高斯函数 $G(x,y,\sigma)$ 与原图像 $I(x,y)$ 的卷积。</p><p><img src="https://img.mahaofei.com/img/202112232025921-sift-theory-7.png" alt=""></p><p>其中$\sigma$为尺度因子，$\sigma$越小对应模糊程度越小，相应的尺度约小。因此大尺度对应图像的概貌特征，小尺度对应图像的细节特征。</p><p><img src="https://img.mahaofei.com/img/202112232025197-sift-theory-8.png" alt=""></p><h4 id="（3）高斯金字塔的构建方法">（3）高斯金字塔的构建方法</h4><p>尺度空间在实现时使用高斯金字塔表示，高斯金字塔构建分为两步：1）对图像做降采样；2）对图像做高斯平滑。</p><p>金字塔模型是指将原始图像不断进行降采样，得到一系列大小不同的图像，由大到小，由下到上。原图像为金字塔的第一层，每次降采样所得到的新图像为金字塔的一层。为了让尺度体现其连续性，高斯金字塔在简单降采样的基础上加上了高斯滤波。</p><p>如上图所示，将图像金字塔每层的一张图像使用不同参数做高斯模糊，Octave表示一幅图像可产生的图像组数，Interval表示一组图像包括的图像层数。另外，降采样时，高斯金字塔上一组图像的初始图像(底层图像)是由前一组图像的倒数第三张图像隔点采样得到的。</p><p>高斯金字塔的层数计算：</p><p><img src="https://img.mahaofei.com/img/202112232025038-sift-theory-9.png" alt=""></p><blockquote><p>M,N：原图像大小<br>t：塔顶图像的最小维度的对数值</p></blockquote><p><img src="https://img.mahaofei.com/img/202112232026124-sift-theory-10.png" alt=""></p><h3 id="2-4-极值检测方法">2.4 极值检测方法</h3><p>由于要在尺度空间中寻找图像的极值点，因此在实际计算中，使用高斯金字塔每组中相邻上下两层图像相减，得到高斯差分图像（Difference of Gaussian ，简称DOG），进行极值检测。即两个相邻尺度的差（这里用常数k区分相邻的尺度）：</p><p>$D(x, y, σ) = (G(x, y, kσ)−G(x, y, σ))∗I(x, y)$</p><p>​$=L(x, y, kσ)−L(x, y, σ)$</p><p>为了寻找高斯差分函数函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。如图所示，中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。</p><p><img src="https://img.mahaofei.com/img/202112232026929-sift-theory-11.png" alt=""></p><p>由于要在相邻尺度进行比较，由于高斯差分金字塔的每一组图像，只能在中间的层进行极值点检测，最上和最下层无法进行。</p><p>为了在每组中检测S个尺度的极值点，则DOG金字塔每组需S+2层图像，而DOG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像，实际计算时S在3到5之间。</p><h3 id="2-5-极值检测的采样频率">2.5 极值检测的采样频率</h3><p>检测局部极大值和极小值，在采样点同层的8个邻域点和上下相邻层的各9个邻域点之中选择，只有大于或这些所有的邻域点才能称为极值。经过检测后绝大多数的采样点都被剔除了。</p><p>其中重要问题就是确定图像和尺度的采样频率，以可靠的检测极值，但事实上极值点可以非常接近，因此需要找到一种平衡效率和完整性的解决方案。</p><h4 id="（1）尺度域的采样频率">（1）尺度域的采样频率</h4><p>经过大量实验数据得到：</p><p>（1）当采样更多尺度时，可重复性没有继续提高，因为这会导致更多的局部极值被检测到，但这些极值平均来说不太稳定，不太可能在被转换后的图像中检测到。</p><p>（2）当采样规模增大时，关键点的数量增加，正确匹配的总数量增加，由于实际使用时物体识别的成功更多取决于正确匹配关键点的数量，而不是正确匹配的百分比，因此使用大量的样本是最好的。但是这会导致计算成本的增加，所以Lowe建议<strong>每组使用3个尺度样本</strong></p><h4 id="（2）空间域的采样频率">（2）空间域的采样频率</h4><p>需要确定在一个尺度内图像域的采样频率，假设极值点可以任意靠近，那么在空间域的采样频率和检测率之间也会有类似的平衡。这里Lowe经过实验，建议选择使用$\sigma=1.6$。</p><p>并且由于在进行极值检测之前进行了差分处理，因此丢弃了最高的空间频率，为了充分利用输入，可以在构建金字塔第一级之前使用线性插值将输入图像的大小增加一倍。</p><h2 id="三、关键点定位">三、关键点定位</h2><h3 id="3-1-关键点的准确定位">3.1 关键点的准确定位</h3><p>离散空间的极值点不是图像真正的极值点。</p><p><img src="https://img.mahaofei.com/img/202112232026016-sift-theory-12.png" alt=""></p><p>为了提高关键点的稳定性，需要对尺度空间函数进行曲线拟合。利用尺度空间函数的Taylor展开式，导数在极值点处为0，求得$x$的偏移量实现对关键点的精确定位。</p><p>将尺度空间函数$D(x,y,\sigma)$进行泰勒展开，使原点与采样点重合。</p><p><img src="https://img.mahaofei.com/img/202112232027590-sift-theory-13.png" alt=""></p><p>对$D(x,y,\sigma)$求导并令其等于零，求得$\hat{x}=−\frac{∂^2D^{-1}}{∂x^2}\frac{∂D}{∂x}$即为$x$的偏移量。</p><h3 id="3-1-消除边缘响应">3.1 消除边缘响应</h3><p>为了稳定，仅去除低对比度的关键点是不够的，还需要消除高斯差分函数带来的边缘响应。在边缘梯度方向的主曲率较大，垂直方向（沿边缘方向）的主曲率较小。主曲率可以通过Hessian矩阵计算：</p><p><img src="https://img.mahaofei.com/img/202112232027721-sift-theory-14.png" alt=""></p><p>其特征值正比于D的主曲率，由于我们只需要特征值的比值$r$，因此可以避免求出特征值的结果。设$\alpha$为较大的特征值，$\beta$为较小的特征值，取$\alpha=r\beta$，利用迹和行列式的特点：</p><p><img src="https://img.mahaofei.com/img/202112232028879-sift-theory-15.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232028531-sift-theory-16.png" alt=""></p><p>因此当两特征值相等时，上式$\frac{Tr(H)^2}{Det(H)}=\frac{(r+1)^2}{r}$有最小值，并且该式随着比值$r$增大而增大，因此要检验主曲率是否在某个阈值以下，只需要检验</p><p>$\frac{Tr(H)^2}{Det(H)}&lt;\frac{(r+1)^2}{r}$。当满足条件时保留特征点，否则剔除。（常用T=1.2）</p><h2 id="四、梯度方向分配">四、梯度方向分配</h2><h3 id="4-1-梯度大小方向求解">4.1 梯度大小方向求解</h3><p>为了使关键点描述子具有旋转不变性，利用图像的局部特征给每一个关键点分配一个基准方向，使描述子对图像旋转具有不变性。对于在高斯差分金字塔中检测出的关键点，采集其所在高斯金字塔图像$3\sigma$邻域窗口的像素的梯度和方向分布特征。梯度的模和方向如下：</p><p><img src="https://img.mahaofei.com/img/202112232029555-sift-theory-17.png" alt=""></p><h3 id="4-2-梯度统计">4.2 梯度统计</h3><p>完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。梯度直方图将0~360°方向分为36份，每个柱子代表10°范围，如图直方图的峰值代表关键点的主方向。</p><p><img src="https://img.mahaofei.com/img/202112232029678-sift-theory-18.png" alt=""></p><p>以直方图中最大值作为该关键点的主方向，为了增强匹配的鲁棒性，只保留峰值大于主方向峰值80％的方向作为该关键点的辅方向。</p><h2 id="五、关键点描述子">五、关键点描述子</h2><p>经过上面的步骤，每一个关键点都拥有位置、尺度、方向三个信息。</p><p>下一步是为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变，使其不随光照、视角等变化而变化。</p><h3 id="5-1-描述符表示">5.1 描述符表示</h3><h4 id="（1）特征向量表示">（1）特征向量表示</h4><p>首先在关键点周围采样图像的梯度大小和方向，利用关键点的尺度选择图像的高斯模糊程度。为了实现方向不变性，描述子的坐标和梯度方向是相对于关键点方向旋转的。</p><p><img src="https://img.mahaofei.com/img/202112232029018-sift-theory-19.png" alt=""></p><p>使用一个$\sigma$等于子窗口宽度的一半的高斯加权函数来为每个采样点的大小赋值。（为了避免随着窗口位置的微小变化导致的描述符的突然变化，同时减少远离描述符中心的梯度影响，这些梯度最容易配准错误）</p><p>描述符由一个包含所有方向直方图条目值的向量构成，Lowe经过实验证明最好的选择是：每个关键点划分4个领域，对应4个描述子，每个描述子使用4x4的方向直方图阵列，每个直方图中有8个梯度方向，因此每个关键点采用4x4x8=128个特征向量。</p><h4 id="（2）归一化处理">（2）归一化处理</h4><p>对特征向量进行修正，减小光照变化对特征向量的影响。</p><ol><li>对比度影响消除</li></ol><blockquote><p>因为图像对比度的变化即每个像素值乘以一个常数，因此归一化会消除对比度的影响。</p></blockquote><p>因此首先将向量归一化为单位长度。</p><ol start="2"><li>照明条件影响消除</li></ol><blockquote><p>图像亮度是每个图像像素加上一个常数，因此亮度变化不会影响图像的梯度，所以描述符对于光照的仿射变化是不变的。（在不考虑非线性光照的情况下）</p></blockquote><p>考虑照明条件变化，可以通过将单位特征向量阈值划为不大于0.2（Lowe实验测得），减少较大梯度的影响，然后重新归一化。此时匹配大梯度不再重要，方向的分布更加重要。</p><h2 id="六、物体识别的应用">六、物体识别的应用</h2><p>目标识别首先通过将每个关键点独立地与从训练图像中提取出的关键点数据库进行匹配来完成。由于模糊的特征和背景影响，一开始匹配肯定是不准确的。所以需要至少有三个特征的聚类首先被识别出来，这些聚类与对象姿态一致，其正确性就比单个特征匹配要高得多。然后对每个聚类进行几何拟合检查，根据拟合结果接受或拒绝。</p><ol><li>从训练图像中识别关键点数据库中的最近邻，找到每个关键点的最佳候选匹配。（最近邻可以使用最小欧式距离）</li><li>如果图像特征在数据库中没有任何正确的匹配，则丢弃。</li><li>如果有多个匹配结果，则定义第二个最近邻为已知来自不同物体。在相似距离内可能会有许多其他错误匹配。我们可以将次近匹配视为在特征空间的这一部分内提供错误匹配密度的估计。</li></ol><h2 id="七、总结">七、总结</h2><p>SIFT特征具有稳定性和不变性，在图像处理和计算机视觉领域有着很重要的作用。</p><p><strong>SIFT算法的主要实现过程</strong></p><ol><li><p><strong>尺度空间极值检测</strong></p></li><li><p><strong>关键点定位</strong></p></li><li><p><strong>方向分配</strong></p></li><li><p><strong>关键点描述和匹配</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> 2D视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 目标识别 </tag>
            
            <tag> SIFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5图形界面GUI开发过程记录</title>
      <link href="/post/6c1e143c.html"/>
      <url>/post/6c1e143c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、PyQT的简介与安装">一、PyQT的简介与安装</h2><h3 id="1-1-常用的图形界面GUI">1.1 常用的图形界面GUI</h3><p>目前主流的python图形界面有Tkinter、PyQT5/PySide2、wxPython等。</p><table><thead><tr><th>图形界面</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Tkinter</td><td>Python标准库、稳定、发布程序较小</td><td>控件少，无法拖拽设计界面</td></tr><tr><td>PyQt5/PySide2</td><td>控件比较丰富、用户多、有designer设计界面</td><td>库比较大，发布出来的程序比较大</td></tr><tr><td>wxPython</td><td>控件比较丰富</td><td>文档少、用户少</td></tr></tbody></table><h3 id="1-2-PyQT5的安装">1.2 PyQT5的安装</h3><p>直接在命令行使用pip工具安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure><p>将PyQt5安装目录下的<code>\plugins\platforms</code>这个路径添加到环境变量Path中。（先找python安装目录<code>Python39</code>或<code>Python38</code>，再找下面的<code>\Lib\site-packages\PyQt5\Qt5</code>）</p><p>如我的路径是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\82785\AppData\Local\Programs\Python\Python39\Lib\site-packages\PyQt5\Qt5\plugins\platforms</span><br></pre></td></tr></table></figure><p><strong>注：设置环境变量后，需要重启电脑，因为新的环境变量要重启后才能被系统识别</strong></p><h2 id="二、PyQt的基本使用">二、PyQt的基本使用</h2><h3 id="2-1-QApplication">2.1 QApplication</h3><p>提供整个图形界面程序的底层管理功能，如初始化、程序入口参数处理、用户事件处理等。</p><ul><li>在创建控件之前，必须先创建QApplication。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = QApplication([])</span><br></pre></td></tr></table></figure><ul><li>在程序末尾，需要添加事件处理循环代码，用于接受输入事件，并分配给相应对象进行处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure><h3 id="2-2-界面控件">2.2 界面控件</h3><p>QMainWindow、QPlainTextEdit、QPushButton是三个控件类，分别是界面的主窗口、文本框、按钮。<code>要想在界面上创建一个控件，就需要在程序代码中创建空间对应的类的实例对象</code>。</p><ul><li>控件是层层嵌套的：<br>创建文本框和按钮时，都需要一个参数window，就是指定父控件对象（主窗口）。<br>而实例化主窗口时，不需要指定父控件，因为主窗口就是最上层控件了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPlainTextEdit(window)</span><br><span class="line">QPushButton(<span class="string">&#x27;文本框&#x27;</span>, window)</span><br></pre></td></tr></table></figure><ul><li>move方法决定了控件的显示位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.move(<span class="number">300</span>, <span class="number">310</span>)<span class="comment"># 主窗口左上角相对屏幕左上角位置</span></span><br><span class="line">textEdit.move(<span class="number">10</span>,<span class="number">25</span>)<span class="comment"># 文本框左上角相对父窗口左上角位置</span></span><br></pre></td></tr></table></figure><ul><li>resize方法决定了控件显示大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.resize(<span class="number">600</span>, <span class="number">400</span>)<span class="comment"># 主窗口宽600像素，高400像素</span></span><br><span class="line">textEdit.resize(<span class="number">200</span>,<span class="number">150</span>)<span class="comment"># 文本框宽200像素，高150像素</span></span><br></pre></td></tr></table></figure><ul><li>show方法将所有放在主窗口的控件显示出来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.show()</span><br></pre></td></tr></table></figure><h3 id="2-3-界面动作处理">2.3 界面动作处理</h3><p>在Qt系统中，当控件被点击、输入文本、拖拽等操作时，会发出信号Signal。</p><p>要想使程序对这些操作进行响应，就要预先在代码中指定处理signal的函数，这样的函数称为slot。</p><p>如定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buttonPress</span>()：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按钮被按下了&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后使用如下代码，让button被按下时，执行buttonPress()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.clicked.connect(buttonPress)</span><br></pre></td></tr></table></figure><h3 id="2-4-窗口封装为类">2.4 窗口封装为类</h3><p>为了模块化、便于使用，以及避免控件中出现的变量名冲突，通常会把<strong>一个窗口和其包含的控件封装到类中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QPushButton,  QPlainTextEdit,QMessageBox</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindows</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.window = QMainWindow()</span><br><span class="line">        self.window.resize(<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">        self.window.move(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        self.window.setWindowTitle(<span class="string">&#x27;示例程序&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.textEdit = QPlainTextEdit(self.window)</span><br><span class="line">        self.textEdit.setPlaceholderText(<span class="string">&quot;文本框提示语&quot;</span>)</span><br><span class="line">        self.textEdit.move(<span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line">        self.textEdit.resize(<span class="number">300</span>, <span class="number">350</span>)</span><br><span class="line"></span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;统计&#x27;</span>, self.window)</span><br><span class="line">        self.button.move(<span class="number">380</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">        self.button.clicked.connect(self.handleCalc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handleCalc</span>(<span class="params">self</span>):</span><br><span class="line">        text = self.textEdit.toPlainText()</span><br><span class="line">        <span class="comment"># 处理程序</span></span><br><span class="line"></span><br><span class="line">app = QApplication([])</span><br><span class="line">mywindow = MyWindows()</span><br><span class="line">mywindow .window.show()</span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h2 id="三、界面设计Qt-Designer">三、界面设计Qt Designer</h2><h3 id="3-1-Qt-Designer的简单介绍">3.1 Qt Designer的简单介绍</h3><p>Qt Designer是一个QT界面生成器，避免了像Tkinter需要将想象的图形界面用代码一行一行写出来。Qt Designer是一种图形化界面设计工具，通过拖拽控件，就可以实现界面布局的设计。</p><p>在python安装目录下的<code>Lib\site-packages\qt5_applications\Qt\bin\designer.exe</code>，这个可执行文件就是Qt Designer程序。</p><p><img src="https://img.mahaofei.com/img/202112232018944-pyqt5-1.png" alt=""></p><p>打开Qt Designer后，界面左侧是控件列表，右侧是对象查看器和属性编辑器。</p><p><img src="https://img.mahaofei.com/img/202112232018814-pyqt5-2.png" alt=""></p><p>创建窗体后，可以直接将左侧的控件，如文本框、按钮等拖入到窗体中，手动调整其大小和位置。在右侧可以修改每个空间的属性。</p><p>创建好图形界面后，点击视图-预览可以查看界面效果，点击保存按钮，即可将图形界面保存为<code>.ui</code>的文件，需要修改界面时可以直接再打开<code>.ui</code>就可以修改界面。</p><h3 id="3-2-布局">3.2 布局</h3><p>简单的控件拖拽布局就不介绍了，这里说一下布局方式。</p><p>常用的布局方式有</p><table><thead><tr><th>布局</th><th>样式</th></tr></thead><tbody><tr><td>水平布局</td><td><img src="https://img.mahaofei.com/img/202112232019148-pyqt5-3.png" alt=""></td></tr><tr><td>垂直布局</td><td><img src="https://img.mahaofei.com/img/202112232019433-pyqt5-4.png" alt=""></td></tr><tr><td>表格布局</td><td><img src="https://img.mahaofei.com/img/202112232020951-pyqt5-5.png" alt=""></td></tr><tr><td>表单布局</td><td><img src="https://img.mahaofei.com/img/202112232020207-pyqt5-6.png" alt=""></td></tr></tbody></table><p>比如点选几个控件，右键设置为水平布局。这样几个空间就组合成了一个大的整体的“控件”。</p><p>再将几个设置好的水平布局选中，右键设置为垂直布局，这样就算是非常快速地制作好了一个非常简单的UI。</p><p><img src="https://img.mahaofei.com/img/202112232021341-pyqt5-7.png" alt=""></p><h3 id="3-3-控件调整">3.3 控件调整</h3><p><strong>（1）控件大小</strong></p><p>主要使用的是<code>sizePolicy</code>这个属性。</p><p>水平策略和垂直策略：</p><p><img src="https://img.mahaofei.com/img/202112232021554-pyqt5-8.png" alt=""></p><p>水平伸缩和垂直伸缩：描述多个部件在水平方向的大小比例，类似于权重。</p><blockquote><p>如两个在同一水平位置的部件的水平伸缩因子分别为1和2，则二者宽带的大小比例为1:2，如果该水平方向再无其他控件，则二者各占布局管理器宽度的1/3和2/3。</p></blockquote><p><strong>（2）控件间距</strong></p><p>上下间距：给控件添加<code>layout</code>属性，通过调整上下的padding和margin来调整间距。</p><p>左右间距：给控件添加<code>layout</code>调整左右的padding和margin来调整间距，或添加<code>horizontal spacer</code>属性调整。</p><h2 id="四、Python程序">四、Python程序</h2><h3 id="4-1-ui文件转换python程序">4.1 ui文件转换python程序</h3><p>使用cmd将目录切换到<code>.ui</code>文件所在目录，使用如下命令生成代码。（请将命令中的name替换成文件名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -o name.py name.ui</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232021448-pyqt5-9.png" alt=""></p><h3 id="4-2-主程序调用ui">4.2 主程序调用ui</h3><p>这时如果尝试运行刚刚生成的python程序是没有用的，因为生成的文件没有程序入口。因此我们需要创建一个主程序用来调用ui程序。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"><span class="comment"># 导入designer工具生成的模块</span></span><br><span class="line"><span class="comment"># 注意导入时filename替换成生成的.py文件名，Ui_file替换成.py文件的类名</span></span><br><span class="line"><span class="keyword">from</span> filename <span class="keyword">import</span> Ui_filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_excel_combine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment"># 将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment"># 程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3 id="4-3-设置按钮、文本框的响应程序">4.3 设置按钮、文本框的响应程序</h3><p>在主程序的MyMainForm类中进行设置，以按钮和文本框为例</p><p><strong>（1）按钮按下处理程序</strong></p><p>例如下面的代码，当按钮被按下时，自动执行括号内的处理函数<code>button_clicked_handle</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buttonname.clicked.connect(button_clicked_handle)</span><br></pre></td></tr></table></figure><p><strong>（2）文本框显示处理程序</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textBrowser.setPlainText(<span class="string">&#x27;显示的字符串&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-4-示例代码">4.4 示例代码</h3><p>我写的代码是合并多个excel数据的程序，其中的GUI部分代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="comment"># 导入designer工具生成的模块</span></span><br><span class="line"><span class="keyword">from</span> excel_combine_ui <span class="keyword">import</span> Ui_excel_combine</span><br><span class="line"></span><br><span class="line">dir_choose = <span class="string">&quot;&quot;</span></span><br><span class="line">filename = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_excel_combine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.cwd = os.getcwd() <span class="comment"># 获取当前程序文件位置</span></span><br><span class="line">        self.sourceButton.clicked.connect(self.slot_source_button)</span><br><span class="line">        self.targetButton.clicked.connect(self.slot_target_button)</span><br><span class="line">        self.combineButton.clicked.connect(self.slot_combine_button)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_source_button</span>(<span class="params">self</span>):</span><br><span class="line">        files, filetype = QFileDialog.getOpenFileNames(self, <span class="string">&quot;选择多个采购申请表&quot;</span>, self.cwd, <span class="string">&quot;All Files (*);;PDF Files (*.pdf);;Text Files (*.txt)&quot;</span>)</span><br><span class="line">        <span class="keyword">global</span> filename</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取消选择\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        filename_print = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            filename.append(file)</span><br><span class="line">            filename_print += file</span><br><span class="line">            filename_print += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.textBrowser.setPlainText(filename_print)</span><br><span class="line">        <span class="comment"># print(&quot;文件筛选器类型：&quot;, filetype)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_target_button</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> dir_choose</span><br><span class="line">        dir_choose = QFileDialog.getExistingDirectory(self, <span class="string">&quot;选择保存目录&quot;</span>, self.cwd)</span><br><span class="line">        <span class="keyword">if</span> dir_choose == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取消选择\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.textBrowser_2.setPlainText(dir_choose)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_combine_button</span>(<span class="params">self</span>):</span><br><span class="line">        wb_template = app.books.<span class="built_in">open</span>(<span class="string">&#x27;采购申请单模板.xls&#x27;</span>)  <span class="comment"># 打开工作簿</span></span><br><span class="line">        combine(wb_template, filename, dir_choose+<span class="string">&#x27;\采购申请表汇总.xls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app1 = QApplication(sys.argv)</span><br><span class="line">    app1.setWindowIcon(QIcon(<span class="string">&#x27;logo.png&#x27;</span>))</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment"># 将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment"># 程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line"></span><br><span class="line">    sys.exit(app1.exec_())</span><br><span class="line">    <span class="comment"># button.clicked.connect(handleCalc) 按钮按下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232022811-pyqt5-10.png" alt=""></p><blockquote><p>更多控件的使用方法可以参考这位博主的文章：<br>链接：<a href="https://blog.csdn.net/weixin_40841247/article/details/88781601">https://blog.csdn.net/weixin_40841247/article/details/88781601</a></p></blockquote><h2 id="五、发布程序">五、发布程序</h2><h3 id="5-1-安装pyinstaller">5.1 安装pyinstaller</h3><p>要将写好的python程序打包成exe可执行程序需要使用pyinstaller，使用pip命令安装pyInstaller：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><h3 id="5-2-打包exe">5.2 打包exe</h3><ol><li><p>打开cmd窗口，进入写好的python程序所在的目录</p></li><li><p>使用如下的命令打包exe，例如我的主程序是<code>main.py</code>，我用到的包有<code>PyQt5</code>和<code>xlwings</code>，我的图标文件是<code>logo.ico</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller main.py --noconsole --hidden-import <span class="string">&quot;PyQt5.QtXml&quot;</span>,<span class="string">&quot;xlwings&quot;</span> --icon=<span class="string">&quot;logo.ico&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232022909-pyqt5-11.png" alt=""></p><p>由于pyInstaller只能分析出需要哪些代码文件。 而程序动态打开的资源文件，比如图片、excel、ui这些，它是不会帮你打包的。</p><p>而我的程序需要从调用xls表格文件，手动拷贝到dist/main目录中。</p><p>然后，再双击运行 main.exe，即可成功。</p><h3 id="5-3-改进：减少打包程序的大小">5.3 改进：减少打包程序的大小</h3><p>刚刚使用命令行直接打包，发现打包出来的程序非常大。原因是打包时系统会将很多原本用不到的依赖库一并打包起来。经过在网上查找方法，发现可以使用虚拟环境，原理是新建一个虚拟环境，然后在虚拟环境中安装程序的依赖库，然后在虚拟环境中完成打包。</p><p><strong>（1）使用pipenv创建虚拟环境</strong></p><p>创建python虚拟环境，需要系统已经安装好python虚拟环境。打开cmd。</p><ol><li>安装pipenv</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure><ol start="2"><li>进入一个空目录，初始化虚拟python环境（注意python版本需要与系统安装的版本一致）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --python 3.9</span><br></pre></td></tr></table></figure><ol start="3"><li>进入虚拟环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><p><strong>（2）安装程序依赖</strong></p><p>在虚拟环境中，只安装python程序使用到的库，尽可能减少打包程序的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line">pip install pyqt5</span><br><span class="line">pip install xlwings</span><br></pre></td></tr></table></figure><p><strong>（3）虚拟环境中打包程序</strong></p><p>在虚拟环境中直接使用pyinstaller打包程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller main.py --noconsole --hidden-import <span class="string">&quot;PyQt5.QtXml&quot;</span>,<span class="string">&quot;xlwings&quot;</span> --icon=<span class="string">&quot;logo.ico&quot;</span></span><br></pre></td></tr></table></figure><p>这样打包完成后的程序就小了很多。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>g2o图优化简介与基本使用方法</title>
      <link href="/post/7851485c.html"/>
      <url>/post/7851485c.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、g2o简介">一、g2o简介</h3><p>g2o（General Graphic Optimization）是一个基于图优化的库，将非线性优化与图论结合起来的理论，我们可以利用g2o求解任何可以表示为图优化的最小二乘问题。</p><blockquote><p>图优化就是把优化问题表现成图的方式。图由顶点和边组成，其中顶点表示优化变量，边表示误差项，对任意一个非线性?&gt; 最小二乘问题，我们都可以构建与之对应的图。<br>（注：这里的图是图论意义上的图，可以用概率论里面的定义，贝叶斯图或因子图。）</p></blockquote><h3 id="二、g2o安装">二、g2o安装</h3><p>首先安装g2o的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qt5-qmake qt5-default libqglviewer-dev-qt5 libsuitesparse-dev libcxsparse3 libcholmod3 </span><br></pre></td></tr></table></figure><p>然后到github下clone此工程，然后编译安装，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o.git</span><br><span class="line"><span class="built_in">cd</span> g2o/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>g2o的头文件在<code>/usr/local/g2o</code>下，库文件在<code>/usr.local/lib</code>下。</p><h3 id="三、利用g2o拟合曲线">三、利用g2o拟合曲线</h3><h4 id="1-拟合步骤">1. 拟合步骤</h4><p><strong>① 定义顶点和边的类型（优化变量与误差项）</strong><br><strong>② 构建图</strong><br><strong>③ 选择优化算法</strong><br><strong>④ 调用g2o进行优化，返回结果</strong></p><h3 id="2-实验-拟合曲线">2. 实验-拟合曲线</h3><p>此示例程序还依赖opencv、Eigen、Ceres库，需要预先安装。</p><p><strong>main.cpp文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/g2o_core_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点（优化变量）（参数：维度、数据类型）</span></span><br><span class="line"><span class="comment">// 优化变量维数：3维    数据类型：Eigen::Vector3d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingVertex</span> : <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW     <span class="comment">// 字节对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;           <span class="comment">// 设定被优化变量的原始值、重置成员函数的估计值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);           <span class="comment">// 更新优化变量（估计值）。增量方程计算出增量△x后，通过此函数对估计值进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读盘</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存盘</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的边（误差项）（参数：观测值维度、类型、连接定点类型）</span></span><br><span class="line"><span class="comment">// 边的模型：BaseUnaryEdge   连接顶点个数：1    测量值数据类型：double  顶点类型：CurveFittingVertex</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingEdge</span> : <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="type">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">CurveFittingEdge</span><span class="params">(<span class="type">double</span> x)</span>:BaseUnaryEdge(),_x(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);        <span class="comment">// _vertices[]存储顶点信息</span></span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>,<span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));        <span class="comment">// _error存储computeError()函数计算的误差</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">exp</span>(abc[<span class="number">0</span>] * _x * _x + abc[<span class="number">1</span>] * _x + abc[<span class="number">2</span>]);</span><br><span class="line">        _jacobianOplusXi[<span class="number">0</span>] = -_x * _x * y;</span><br><span class="line">        _jacobianOplusXi[<span class="number">1</span>] = -_x * y;</span><br><span class="line">        _jacobianOplusXi[<span class="number">2</span>] = -y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _x;    <span class="comment">//x值；（y值为_measurement测量值）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义数据参数</span></span><br><span class="line">    <span class="type">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;    <span class="comment">//真实参数值</span></span><br><span class="line">    <span class="type">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;   <span class="comment">//估计参数值</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                            <span class="comment">//数据点个数</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                   <span class="comment">//噪声Sigma值</span></span><br><span class="line">    <span class="type">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">    cv::RNG rng;                            <span class="comment">//随机数产生器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成100个带高斯噪声的数据</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建图优化</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;    <span class="comment">// 配置BlockSolver，每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::LinearSolverDense&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;    <span class="comment">// 创建BlockSolver，并用定义的线性求解器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置梯度下降的方法，创建总求解器solver</span></span><br><span class="line">    <span class="keyword">auto</span> solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(g2o::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(g2o::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;()));</span><br><span class="line">    g2o::SparseOptimizer optimizer;     <span class="comment">//创建系数优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver);     <span class="comment">//设置求解方法</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>); <span class="comment">//打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中加入顶点</span></span><br><span class="line">    CurveFittingVertex *v = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    v-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(ae, be, ce));</span><br><span class="line">    v-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中加入边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]);</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);                     <span class="comment">//定义边的编号（决定在H矩阵中的位置）</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, v);           <span class="comment">//设置连接的顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]);    <span class="comment">//设置观测值</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));    <span class="comment">//信息矩阵：协方差矩阵的逆</span></span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Start optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//记录算法执行时间</span></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">//初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);    <span class="comment">//执行10次</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; s.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d abc_estimate = v-&gt;<span class="built_in">estimate</span>();   <span class="comment">//获取当前值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;estimated model: &quot;</span> &lt;&lt; abc_estimate.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="built_in">project</span>(g2oCurveFitting)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"># OpenCV库</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Eigen库</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"># Ceres库</span><br><span class="line"><span class="built_in">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># g2o库</span><br><span class="line"><span class="built_in">list</span>( APPEND CMAKE_MODULE_PATH /home/huffie/slam/<span class="number">3</span>rdparty/g2o/cmake_modules ) #刚才clone的项目文件夹</span><br><span class="line"><span class="built_in">set</span>(G2O_ROOT /usr/local/include/g2o)</span><br><span class="line"><span class="built_in">find_package</span>(G2O REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;G2O_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(g2oCurveFitting main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting  g2o_stuff   g2o_core )</span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting $&#123;CERES_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 实验 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Ceres基本使用方法】使用Ceres拟合曲线求解最小二乘问题</title>
      <link href="/post/1efb54e0.html"/>
      <url>/post/1efb54e0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Ceres简介">一、Ceres简介</h3><p>Ceres是一个最小二乘问题求解库，我们只需要定义待优化的问题，然后交给它计算即可。</p><p><strong>① 基本概念</strong><br>常用的最小二乘问题形式如下：</p><p><img src="https://img.mahaofei.com/img/202112232017086-ceres-introduction-1.png" alt=""></p><ul><li>参数块：$x_1$, … $x_n$等优化变量</li><li>代价函数（残差块/误差项）：$f_i$</li><li>核函数：ρ(·)，目标函数由许多平方项经过核函数求和自称</li></ul><p><strong>② 使用方法</strong></p><ol><li>定义每个参数块。参数块就是简单的向量，也可以是四元数、李代数等特殊的结构。</li><li>定义残差块的计算方式。残差块对参数块进行自定义计算，返回残差值，然后求平方和作为目标函数的值。</li><li>定义雅可比的计算方式。</li><li>把所有的参数块和残差块加入Ceres定义的Problem对象中，调用Solve函数求解</li></ol><h3 id="二、Ceres安装">二、Ceres安装</h3><p>首先下载Ceres的源代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceres-solver/ceres-solver.git</span><br></pre></td></tr></table></figure><p>安装ceres所需要的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libsuitesparse-dev libcxsparse3 libgflags-dev libgoogle-glog-dev libgtest-dev</span><br></pre></td></tr></table></figure><p>然后进入文件夹编译安装ceres，这里耗时比较久大概20min左右。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ceres-solver/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，如果在<code>/usr/local/include/ceres/</code>目录下能找到Ceres的头文件，并且也有库文件<code>/usr/local/lib/libceres.a </code>，说明安装成功了，可以使用Ceres进行优化计算了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /usr/local/include/ceres/</span><br><span class="line">ll /usr/local/lib/libceres.a </span><br></pre></td></tr></table></figure><h3 id="三、使用Ceres拟合曲线">三、使用Ceres拟合曲线</h3><p>此示例程序依赖opencv、Eigen库，需要预先安装。</p><p><strong>main.cpp</strong>文件代码程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建代价函数的计算模型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CURVE_FITTING_COST</span>&#123;</span><br><span class="line">    <span class="built_in">CURVE_FITTING_COST</span>(<span class="type">double</span> x, <span class="type">double</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()，仿函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> T *<span class="type">const</span> abc, <span class="comment">// 模型参数，有3维</span></span></span></span><br><span class="line"><span class="params"><span class="function">            T *residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(_y) - ceres::<span class="built_in">exp</span>(abc[<span class="number">0</span>] * <span class="built_in">T</span>(_x) * <span class="built_in">T</span>(_x) + abc[<span class="number">1</span>] * <span class="built_in">T</span>(_x) + abc[<span class="number">2</span>]); <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义数据参数</span></span><br><span class="line">    <span class="type">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;    <span class="comment">//真实参数值</span></span><br><span class="line">    <span class="type">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;   <span class="comment">//估计参数值</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                            <span class="comment">//数据点个数</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                   <span class="comment">//噪声Sigma值</span></span><br><span class="line">    <span class="type">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">    cv::RNG rng;                            <span class="comment">//随机数产生器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成100个带高斯噪声的数据</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> abc[<span class="number">3</span>] = &#123;ae, be, ce&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建最小二乘问题</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">//添加误差项。使用自动求导，模板参数：误差类型、输出维度、输入维度、维数要与前面struct中一致</span></span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(<span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt;(<span class="keyword">new</span> <span class="built_in">CURVE_FITTING_COST</span>(x_data[i], y_data[i])),<span class="literal">nullptr</span>,abc);</span><br><span class="line">        <span class="comment">//nullptr为核函数不使用为空，abc为待估计参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置并运行求解器</span></span><br><span class="line">    ceres::Solver::Options options;     <span class="comment">//定义配置项</span></span><br><span class="line">    options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;  <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;    <span class="comment">//输出到cout</span></span><br><span class="line">    ceres::Solver::Summary summary; <span class="comment">//定义优化信息</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//计时：求解开始时间</span></span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);  <span class="comment">//开始优化求解！</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//计时：求解结束时间</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);  <span class="comment">//计算求解耗时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s.&quot;</span> &lt;&lt; endl;  <span class="comment">//输出求解耗时</span></span><br><span class="line">    cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl;  <span class="comment">//输出简要优化信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;estimated a, b, c = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a:abc)    <span class="comment">//输出优化变量</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt</strong>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="built_in">project</span>(ceresCurveFitting)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"># OpenCV库</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Ceres库</span><br><span class="line"><span class="built_in">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Eigen库</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件</span><br><span class="line"><span class="built_in">add_executable</span>(ceresCurveFitting main.cpp)</span><br><span class="line"></span><br><span class="line"># 链接库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(ceresCurveFitting $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(ceresCurveFitting $&#123;CERES_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232017359-ceres-introduction-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 实验 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32串口通信无反应</title>
      <link href="/post/7b1db17f.html"/>
      <url>/post/7b1db17f.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述：</h1><p><strong>本人使用STM32F103C8T6最小系统板</strong>，当我在windows上调试好STM32程序并成功实现串口通信后。重启电脑后串口通信没有响应。</p><h1>问题原因</h1><p>最小系统板<strong>烧录时需要将Boot0置1、Boot1置0</strong>。</p><p>最小系统板<strong>运行程序时将Boot0置0、Boot1置0不变</strong></p><h1>解决过程：</h1><ol><li>烧录程序</li></ol><p>Boot0置1、Boot1置0烧录程序后，<strong>立即开启</strong>串口调试助手（不断电），此时上位机可以与单片机通信。并且可以看到<strong>USB转TTL模块亮蓝灯</strong>。</p><ol start="2"><li>问题出现</li></ol><p>若此时拔下USB转TTL模块重新插入，或重启电脑，此时可以看到<strong>USB转TTL模块蓝灯灭</strong>，此时再次使用串口调试助手，无法实现串口通信。</p><ol start="3"><li>问题解决</li></ol><p>将Boot0置0、Boot1置0后，再次插入USB转TTL模块，可以看到蓝灯亮，此时可以实现串口通信。</p><p><img src="https://img.mahaofei.com/img/20220422164159.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS外接usb摄像头标定方法</title>
      <link href="/post/130b716a.html"/>
      <url>/post/130b716a.html</url>
      
        <content type="html"><![CDATA[<p>usb_cam官方文档：<a href="http://wiki.ros.org/camera_calibration">http://wiki.ros.org/camera_calibration</a><br>camera_calibrate官方文档：<a href="http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration">http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration</a><br>棋盘格也在上面的链接中下载。</p><p>摄像头标定的目的是消除相机畸变，具体畸变原理可以参考之前的文章<a href="https://blog.csdn.net/weixin_44543463/article/details/120659447">【相机模型与去畸变方法详解】</a>。usb摄像头在ros系统标定过程大致可以分成几个步骤。①安装usb_camera驱动包；② 运行usb_cam读取usb摄像头图像；③下载打印棋盘格并进行摄像头标定。</p><h3 id="1-安装usb-camera驱动包">1. 安装usb_camera驱动包</h3><ul><li>进入工作空间的src目录（这里工作空间目录可能都不一样，自行修改）</li><li>下载usb_cam源代码</li><li>编译安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ros-drivers/usb_cam.git</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="2-运行usb-cam读取摄像头图像">2. 运行usb_cam读取摄像头图像</h3><p>首先打开一个终端，运行<code>roscore</code></p><p>然后再打开一个终端，运行<code>usb_cam-test.launch</code>启动文件（由于刚才下载的源代码中由测试文件，因此可以直接启动）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/usb_cam/launch</span><br><span class="line">roslaunch usb_cam-test.launch</span><br></pre></td></tr></table></figure><p>默认情况下开启的是电脑自带摄像头，如果需要启动外置摄像头，则修改一下launch文件，将参数第一行的value改为<code>value=&quot;/dev/video1&quot;</code>，然后重新编译一下。</p><blockquote><p>如果更改后启动报错，那么执行<code>ls /dev/video*</code>命令看看外界摄像头是那个，再将launch文件改为对应的video2或video3。<br>比如我的usb摄像头就是 /dev/video2</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;video_device&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/dev/video1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果出现如下错误<br>ERROR: cannot launch node of type [usb_cam/usb_cam_node]: usb_cam<br>ROS path [0]=/opt/ros/kinetic/share/ros<br>ROS path [1]=/opt/ros/kinetic/share<br>首先进入工作空间目录</p></blockquote><h3 id="3-进行摄像头标定">3. 进行摄像头标定</h3><p>再次打开一个终端（前两个分别运行<code>roscore</code>和<code>usb_cam-test</code>）</p><p><strong>① 查看主题名称</strong></p><p>输入<code>rostopic list</code>查看ros中的主题，检查是否有<code>/usb_cam/camera_info</code>和<code>/usb_cam/image_raw</code>两个主题。（主题名可能会不一样，有可能是/usb_cam_node记住自己的这两个主题的名字）</p><p><img src="https://img.mahaofei.com/img/202112232015769-camera-calibrate-1.png" alt=""></p><blockquote><p>如果出现 ImportError: No module named cv2的问题，请参考下面这篇文章<br>文章链接：<a href="https://blog.csdn.net/weixin_44543463/article/details/120717831#pic_center">【ImportError: No module named cv2问题的解决方法（修改python默认版本）】</a></p></blockquote><p><strong>② 执行命令启动标定程序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.03 image:=/usb_cam/image_raw camera:=/usb_cam</span><br></pre></td></tr></table></figure><p>其中的8x6是指的棋盘格内部角点的个数，如下图我下载的棋盘格内部角点是8x6的。如果你是11x8角点的棋盘格，那么命令里面的8x6替换成11x8即可。</p><p><img src="https://img.mahaofei.com/img/202112232016343-camera-calibrate-2.png" alt=""></p><p><strong>③ 变换角度使程序记录样本</strong></p><p>拿着棋盘格纸多变幻几个角度，离远离近，边边角角都采集一些样本，当命令行里看到sample接近50的时候，标定按钮calibrate就会变亮了。</p><p><strong>④ 进行标定并保存</strong><br>点击CALIBRATE按钮进行标定，等待一小段时间后，就可以在命令行中看到标定的结果。<br>标定没有问题的花，点击COMMIT按钮就可以保存了，保存之后，下次再启动usb_camera就会自动使用标定的参数，可以发现摄像头不再畸变了。</p><p><img src="https://img.mahaofei.com/img/202112232016191-camera-calibrate-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232016631-camera-calibrate-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil5 C51版 下载与安装教程（51单片机编程软件）</title>
      <link href="/post/6c3a51dc.html"/>
      <url>/post/6c3a51dc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>百度网盘<br>链接：<a href="https://pan.baidu.com/s/1PmlKwowGii04hX3KAxribg?pwd=4u9r">https://pan.baidu.com/s/1PmlKwowGii04hX3KAxribg?pwd=4u9r</a><br>提取码: 4u9r</p></blockquote><ol><li>解压安装包，右键【C51-V957.exe】，<strong>以管理员身份运行</strong></li></ol><p><img src="https://img.mahaofei.com/img/202112232002909-keil51-1.png" alt=""></p><ol start="2"><li>莫得选择，<strong>点击next</strong>继续安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232002704-keil51-2.png" alt=""></p><ol start="3"><li><strong>同意</strong>用户协议，<strong>点击next</strong>继续</li></ol><p><img src="https://img.mahaofei.com/img/202112232003825-keil51-3.png" alt=""></p><ol start="4"><li>选择安装路径，<strong>路径不能有中文</strong>，进行安装（注：如果想要安装51和MDK两个版本的Keil，也就是想要编写51单片机和32单片机两种程序，需要安装在两个单独的文件夹中）</li></ol><p><img src="https://img.mahaofei.com/img/202112232003419-keil51-4.png" alt=""></p><ol start="5"><li><strong>信息随便输</strong>，输完直接<strong>点击next</strong>就可以</li></ol><p><img src="https://img.mahaofei.com/img/202112232003599-keil51-5.png" alt=""></p><ol start="6"><li>安装过程很快，大约十几秒，点击finish完成安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232004114-keil51-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232004458-keil51-7.png" alt=""></p><ol start="7"><li>回到桌面，找到【Keil5】的快捷方式，右键<strong>以管理员身份运行</strong>，然后打开【File -&gt; License Management】选项卡</li></ol><p><img src="https://img.mahaofei.com/img/202112232004254-keil51-8.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232004032-keil51-9.png" alt=""></p><ol start="8"><li>在解压的安装包中找到【Crack.exe】文件，<strong>右键以管理员身份运行</strong></li></ol><p><img src="https://img.mahaofei.com/img/202112232005088-keil51-10.png" alt=""></p><ol start="9"><li>在【License Management】中<strong>复制CID</strong>，<strong>粘贴到破解程序</strong>中，target选择C51，<strong>点击Generate</strong>生成激活码</li></ol><p><img src="https://img.mahaofei.com/img/202112232005496-keil51-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232005539-keil51-12.png" alt=""></p><ol start="10"><li><p>将激活码粘贴回【License Management】下方的输入框中，并点击【Add LIC】</p><p><img src="https://img.mahaofei.com/img/202112232006203-keil51-13.png" alt=""></p></li><li><p>可以看到已经成功激活，激活时间到2032年</p><p><img src="https://img.mahaofei.com/img/202112232006493-keil51-14.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil5 MDK版 下载与安装教程（STM32单片机编程软件）</title>
      <link href="/post/1b083906.html"/>
      <url>/post/1b083906.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>百度网盘<br>链接：<a href="https://pan.baidu.com/s/1kuIhOzStosHBI9BwOiSFgg?pwd=ww7z">https://pan.baidu.com/s/1kuIhOzStosHBI9BwOiSFgg?pwd=ww7z</a><br>提取码: ww7z</p></blockquote><ol><li>解压安装包，<strong>以管理员身份运行</strong>【MDK528.exe】</li></ol><p><img src="https://img.mahaofei.com/img/202112232006461-keilmdk-1.png" alt=""></p><ol start="2"><li>按步骤一直安装就可以，每一步我都在下面截了图，可以对照一下。</li></ol><p><img src="https://img.mahaofei.com/img/202112232007055-keilmdk-2.png" alt=""></p><ol start="3"><li>选择我同意用户协议，然后next</li></ol><p><img src="https://img.mahaofei.com/img/202112232007859-keilmdk-3.png" alt=""></p><ol start="4"><li>选择安装位置，一定要和Keil C51版本安装在<strong>不同的文件夹</strong>中</li></ol><p><img src="https://img.mahaofei.com/img/202112232007389-keilmdk-4.png" alt=""></p><ol start="5"><li>信息随便填</li></ol><p><img src="https://img.mahaofei.com/img/202112232010807-keilmdk-5.png" alt=""></p><ol start="6"><li>等待安装，大约耗时1分钟左右</li></ol><p><img src="https://img.mahaofei.com/img/202112232010318-keilmdk-6.png" alt=""></p><ol start="7"><li>如果安装过程中弹出需要安装某驱动，一定要安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232011061-keilmdk-7.png" alt=""></p><ol start="8"><li>不需要展示新特性，直接下一步点击finish完成即可。</li></ol><p><img src="https://img.mahaofei.com/img/202112232011656-keilmdk-8.png" alt=""></p><ol start="9"><li>出现下面这个包安装界面，直接关闭即可，后续我们手动安装包，要快得多</li></ol><p><img src="https://img.mahaofei.com/img/202112232012974-keilmdk-9.png" alt=""></p><blockquote><p>如果之前安装过Keil51版本，想要两个版本共存，需要加入以下步骤。如果仅安装Keil MDK版，可跳过此部分。</p><ol><li><p>打开C51安装路径，找到 TOOLS.INI  这个文件</p></li><li><p>以记事本打开【TOOLS.INI】这个文件，复制 [C51]（包括）以下的全部内容</p></li><li><p>粘贴至MDK-ARM安装目录下的  TOOLS.INI 文件末尾，保存，关闭。</p></li></ol><p><img src="https://img.mahaofei.com/img/202112232012255-keilmdk-10.png" alt=""></p></blockquote><ol start="10"><li><p>在桌面找到【Keil 5】的快捷方式，右键以管理员身份运行。然后打开【File -&gt; License Management】选项卡。</p><p><img src="https://img.mahaofei.com/img/202112232012315-keilmdk-11.png" alt=""></p></li><li><p>复制右上角的CID</p><p><img src="https://img.mahaofei.com/img/202112232013981-keilmdk-12.png" alt=""></p></li><li><p>打开解压的安装包，找到【keygen.exe】，右键以管理员身份运行</p><p><img src="https://img.mahaofei.com/img/202112232013788-keilmdk-13.png" alt=""></p></li><li><p><strong>粘贴CID</strong>到对应的输入框中，<strong>target选择ARM</strong>，然后点击<strong>Generate生成激活码</strong>。</p><p><img src="https://img.mahaofei.com/img/202112232014581-keilmdk-14.png" alt=""></p></li><li><p>复制生成的激活码，回到Keil中的【License Management】对话框，在下方LIC中粘贴激活码，然后点击Add LIC激活成功。（激活的日期过了也不影响使用）</p><p><img src="https://img.mahaofei.com/img/202112232014618-keilmdk-15.png" alt=""></p></li><li><p>安装剩下的两个库文件，直接双击就可以安装。（两个库文件分别对应STM32F1和F4的芯片）</p><p><img src="https://img.mahaofei.com/img/202112232014820-keilmdk-16.png" alt=""></p></li><li><p>至此安装完成，可以正常使用。</p><p><img src="https://img.mahaofei.com/img/202112232015660-keilmdk-17.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS+Gazebo仿真差速小车并实现控制</title>
      <link href="/post/fc92db80.html"/>
      <url>/post/fc92db80.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本工程的功能包有两个，分别用于<strong>gazebo仿真</strong>与<strong>键盘控制运动</strong><br>功能包原文件如下：<br>diff_wheeled_robot_control : <a href="https://huffie.lanzouw.com/iXilxvdqola">https://huffie.lanzouw.com/iXilxvdqola</a><br>diff_wheeled_robot_gazebo: <a href="https://huffie.lanzouw.com/ixG3uvdqoyd">https://huffie.lanzouw.com/ixG3uvdqoyd</a></p></blockquote><p><strong>准备工作：</strong><br>如果你是第一次使用gazebo，需要先安装下面的包才可以正常使用：<br>（这里以noetic版本为例，如果你是其他版本的ros，自行更换中间的代码即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-gazebo-ros-pkgs ros-noetic-gazebo-ros ros-noetic-gazebo-msgs ros-noetic-gazebo-plugins ros-noetic-gazebo-ros-control</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行执行  <code>gazebo</code>命令检查是否正确安装，如果看到下面的界面说明安装没有问题。</p><p><img src="https://img.mahaofei.com/img/202112232001567-ros-gazebo-1.png" alt=""></p><p>然后再在命令行中运行下面的命令，检查Gazebo的ROS接口是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore &amp; rosrun gazebo_ros gazebo</span><br></pre></td></tr></table></figure><p>这个命令会运行roscore，同时也会启动gazebo，如果能看到gazebo的界面说明没有问题。</p><h3 id="一、创建小车模型">一、创建小车模型</h3><p><strong>1. 首先创建一个功能包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg diff_wheeled_robot_gazebo roscpp tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><blockquote><p>如果之前没有创建过ROS工作空间，可以先执行如下命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></blockquote><p><strong>2. 创建基本文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> diff_wheeled_robot_gazebo/</span><br><span class="line"><span class="built_in">mkdir</span> urdf meshes launch world</span><br></pre></td></tr></table></figure><p><strong>3. 复制模型文件</strong><br>将<a href="https://huffie.lanzouw.com/ixG3uvdqoyd">提供的gazebo工程包</a>urdf文件夹中的 <code>diff_wheeled_robot.xacro</code> 文件和 <code>wheel.urdf.xacro</code> 文件复制进自己的工程的urdf文件夹内。</p><p>同时将mesh文件夹中万向轮的三维模型 <code>caster_wheel.stl</code> 文件复制进自己工程的meshes文件夹内。</p><p>关于xacro的代码解释，可以参考另一篇机械臂相关内容：<a href="https://blog.csdn.net/weixin_44543463/article/details/120607629">urdf与xacro的使用方法 &amp; 机械臂模型仿真示例</a></p><p><strong>4. 创建launch文件</strong><br>回到上一级，进入launch文件夹，创建一个<code>diff_wheeled_gazebo.launch</code>文件，并在其中添加如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- We resume the logic in empty_world.launch --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg debug)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg use_sim_time)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg headless)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- urdf xml robot description loaded on the Parameter Server--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find diff_wheeled_robot_gazebo)/urdf/diff_wheeled_robot.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Run a python script to the send a service call to gazebo_ros to spawn a URDF robot --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;urdf_spawner&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">args</span>=<span class="string">&quot;-urdf -model diff_wheeled_robot -param robot_description&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5. 编译并启动节点，查看机器人模型</strong><br>首先编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_gazebo diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><p>可以看到已经正常启动Gazebo，并且小车的模型也已经正常加载出来了</p><p><img src="https://img.mahaofei.com/img/202112232001178-ros-gazebo-2.png" alt=""></p><h3 id="二、控制小车移动">二、控制小车移动</h3><p><strong>1. 插件介绍</strong><br>控制小车移动所使用的插件是 <code>libgazebo_ros_diff_drive.so</code> 。此插件的添加代码已经写在了xacro文件中如下：</p><p><img src="https://img.mahaofei.com/img/202112232001660-ros-gazebo-3.png" alt=""></p><p>其中可以指定的参数包括轮子的关节、轮子的间距、车轮直径、里程计的主题等等。这里面最重要的一个参数是控制命令主题 <code>commandTopic</code>，用于驱动车轮的运动。在这里我们可以通过向 <code>/cmd_vel</code> 主题发布数据来控制小车的运动。</p><p><strong>2. 测试运动</strong><br>在gazebo仿真正常运行的情况下，新打开一个终端输入如下指令，可以使小车进行圆周运动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -r 10 /cmd_vel geometry_msgs/Twist <span class="string">&#x27;&#123;linear: &#123;x: 0.5, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 0.5&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232001294-ros-gazebo-4.png" alt=""></p><h3 id="三、键盘控制小车移动">三、键盘控制小车移动</h3><p><strong>1. 创建功能包</strong><br>创建一个功能包用于驱动小车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin/src</span><br><span class="line">catkin_create_pkg diff_wheeled_robot_control rospy tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><p>将<a href="https://huffie.lanzouw.com/iXilxvdqola">control工程包</a>中的<code>launch</code>文件夹和<code>scripts</code>文件夹复制到新创建的功能包中。</p><p><strong>2. 编译启动仿真</strong></p><p>回到工作空间目录进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>启动仿真程序</p><p>首先和之前一样启动小车的仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_gazebo diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><p>然后新打开一个终端启动键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_control keyboard_teleop.launch</span><br></pre></td></tr></table></figure><p>这时候终端窗口内会出现提示，在终端内按下按键即可控制小车</p><p><img src="https://img.mahaofei.com/img/202112232002981-ros-gazebo-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232002842-ros-gazebo-6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabVIEW2020下载与安装教程</title>
      <link href="/post/38b2093b.html"/>
      <url>/post/38b2093b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接:  <a href="https://pan.baidu.com/s/15mAoxOT_9aMnUQet08Wj4g">https://pan.baidu.com/s/15mAoxOT_9aMnUQet08Wj4g</a><br>提取码: evvm</p></blockquote><p>此教程为Labview2020 中文版的安装教程，英文版安装过程相同。</p><ol><li>打开解压后的文件夹，<strong>进入安装包目录</strong>，双击运行【<strong>Install.exe</strong>】开始安装。<br><img src="https://img.mahaofei.com/img/202112230940458-labview2020-1.png" alt=""></li><li>接受许可协议，<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230941389-labview2020-2.png" alt=""></li><li>直接<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230941226-labview2020-3.png" alt=""></li><li>莫得选择，继续<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230942373-labview2020-4.png" alt=""></li><li><strong>等待十多秒</strong>安装相关组件，然后会<strong>弹出选择菜单</strong>，按照默认选择<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202112230942043-labview2020-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230942214-labview2020-6.png" alt=""></li><li><strong>我接受，然后下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943289-labview2020-7.png" alt=""></li><li>还是莫得选择，继续<strong>接受，然后下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943520-labview2020-8.png" alt=""></li><li>核对信息，正常安装不会有问题，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943878-labview2020-9.png" alt=""></li><li><strong>等待安装</strong>，安装过程耗时分钟左右<br><img src="https://img.mahaofei.com/img/202112230944483-labview2020-10.png" alt=""></li><li><strong>选择yes</strong><br><img src="https://img.mahaofei.com/img/202112230944354-labview2020-11.png" alt=""></li><li>选择<strong>不加入用户体验改进计划</strong>，<strong>确定</strong><br><img src="https://img.mahaofei.com/img/202112230944025-labview2020-12.png" alt=""></li><li>在弹出的登陆页面<strong>点击取消</strong><br><img src="https://img.mahaofei.com/img/202112230944296-labview2020-13.png" alt=""></li><li>不需要重启，<strong>点击右上角x关闭安装程序即可</strong><br><img src="https://img.mahaofei.com/img/202112230945782-labview2020-14.png" alt=""></li><li>打开安装包，找到【<strong>NI License Acticator 1.2</strong>】，右键<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230945417-labview2020-15.png" alt=""></li><li>将<strong>全部选项右键激活</strong><br><img src="https://img.mahaofei.com/img/202112230945106-labview2020-16.png" alt=""></li><li>至此完成安装，在开始菜单找到安装好的程序启动<br><img src="https://img.mahaofei.com/img/202112230946133-labview2020-17.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112230946156-labview2020-18.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ImportError No module named cv2问题的解决方法（修改python默认版本）</title>
      <link href="/post/cad41dc4.html"/>
      <url>/post/cad41dc4.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>在调用opencv安装包时，会出现 <strong>ImportError: No module named cv2</strong> 的问题：</p><p><img src="https://img.mahaofei.com/img/202112231958111-no-module-1.png" alt=""></p><h3 id="产生原因">产生原因</h3><p>我<strong>确定我已经安装了opencv</strong>，但为什么还是显示没有此模块。查阅资料后发现是因为<strong>安装opencv是会安装到它默认的python版本</strong>，而这个<strong>opencv安装的python版本与系统默认使用python的版本</strong>不一致，才会导致找不到模块。</p><p>例如我的电脑里安装了python2.7和python3.8两个版本，ubuntu系统启动程序默认使用python2.7，而opencv则安装在python3.8环境中。</p><h3 id="解决方法">解决方法</h3><blockquote><p>首先确定你是不是真的没有安装opencv的python支持，可以运行如下代码安装：</p><p>pip3 install opencv-python</p><p>如果安装完还不能解决问题，看以下步骤</p></blockquote><p>更改系统的默认python版本，改为所使用的高版本。</p><p>可以先使用<code>ls /usr/bin/python*</code>查看系统中存在的python版本</p><p><img src="https://img.mahaofei.com/img/202112231958436-no-module-2.png" alt=""></p><p>然后移除软连接，更改python默认版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /usr/bin/python</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/python3.8 /usr/bin/python</span><br></pre></td></tr></table></figure><p> <br>再次启动之前的程序，正常启动，不再显示ImportError: No module named cv2了！</p><p><img src="https://img.mahaofei.com/img/202112231959476-no-module-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urdf与xacro的使用方法 &amp; 机械臂模型仿真示例</title>
      <link href="/post/2a57a647.html"/>
      <url>/post/2a57a647.html</url>
      
        <content type="html"><![CDATA[<p>为什么要创建机器人的三维模型，原因在于机器人机器人仿真工具可以帮助我们体现发现设计中的一些关键错误。<br>而模型仿真的含义，在于我们创建的是机器人模型，因此不一定和实际机器人长得一模一样。但因为是仿真，所以模型必须具备所有的真实硬件特点。</p><h3 id="一、机器人建模的工具">一、机器人建模的工具</h3><p>ROS提供了许多功能包帮助我们进行机器人的建模，并使用ROS进行仿真。例如urdf、kdl_parser、robot_state_publisher、collada_urdf等等。</p><blockquote><p><strong>urdf是一种机器人模型的描述格式，基于XML规范，通过树状结构进行链接，因此机器人只能通过关节进行刚性连接</strong></p></blockquote><p><strong>1. robot_mode</strong><br>robot_model是一个包含了许多功能包的功能包集，包括如urdf等功能包。可以辅助我们创建机器人三维模型。</p><p><strong>2. 有关URDF的功能包</strong></p><ul><li><strong>joint_state_publisher</strong>：读取机器人模型描述文件、发布各关节信息、可使用RViz仿真、验证各关节旋转平移关系。</li><li><strong>kdl_parser</strong>：发布关节状态、正向/逆向运动学分析。</li><li><strong>robot_state_publisher</strong>：读取当前机器人关节状态，发布机器人的位姿状态。</li></ul><p><strong>3. xacro</strong><br>xacro相当于urdf的升级版本，可以让urdf更易读。并且xacro可以被用来描述复杂的机器人模型。</p><h3 id="二、URDF模型">二、URDF模型</h3><h4 id="2-1-URDF模型介绍">2.1 URDF模型介绍</h4><p><strong>1. URDF介绍</strong><br>URDF是一种机器人模型的描述文件，通过创建<code>.urdf</code>的文件，并使用xml标签来描述机器人模型。</p><p><strong>2. URDF常用标签</strong></p><ul><li><strong>robot</strong>：概述整个机器人模型，定义机器人的名字，连接件和关节。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;name of robot&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>link</strong>：描述机器人某个刚体的外观属性<code>&lt;visual /&gt;</code>，包括大小、形状、颜色，也可以描述动态特性如惯性参数<code>&lt;inertial&gt;</code>、碰撞特性<code>&lt;collision&gt;</code>。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;name of link&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">visual</span>&gt;</span>............<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inertial</span>&gt;</span>..........<span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collision</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>joint</strong>：代表机器人的关节，可以机器人的定义运动学和动力学参数，也可以限制机器人的运动和速度。不同的关节标签代表了不同的关节类型如下</li></ul><table><thead><tr><th>joint标签</th><th>代表关节类型</th></tr></thead><tbody><tr><td><code>&lt;revolute&gt;</code></td><td>旋转副（有角度限制）</td></tr><tr><td><code>&lt;continuous&gt;</code></td><td>旋转副（无限旋转）</td></tr><tr><td><code>&lt;prismatic&gt;</code></td><td>移动副</td></tr><tr><td><code>&lt;fixed&gt;</code></td><td>固定副</td></tr><tr><td><code>&lt;float&gt;</code></td><td>浮动副</td></tr><tr><td><code>&lt;planar&gt;</code></td><td>平面副</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;name of joint&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calibration</span>&gt;</span>......<span class="tag">&lt;/<span class="name">calibration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span> <span class="attr">......</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span> <span class="attr">......</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>gazebo</strong>：包含了Gazebo仿真器的一些仿真参数，可以使用此标签引入gazebo插件、gazebo物理属性设置等等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Black<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-创建功能包">2.2 创建功能包</h4><p><strong>1. 首先进入catkin工作空间中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br></pre></td></tr></table></figure><blockquote><p>如果之前没有创建过ROS工作空间，可以先执行如下命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>2. 创建功能包</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg robot_description_pkg roscpp tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><p><strong>3. 创建基本文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> robot_description_pkg</span><br><span class="line"><span class="built_in">mkdir</span> urdf meshes launch</span><br></pre></td></tr></table></figure><p>urdf文件夹主要用来保存机器人模型的描述文件；meshes文件用来保存模型文件；launch文件夹保存驱动文件，我们会需要创建启动文件启动RViz来展示机器人模型。</p><h4 id="2-3-创建URDF模型">2.3 创建URDF模型</h4><p>以一个平移与倾斜机构为例，如下图所示</p><p><strong>1. 创建urdf文件</strong><br>进入刚才创建的urdf文件夹下，新建一个<code>pan_tilt.urdf</code>文件，并输入以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;pan_tilt&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义了base_link --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;visual&gt;标签描述了在仿真环境的外观，包括几何外形&lt;geometry&gt;（圆柱形cylinder）等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.2&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 0 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义了关节pan_joint，以及其关节类型：旋转副（有限制） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 旋转副连接的两个刚体分别为base_link和pan_link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;pan_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;pan_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.1&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;300&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-3.14&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;3.14&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span>=<span class="string">&quot;50&quot;</span> <span class="attr">friction</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;pan_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.4&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.09&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 1 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;tilt_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;pan_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;tilt_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;300&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-4.64&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;-1.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span>=<span class="string">&quot;50&quot;</span> <span class="attr">friction</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;tilt_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.4&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 1.5 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 检查urdf文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf pan_tilt.urdf</span><br></pre></td></tr></table></figure><p>如果urdf文件没有问题，会输出如下信息</p><p><img src="https://img.mahaofei.com/img/202112231956685-urdf-xacro-1.png" alt=""></p><p><strong>3. 创建launch文件</strong><br>进入之前创建的launch文件夹，创建<code>view_demo.launch</code>文件，并添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description_pkg)/urdf/pan_tilt.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_description_pkg)/urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. 启动节点查看仿真模型</strong><br>首先编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch robot_description_pkg view_demo.launch </span><br></pre></td></tr></table></figure><p>打开后会发现出现Unknown frame map的提示，这时候只需要将<code>Fixed Frame</code>改为<code>base_link</code>即可。</p><p><img src="https://img.mahaofei.com/img/202112231957653-urdf-xacro-2.png" alt=""></p><p>然后在左下角点击<code>Add</code>，添加<code>RobotModel</code>就可以正常看到机器人模型了。</p><p><img src="https://img.mahaofei.com/img/202112231957351-urdf-xacro-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231957826-urdf-xacro-4.png" alt=""></p><h3 id="三、Xacro模型">三、Xacro模型</h3><p>URDF模型虽然简单，但存在一些问题，例如代码重用性不好（重复代码只能复制），模块化不好（不能引用其它URDF文件）等等。<br>而xacro是urdf的Plus版本，它通过创建macro来描述模型，macro可以被复用，也可以被其他文件引用，让代码更可读。</p><h4 id="3-1-Xacro的使用示例">3.1 Xacro的使用示例</h4><p>将经常改变的部分参数值统一定义在文件开头，这样改变参数值更简单，而不用在代码中一个一个参数找，然后代替它们。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;pan_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;pan_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231957996-urdf-xacro-5.png" alt=""></p><h4 id="3-2-数学表达式">3.2 数学表达式</h4><p>在xacro标签的<code>$&#123;&#125;</code>中可以使用数学表达式进行基本的运算，支持的数学运算包括+，-，×，÷。求幂和模运算不支持。</p><h4 id="3-3-xacro到URDF的转换">3.3 xacro到URDF的转换</h4><p>如果编写完成了xacro的模型文件，可以使用下面的命令完成到urdf的转换。其中<code>&gt;</code>两侧分别是转换前后的xacro和urdf文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro.py filename.xacro &gt; newfilename.urdf</span><br></pre></td></tr></table></figure><h3 id="四、实例：7自由度机械臂">四、实例：7自由度机械臂</h3><h4 id="4-1-7自由度机械臂介绍">4.1 7自由度机械臂介绍</h4><p>我们知道确定机械臂末端的位姿需要6个自由度（3坐标+3方向），因此七自由度机械臂属于冗驱机构，即我们可以通过针对同一个位姿得到不同的关节配置，这样可以有效提高机器人柔性和功能性，并且更容易避免碰撞。</p><h4 id="4-2-创建前的准备工作">4.2 创建前的准备工作</h4><p><strong>① 机械臂清单明细</strong></p><table><thead><tr><th>项目</th><th>参数</th></tr></thead><tbody><tr><td>自由度</td><td>7</td></tr><tr><td>机械臂长度</td><td>50cm</td></tr><tr><td>臂展</td><td>35cm</td></tr><tr><td>刚体数</td><td>12</td></tr><tr><td>关节数</td><td>11</td></tr></tbody></table><p><strong>② 关节列表</strong></p><table><thead><tr><th>序号</th><th>关节名称</th><th>关节类型</th><th>角度限制</th></tr></thead><tbody><tr><td>1</td><td>bottom_joint</td><td>固定（Fixed）</td><td>–</td></tr><tr><td>2</td><td>shoulder_pan_joint</td><td>旋转（Revolute）</td><td>-150~114</td></tr><tr><td>3</td><td>shoulder_pitch_joint</td><td>旋转（Revolute）</td><td>-67~109</td></tr><tr><td>4</td><td>elbow_roll_joint</td><td>旋转（Revolute）</td><td>-150~41</td></tr><tr><td>5</td><td>elbow_pitch_joint</td><td>旋转（Revolute）</td><td>-92~110</td></tr><tr><td>6</td><td>wrist_roll_joint</td><td>旋转（Revolute）</td><td>-150~150</td></tr><tr><td>7</td><td>wrist_pitch_joint</td><td>旋转（Revolute）</td><td>92-113</td></tr><tr><td>8</td><td>gripper_roll_joint</td><td>旋转（Revolute）</td><td>-150~150</td></tr><tr><td>9</td><td>finger_joint1</td><td>移动（Prismatic）</td><td>0~3cm</td></tr><tr><td>10</td><td>finger_joint2</td><td>移动（Prismatic）</td><td>0~3cm</td></tr></tbody></table><h4 id="4-3-模型代码详解">4.3 模型代码详解</h4><p>代码中主要由几部分组成<br><strong>① 常量定义</strong><br>定义常用的数学常量以及各机械臂刚体的参数值，例如下面的代码片段就分别为数学常量的定义以及肩部刚体的参数值定义。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constants --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;M_SCALE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001 0.001 0.001&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;M_PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.14159&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Shoulder pan link properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shoulder_pan_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shoulder_pan_len&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>② 惯性矩阵定义</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;mass&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mass&#125;&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 传动件配置</strong><br>通过使用<code>&lt;transmission&gt;</code>标签定义连接执行器的关节，它可以定义电机的类型、参数，硬件接口的类型以及ROS控制器的接口等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;transmission_block&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;motor1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④ 引用其他xacro文件</strong><br>通过使用<code>&lt;xacro:include&gt;</code>标签，可以引用其他xacro文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find mastering_ros_robot_description_pkg)/urdf/sensors/xtion_pro_live.urdf.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑤ 插入简单模型</strong><br>与urdf一样，使用mesh标签插入一些基础的形状如圆柱体、长方体等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;bottom_link&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot; 0 0 -0.04&quot;</span>  <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 0.02&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Brown&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot; 0 0 -0.04&quot;</span>  <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 0.02&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-4-在rviz中仿真">4.4 在rviz中仿真</h4><p><strong>① 将xacro文件转换为urdf模型</strong><br>首先进入到存放xacro文件的目录下，运行如下代码从<code>.xacro</code>文件生成<code>.urdf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro seven_dof_arm.xacro &gt; seven_dof_arm.xacro.urdf</span><br></pre></td></tr></table></figure><p>然后可以检查urdf文件是否正确生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf seven_dof_arm.xacro.urdf</span><br></pre></td></tr></table></figure><p><strong>② 编辑launch文件</strong><br>进入launch文件夹，编辑launch文件如下，基本与上一小节一样，这里不再过多赘述</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description_pkg)/urdf/seven_dof_arm.xacro.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_description_pkg)/urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 编译运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">roslaunch robot_description_pkg view_arm.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231958358-urdf-xacro-6.png" alt=""></p><blockquote><p>功能包文件<br>链接：<a href="https://huffie.lanzouw.com/ieTZMv5t3fi">https://huffie.lanzouw.com/ieTZMv5t3fi</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机模型与去畸变方法详解</title>
      <link href="/post/6e0a2557.html"/>
      <url>/post/6e0a2557.html</url>
      
        <content type="html"><![CDATA[<p>相机我们都熟悉，可以将三维空间的点集映射到二维平面中。而这映射过程，就需要我们使用几何模型去描述。</p><p>最简单最基础的模型就是针孔相机模型，它描述了相机的基本投影与成像的惯性。</p><p>但是我们常用的相机都是存在透镜的，因为透镜的缘故，光线投影成像时就会产生畸变，这时就需要畸变模型进行更准确的描述了。</p><p>此外，在许多场合还会需要利用摄像头实现测距功能，因此这里也介绍了双目相机模型和RGB-D深度相机模型。</p><h3 id="一、针孔相机模型">一、针孔相机模型</h3><p>实际物体的各点转换为图像上像素的过程可概括为<br>① 首先获得世界坐标系下实际点的坐标<br>② 将世界坐标系的坐标转换成相机坐标系下的坐标<br>③ 相机坐标系的坐标映射为图像上的某一个像素点</p><h4 id="1-1-成像原理">1.1 成像原理</h4><p>我们中学都做过小孔成像的物理实验，现实的空间点经过小孔投影后，在平面上会成一个倒立的像。而且实际点到光轴的距离X，与图像上对应点到中心的距离X’，其比值与实际点到小孔的垂直距离以及焦距有关。</p><p><img src="https://img.mahaofei.com/img/202112231944496-camera-models-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231944774-camera-models-2.png" alt=""></p><p>这样，我们可以在成像平面上可以得到真实物体的等比例放缩后的图像。不过相机中，我们最后获得的是一个个像素，因此还需要对所成的像进行采样和量化。</p><h4 id="1-2-实际坐标与像素坐标的关系">1.2 实际坐标与像素坐标的关系</h4><p>我们设在成像平面上固定一个像素坐标系ouv，<strong>原点o在图像左上角，u轴与x轴同向平行，v轴与y轴反向平行</strong>。这样像素坐标系和物理成像之间差了一个缩放和原点的平移。设像素坐标在u轴缩放了α倍，在v轴缩放了β倍，则关系式如下：</p><p><img src="https://img.mahaofei.com/img/202112231945301-camera-models-3.png" alt=""></p><p>将两个等式中的X’和Y’用上面的关系式替换为X与Y的表达式</p><p><img src="https://img.mahaofei.com/img/202112231945240-camera-models-4.png" alt=""></p><p>改写成矩阵形式更加简洁形象</p><p><img src="https://img.mahaofei.com/img/202112231946066-camera-models-5.png" alt=""></p><p>这样，就得到了<strong>实际点P与像素点(u,v)之间的对应关系</strong>，并且由中间量组成的矩阵称为相机的内参数矩阵K。这个内参数矩阵通常相机厂商会提供，如果没有则需要自己进行相机标定。</p><h4 id="1-3-如何获得实际坐标">1.3 如何获得实际坐标</h4><p>我们通常说的某个点的空间位置是以世界坐标系为基础描述的，但是在相机模型中，我们需要实际点相对于相机的位置关系。而且由于相机是在运动的，因此利用变化矩阵的相关知识可以得到下面的式子</p><p><img src="https://img.mahaofei.com/img/202112231946623-camera-models-6.png" alt=""></p><p>其中相机的R，t就是相机的外参，外参会随相机运动而变化，内参则不会发生改变。</p><h3 id="二、畸变相机模型">二、畸变相机模型</h3><h4 id="2-1-两种常见畸变的介绍">2.1 两种常见畸变的介绍</h4><p>实际的相机为了获得更好的成像效果，通常会在相机前方加入透镜，透镜的加入会使得光线传播收到影响，即真实世界的直线在图像中变成了曲线，这种叫径向畸变。径向畸变又分为桶形畸变和枕形畸变。</p><p><img src="https://img.mahaofei.com/img/202112231948890-camera-models-7.png" alt=""></p><p>同时由于安装误差，透镜和成像平面不会完全平行，也会使投影位置发生变化，这种叫切向畸变。</p><h4 id="2-2-去畸变方法">2.2 去畸变方法</h4><p><strong>① 对于径向畸变</strong><br>径向畸变可以看做坐标点沿长度方向发生了变化，即坐标点距离原点距离变了。通常使用的模型如下，假设畸变成多项式关系，使用三个参数k1, k2, k3表达畸变。</p><p><img src="https://img.mahaofei.com/img/202112231948919-camera-models-8.png" alt=""></p><p>其中 [$x_{distorted}$, $y_{distorted}$] 是畸变后的点的归一化坐标。r表示点p与坐标系原点的距离。<br><strong>② 对于切向畸变</strong><br>切向畸变可以看做坐标点沿切线方向发生了变化，即水平夹角变了。通常使用p1, p2两个参数表达切向畸变，具体公式如下。</p><p><img src="https://img.mahaofei.com/img/202112231949498-camera-models-9.png" alt=""></p><p><strong>③ 综合方法</strong><br>结合上面两种径向畸变和切向畸变的公式，可以得到综合的去畸变公式，也就是说我们通过五个畸变系数就可以确定点在像素平面的正确位置。</p><p><img src="https://img.mahaofei.com/img/202112231949756-camera-models-10.png" alt=""></p><h4 id="2-3-示例程序">2.3 示例程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">string image_file = <span class="string">&quot;./distorted.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//定义畸变系数</span></span><br><span class="line">        <span class="type">double</span> k1 = <span class="number">-0.28340811</span>, k2 = <span class="number">0.07395907</span>, p1 = <span class="number">0.00019359</span>, p2 = <span class="number">1.76187114e-05</span>;</span><br><span class="line">        <span class="comment">//相机内参</span></span><br><span class="line">        <span class="type">double</span> fx = <span class="number">458.654</span>, fy = <span class="number">457.296</span>, cx = <span class="number">367.215</span>, cy = <span class="number">248.375</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入图像，灰度图</span></span><br><span class="line">        Mat image = <span class="built_in">imread</span>(image_file, <span class="number">0</span>);</span><br><span class="line">        Mat image_undistort = <span class="built_in">Mat</span>(image.rows, image.cols, CV_8UC1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个像素，计算后去畸变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; image.rows; v++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; image.cols; u++)&#123;</span><br><span class="line">                <span class="comment">//根据公式计算去畸变图像上点(u, v)对应在畸变图像的坐标(u_distorted, v(distorted))，建立对应关系</span></span><br><span class="line">                        <span class="type">double</span> x = (u - cx) / fx;</span><br><span class="line">                        <span class="type">double</span> y = (v - cy) / fx;</span><br><span class="line">                        <span class="type">double</span> r = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">                        <span class="type">double</span> x_distorted = x*(<span class="number">1</span>+k1*r*r+k2*r*r*r*r)+<span class="number">2</span>*p1*x*y+p2*(r*r+<span class="number">2</span>*x*x);</span><br><span class="line">                        <span class="type">double</span> y_distorted = y*(<span class="number">1</span>+k1*r*r+k2*r*r*r*r)+<span class="number">2</span>*p2*x*y+p1*(r*r+<span class="number">2</span>*x*x);</span><br><span class="line">                        <span class="type">double</span> u_distorted = fx * x_distorted + cx;</span><br><span class="line">                        <span class="type">double</span> v_distorted = fy * y_distorted + cy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将畸变图像上点的坐标，赋值到去畸变图像中（最近邻插值）</span></span><br><span class="line">                        <span class="keyword">if</span> (u_distorted &gt;= <span class="number">0</span> &amp;&amp; v_distorted &gt;=<span class="number">0</span> &amp;&amp; u_distorted &lt; image.rows &amp;&amp; v_distorted &lt; image.cols)&#123;</span><br><span class="line">                                image_undistort.<span class="built_in">at</span>&lt;uchar&gt;(v, u) = image.<span class="built_in">at</span>&lt;uchar&gt;((<span class="type">int</span>)v_distorted, (<span class="type">int</span>)u_distorted);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                image_undistort.<span class="built_in">at</span>&lt;uchar&gt;(v, u) = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Distorted Image&quot;</span>, image);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Undistorted Image&quot;</span>, image_undistort);</span><br><span class="line">        <span class="built_in">waitKey</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231950737-camera-models-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231950996-camera-models-12.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PC端】各大网站VIP视频免费观看的一种方法</title>
      <link href="/post/868ab6af.html"/>
      <url>/post/868ab6af.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/ed0a954c38ff402899d5e249a893195a.gif" alt=""></p><h2 id="一、安装TamperMonkey扩展程序（油猴）">一、安装TamperMonkey扩展程序（油猴）</h2><p>需要使用Edge浏览器或Chrome浏览器。</p><h3 id="1-1-如何使用Edge浏览器安装油猴-2">1.1 如何使用Edge浏览器安装油猴</h3><p>使用Edge浏览器安装油猴十分简单，直接进入<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?hl=zh-CN">【扩展应用商店】</a>安装即可。</p><h3 id="1-2-如何使用Chrome浏览器安装油猴-2">1.2 如何使用Chrome浏览器安装油猴</h3><ol><li>如果可以科学上网，进入<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">【Chrome扩展程序商店】</a>，点击右侧的添加至chrome即可。<br>ps.查外文文献查资料会经常需要科学上网。<br><img src="https://img.mahaofei.com/img/202112230934697-vip-2.png" alt=""></li><li>如果无法打开上面的网页，可以<a href="https://huffie.lanzouw.com/i6TuUuhjdyd">【点此下载】</a>离线包。①将下载的压缩文件解压；②打开浏览器扩展程序管理页面；③右上角打开开发者模式；④将解压出来的【TamperMonkey.crx】文件拖到到此页面。<br><img src="https://img.mahaofei.com/img/202112230935440-vip-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230936262-vip-4.png" alt=""></li></ol><h2 id="二、安装油猴脚本-2">二、安装油猴脚本</h2><p>各个浏览器都一样，直接<a href="https://greasyfork.org/zh-CN/scripts/370634-%E6%87%92%E4%BA%BA%E4%B8%93%E7%94%A8-%E5%85%A8%E7%BD%91vip%E8%A7%86%E9%A2%91%E5%85%8D%E8%B4%B9%E7%A0%B4%E8%A7%A3%E5%8E%BB%E5%B9%BF%E5%91%8A-%E5%85%A8%E7%BD%91%E9%9F%B3%E4%B9%90%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%AD%89%E5%A4%9A%E5%90%88%E4%B8%80%E7%89%88-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0-%E6%94%BE%E5%BF%83%E4%BD%BF%E7%94%A8">进入此页面</a>安装即可</p><p><img src="https://img.mahaofei.com/img/202112230936366-vip-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112230937609-vip-6.png" alt=""></p><p>安装完成后不会有任何提示。</p><h2 id="三、测试">三、测试</h2><p>这时候随便打开一个付费视频网页，会看到左侧多了一个VIP的弹窗，这里可以更换视频源进行播放。这里以其中一个名叫B站1的源进行测试。</p><p><img src="https://img.mahaofei.com/img/202112230938392-vip-7.png" alt=""></p><p>可以看到视频正常播放（账号不是VIP），这里的视频源有的有弹幕，有的没有弹幕，有的会在视频中嵌入广告，有的则不会嵌入广告，还请自动忽略视频中可能飘过的各种博彩信息。</p><p><img src="https://img.mahaofei.com/img/202112230939099-vip-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研问题汇总</title>
      <link href="/post/b9343102.html"/>
      <url>/post/b9343102.html</url>
      
        <content type="html"><![CDATA[<p>能找到这篇文章说明你真的有认真在看，加油！相信你一定能收获最好的结果！</p><p>下面谈到的问题都是我面试的时候被问到过的，仅供参考，每个学校的面试风格有所区别，但整体上是差不多的。</p><h3 id="一、简历问题">一、简历问题</h3><ol><li>介绍一下你参加过哪些科研训练/简单介绍一下你的科研经历</li><li>介绍一下你使用过哪些视觉的方法（简历上有写到相关项目）</li><li>说几个OpenCV里用到的函数，这些函数的具体功能是什么</li><li>机器人是一个大类，没有考虑过具体的细分方向？</li><li>什么是SLAM（回答问题时说研究方向对SLAM感兴趣）</li><li>看你简历，你掌握的东西不少，为什么学的这么杂，有没有哪一项是比较厉害的。（简历最下面写了比较多的掌握技能）</li></ol><h3 id="二、项目问题">二、项目问题</h3><ol><li>简单介绍一下你这个XXXXXX项目/介绍一个你觉得做的最好的项目。</li><li>你在这个项目中主要参与哪些工作</li><li>你们做的机器人有多少条腿，为什么是这么多条腿，这些腿的布局是怎么选的，为什么这么选，是怎么进行计算比较的？（考察项目设计方案，是不是真的自己做的）</li><li>你做的这个项目有没有实现预期的功能？</li><li>机器人内部有哪些传感器？</li><li>机器人内部的加速度传感器的采样频率是多少？</li></ol><h3 id="三、闲聊问题">三、闲聊问题</h3><ol><li>想来我校读研的原因，为什么会选择我们学校，有多大概率来。</li><li>你报名了几个夏令营，我们学校在你的意向中排第几顺位？</li></ol><h3 id="四、英文问题">四、英文问题</h3><ol><li>介绍一下你的校园</li><li>你对哪个研究方向感兴趣</li></ol><blockquote><p>我只在上交、哈工大遇到了英文问题，其它学校都是全程中文，也可能是我报名的学校学院比较巧。下面几个是朋友遇到的英文问题，在这里列出来，也作为参考。</p><ol start="3"><li><p>介绍一下自己的家乡</p></li><li><p>你最喜欢哪个季节</p></li></ol></blockquote><h3 id="五、专业问题">五、专业问题</h3><ol><li>什么是PID，比例环节是不是会让系统更稳定，PID分别对系统误差有什么影响？</li><li>什么是装配精度？装配精度包括哪几方面？</li><li>什么是阿贝原则？举两个例子解释阿贝原则。</li><li>材料的强度和刚度有什么区别？</li><li>影响材料弹性模量的因素有哪些？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>保研经验分享</title>
      <link href="/post/95ebe1c5.html"/>
      <url>/post/95ebe1c5.html</url>
      
        <content type="html"><![CDATA[<h3 id="〇、关于我">〇、关于我</h3><h4 id="0-1-个人信息">0.1 个人信息</h4><p><strong>机械电子工程专业，绩点3.95/4，专业排名1/133，无科研成果，11项省级以上竞赛，一篇专利、一篇软著</strong></p><h4 id="0-2-夏令营情况">0.2 夏令营情况</h4><p><strong>入营且通过</strong>：哈工大机电学院、沈自所、大连理工、中科大工程科学学院</p><p><strong>入营未通过</strong>：上交机动学院、天大机械学院（与期末冲突）、华科机械学院、</p><p><strong>未入营</strong>：浙大机械学院、华科机械学院、清深先进制造学部、自动化所、北理机电学院、西交机械学院、哈深机电学院</p><h4 id="0-3-预推免情况">0.3 预推免情况</h4><p><strong>入营并通过</strong>：天大机械学院</p><p><strong>入营未通过</strong>：无</p><p><strong>未入营</strong>：上交机动学院、浙大控制学院、自动化所、西交机械学院、北航自动化</p><h4 id="0-4-最终去向">0.4 最终去向</h4><p>哈工大机电学院机器人所</p><h3 id="一、保研流程">一、保研流程</h3><p>保研大概可以分为三个阶段，分别是<strong>夏令营</strong>，<strong>预推免</strong>，和<strong>九推</strong>。夏令营5月到7月各大学校发一轮优秀营员，预推免8月-9月再发一轮拟录取offer，然后9月28号在研究生报名系统里填报学校的时候还有机会捡漏。</p><h4 id="1-1-夏令营">1.1 夏令营</h4><p>首先是夏令营，夏令营应该是最早的一批面试。夏令营一般会线上或线下举办一些讲座，宣传一下学校学院，然后就是关键面试，面试结束，夏令营就算结束了。只要夏令营面试通过拿到“优秀营员”，就说明只要你9月28日开放报名系统后填这个学校的志愿，你就会被录取。当然这里也会有一些例外情况，后面会再说。</p><p><strong>① 夏令营如何报名</strong></p><p>夏令营的报名从5月份就开始了，然后一直持续到7月。大部分学校集中在6月多报名，七月多面试。这期间你需要去各个学校官网、学院官网、或者研招办官网、或者通过一些公众号，及时了解各个学校的通知。大部分学校的报名时间就1-2周，如果错过了就没办法报名了。</p><p><strong>② 夏令营的报名策略</strong></p><p>夏令营相对来说通过难度会大一些，而且有的学校是线下开展，可能需要占用3-4天的时间。但是我还是建议你们尽可能的多报一些学校，冲刺的、稳妥的、保底的，都报几个学校。我当时报了十多个快20个学校，最后通过材料初审的也就那么几个学校。另外能参加面试的尽量参加，一方面给自己更多的机会，另一方面可以涨涨面试经验。</p><h4 id="1-2-预推免">1.2 预推免</h4><p>夏令营结束之后，下一个可以参加学校面试的就是预推免阶段了。夏令营没有拿到很好的offer的话，预推免还可以继续报名这个学校，而且预推免的通过难度相对小一些，更有可能冲刺到好学校。</p><p><strong>① 预推免如何报名</strong></p><p>预推免的报名时间大概在8月-9月上旬，也是看看学校、学院、学校研招网这些官方网站，或者公众号了解通知</p><p><strong>② 预推免的报名策略</strong></p><p>预推免的面试一般是9月初了，这时候建议根据自己夏令营的情况，报名一些冲刺的学校，有些学校的材料可能会很麻烦，但是大家尽量报名吧，不通过也没事，尽量别留下遗憾就行。</p><h4 id="1-3-九推">1.3 九推</h4><p>九月推免，一般就是说9月28号在国家研究生报名系统里报名学校了。报名学校的时候，按理说还是可以报名学校然后给你面试的，但是好的学校基本都已经通过夏令营和预推免招到了足够的学生，只有方向不太好的学院才会出现报名的人太少，系统开放之后可以再报名捡漏的情况，这样风险太大，一般还是在夏令营和预推免拿到学校的offer后，你这边报名他们学校，然后那边老师确认一下，就算完成了。</p><p>整体就是这么个流程，从5月持续到9月底。</p><h3 id="二、保研如何准备">二、保研如何准备</h3><h4 id="2-1-院校选择（自身定位）">2.1 院校选择（自身定位）</h4><p>院校的选择主要是要考虑学院实力，学院的整体研究方向，学校所在地域这些因素。</p><p>学院实力根据第四轮学科评估，看是A+还是A还是A-，大体判断学院实力。</p><p>学院的整体研究方向主要去学院官网看就可以，学院官网会介绍学院的一些研究成果等等，或者打开几个老师的主页，看看老师们大都在做什么。</p><p>学校所在地域，这一点需要根据你未来的发展方向选择。</p><p>而具体到要报名哪些学校，每个人就都不太一样了，一方面要考虑自己的未来发展方向，另一方面根据自身的综合实力，可以参考专业往年的情况。</p><h4 id="2-2-材料方面">2.2 材料方面</h4><p>保研申请的材料虽然多，但每个学校需要的东西都是差不多的，报名完第一个以后，后面的就都差不多了。需要的材料大家尽量提前准备，并且要随着对保研的了解还有面试过程要不断修改。需要的材料，随便找一个学校的预推免或夏令营通知就可以看到了，下面这个图片就是某高校夏令营的申请材料要求。</p><p>最好提前准备的材料包括：个人简历，个人陈述1000字左右，推荐信，有的学校线上面试会需要PPT。</p><p><img src="https://img-blog.csdnimg.cn/723bd0953c134211891e7cb60912a40e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h4 id="2-3-关于面试">2.3 关于面试</h4><p>我也参加了大大小小好多学校的面试了，总结下来面试基本流程就是，首先是自我介绍，然后可能会问你几个英语问题考察一下你的英语能力，包括研究方向，介绍本科学校等等。然后就是根据简历、自我介绍的东西问你问题，绝大部分都是问你项目有关的内容，问专业课的倒是并不多。其次就是和你聊聊天，比如对什么感兴趣，报了哪些学校，联系老师了没。</p><p>所以大家最好能提前准备好2分钟左右的自我介绍，多熟练熟练。然后好好看看项目的内容，所有的细节问题都要能答的上来。另外准备准备一些常规的问题，比如说研究方向啥的。这里我放了我遇到的一些<a href="https://www.mahaofei.com/04_essays/01_experience/01_questions/">面试问题</a>，仅供参考。</p><h4 id="2-3-联系老师">2.3 联系老师</h4><p>我是挺建议提前联系老师的，尤其是那种想要特别想要去的学校，最好提前联系老师，因为你不联系，老师可能就没名额了。我遇到的最离谱的是，六月多上交一位老师的名额就满了，虽然这是极少数情况，但是还是越厉害的老师，名额就越抢手，建议提前邮件联系，记得用学校的邮箱。</p><h3 id="三、经验分享">三、经验分享</h3><h4 id="3-1-导师的选择">3.1 导师的选择</h4><p>导师的所有信息，在学院官网的师资队伍页面都可以看到。</p><ol><li><p>导师的类型，学术大牛教授型、年轻有为奋斗型，不同的导师可能会决定着你研究生阶段的生活状态。</p></li><li><p>导师的研究方向，可以看老师主页的个人简介，以及做过的项目，还有最近发的论文。</p></li><li><p>导师的人品，网上搜导师评价网、导师点评网，问去过的学长学姐，渠道很多，虽然看似与科研没什么关系，但实际上影响很大</p></li></ol><h4 id="3-2-夏令营与预推免的报名策略">3.2 夏令营与预推免的报名策略</h4><p>根据上一届的学长学姐的情况来看，预推免比夏令营更有机会冲刺高等院校，也就是说你在夏令营尽可能多参加一些，一方面是积累面试经验，重要的是一定要有一个保底的offer，这样预推免就主要准备比保底offer更好的学校就可以了，这样主动性会大一些。</p><h4 id="3-3-信息的获取">3.3 信息的获取</h4><p><strong>① 官方渠道</strong>： 学校官网、学院官网、学校。注意这三个网站是不一样的，有的学校会在这些网站都发布推免招生信息，但有的学校只在学院官网发通知，有的学校只在研招网发通知，这些网站报名的时候最好都看看。不要出现你以为学校还没发通知，其实是发了通知你没看到这种情况。</p><p>**① 公众号：**保研、保研人、保研圈、预研家等等。这些公众号上会不定时的推送保研的最新资讯，比如xxx所高校发布夏令营招生通知，然后下面一大堆链接。公众号里也有很多保研的经验分享。</p><h3 id="四、题外话">四、题外话</h3><p>其实我最后还是想讲一下关于个人规划这件事，因为保研过程中你肯定会面临很多选择，包括对专业研究方向的选择，读研读博的计划，导师的选择，学校的选择，城市的选择等等。</p><p>但这些所有的选择其实都归结于你对与自己未来有怎样的规划，你是想读研读博一条路做科研，还是想读研出去企业工作，还是想读研然后考选调走公务员，还是说打算自己创业等等。</p><p>这些不同的个人规划，对应的是不同的选择。但当你确定了自己的发展路线之后，这些看起来很纠结的问题就不会那么纠结了。可能有的人会说，我现在不知道自己未来要走哪条路，我想先走一步看一步，但是我比较认为，越早能确定自己的人生路线，更早的开始努力是最值得的，如果你读完研发现自己想做的和自己在做的完全不一样，到那时后悔就晚了，已经付出了巨大的时间成本了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>科学上网方法（如何访问Google,ChatGPT）</title>
      <link href="/post/24b9bc9.html"/>
      <url>/post/24b9bc9.html</url>
      
        <content type="html"><![CDATA[<h1>一、免费方法</h1><h2 id="1-1-应用介绍">1.1 应用介绍</h2><p>Cloudflare是一家全球领先的云端网络服务提供商，它提供了一系列的网络安全、性能优化和CDN加速解决方案，同时也是最大的域名解析商。本次推荐的应用就是Cloudflare推出的一项虚拟私人网络（VPN）服务。</p><p>在浏览器输入<code>1.1.1.1</code>这个IP地址，就可以进入WARP的应用主页，目前该应用全平台支持，包括Windows, Linux, Andorid, IOS, macOS。</p><p><img src="https://img.mahaofei.com/img/202308031514648.png" alt="image.png"></p><p><strong>注意：该方法目前无法访问ChatGPT，但是可以正常访问Google，Github，youtube等常规网站，想要访问ChanGPT请参考 二、付费方法</strong></p><h2 id="1-2-使用方法">1.2 使用方法</h2><p>进入<a href="1.1.1.1">1.1.1.1</a>下载自己平台对应的安装包。</p><p><strong>（1）Windows</strong></p><p>下载完成之后直接安装，然后在右下角可以看到一个云的图标，点击开启按钮就可以开启科学上网了。</p><p><img src="https://img.mahaofei.com/img/202308031519629.png" alt=""></p><p><strong>（2）Ubuntu</strong></p><p>（不建议安装在服务器上，服务器使用此方法可能会导致无法 SSH 与远程桌面）</p><p>支持16.04-22.04的Ubuntu版本，根据<a href="https://pkg.cloudflareclient.com/">官方教程</a>进行安装，安装步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add cloudflare gpg key</span></span><br><span class="line">curl https://pkg.cloudflareclient.com/pubkey.gpg | sudo gpg --yes --dearmor --output /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add this repo to your apt repositories</span></span><br><span class="line">echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ $(lsb_release -cs) main&quot; | sudo tee /etc/apt/sources.list.d/cloudflare-client.list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install cloudflare-warp</span><br></pre></td></tr></table></figure><p>命令行启动方法，参考该<a href="https://github.com/cloudflare/cloudflare-docs/blob/production/content/warp-client/get-started/linux.md">使用说明</a>，常用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册客户端</span></span><br><span class="line">warp-cli register</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接客户端</span></span><br><span class="line">warp-cli connect</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否连接（warp=on）</span></span><br><span class="line">curl https://www.cloudflare.com/cdn-cgi/trace/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">断开连接</span></span><br><span class="line">warp-cli disconnect</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202308031523640.png" alt="image.png"></p><p>图形化界面启动方法，由于官方没有提供图形化界面，因此找了Github第三方开发的界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mrmoein/warp-cloudflare-gui</span><br><span class="line">cd warp-cloudflare-gui</span><br><span class="line">python3 install.py</span><br><span class="line">sudo chmod +x ~/.local/share/applications/warp-gui.desktop</span><br></pre></td></tr></table></figure><p>安装完成之后可以直接在应用列表找到<code>Warp Cloudflare</code>，效果如图</p><p><img src="https://img.mahaofei.com/img/202312241219060.png" alt="image.png"></p><p>设置开机自启动，打开<code>Startup Applications Preferences</code>或者叫<code>应用启动程序</code>，添加一个启动程序。</p><p>找到刚才<code>git clone</code>的包中的<code>main.py</code>路径，将其添加到启动应用程序的命令栏中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果想启动的时候最小化到右上角，则添加--hide</span><br><span class="line">python3 /home/【你的路径】/warp-cloudflare-gui/main.py --hide</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202312241222974.png" alt="image.png"></p><p>保存，完成。</p><blockquote><p>[!question]- 如果出现一直显示 “正在连接” 而无法使用，可以使用下面的工具<br>下载[该工具]( <a href="https://pan.kejicode.cn/d/Onedrive/WIN%E7%AB%AFwarp%E8%87%AA%E9%80%89IP">https://pan.kejicode.cn/d/Onedrive/WIN端warp自选IP</a> (%E6%89%8B%E5%8A%A8%2B%E8%87%AA%E5%8A%A8).rar?sign=RqBdHIMyyhge4edls16b7Km0rGoqxuNqVboC-09h5cA=:0)，按照其中的要求进行配置</p><ol><li>断开所有的节点连接</li><li>双击 <code>手动方式1</code>，生成一个 <code>result.csv</code> 文件</li><li>打开 <code>result.csv</code> 文件，复制第一行的 IP 地址端口</li><li>双击 <code>手动方式2</code>，将复制的 IP 地址端口粘贴进去，回车即可完成。</li></ol></blockquote><p><strong>（3）Android</strong></p><p>在 APK Pure 等网站中下载 <code>1.1.1.1</code> 的安装包，安装完成之后即可使用。</p><p><img src="https://img.mahaofei.com/img/202401242127777.jpg" alt="Screenshot_20240124_210343.jpg"></p><p><strong>（4）IOS/macOS</strong></p><p>没有相关设备，暂时无法测试。</p><blockquote><p>==以下是过时的方法，现在不知道还能不能用，仅供参考==<br><strong>1. 谷歌访问助手</strong><br>谷歌访问助手：<a href="https://huffie.lanzouw.com/iRTKwusg31i">点此下载</a><br>需要搭配Chrome浏览器使用，下载完成后，打开谷歌浏览器的扩展程序页面（<a href="">chrome://extensions/</a>）将crx文件拖到此页即可，安装完成。然后按照插件内的指示即可实现某些网页的加速。<strong>（不过这个插件偶尔会被封一段时间，无法访问）</strong><br><strong>2. 免费机场节点</strong><br>之前有曾经使用过一段时间的免费机场节点，但大都连接速度满，且不稳定，目前我知道的机场节点大多数都已被封，下面这两个之前用过，现在应该还可以用，但是不知道稳定性如何。<br><strong><a href="https://j01.best/">① 几鸡</a></strong><br><strong><a href="https://ikuuu.co/">② ikuuu</a></strong></p></blockquote><h1>二、付费方法</h1><p>免费方法的Cloudflare-WARP已经能够满足绝大部分需求，付费方法主要是用来访问ChatGPT</p><h2 id="2-1-机场推荐">2.1 机场推荐</h2><p>所谓机场，是指翻墙节点的提供方。由于以前常用的翻墙工具图标为小飞机，因此将翻墙服务的提供商称作机场。</p><p><strong><a href="https://mojie.link/#/register?code=eXhdl9bj">魔戒</a></strong></p><p>推荐流量套餐（不限时间），对于只使用查阅文献，chatgpt 等，不看视频的用户个人认为还是很合适的。</p><p><img src="https://img.mahaofei.com/img/202311082118218.png" alt="image.png"></p><p>其他类似网站还有很多，有兴趣的可以到<a href="https://fanqiangdang.com/forum.php">【论坛】</a>中找找，这里就只列出我用过的两个。**</p><h2 id="2-2-如何使用">2.2 如何使用</h2><p>这里以<a href="https://mojie.link/#/register?code=eXhdl9bj">魔戒</a>为例</p><p><strong>1. 下载安装clash</strong></p><blockquote><p><s>Github 链接：<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/">https://github.com/Fndroid/clash_for_windows_pkg/releases/</a></s><br>==Clash 作者 Fndroid 已经将 Clash_for_Windows 各平台客户端内核删库停更，但是当前各个版本依然能用。==<br>最后一版备份链接：<a href="https://archive.org/download/clash_for_windows_pkg">https://archive.org/download/clash_for_windows_pkg</a><br>打不开上面的备份链接可以从这里下载：<a href="https://www.clash.la/archives/750/">https://www.clash.la/archives/750/</a><br>下载其中的【 <a href="https://archive.org/download/clash_for_windows_pkg/Clash.for.Windows.Setup.0.20.39.exe">Clash.for.Windows.Setup.0.20.39.exe</a> 】然后安装即可。</p></blockquote><p>如果无法打开 github，可以从<a href="https://clashcn.com/clash-for-windows">此处</a>下载，<a href="https://down.clashcn.com/soft/clashcn.com_Clash.for.Windows-0.20.39-win-CN.7z">汉化版</a>与<a href="https://down.clashcn.com/soft/clashcn.com_Clash.for.Windows.Setup.0.20.39.exe">官方原版</a>都可以</p><p><strong>2. 添加订阅</strong></p><p>打开机场网站，找到【仪表盘 -&gt; 一键订阅 -&gt; 导入到 Clash】，即可成功完成订阅的添加。</p><p><img src="https://img.mahaofei.com/img/202311082121679.png" alt="image.png"></p><p>或者复制订阅地址，粘贴到Clash中的如下图所示位置，点击Download，一样可以添加订阅。</p><p><img src="https://img.mahaofei.com/img/202112230933772-findpaper-4.png" alt=""></p><p><strong>3. 进入【General】页面，打开【System Proxy】，即可成功访问Google Scholar等网站。</strong></p><p><img src="https://img.mahaofei.com/img/202112230933274-findpaper-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112230933339-findpaper-6.png" alt=""></p><p>在Proxies中可以选择节点，通常来说选择美国、欧洲、台湾省的节点可以比较稳定的访问ChatGPT。</p><p><img src="https://img.mahaofei.com/img/202308031557877.png" alt="image.png"></p><p><img src="https://img.mahaofei.com/img/202112230933377-findpaper-7.gif" alt=""></p><blockquote><p>谨记：本方法仅用于学习交流使用，禁止用于商业用途，严禁访问除学习研究外的其他网站，否则一切后果请用户自负。本页所有信息来自网络，仅供学习参考。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘不限速下载方法</title>
      <link href="/post/e5808c6a.html"/>
      <url>/post/e5808c6a.html</url>
      
        <content type="html"><![CDATA[<h1>一、安装TamperMonkey扩展程序（油猴）</h1><p>需要使用Edge浏览器或Chrome浏览器。</p><h2 id="1-1-如何使用Edge浏览器安装油猴">1.1 如何使用Edge浏览器安装油猴</h2><p>使用Edge浏览器安装油猴十分简单，直接进入<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?hl=zh-CN">【扩展应用商店】</a>安装即可。</p><h2 id="1-2-如何使用Chrome浏览器安装油猴">1.2 如何使用Chrome浏览器安装油猴</h2><ol><li><p>如果可以科学上网，进入<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">【Chrome扩展程序商店】</a>，点击右侧的添加至chrome即可。<br>ps.查外文文献查资料会经常需要科学上网。<br><img src="https://img.mahaofei.com/img/202112230923512-tampermonkey.png" alt=""></p></li><li><p>如果无法打开上面的网页，可以<a href="https://huffie.lanzouw.com/i6TuUuhjdyd">【点此下载】</a>离线包。①将下载的压缩文件解压；②打开浏览器扩展程序管理页面；③右上角打开开发者模式；④将解压出来的【TamperMonkey.crx】文件拖到到此页面。</p></li></ol><p><img src="https://img.mahaofei.com/img/202112230924215-chrome-extension.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230924091-chrome-extension.png" alt=""></p><h2 id="二、安装油猴脚本">二、安装油猴脚本</h2><p>这一步不论什么浏览器都一样。打开<a href="https://greasyfork.org/zh-CN/scripts/436446-%E7%BD%91%E7%9B%98%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B">【此网页】</a>，安装脚本即可。</p><p>ps. 油猴是一个非常实用的插件，GreasyFork里面有很多实用的脚本，想了解的可以自行探索。</p><h1>三、开始下载</h1><h2 id="3-1-下载方法">3.1 下载方法</h2><p>进入<a href="http://pan.baidu.com/">百度网盘网页版</a>，选中要下载的文件，点击左上角的下载助手-API下载，即可直接下载。</p><p><img src="https://pic.rmb.bdstatic.com/bjh/32b2bead4b1c7fc806eacfde29b78f975055.gif" alt=""></p><p><img src="https://pic.rmb.bdstatic.com/bjh/5511a57ed37398ab870ab0095b78948a6031.gif" alt=""></p><h2 id="3-2-更快的下载">3.2 更快的下载</h2><p><strong>默认的网页下载是单线程的，而如果想要下载更快，还可以使用多线程下载器，比如IDM。</strong></p><p>如果你已经在使用IDM，那么可以跳过这一步。</p><p>如果没有，可以使用<a href="https://huffie.lanzouw.com/i6TuUuhjdyd">【点此下载】</a>离线包解压的文件夹中的IDM绿色版。</p><ol><li>将压缩包解压后运行【绿化.bat】；<br><img src="https://img.mahaofei.com/img/202112230928396-lvhua.png" alt=""></li><li>运行【IDMan.exe】</li><li>打开【选项】菜单，点击【下载】栏，将用户代理UA修改为：<strong>softxm;netdisk</strong><br><img src="https://img.mahaofei.com/img/202112230929578-daili.png" alt=""></li><li>点击【连接】栏，将最大连接数设置为<strong>4</strong>，点击【确定】<br><img src="https://img.mahaofei.com/img/202112230929559-linknumber.png" alt=""></li></ol><h2 id="3-3-选择文件下载">3.3 选择文件下载</h2><p>还是使用上面的方法，进行下载。</p><p>下载速度根据当前网络状况，校园网一般在<strong>5MB/s~10MB/s</strong><br><img src="https://img.mahaofei.com/img/202112230930623-ceshi.png" alt=""></p><h1>四、其它方法</h1><p>据我所知，有一款工具名为<a href="https://kinhdown.kinh.cc/">KinhDown</a>也十分好用，有兴趣的可以去官网了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows各版本与Office全系列激活方法</title>
      <link href="/post/c5d699a.html"/>
      <url>/post/c5d699a.html</url>
      
        <content type="html"><![CDATA[<h1>Office推荐方法</h1><p><a href="https://account.microsoft.com/services">https://account.microsoft.com/services</a></p><p>到这个网站能看到自己已经购买过的office，一般买过电脑后，都会附赠office，从这里下载然后安装，再登陆自己的账号，就能正常使用了，而且是绝对正版的。</p><p><img src="https://img.mahaofei.com/img/20230314162622.png" alt=""></p><h1>万能激活方法</h1><p>这里提供一个工具的下载链接：<a href="https://huffie.lanzouw.com/i1w7Vuxyzxa">https://huffie.lanzouw.com/i1w7Vuxyzxa</a>，解压后以管理员身份运行。</p><p>具体功能和使用方法不必多说，看图即可（一键激活）。</p><p><strong>需要注意：解压之前一定退出所有安全管家，如果还是找不到，看一下是不是被Windows Defender删掉了</strong></p><p><img src="https://img.mahaofei.com/img/202112230939435-winoffice-1.png" alt=""></p><p>如果完成后，出现【Microsoft office无法验证此产品的许可证，应使用控制面板修复office程序】</p><ol><li>点击【其它】</li><li>选择产品【Microsoft Office 20XX】；选择版本选择【XXXX】（你自己的版本）</li><li>选择类型【Fix_Banner_New】</li><li>点击【开始】</li></ol><p>就可以修复许可证弹窗了。</p><h1>许可证问题解决方案</h1><p>如果按照上面的Fix_Banner_New还是解决不了许可证弹窗问题，那么按照官方回答的方法：</p><p><a href="https://answers.microsoft.com/zh-hans/msoffice/forum/all/win10-office-16/3bf97673-1a84-46be-9e15-71f9859368f4">https://answers.microsoft.com/zh-hans/msoffice/forum/all/win10-office-16/3bf97673-1a84-46be-9e15-71f9859368f4</a></p><p>《修改注册表权限》</p><ol><li>登陆管理者账号</li><li>同时按【win键+R】，输入regedit，打开【注册表】</li><li>展开 【HKEY_USERS】&gt;【 S-1-5-20】</li><li>右键单击【 S-1-5-20】&gt;【权限】</li><li>选择【添加】</li><li>键入登录的用户的名称，选择【检查名称】&gt;【确定】</li><li>选择【高级】&gt;【高级安全设置】&gt;【权限】选项卡</li><li>为下方的用户，添加权限：  【编辑】&gt;【基本权限】&gt; 选择【完全控制】&gt; 【确定】</li></ol><ul><li>刚刚添加的用户</li><li>【NETWORK SERVICE】</li></ul><ol start="9"><li>返回到【高级安全设置】&gt; 勾选【替换所有子对象权限项目】&gt;【确定】</li><li>重启电脑</li></ol><p>如果没找到【NETWORK SERVICE】用户，那么就按照第6步手动添加一个。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自控力极差的人如何自救？——来自Clei的回答</title>
      <link href="/post/cbce80b0.html"/>
      <url>/post/cbce80b0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：Clei<br>链接：<a href="https://www.zhihu.com/question/21368231/answer/90497581">https://www.zhihu.com/question/21368231/answer/90497581</a><br>来源：知乎</p></blockquote><p>很多人觉得自己计划完不成，拖延，生活中养成种种恶习的根源在于自制力不强，以为增强了自制力，一切问题就能迎刃而解——<strong>这个想法是错的，自制力并不是解决这些问题的关键。</strong></p><p>那什么才是呢？诸位稍安勿燥，这个后面自然会讲到，但在此之前，且听我讲一个哈佛学霸的故事。</p><p><strong>一. 75%真实的故事</strong></p><p>故事主人公叫 Tal ，是哈佛大学心理系大三的学生，同时也是学校壁球队的主力。他每天很早起床去跑步，然后去学校，一天的课程结束后，他会去球场和教练进行常规训练、打比赛，在此之后，他会去健身房健身，然后回家，做作业，看书学习，睡觉。日复一日，从不间断。</p><p>于是大家纷纷认为 Tal 童鞋是一个高度自律的学霸。Tal 童鞋也是这么看待自己的，直到寒假到来。</p><p>作为学霸，寒假当然不会满足于过过圣诞节，看看之前很火的天朝剧《Nirvana in Fire》（琅琊榜），Tal 打算预学两门下学期的课，完成一个 Research Project，并且平均每天保持1小时以上的锻炼。</p><p><img src="https://img.mahaofei.com/img/202112231940097-self-control-1.png" alt=""></p><p>嗯，结局喜闻乐见：Tal 童鞋跪了，他唯一的成就是如愿看完了 Huge（胡歌）主演的这部大作，哦对，还胖了四斤。啥，你问学习研究和锻炼呢？Tal 只在头两天看了10页书，加起来锻炼了一个小时而已。</p><p>看到这里我知道有人要跳出来说：“不！这不是真的！学霸辣么自律，寒假计划怎么会失败？！一定是你瞎编的！”</p><p>对，如你所见，我瞎编了25%的部分，但那仅仅是具体的失败细节，事实仍然没有变化——Tal童鞋的计划的的确确泡汤了。不信你看，下面是他的原话，还有视频截图为证。</p><blockquote><p>I can’t wait to have the freedom without squash and just focus on my classes. Catch up on all the readings and writings and stuff. Winter holiday came. I stopped playing completely. And instead of becoming more productive, I became far less productive.<br>我等不及没有壁球的自由，以专注于我的学习，追上阅读、写作的进度。寒假来了，我不用再进行（壁球）训练了，但与高效学习相反，我反而效率变低很多。</p></blockquote><p><img src="https://img.mahaofei.com/img/202112231940884-self-control-2.png" alt=""></p><p>有些读者已经认出 Tal 了，没错，他现在是哈佛的 Tal 教授，这张图来自于他广为流传的《积极心理学》课程的第11集的39分47秒。（借机安利下，作为哈佛当年最受欢迎的选修课没有之一，这门课于2010年被网易公开课收录，并取了个很鸡汤的名字，叫《哈佛幸福课》，此后长期霸占排行榜第一，累计观看数早已破千万。）</p><p><strong>二.学霸们的困扰</strong></p><p>Tal 教授用亲身经历证明了，在寒假计划这种事上，学霸和普通人其实有着同样的困扰。有人会说Tal 是个例，但不是的，我的很多朋友都是学霸，即使是在 MIT 念 Phd 的哥们，也会面临在家睡到中午起不来，学习计划迟迟无法落实的问题。</p><p>当然，还是有人会举手，说不对啊，我就认识那种寒假计划很充实，还全都落实了的学霸！对，没错，我们姑且把这样的人称之为“成熟体学霸&quot;，把前面那些计划泡汤了的称为“幼年体学霸”。在你们见到的那些学霸里，相当一部分仍处于“幼年体”，仍会和普通人一样，受到自控力和拖延症的困扰。</p><p>那么问题来了，“幼年体学霸”是如何成长为“成熟体学霸“的呢？</p><p><img src="https://img.mahaofei.com/img/202112231941417-self-control-3.png" alt=""></p><p>（上面这张图好暴露年龄啊！）</p><p>虽然计划泡汤了，学霸毕竟是学霸，很快展现出了他与普通人的区别：</p><p>普通人是这样的：计划失败 -&gt; 沮丧 -&gt; 骂自己一顿 -&gt; 制订新计划 -&gt; 继续失败</p><p>学霸是这样的：<strong>计划失败 -&gt; 沮丧 -&gt; 骂自己一顿 -&gt; 深度思考计划为啥失败 -&gt; 改善问题 -&gt; 制订新计划</strong></p><p>当然新计划可能成功，也可能失败，失败之后，学霸会重复上述流程。久而久之，新计划中失败的越来越少，成功的越来越多，学霸也实现了幼年期到成熟期的进化。</p><p>那么为啥计划会失败呢？明明学霸们平时是拥有高度自控力的，难道到了寒假自控力会失效？</p><p>这就要说到自控力的假象了。</p><p><strong>三.自控力的假象与真相</strong></p><p>不知道大家有没有这样一种感觉：高考前是自己学习力和自控力的巅峰，那时候每天都要做好多题，学到很晚，但第二天还是精神抖擞，继续奋战；上了大学之后，时间宽裕了，反而变得懒散了，没有之前学习的劲头和毅力了，到了假期更是懒得一发不可收拾，熬夜看剧、晚睡晚起、暴饮暴食那都是家常便饭。</p><p>为什么会这样呢？难道时间越宽裕，自控力就越薄弱？这显然不科学。那就是因为时间越宽裕，我们越容易懈怠和堕落？但这是结果，并不是原因。<strong>我们以为自己的自控力曾经很强，上大学后变弱了，放假后则因为懈怠愈发孱弱——这其实这个假象。那真相是什么？</strong></p><p>Tal老师为我们揭示了两个真相：</p><p><strong>1.保证我们高效运转的其实是习惯，而不是自控力。</strong></p><p>想想在高考之前的那种紧张的学习氛围里，我们被动的养成了很多习惯——每天规律的上课、自习、吃饭和睡觉，我们目标明确——每个月、每个星期乃至每天复习什么，老师们都替我们安排好了。这些我们习以为常，就像你每天早上起床都会自动去刷牙一样自然（说不刷牙的你走开！）</p><p>你想想想你起床后刷牙的过程：穿衣服（好吧我知道有人不穿），拿起杯子和牙刷，走到卫生间，接水，挤牙膏，开始刷。即使你可能还睡眼惺忪，但这一套流程你仍然能精确无比、毫不费力的执行下来。这个过程需要一丢丢的自控力吗？基本不需要对不对？</p><p><img src="https://img.mahaofei.com/img/202112231941053-self-control-4.png" alt=""></p><p>所以高中的那些学习，其实并不需要太多自控力**。**而当你进了大学，课程安排变得自由了，你丧失了那些被动习惯，开始自己规划学习和生活时，才是需要自控力的时候。而此时，很多人不得不面对第二个真相：</p><p><strong>2.人的自控力是有限的</strong></p><p>很多人不知道，**自控力和肌肉力量一样是有限的。**这个结论被大量的心理学实验证明，大家上网搜索一下就能看到，我这里不做赘述，我只打个比方，相信能帮你更好的理解这个结论：</p><p>想象下，当你搬宿舍、或是换教室时，你把一摞又一摞沉重的书本，吃力的从这个屋子搬到那个屋子之后，你双臂酸软，腰酸背疼，严重者可能连一杯水都举不起来——因为你的肌肉力量耗尽了。</p><p>自控力也一样，我们在日常生活中要面对各种各样的诱惑：桌上昨天新买的一大堆零食，双十一淘宝主页玲琅满目的商品，男神胡歌的新剧又开播了……我们要反复抵抗这些诱惑才能专注于那些重要的目标，比如学习和减肥。每拒绝一次诱惑，你的自制力就消耗一分，如果面临的诱惑太多，总会有一个时刻，我们会累到无力抵抗，任由暴饮暴食、刷爆淘宝、熬夜看剧这些行为支配我们的生活。</p><p><img src="https://img.mahaofei.com/img/202112231942455-self-control-5.png" alt=""></p><p>当然现实没有那么可怕，肌肉酸痛过两天会恢复，自制力嘛，你睡个好觉也能回归正常。有意思的是，不同人天生力气不一样，自制力强弱也不一样，自制力超群或是弱到掉渣的，在人群中都占很小的比例，大多数人都处在中间那个状态——不好也不坏。</p><p>所以我们得出的结论是：学霸就是那群天生自制力超群的人？如果是这样，那我写这篇文章也太没意思了。</p><p>有机智的童鞋马上反应过来了：哦！既然我们可以锻炼肌肉，自制力也是可以锻炼的，对吧！我们只要把自制力锻炼到很强就可以了！</p><p>这话没错，然而肌肉力量有极限，自制力也是有极限的。生活中，我们面临的诱惑如此之多，靠后天锻炼出来的自制力依然会不够用。另一方面，就像上面讲到的第一点：<strong>无论是校园里的“成熟期学霸”，还是社会里的精英人士，其高效的学习和生活，并不像我们往常以为的那样，依赖于强大的自制力，而是得益于后天构建起来的习惯体系。</strong></p><p><img src="https://img.mahaofei.com/img/202112231942065-self-control-6.png" alt=""></p><p><strong>如何利用我们有限的自制力，去构建这样一套体系，才是我最想说的东西</strong>，当年的Tal童鞋，也是在意识到这个问题之后，才开始了他的翻盘之旅，成功进化为成熟体学霸，最后成为哈佛教授，走上人生巅峰的。（好吧别打我，我承认后面这段是我瞎编的。）</p><p>但是构建习惯体系，并不是一件轻松的事情，原因有两个：</p><p>1.很多人没有意识到，有一个看不见的敌人在阻挠我们的行动，</p><p>2.很多人不知道，习惯背后的原理。</p><p><strong>四. 看不见的敌人</strong></p><p>很多人都想要减肥，想要健身，但大多数人的状况是：决定要减肥或健身后，制定了详细的计划，买了一堆装备，办了几千块的健身卡，却在去了不到三次后，将这些东西都束之高阁。</p><p>为什么建立一个锻炼的习惯这么难呢？因为太多人不了解习惯背后的原理，更重要的原因是，<strong>太多人太急了，太想在短期内看到显著的改变。</strong></p><p>是的，我们都希望一夜暴富，一朝成名，都喜欢看“穷小子白手起家创业成功，一年变身亿万富翁”、“胖女孩半年瘦身八十斤俘获男神芳心”的故事。但这些不是我们的错，<strong>我们之所以天生短视，喜欢即时的反馈和满足感，是因为大脑里，住着一个看不见的敌人在捣乱。首先你得意识到它的存在，然后才能战胜它。</strong></p><p>在几百万年前，我们的祖先还茹毛饮血的时候，资源稀缺，吃了上顿没下顿，大脑需要持续的分泌化学物质，它们促使人们去寻找并摄入食物，热量越高越好，把自身的脂肪储存的越多越好；如果不是这种机制，人类很可能存活不到今天。</p><p><img src="https://img.mahaofei.com/img/202112231942782-self-control-7.png" alt=""></p><p>可我们不是原始人，我们进化出了更高级的控制单元，所以我们学会了计划，学会了为达成长期目标放弃短期利益。<strong>但原始的那部分大脑并没有消亡，它依然在时刻争夺着身体的控制权，促使我们孜孜不倦的寻求即时的满足感。</strong></p><p>所以你明白了吗？为什么在认真学习时，忽然会冒出“学这么久了，看一集美剧吧！”的念头；为什么晚饭吃了不少，睡前还是管不住自己伸向零食的手；为什么你打开手机想要背单词，却鬼使神差的戳开了微博；这些的本质都是原始大脑在作怪。</p><p>好了，看到这里，你意识到敌人的存在了，即大脑的原始部分；你也意识到它惯用的伎俩——即时满足感。但这还不够，要打败它，你得掌握科学的武器，也就是习惯的原理。</p><p><strong>五.习惯的原理</strong></p><p>习惯的养成，依赖于四个部分：<strong>触机（cue）、惯性行为（routine）、奖励（reward）和信念（belief）：</strong></p><blockquote><p>**触机：**即触发习惯的原因，你可以想象成手枪的扳机，按下扳机，子弹就打出去了。习惯的触机有很多，可能是时间、地点或场景。你早上刷牙的触机是起床这个动作；去吃午饭是因为时间到了（额，好吧，还有肚子饿了）；有人习惯睡前刷微博，那么触机可能是你躺下来盖上被子。触机本身没有好坏之分，决定习惯好坏的，是它引发的惯性行为。<br>**惯性行为：**之所以叫惯性，是因为它是无意识的，比如一打开电脑就先上网看看娱乐新闻；比如睡前一定要刷一下朋友圈。在建立新习惯的过程中，<strong>我们的自制力，就用于修正那些引起拖延的旧行为，将其替换为新的惯性</strong>。在更正坏习惯时，你需要格外留意引发它的触机，同时关注自己的行为，不断提醒自己不要重蹈覆辙。这一步是最消耗时间和精力的过程，可能要与旧习惯反复拉锯，因为良好惯性行为的建立不仅需要有自制力去克服旧的行为，还需要在行为结束时获得正向的反馈，也就是下面要说的“奖励”。<br><strong>奖励：这是习惯养成中至关重要的一环，它往往被人们忽略</strong>。为什么坏习惯容易养成且难以改变？因为它们的奖励往往即时而明显：打游戏、刷网页、吃零食这些哪个不是这样？好习惯难以形成，也恰恰因为短期的奖励不够明显。背单词、健身、练书法这些行为往往需要较长的时间才能看到效果，有些人天生能从过程中获得精神激励，但很多人不行，那我们需要人为的赋予自己奖励：比如记录自己的成长和进步、时不时发个微博鼓励下自己、达成一些小目标时吃顿好的庆祝下等等（啊喂也不要暴饮暴食啊！）<br>关于奖励，稍稍多说几句。诸如学习、健身这种事本身是有点反人性的，有没有什么办法能快速建立正向奖励机制呢？这个展开能写两本书…知乎上有很多学习、健身相关的优质答案了，我这里不赘述。我想提供一种思维：<strong>积极的、开放性的、成长性的思维。即多去看看那些享受学习、享受健身的人是怎么做到这些事情的，尝试去学习他们的方法，把目光放在积极面上，而不是怀疑自己能力不行，觉得自己做不好。</strong> 此外，强化你的“信念”有助于你获得精神上的正反馈。 <strong>信念：</strong> 这是支撑你建立习惯的内在动力：你想要每天背单词，是为了干掉英语考试；你想要学会弹吉他，是为了能在各种晚会上一显身手；你想要规律饮食、早睡早起，是为了身体健康；你想要健身减肥，可能是想俘获女神/男神的芳心。总之，你是想成为一个更好的人。<strong>信念能让你你在养成好的习惯时获得精神上的正向反馈，同时，你的信念越强烈，就越能忍受改变过程中的痛苦与反复。</strong></p></blockquote><p>明白了这些，可以更好的帮你建立习惯，而关于如何建立习惯，有太多的技巧，诸如远离诱惑、分解目标、建立记录和反馈机制……多的能写出一本书（事实上有很多关于习惯的书了，后面我会推荐一本），我这里想说点心态上的东西，也是我在踩了无数坑后，用斑斑血泪换到的重要经验：</p><p><strong>六. 三点心态</strong></p><p><strong>1.接受自己是个普通人</strong></p><p>真的，大家都是普通人，承认这一点没啥可耻的。拿我最喜欢的肌肉模型举例子吧，我始终觉得，建立习惯也好，培养能力也好，都跟锻炼肌肉是一码事：你今天只能举30斤的哑铃，下周你最多举35斤，你不能说明天我就要举60斤。同样的，如果你之前从没去过健身房，不要指望刚开始一周能去三次，更科学的计划，是从一周去一次做起；如果你之前沉迷游戏，一周打七天，不要指望明天就能戒掉它，科学一点的目标，是下周只打六天。</p><p>承认自己一口气吃不成个胖子，敢于面对现实，也是成熟的标志之一，不是吗？《积极心理学》中的建议是：<strong>对于一般人，一个月能建立一到两个习惯就很不错了</strong>。不要太贪心，你真能做到，一年下来至少养成12个习惯，你能够爆掉大多数人了。</p><p>允许自己失败，允许自己休息，在此之上，我特别想强调的是：对自己少一些苛责，多一些鼓励。</p><p><strong>2.少一些苛责，多一些鼓励</strong></p><p>**我们从小到大接受的教育，太过于强调严格自律和自我批评，却很少教我们如何鼓励自己。**太多人放弃改变，是因为在反复的失败后，用批评和苛责扑灭了自己内心的火种。</p><p>我大学最堕落的两年，深受这种思想所害，最后让我走出来的，不止是不甘堕落，更是每次失败后，像对待朋友，有时甚至是像对待小孩子一样，鼓励自己，哄自己：“这周计划锻炼三次，只锻炼了一次？没事，也比不锻炼强吧，是不是计划不合理？下周试试两次吧！”“今天计划要学的又没学完，下午还刷了两个小时网页……没关系，比昨天好啦！昨天刷了大半天好嘛！”。</p><p>计划失败了，大多数人会羞愧，会痛苦，会责骂自己。<strong>但少有人去安慰自己，告诉自己“没关系，你是个普通人，你总会有脆弱的时候”；少有人像鼓励朋友一样鼓励自己，跟自己说“加油，还有机会，来！想一想下次怎么可以做得更好”。</strong></p><p><img src="https://img.mahaofei.com/img/202112231943683-self-control-8.png" alt=""></p><p>真的，在与欲望和弱点搏斗的过程中，我们大多数时候是没有队友的，你只有自己给自己打气。</p><p>嗯，有人担心过多的自我安慰会让自己松懈，所以我要强调的最后一点，是行动。</p><p><strong>3.行动起来，从现在开始</strong></p><p>**无论你苛责还是鼓励自己，最后引发改变的，是行动。**想做什么，现在就开始做吧，不要等到以后。在我的认知中，90%的“明天再说”等于“明天就忘” 。想看书的，今晚睡前就拿起来，哪怕只看一页；想锻炼的，今天就蹦跶起来，哪怕只是一组4分钟的燃脂训练；想学画画的，今天就画起来，哪怕就画一个水杯。</p><p><strong>只要你做了，无论多少，你都是在行动，都是改变，而如上一点所说：再微小的改变，都值得褒奖。</strong></p><p>就像虽然90%的人看了这篇回答，过两天还是会忘记。但我觉得吧，不要紧啦，大家都是普通人嘛，别苛责自己，至少这么长的文章，你都快看完了，对不对？你还是很棒哒！而且看了这篇文章本身，就是“从现在做起”的体现啊！</p><p>你看，学以致用嘛，我就是这么看得开 ╮(￣▽￣&quot;)╭</p><p>最后，送一句我爱极了的话给大家：</p><blockquote><p>Incremental change is better than ambitious failure.<br>逐步的改善好过雄心勃勃的失败。</p></blockquote><p><strong>End. 后记-为什么要写这篇文字</strong></p><p>**我曾是一个学渣，很渣很渣的那种：**我背着笔记本去图书馆，却刷了半天的网页，又看了半天的电影，晚上我把自己骂一顿，决定明天好好学习，结果第二天又故态复萌；我曾整天翘课打游戏，晚上通宵到早上7点，睡到中午1点，起来吃碗泡面，下午继续打，这样循环了一个多学期。我不是没有想过改变，但每一次下定决心后的热血，都持续不到三天，很快就会陷入计划失败-&gt; 自责 -&gt; 重新计划-&gt; 计划失败的恶性循环。</p><p>在相当长的一段时间里，我都以为自控力是限制自己进步的最大阻碍，我痛恨没有毅力的自己，觉得这辈子没啥出息了。直到后来，见了很多很多人，读了很多很多书，我才明白以前很多对于自控、习惯和效率的理解都是错的。在那以后，我慢慢摆脱了诸如自控失败、拖延症这类问题的困扰，变成了别人眼中的“学霸”；我找到了自己喜欢做的事情，每天过得忙碌而有意义。</p><p>而为了达到今天的状态，我走了太多太多的弯路，我也看到太多人，跟我掉进同样的坑里，想要爬出来，却因为力气用错了地方而徒劳无功。<strong>即使是寒假计划失败这样一件看上去很小的事，背后却隐藏着太多的学问</strong>，它们分散在不同的书与课程里，没有足够经历的人，难以一窥全貌，结果就是反复的掉进坑里，在爬坡的过程中耗尽了心力，最终放弃了自己。</p><p><strong>我常常想，如果当年有人告诉我正确的道理和方法，我的人生会不会顺遂很多？</strong></p><p>所以我啰啰嗦嗦的写这么多，哪怕只对一个读者有用，就不枉我花二十多个小时，去琢磨和修改这篇东西。</p><p>最后的最后，再送两段话给大家：</p><blockquote><p>“在生活的过程中，会有很多次机会，让你不得不面对自己身上的缺陷和弱点，事实会一次又一次提醒你，你是一个不完美的人，需要改变。可人的本性是懒惰又脆弱的，大部分人选择麻痹自己，转向短期的即时刺激（上网购物打游戏，暴食社交一夜情），少数人选择改变自己，于是就会有痛苦，有反复，有成功和放弃。”<br>“没有人生来完美，每一个趋近于优秀的人格，都是经过了多次自我改造的结果。没有试图去改变的人，继续重复着自己日复一日的生活，看着那些早已看过的烂熟于心的风景，而对于正在改变的人来说，每一天都是新的。”</p></blockquote><p>这两段话来自知友</p><p><a href="http://www.zhihu.com/people/20366583aa36670a6aab34635a37bcfd">@陈诺</a></p><p>，我稍有改动，基本没有曲解原意，推荐大家看看她的回答，很多答案对我帮助很大。</p><p><strong>在改变的路上没有捷径，只有不懈的坚持和科学的方法</strong>，祝你们每一天都和之前不一样，每一天都是新的，大家共勉。</p><p><strong>Ref.推荐阅读 &amp; 参考文献</strong></p><p>一篇回答无法解决所有的问题，希望能给大家一些启发。这篇回答的所有重要观点，几乎都来自于下面这些书和课程，推荐给大家：</p><ol><li><a href="https%3A//book.douban.com/subject/10786473/">自控力 (豆瓣)</a></li><li><a href="https%3A//book.douban.com/subject/20507212/">习惯的力量 (豆瓣)</a></li><li><a href="https://www.bilibili.com/video/BV1kx411S7ZU">哈佛大学公开课：幸福课</a></li></ol><p>另附一篇回答，为什么期望短期内获得大幅改变的想法不切实际而且有害：</p><ul><li><a href="https://www.zhihu.com/question/29147255/answer/152408781">人可能在短时间内各方面都得到大幅提高吗</a>？</li></ul><p><strong>真·后记（2016.3.18更新）</strong></p><p>这篇回答短时间内获得了大量的赞，这令我始料未及。我想强调一点，这篇文章的初衷，是给大家一些启发，让大家对习惯和自控有一些正确的认知。更全面科学的解答，我还是极力推荐大家学一学上面的书和课程。</p><p>此外，一夜顿悟从而扭转人生这样的事极少发生。<strong>真正的顿悟（例如王阳明龙场悟道）之所以能发生，源于之前长期的实践和思考，是量变的积累遇到了合适的契机，从而引发了质变。</strong></p><p>改变没有捷径，它是漫长的过程，它始于你的意愿，在正确的行动下得到积极的结果。《自控力》这本书很多人买了，有多少真的看完了？又有多少人长期对照自己的问题回去翻阅过三遍以上？又有多少人按它讲的方法去冥想、去运动、去观察记录自己的行为？《幸福课》也有很多人看过，又有多少人认真的做笔记，按课里的方法去设定目标、去挑战风险、去写感恩记录、去关注事物的积极面？</p><p><strong>懂得很多道理只是前提，决定你能不能过好这一生的，是你的选择和行动。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 好文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大疆RoboMaster技术总监：我是如何成为一名机器人工程师的</title>
      <link href="/post/d782e1e8.html"/>
      <url>/post/d782e1e8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者 | YY硕</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><p>来源：知乎</p></blockquote><h2 id="▌前言">▌前言</h2><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p><p>两年前，我在知乎回答<a href="https://www.zhihu.com/question/20435673/answer/29927998">如何定义「机器人」？</a>中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里<a href="https://www.zhihu.com/question/36653316/answer/85774195">对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？</a>我说到传感器是和物理世界交互的基础。后来，我又在知乎回答<a href="https://www.zhihu.com/question/45766810/answer/100301388">有哪些与控制、机器人等相关的 quotes？</a>中提到莫拉维克悖论（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Moravec%27s_paradox">Moravec’s paradox</a>），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p><p>把之前的回答再翻出来是为了支持以下观点：<strong>机器人学的核心问题是做好和物理世界的交互</strong>。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：<strong>传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动</strong>（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p><p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的<a href="https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf">课程分类方式</a>，机器人学有四个核心领域：</p><ol><li>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。</li><li>认知。人工智能、知识表达、规划、任务调度、机器学习等。</li><li>行为。运动学、动力学、控制、manipulation和locomotion等。</li><li>数学基础。最优估计、微分几何、计算几何、运筹学等。</li></ol><p>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p><p>一些可能有争议性的观点：</p><ol><li><p>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</p></li><li><p>机器人学是屠龙之术。这话是 Ninebot 创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</p></li><li><p>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</p></li></ol><p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p><p><strong>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。</strong></p><p>按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间 6-8 个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p><p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p><p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p><h2 id="▌大一">▌大一</h2><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的 VPN，先确保自己能上 Google，不要心疼 VPN 的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail 账号，再注册 stackoverflow 账号，再注册 github 的账号，再注册CSDN 账号，注册完登录上去逛逛，暂时先不要问为什么。</p><p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p><p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。<strong>一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数</strong>，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p><p>网上有很多对于如何学好线性代数的讨论，比如知乎问题<a href="https://www.zhihu.com/question/20534668">如何理解线性代数？ - 数学学习</a>。Matrix67大神的文章<a href="https://link.zhihu.com/?target=http%3A//www.matrix67.com/blog/archives/4294">随记：我们需要怎样的数学教育？</a>也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做<a href="https://www.math.brown.edu/~treil/papers/LADW/book.pdf">《Linear Algebra Done Wrong》</a>，我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是<a href="https://link.zhihu.com/?target=http%3A//open.163.com/special/opencourse/daishu.html">麻省理工公开课：线性代数</a>。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p><p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p><p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是<a href="https://link.zhihu.com/?target=http%3A//open.163.com/special/opencourse/bianchengdaolun.html">麻省理工学院公开课：计算机科学及编程导论</a>，比较好的Python开发学习环境是<a href="%5Bhttp://www.continuum.io/downloads%5D(https://link.zhihu.com/?target=http%3A//www.continuum.io/downloads)">Anacoda</a>。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</p><p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p><p>学习C我个人入门用的是清华大学出版的《<a href="https://link.zhihu.com/?target=http%3A//product.dangdang.com/8880276.html">C++语言程序设计</a>》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="https://link.zhihu.com/?target=http%3A//songjinshan.com/akabook/zh/index.html">http://songjinshan.com/akabook/zh/index.html</a>，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</p><p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（<a href="https://link.zhihu.com/?target=http%3A//www.ubuntu.com/global">The leading OS for PC, tablet, phone and cloud</a>）。原因是机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http%3A//www.ros.org/">ROS.org | Powering the world’s robots</a>）是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p><p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（<a href="https://link.zhihu.com/?target=http%3A//tieba.baidu.com/p/591519800">Makefile详解（超级好）_mingw吧</a>）这篇文章看。</p><p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。</p><p>再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http%3A//www.ros.org/">ROS.org | Powering the world’s robots</a>）里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。</p><p>更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="https://link.zhihu.com/?target=http%3A//www.w3schools.com/">http://www.w3schools.com/</a>，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上<a href="https://link.zhihu.com/?target=http%3A//threejs.org/examples/">three.js / examples</a>跪着看看热闹。</p><p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[<a href="https://link.zhihu.com/?target=https%3A//www.douban.com/group/topic/11115261/">转]MIT牛人解说数学体系</a>，另一个是前Goolge研究员吴军博士写的《数学之美》（<a href="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/10750155/">数学之美 (豆瓣)</a>）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p><h2 id="▌大二">▌大二</h2><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p><p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答<a href="https://www.zhihu.com/question/34670420/answer/59676472">如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？</a>里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p><p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p><p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p><p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p><p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p><p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p><p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买<a href="https://link.zhihu.com/?target=http%3A//www.makeblock.com/">Arduino STEM educational Robot kits Building Platform</a>的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛<a href="https://link.zhihu.com/?target=http%3A//www.amobbs.com/forum-3020-1.html">STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)</a>上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p><p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加 RoboMasters。</p><p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p><p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p><p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如 6 条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p><p>另外你其他方面的能力也不能落下。大二结束的时候，你的 Linux 应该用的很熟练了，除了 makefile，你也用起了 cmake。你也应该开始理解 Github 存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了 Github 上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p><p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用 Java 或 C++ 教授。在面向对象的程序课里面，一定要积累 3000 行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p><p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（<a href="https://www.zhihu.com/question/27834147">Mathematica 到底有多厉害？ - Wolfram Mathematica</a>），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="https://link.zhihu.com/?target=http%3A//ctms.engin.umich.edu/CTMS/index.php%3Fexample%3DIntroduction%26section%3DSimulinkControl">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl</a>），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（<a href="https://link.zhihu.com/?target=http%3A//www.mathworks.com/help/control/examples/control-of-an-inverted-pendulum-on-a-cart.html">Control of an Inverted Pendulum on a Cart</a>）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p><p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p><h2 id="▌大三">▌大三</h2><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p><p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p><p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（<a href="https://link.zhihu.com/?target=http%3A//opencv.org/">OpenCV | OpenCV</a>）了。</p><p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 <a href="https://www.zhihu.com/people/liu-top">@Liu Top</a>的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p><p><strong>第一步：自己调一个小四轴飞起来</strong></p><p>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 <a href="https://link.zhihu.com/?target=https%3A//chiplab7.taobao.com/">首页-第七实验室</a> 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p><p><strong>第二步：看硬件图、读代码</strong></p><p>chiplab7 的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7 淘宝掌柜的又很认真负责，我学用的时候，发现代码有 bug 和看不懂的地方，都可以直接找掌柜问。</p><p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7 的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环 PID 控制，基本都是基础的基础了。</p><p><strong>第三步：小修小改加深理解</strong></p><p>chiplab7 的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个 20 块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p><p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解 PID 控制的方式，而且 chiplab7 的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p><p><strong>第四步：理解核心的数学和控制知识</strong></p><p>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。</p><p>姿态解算和控制解算涉及的知识有：</p><ol><li><p>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。</p><p>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</p></li><li><p>自动控制原理。讲 PID 的书和文章就多了去了，没有太多复杂的书。</p></li><li><p>线性估计基本原理。其实就是互补滤波：<a href="https://link.zhihu.com/?target=http%3A//www.pieter-jan.com/node/11">Reading a IMU Without Kalman: The Complementary Filter</a> 。拿这个关键词百度各种搜就会了。</p></li></ol><p><strong>第五步：重头开始造轮子</strong></p><p>知乎著名网友 vczh 曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读 STM32 的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做 PCB layout、制板自己焊元件，全套花不了 1000 块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</p><p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters 机器人的变形。</p><p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：<a href="https://www.zhihu.com/question/46824735/answer/115202408?from=profile_answer_card">做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答</a>，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p><p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p><p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32 上，有 freeRTOS，uCOS，Vxworks 这么几种实时操作系统；Linux 是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上 Google 和 CSDN 去查大神们的介绍。</p><p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式 Linux 平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式 Linux 系统在里面，一定要尽早顶起来路由器，代码定时提交 SVN 或者 git。</p><p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆 RoboMasters 比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p><p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p><p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p><p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p><p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="https://link.zhihu.com/?target=http%3A//www.topologywithouttears.net/">http://www.topologywithouttears.net/</a>），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</p><p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明&quot;det(AB) = det(A)det(B)&quot;，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p><h2 id="▌大四">▌大四</h2><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p><p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p><ol><li><p>概率机器人学，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></p></li><li><p>凸优化，<a href="https://link.zhihu.com/?target=https%3A//web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</a></p></li><li><p>线性系统理论，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></p></li><li><p>Multiple View Geometry in Computer Vision，<a href="https://link.zhihu.com/?target=http%3A//www.robots.ox.ac.uk/~vgg/hzbook/">Multiple View Geometry in Computer Vision</a></p></li><li><p>线性估计，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></p></li><li><p>《机器学习》，周志华老师的书。</p></li><li><p>An Invitation to 3-D Vision，<a href="https://link.zhihu.com/?target=https%3A//www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf">https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf</a></p></li><li><p>Modern Control Systems，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></p></li><li><p>Rigid Body Dynamics，<a href="https://link.zhihu.com/?target=http%3A//authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf</a>。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</p></li><li><p>Feedback Systems: An Introduction for Scientists and Engineers，<a href="https://link.zhihu.com/?target=http%3A//www.cds.caltech.edu/~murray/amwiki/index.php/Main_Page">FBSwiki</a></p></li></ol><p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p><p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p><p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答<a href="https://www.zhihu.com/question/21958225/answer/20255931">高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答</a>里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p><p>ROS 的可视化工具 Rviz 里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p><p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p><p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐<a href="https://link.zhihu.com/?target=https%3A//inkscape.org/en/">Draw Freely | Inkscape</a>，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p><p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己 Github 链接（如果你按我说的，大学第一天就申请 Github 账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p><p>关于毕业设计的选题，我推荐这么几个：</p><ol><li>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</li><li>手写四旋翼飞行器基于 GPS 的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU 原理、轨迹生成和优化等。</li><li>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID 控制、IMU 原理等。</li><li>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</li><li>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</li></ol><p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D 打印结构，大四要多给自己留时间去看书和写代码。</p><p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p><h2 id="▌研究生一年级">▌研究生一年级</h2><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。、</p><p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p><p>如果做控制系统的研究，3、8、9、10一定要精读。</p><p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p><p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书<a href="https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">Stochastic models estimation and control</a>。</p><p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（<a href="https://link.zhihu.com/?target=http%3A//www.robots.ox.ac.uk/~gk/PTAM/">Parallel Tracking and Mapping for Small AR Workspaces (PTAM)</a>），ROS的标配VO（<a href="https://link.zhihu.com/?target=http%3A//wiki.ros.org/viso2_ros">viso2_ros - ROS Wiki</a>），SVO（<a href="https://link.zhihu.com/?target=https%3A//github.com/uzh-rpg/rpg_svo">GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry</a>），LSD-SLAM（<a href="https://link.zhihu.com/?target=http%3A//vision.in.tum.de/research/vslam/lsdslam">http://vision.in.tum.de/research/vslam/lsdslam</a>）ORB-SLAM（<a href="https://link.zhihu.com/?target=https%3A//github.com/raulmur/ORB_SLAM2">GitHub - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities</a>），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/gaoxiang12/tag/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人 - 标签</a>。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://link.zhihu.com/?target=https%3A//github.com/hcdth011/ROS-Hydro-SLAM">https://github.com/hcdth011/ROS-Hydro-SLAM</a>，就在ROS上实现了几种定位算法的对比。</p><p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p><p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答<a href="https://www.zhihu.com/question/31586826/answer/65274168">RoboMasters2015夏令营是怎样的？</a>里吹过一波M100，前面说过的今年夏令营的知乎回答<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>里也有人帮我吹了一波。</p><p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p><p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。</p><p>上面提到的《Convex Optimization》<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf%EF%BC%8C%E4%B9%9F%E6%98%AF%E4%B8%80%E6%9C%AC%E7%A5%9E%E4%B9%A6%EF%BC%8C%E5%90%8C%E5%AD%A6%E4%BB%AC%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%A4%E7%9C%9F%E8%AF%BB%E4%B8%80%E8%AF%BB%E3%80%82">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。</a></p><p>Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p><p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书<a href="https://link.zhihu.com/?target=https%3A//www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">Stochastic models estimation and control</a>也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</p><p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包<a href="https://link.zhihu.com/?target=http%3A//moveit.ros.org/">MoveIt! Motion Planning Framework</a>，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters">Denavit</a>），这个东西我并不太会。我只会向同学们推荐我导师的著作<a href="http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">《A mathematical introduction to robotic manipulation》</a></p><p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p><p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章<a href="%5Bhttp://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf%5D(https://link.zhihu.com/?target=http%3A//www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf)">An elementary introduction to groups and representations的前50页</a>。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</p><p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。</p><p>当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p><h2 id="▌研究生二年级">▌研究生二年级</h2><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p><p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p><p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p><p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p><p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="https://link.zhihu.com/?target=http%3A//www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html</a>，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。</p><p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（<a href="https://link.zhihu.com/?target=http%3A//news.berkeley.edu/2015/05/21/deep-learning-robot-masters-skills-via-trial-and-error/">New ‘deep learning’ technique enables robot mastery of skills via trial and error</a>），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神<a href="https://www.zhihu.com/people/70bcce80353eccd2938cbfa2ac856aab">@戴泓楷</a><a href="https://www.zhihu.com/people/0eeca981bb238839881694643181fa91">@周佳骥</a>。</p><p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成 PPT 讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p><p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p><h2 id="▌结束语">▌结束语</h2><p>我从 2008 年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python 还是很小众的语言，Ubuntu 8.04 还很不稳定，Chrome 还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了 ROS 的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p><blockquote><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><p>如有侵权，请邮件联系：<a href="haofei_ma@163.com">haofei_ma@163.com</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 好文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS系统基本功能的使用详解（基本指令/节点/服务/启动文件/动态参数）</title>
      <link href="/post/9187e22b.html"/>
      <url>/post/9187e22b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建工作空间">一、创建工作空间</h2><p><strong>1. 新建文件夹</strong><br>新建一个<code>catkin_ws</code>的文件夹，并在里面创建<code>src</code>子目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/dev/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure><p><strong>2. 初始化工作空间</strong><br>在刚创建的src子目录中，使用如下命令创建工作空间，但此时工作空间中还没有任何功能包，只有CMakeLists.txt。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p><strong>3. 编译工作空间</strong><br>回到工作空间的顶层目录<code>catkin_ws</code>文件夹中，使用<code>catkin_make</code>命令执行编译。编译完成后使用<code>ll</code>指令可以看到生成了<code>build</code>和<code>devel</code>两个文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p><strong>4. 完成配置</strong><br>重新加载<code>setup.bash</code>文件，完成工作空间创建的最后一步配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><p>其实如果你在<code>~/.bashrc</code>中加入了此命令行，就可以通过重启终端得到同样的效果，添加命令如下，其中<code>noetic</code>是我的ros系统的版本号，如果你的版本不同，务必更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="二、创建与编译ROS功能包">二、创建与编译ROS功能包</h2><p><strong>1. 创建功能包</strong><br>功能包可以通过手动方式创建，但为了方便，通常会使用<code>catkin_create_pkg</code>命令创建功能包，此命令的格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg [package_name] [depend1] [depend2] [depend3]</span><br></pre></td></tr></table></figure><p>其中的depend依赖项包括：</p><ul><li><code>std_msgs</code>：包含常见的消息类型，表示基本数据类型和其他基本的消息构造。</li><li><code>roscpp</code>：使用C++编写ROS的各种功能。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="built_in">cd</span> ~dev/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_package std_msgs roscpp</span><br></pre></td></tr></table></figure><p><strong>2. 编译功能包</strong><br>回到<code>catkin_ws</code>文件夹下执行编译操作，如果没有报错，则说明功能包编译成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h2 id="三、ROS的基本命令">三、ROS的基本命令</h2><h3 id="3-1-节点">3.1 节点</h3><p><strong>1. rosnode指令</strong><br>rosnode工具可以打印ROS节点的相关信息，具体命令如下：</p><table><thead><tr><th>rosnode指令</th><th>作用</th><th></th></tr></thead><tbody><tr><td><code>rosnode ping NODE</code></td><td>测试节点的连通性</td><td></td></tr><tr><td><code>rosnode list</code></td><td>列出活动节点</td><td></td></tr><tr><td><code>rosnode info NODE</code></td><td>输出此节点的信息</td><td></td></tr><tr><td><code>rosnode machine</code></td><td>打印运行在特定计算机中的节点</td><td></td></tr><tr><td><code>rosnode kill NODE</code></td><td>结束节点进程</td><td></td></tr><tr><td><code>rosnode cleanup</code></td><td>将无法访问的节点的注册信息清除</td><td></td></tr></tbody></table><p><strong>2. 运行节点</strong><br>首先使用<code>roscore</code>指令启动ros程序，然后再打开一个新的终端窗口执行接下来的操作。</p><p>我们可以使用<code>rosrun</code>指令运行一个节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>节点成功运行后再次使用<code>rosnode list</code>可以看到正在运行的节点，使用<code>rosnode info /turtlesim</code>可以查看此节点的详细信息，包括发布（Publications）、订阅（Subscriptions）以及节点具有的服务（Services）等。</p><h3 id="3-2-主题">3.2 主题</h3><p><strong>1. rostopic指令</strong><br>节点可以通过发布主题和订阅主题实现数据的传输，通过主题的消息传输不需要节点直接连接，一个主题可以有多个订阅者和多个发布者。要实现主题与节点之间的交互，可以使用rostopic指令。</p><table><thead><tr><th>rostopic指令</th><th>作用</th></tr></thead><tbody><tr><td><code>rostopic bw TOPIC</code></td><td>显示主题所用的带宽</td></tr><tr><td><code>rostopic echo TOPIC</code></td><td>将主题的消息输出到屏幕</td></tr><tr><td><code>rostopic find TOPIC</code></td><td>查找主题</td></tr><tr><td><code>rostopic hz TOPIC</code></td><td>显示主题发布频率</td></tr><tr><td><code>rostopic info TOPIC</code></td><td>输出主题详细信息</td></tr><tr><td><code>rostopic list TOPIC</code></td><td>列出活动主题</td></tr><tr><td><code>rostopic pubs TOPIC</code></td><td>将数据发布到主题</td></tr><tr><td><code>rostopic type TOPIC</code></td><td>输出主题的类型</td></tr></tbody></table><p><strong>2. 发布主题</strong><br>可以通过<code>rostopic list</code>列出当前节点的主题。通过echo参数可以打印节点发出的消息，如：<code>rostopic echo /turtle1/cmd_vel</code>。</p><p>此外，我们也可以直接通过<code>rostopic pub</code>发布主题，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;&#123;linear: &#123;x: 1, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 1&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231935919-ros-basic-1.png" alt=""></p><h3 id="3-3-服务">3.3 服务</h3><p><strong>1. rosservice指令</strong><br>服务是节点之间相互通信的另一种方法，服务允许节点发送请求和接受响应。可以使用rosservice指令操作服务。</p><ul><li><code>roservice args /service</code>：输出服务参数</li><li><code>rosservice call /service</code>：根据命令行参数调用服务</li><li><code>rosservice find msgtype</code>：根据服务类型查询服务</li><li><code>rosservice info /service</code>：输出服务信息</li><li><code>rosservice list</code>：列出活动服务清单</li><li><code>rosservice type /service</code>：输出服务类型</li><li><code>rosservice uri /service</code>：输出ROSRPC URI服务</li></ul><p><strong>2. 服务的使用</strong><br>使用<code>rosservice list</code>可以列出所有的服务，使用<code>rosservice call [service] [args]</code>可以调用某个服务，例如<code>rosservice call /clear</code>可以清除海龟图上的线条。</p><p>此外，使用<code>rossrv show turtlesim/Spawn</code>可以查看/spawn服务的详细参数。</p><p><img src="https://img.mahaofei.com/img/202112231935033-ros-basic-2.png" alt=""></p><p>通过这些参数就可以调用/spawn服务创建第二只海龟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn 3 3 0.5 <span class="string">&quot;new_turtle&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231936813-ros-basic-3.png" alt=""></p><h3 id="3-4-参数服务器">3.4 参数服务器</h3><p><strong>1. rosparam指令</strong><br>参数服务器存储了所有节点都可以访问的共享数据，可以通过rosparam指令管理参数服务器。</p><table><thead><tr><th>rosparam指令</th><th>作用</th></tr></thead><tbody><tr><td><code>rosparam set parameter value</code></td><td>设置参数值</td></tr><tr><td><code>rosparam get parameter</code></td><td>获取参数值</td></tr><tr><td><code>rosparam load file</code></td><td>从文件加载参数</td></tr><tr><td><code>rosparam dump file</code></td><td>将参数保存至文件</td></tr><tr><td><code>rosparam delete parameter</code></td><td>删除参数</td></tr><tr><td><code>rosparam list</code></td><td>列出所有参数名</td></tr></tbody></table><p><strong>2. 使用参数服务器</strong><br>以小海龟程序为例，通过rosparam list列出参数列表，可以看到背景background是turtlesim节点的参数，因此我们可以通过get指令获取参数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br><span class="line">rosparam get /turtlesim/background_g</span><br><span class="line">rosparam <span class="built_in">set</span> /turtlesim/background_g 200</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231936964-ros-basic-4.png" alt=""></p><h2 id="四、节点的创建与运行">四、节点的创建与运行</h2><p>这一部分会以一个具体实验为例，通过创建一个talker和一个listener并实现两者之间的信息交流，进而介绍创建节点的方法。</p><h3 id="4-1-创建源文件">4.1 创建源文件</h3><p>首先进入工作空间<code>~/dev/catkin_ws</code>文件夹中的功能包<code>test_package/src/</code>文件夹中，在这里创建两个cpp文件，分别作为消息的发送方和接收方。在这里我讲两个源文件分别命名<code>talker.cpp</code>和<code>listener.cpp</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//talker.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span><span class="comment">//包含ros节点的必要文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span><span class="comment">//包含要使用的消息类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);<span class="comment">//启动节点并设置名称</span></span><br><span class="line">        ros::NodeHandle n;<span class="comment">//设置节点进程的句柄</span></span><br><span class="line">        ros::Publisher chatter_pub = n.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;message&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//将节点设置成发布者，并设置主题名称为message，缓冲区1000个消息</span></span><br><span class="line">        <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//数据发送频率10HZ</span></span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">                std_msgs::String msg;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; <span class="string">&quot;I&#x27;m talker node~~~&quot;</span>;</span><br><span class="line">                msg.data = ss.<span class="built_in">str</span>();<span class="comment">//创建了一个消息变量</span></span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());<span class="comment">//屏幕输出消息信息</span></span><br><span class="line">                chatter_pub.<span class="built_in">publish</span>(msg);<span class="comment">//发布消息</span></span><br><span class="line">                ros::<span class="built_in">spinOnce</span>();<span class="comment">//如果有订阅者出现，就会更新所有主题</span></span><br><span class="line">                loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listener.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，节点每收到一条消息都会调用此函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">messageCallback</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I am listener, I heard: [%s]&quot;</span>,msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;message&quot;</span>, <span class="number">1000</span>, messageCallback);</span><br><span class="line">        <span class="comment">//创建一个订阅者，从message主题获取消息，设置缓冲区1000个消息，处理消息的回调函数为messageCallback</span></span><br><span class="line">        ros::<span class="built_in">spin</span>();<span class="comment">//消息回调处理，调用后不再返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-修改CMakeLists-txt">4.2 修改CMakeLists.txt</h3><p>编辑<code>catkin_ws/src/test_package/</code>中的CMakeLists.txt，在最后加入如下的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include_directories(</span><br><span class="line">        include</span><br><span class="line">        $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 指定编译后可执行文件的名称</span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line"># 定义目标的依赖文件</span><br><span class="line">add_dependencies(talker test_package_generate_messages_cpp)</span><br><span class="line">add_dependencies(listener test_package_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-编译节点">4.3 编译节点</h3><p>回到工作空间根目录进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>如果出现<code>The dependency target does not exist.</code>的错误，将CMakeLists.txt开头的cmake版本改为2.8.3即可。</p><p>编译完成后需要设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/ros/tr3_6/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="4-4-运行节点">4.4 运行节点</h3><p>然后开始运行节点，首先运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>然后再打开两个窗口分别运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_package example1_a</span><br><span class="line">rosrun test_package example1_b</span><br></pre></td></tr></table></figure><p>可以看到消息的接受和发送。</p><p><img src="https://img.mahaofei.com/img/202112231936146-ros-basic-5.png" alt=""></p><h2 id="五、服务的创建与使用">五、服务的创建与使用</h2><p>本节将创建两个节点，分别作为服务器和客户端，通过服务的调用实现两个节点的数据传输，并实现数字求和的功能。</p><h3 id="5-1-创建msg文件">5.1 创建msg文件</h3><p>使用服务之前，首先需要创建msg和srv文件，它们用于说明传输的数据类型和数据值。<br><strong>1. 首先创建msg文件</strong><br>在<code>test_package</code>功能包下创建<code>msg</code>文件夹，并在<code>msg</code>文件夹中创建一个新的文件<code>test_msg.msg</code>。在文件中输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">int32 num3</span><br></pre></td></tr></table></figure><p><strong>2. 编辑package.xml文件</strong><br>在<code>package.xml</code>文件中找到下面两行，取消这两行的注释<code>&lt;!-- --&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 编辑CMakeLists.txt文件</strong><br>打开功能包目录下的<code>CMakeLists.txt</code>文件。</p><p>找到<code>find_package()</code>，在其中加入<code>message_generation</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>找到如下的两段，取消注释，并将刚才创建的<code>test_message.msg</code>消息名称加入其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Generate messages in the <span class="string">&#x27;msg&#x27;</span> folder</span><br><span class="line"><span class="title function_">add_message_files</span><span class="params">(</span></span><br><span class="line"><span class="params">  FILES</span></span><br><span class="line"><span class="params">  test_msg.msg</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Generate added messages and services with any dependencies listed here</span><br><span class="line"><span class="title function_">generate_messages</span><span class="params">(</span></span><br><span class="line"><span class="params">  DEPENDENCIES</span></span><br><span class="line"><span class="params">  std_msgs</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p><strong>4. 编译测试</strong><br>进行完以上的步骤后，使用下面的命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译完成后，要检查刚才创建的msg文件是否成功编译，使用<code>rosmsg show</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg show test_package/test_msg</span><br></pre></td></tr></table></figure><p>如果输出内容与<code>test_msg.msg</code>文件内的内容一致，说明编译正确。</p><h3 id="5-2-创建srv文件">5.2 创建srv文件</h3><p><strong>1. 创建srv文件</strong><br>在<code>test_package</code>功能包下创建<code>srv</code>文件夹，并在<code>srv</code>文件夹中创建一个新的文件<code>test_srv.srv</code>。在文件中输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">int32 num3</span><br><span class="line">---</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure><p><strong>2. 编辑package.xml文件</strong><br>在创建msg文件时已经完成了package.xml文件的编辑，这里不需要额外的修改。</p><p><strong>3. 编辑CMakeLists.txt</strong><br>找到<code>catkin_package</code>，将其注释取消，并加入正确的数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES test_package</span><br><span class="line">#  CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">  CATKIN_DEPENDS message_runtime</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>取消<code>add_service_files</code>的注释，并添加刚创建的服务文件的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Generate services in the <span class="string">&#x27;srv&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">add_service_files</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  FILES</span></span></span><br><span class="line"><span class="params"><span class="function">  test_srv.srv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p><strong>4. 编译测试</strong><br>完成上面的文件创建和修改后，使用下面的命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译完成后，要检测服务文件编译是否正确，可以使用<code>rossrv show</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rossrv show test_package/test_srv.srv</span><br></pre></td></tr></table></figure><p>如果打印内容与<code>test_srv.srv</code>文件内的内容一致，说明编译正确。</p><h3 id="5-3-创建-cpp源文件">5.3 创建.cpp源文件</h3><p><strong>1. 创建源文件</strong><br>在功能包文件夹中的src目录下<code>catkin_ws/test_package/src</code>，创建两个<code>.cpp</code>文件，分别为<code>server.cpp</code>和<code>client.cpp</code>，分别作为服务器和客户端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test_package/test_srv.h&quot;</span><span class="comment">//包含创建的srv文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对三个变量求和，并将计算结果发送给其他节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(test_package::test_srv::Request &amp;req, test_package::test_srv::Response &amp;res)</span></span>&#123;</span><br><span class="line">        res.sum = req.num1 + req.num2 + req.num3;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;request: num1=%ld, num2=%ld, num3=%ld&quot;</span>, (<span class="type">int</span>)req.num1, (<span class="type">int</span>)req.num2, (<span class="type">int</span>)req.num3);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">int</span>)res.sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_3_ints_server&quot;</span>);</span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        <span class="comment">//创建服务&quot;add_3_ints&quot;的服务端，并在ROS中广播</span></span><br><span class="line">        ros::ServiceServer service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;add_3_ints&quot;</span>, add);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to add 3 ints!&quot;</span>);</span><br><span class="line">        ros::<span class="built_in">spin</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test_package/test_srv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_3_ints_client&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;usage: add_3_ints_client num1 num2 num3&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        <span class="comment">//以&quot;add_3_ints&quot;为名称创建客户端</span></span><br><span class="line">        ros::ServiceClient client = n.<span class="built_in">serviceClient</span>&lt;test_package::test_srv&gt;(<span class="string">&quot;add_3_ints&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建srv文件的一个实例，并在其中加入需要发送的数据值</span></span><br><span class="line">        test_package::test_srv srv;</span><br><span class="line">        srv.request.num1 = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        srv.request.num2 = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line">        srv.request.num3 = <span class="built_in">atoll</span>(argv[<span class="number">3</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用服务并发送数据，如果调用成功，服务端会返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(client.<span class="built_in">call</span>(srv))&#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sum: %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)srv.response.sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service add_3_ints&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>2. 编辑CMakeLists.txt</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(server src/server.cpp)</span><br><span class="line">add_executable(client src/client.cpp)</span><br><span class="line"></span><br><span class="line">add_dependencies(server test_package_generate_messages_cpp)</span><br><span class="line">add_dependencies(client test_package_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-测试程序">5.4 测试程序</h3><p>回到<code>catkin_ws</code>工作空间中，进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译完成后，先打开一个终端，运行<code>roscore</code>，然后再打开两个新终端窗口，分别运行如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_package server</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_package client 6 4 2</span><br></pre></td></tr></table></figure><p>可以看到服务端和客户端实现了消息的通信，完成了三个数字的求和计算。</p><p><img src="https://img.mahaofei.com/img/202112231937487-ros-basic-6.png" alt=""></p><h2 id="六、启动文件的配置">六、启动文件的配置</h2><p>在前面，我们已经实现了节点的创建和使用，但是每个节点都需要打开不同的命令行窗口执行，如果节点数目更多，那么启动节点将会是一件非常麻烦的事情。</p><p>通过启动文件我们可以在命令行窗口实现启动多个节点，只需要运行后缀名为<code>.launch</code>的文件即可启动多个节点。</p><h3 id="6-1-创建-launch文件">6.1 创建.launch文件</h3><p>首先在功能包内创建一个名为<code>launch</code>的文件夹，并在其中创建<code>test.launch</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line"><span class="built_in">mkdir</span> launch</span><br><span class="line"><span class="built_in">cd</span> launch</span><br><span class="line">vim test.launch</span><br></pre></td></tr></table></figure><p>在<code>test.launch</code>文件内输入如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;test_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;test_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-启动节点">6.2 启动节点</h3><p>上面编写的启动文件可以启动前文实验的<code>talker</code>和<code>listener</code>两个节点，启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch test_package test.launch</span><br></pre></td></tr></table></figure><p>系统会输出以下信息，说明启动成功。</p><p><img src="https://img.mahaofei.com/img/202112231937973-ros-basic-7.png" alt=""></p><p>使用<code>rosnode list</code>可以列出活动的节点，可以看到我们已经成功启动了<code>talker</code>和<code>listener</code>两个节点。</p><p><img src="https://img.mahaofei.com/img/202112231938050-ros-basic-8.png" alt=""></p><p>如果想看到两个节点传递的信息，可以使用<code>rqt_console</code></p><p><img src="https://img.mahaofei.com/img/202112231938582-ros-basic-9.png" alt=""></p><h2 id="七、动态参数的使用">七、动态参数的使用</h2><p>一般情况下，我们编写一个节点时，只能以数据初始化节点内的变量，如果我们想要改变这些变量值，可以使用主题，服务或参数服务器，但这种方式无法在线动态更新，如果listener不主动查询，我们无法知道参数是否更新。有时我们需要在线动态更新参数，这时就需要使用动态参数。</p><h3 id="7-1-创建配置文件">7.1 创建配置文件</h3><p>首先在功能包内新建一个名为<code>cfg</code>的文件夹，并在其内创建一个<code>test.cfg</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line"><span class="built_in">mkdir</span> cfg</span><br><span class="line"><span class="built_in">cd</span> cfg</span><br><span class="line">vim test.cfg</span><br></pre></td></tr></table></figure><p>在<code>test.cfg</code>内添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化ROS并导入参数生成器</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">PACKAGE = <span class="string">&quot;test_package&quot;</span></span><br><span class="line"><span class="keyword">from</span> dynamic_reconfigure.parameter_generator_catkin <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数生成器，通过gen我们可以添加参数</span></span><br><span class="line">gen = ParameterGenerator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入不同的参数类型并设置默认值、描述、取值范围等</span></span><br><span class="line"><span class="comment"># gen.add(name, type, level, description, default, min, max)</span></span><br><span class="line">gen.add(<span class="string">&quot;double_param&quot;</span>, double_t, <span class="number">0</span>, <span class="string">&quot;A double parameter&quot;</span>, <span class="number">.1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">gen.add(<span class="string">&quot;str_param&quot;</span>, str_t, <span class="number">0</span>, <span class="string">&quot;A string parameter&quot;</span>, <span class="string">&quot;test_default_string&quot;</span>)</span><br><span class="line">gen.add(<span class="string">&quot;int_param&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;An Integer parameter&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">gen.add(<span class="string">&quot;bool_param&quot;</span>, bool_t, <span class="number">0</span>, <span class="string">&quot;A Boolean parameter&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">size_enum = gen.enum([gen.const(<span class="string">&quot;Low&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;Low is 0&quot;</span>), gen.const(<span class="string">&quot;Medium&quot;</span>, int_t, <span class="number">1</span>, <span class="string">&quot;Medium is 1&quot;</span>), gen.const(<span class="string">&quot;High&quot;</span>, int_t, <span class="number">2</span>, <span class="string">&quot;High is 2&quot;</span>), gen.const(<span class="string">&quot;Exlarge&quot;</span>, int_t, <span class="number">3</span>, <span class="string">&quot;Exlarge is 3&quot;</span>)], <span class="string">&quot;Select from the list&quot;</span>)</span><br><span class="line"></span><br><span class="line">gen.add(<span class="string">&quot;size&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;Select from the list&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, edit_method=size_enum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成必要的文件并退出程序</span></span><br><span class="line">exit(gen.generate(PACKAGE, <span class="string">&quot;test_package&quot;</span>, <span class="string">&quot;test_&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>test.cfg</code>是由ROS执行的可执行文件，因此我们需要改变文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x test.cfg</span><br></pre></td></tr></table></figure><h3 id="7-2-修改CMakeLists-txt添加配置文件的编译">7.2 修改CMakeLists.txt添加配置文件的编译</h3><p>打开<code>CMakeLists.txt</code>，找到<code>find_package</code>，在最后加入<code>dynamic_reconfigure</code>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">  dynamic_reconfigure</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>找到<code>generate_dynamic_reconfigure_options</code>，取消注释，并将内部的配置文件改为刚创建的配置文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## Generate dynamic reconfigure parameters in the <span class="string">&#x27;cfg&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">generate_dynamic_reconfigure_options</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  cfg/test.cfg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><h3 id="7-3-创建节点">7.3 创建节点</h3><p>接下来需要创建一个具有动态配置支持的新节点。</p><p>在<code>src</code>文件夹下创建一个新文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line">vim src/dynamic_param.cpp</span><br></pre></td></tr></table></figure><p>在文件中写入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dynamic_reconfigure/server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;test_package/test_Config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数将输出参数的新值，参数名称必须与test.cfg配置文件相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(test_package::test_Config &amp;config, <span class="type">uint32_t</span> level)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Reconfigure Request: %d %f %s %s %d&quot;</span>, config.int_param, config.double_param, config.str_param.<span class="built_in">c_str</span>(), config.bool_param?<span class="string">&quot;True&quot;</span>:<span class="string">&quot;False&quot;</span>, config.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_dynamic_reconfigure&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化服务器</span></span><br><span class="line">        dynamic_reconfigure::Server&lt;test_package::test_Config&gt; server;</span><br><span class="line"><span class="comment">//向服务器发送回调函数，当服务器得到重新配置请求，会调用回调函数        </span></span><br><span class="line">        dynamic_reconfigure::Server&lt;test_package::test_Config&gt;::CallbackType f;</span><br><span class="line">        f = boost::<span class="built_in">bind</span>(&amp;callback, _1, _2);</span><br><span class="line">        server.<span class="built_in">setCallback</span>(f);</span><br><span class="line"></span><br><span class="line">        ros::<span class="built_in">spin</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="7-4-修改CMakeLists-txt添加节点的编译">7.4 修改CMakeLists.txt添加节点的编译</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(dynamic_param src/dynamic_param.cpp)</span><br><span class="line"><span class="built_in">add_dependencies</span>(dynamic_param test_package_gencfg)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(dynamic_param $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-5-运行配置">7.5 运行配置</h3><p>打开三个终端命令行窗口，分别运行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun test_package dynamic_param</span><br><span class="line">rosrun rqt_reconfigure rqt_reconfigure</span><br></pre></td></tr></table></figure><p>执行完成后，会看到一个<code>rqt_reconfigure</code>窗口，在这个窗口中就可以动态的配置节点的参数，并且在调整参数时，可以看到命令行打印参数的改变。<br><img src="https://img.mahaofei.com/img/202112231938492-ros-basic-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《cmake practice》总结  cmake的构建过程与基本指令</title>
      <link href="/post/4e7d4c9e.html"/>
      <url>/post/4e7d4c9e.html</url>
      
        <content type="html"><![CDATA[<h2 id="〇、基本语法规则">〇、基本语法规则</h2><h3 id="0-1-变量">0.1 变量</h3><p>  变量使用 ${VALUENAME} 方式取值，但是在IF控制语句中直接使用变量名。</p><ol><li><code>CMAKE_BINARY_DIR</code> 或 <code>PROJECT_BINARY_DIR</code> 或 <code>&lt;ProjectName&gt;_BINARY_DIR</code>：均代表编译目录。如果是内部构建，就是指工程顶层目录；如果是外部构建，就是指工程编译发生的目录。</li><li><code>CMAKE_SOURCE_DIR</code> 或 <code>PROJECT_SOURCE_DIR</code> 或 <code>&lt;ProjectName&gt;_SOURCE_DIR</code>：均代表工程顶层目录。</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：代表当前处理的 CMakeLists.txt 所在的路径。</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>：如果是内部构建，与<code>CMAKE_CURRENT_SOURCE_DIR</code>相同；如果是外部构建，则代表目标编译目录。</li><li><code>CMAKE_CURRENT_LIST_FILE</code>：这个变量所在的CMakeLists.txt的完整路径。</li><li><code>CMAKE_CURRENT_LIST_LINE</code>：这个变量所在的行。</li><li><code>CMAKE_MODULE_PATH</code>：定义cmake模块所在的路径</li><li><code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code>：分别重新定义最终结果的存放目录。</li><li><code>PROJECT_NAME</code>：项目名称</li></ol><h3 id="0-2-指令规则">0.2 指令规则</h3><p>  1. 基本语法为：指令(参数1 参数2 …)<br>  2. 参数之间使用空格或分号隔开，例如<code>ADD_EXECUTABLE(hello main.c;func.c)</code><br>  3. 指令不区分大小写，参数和变量区分大小写，但推荐全部使用大写指令<br>  4. 当文件名中含有空格时，必须使用双引号，例如<code>SET(SRC_LIST &quot;fu nc.c&quot;)</code></p><h3 id="0-3-基本构建过程">0.3 基本构建过程</h3><p>  1. 编写程序与CMakeLists.txt文件<br>  2. 建立外部编译目录：<code>mkdir build</code><br>  3. 进入外部编译目录：<code>cd build</code><br>  4. 构建工程：<code>cmake ..</code><br>  5. 实际构建：<code>make</code><br>  6. 运行程序：<code>./&lt;Executable Filename&gt;</code><br>  7. 清理工程：<code>make clean</code></p><h2 id="一、基本指令">一、基本指令</h2><h3 id="1-PROJECT指令">1. PROJECT指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROJECT(projectname [CXX] [C] [Java])</span><br><span class="line"># 例：PROJECT(HELLO)</span><br></pre></td></tr></table></figure><p>  定义工程名称，并可制订工程支持的语言，默认支持所有语言。此指令隐式的定义了两个变量 <code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCE_DIR</code>。</p><h3 id="2-SET指令">2. SET指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"># 例<span class="number">1</span>：SET(SRC_LIST main.c)</span><br><span class="line"># 例<span class="number">2</span>：SET(EXECUTABLE_OUPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br></pre></td></tr></table></figure><p>  用来显式的定义变量。<br>  在<code>ADD_EXECUTABL</code>所在的CMakeLists.txt文件中，添加如例2的语句，可以修改最终目标二进制文件输出的路径为<code>build/bin</code></p><h3 id="3-MESSAGE指令">3. MESSAGE指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">&quot;message to display&quot;</span>)</span><br><span class="line"># 例：MESSAGE(STATUS <span class="string">&quot;This is BINARY dir $&#123;HELLO_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>  用于向终端输出用户定义的信息，包括三种类型</p><ul><li>SEND_ERROR：产生错误，生成过程被跳过</li><li>STATUS：输出前缀为-的信息</li><li>FATAL_ERROR：立即终止所有cmake过程</li></ul><h3 id="4-ADD-EXECUTABLE指令">4. ADD_EXECUTABLE指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_EXECUTABLE(&lt;Executable Filename&gt; $&#123;SRC_LIST&#125;)</span><br><span class="line"># 例：ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>  定义工程会生成文件名为<code>&lt;Executable Filename&gt;</code>的可执行文件，相关的源文件是SRC_LIST中定义的源文件列表。</p><h3 id="5-ADD-SUBDIRECTORY指令">5. ADD_SUBDIRECTORY指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"># 例：ADD_SUBDIRECTORY(src bin)</span><br></pre></td></tr></table></figure><p>  用于将子目录加入当前工程，并可以指定其二进制文件存放的位置。<code>EXCLUDE_FROM_ALL</code>含义是将此目录从编译过程中排除。（例：将src子目录加入工程，并制订编译输出路径为bin，那么编译结果都将放在<code>build/bin</code>中）</p><h3 id="6-INSTALL指令">6. INSTALL指令</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">INSTALL</span>(TARGETS targets... [EXPORT &lt;<span class="keyword">export</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line"># 例：<span class="built_in">INSTALL</span>(FILES COPYRIGHT README DESTINATION share/doc/cmake/test)</span><br><span class="line"># 例：<span class="built_in">INSTALL</span>(PROGRAMS runprog.sh DESTINATION bin)</span><br></pre></td></tr></table></figure><p>  INSTALL指令用于安装各种类型的文件，参数中的TARGETS就是要安装的文件，可以是二进制文件、动态库、静态库。在各个CMakeLists.txt中编写好INSTALL指令后就可以开始安装了。<br>  安装的过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=&lt;Install Path&gt;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="7-ADD-DEPENDENCIES指令">7. ADD_DEPENDENCIES指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)</span><br></pre></td></tr></table></figure><p>  定义target以来的其他target，确保在本项目编译前，其他target已经被构建</p><h3 id="8-ADD-TEST与ENABLE-TESTING指令">8. ADD_TEST与ENABLE_TESTING指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_TEST(testname Exename arg1 arg2 ...)</span><br><span class="line">ENABLE_TEST()</span><br></pre></td></tr></table></figure><p>  用于创建test目标，生成makefile后就可以通过make test进行测试了。</p><h3 id="9-EXEC-PROGRAM">9. EXEC_PROGRAM</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXEC_PROGRAM</span>(Executable</span><br><span class="line">[directory in which to run]</span><br><span class="line">[ARGS &lt;arguments to executable&gt;]</span><br><span class="line">[OUTPUT_VARIABLE &lt;var&gt;]</span><br><span class="line">[RETURN_VALUE &lt;var&gt;])</span><br></pre></td></tr></table></figure><p>  用于指定在特定的目录运行某个程序。</p><h2 id="三、静态库与动态库的构建与使用">三、静态库与动态库的构建与使用</h2><h3 id="3-1-静态库和动态库的构建方法">3.1 静态库和动态库的构建方法</h3><p>  1. 在工程目录下新建一个<code>lib</code>文件夹，并将其添加进工程目录中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 工程目录下的CMakeLists.txt</span><br><span class="line"><span class="title function_">PROJECT</span><span class="params">(HELLOLIB)</span></span><br><span class="line"><span class="title function_">ADD_SUBDIRECTORY</span><span class="params">(lib)</span></span><br></pre></td></tr></table></figure><p>  2. 在<code>lib</code>文件夹下创建源文件。<br>  3. 在<code>lib</code>目录下创建<code>CMakeLists.txt</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET(LIBHELLO_SRC hello.c)</span><br><span class="line">#创建动态库</span><br><span class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">#创建静态库</span><br><span class="line">ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">#实现动态库版本号</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>)</span><br><span class="line">#安装共享库和头文件</span><br><span class="line">INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br><span class="line">INSTALL(FILES hello.h DESTINATION include/hello)</span><br></pre></td></tr></table></figure><p>  4. 安装共享库和头文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="3-2-外部共享库和头文件的使用">3.2 外部共享库和头文件的使用</h3><p>  1. 在新工程目录下创建<code>src</code>目录，并在其中编写源文件main.c<br>  2. 编写工程目录下<code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROJECT(NEWHELLO)</span><br><span class="line">ADD_SUBDIRECTORY(src)</span><br></pre></td></tr></table></figure><p>  3. 编写<code>src</code>目录下的<code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ADD_EXECUTABLE(main main.c)</span><br><span class="line"># 添加头文件搜索路径</span><br><span class="line">INCLUDE_DIRECTORIES(/usr/include/hello)</span><br><span class="line"># 将目标文件链接到共享库</span><br><span class="line">TARGET_LINK_LIBRARIES(main libhello.so)</span><br><span class="line"># 或：TARGET_LINK_LIBRARIES(main hello)</span><br><span class="line"># 或链接到静态库：TARGET_LINK_LIBRARIES(main libhello.a)</span><br></pre></td></tr></table></figure><p>  4. 构建运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>参考自<a href="https://huffie.lanzoui.com/i2kKdu0fu9e">《cmake practice》</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV/C++】KNN算法识别数字的实现原理与代码详解</title>
      <link href="/post/c386d502.html"/>
      <url>/post/c386d502.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、KNN原理">一、KNN原理</h2><h3 id="1-1-KNN原理介绍">1.1 KNN原理介绍</h3><p>  KNN算法，即K最近邻算法，顾名思义其<strong>原理是当要预测一个新的值x的时候，根据离他最近的K个点大多属于什么类别来判断x属于哪个类别</strong>。</p><blockquote><p><a href="https://www.cnblogs.com/listenfwind/p/10311496.html">zzzzMing -大数据技术-深入浅出KNN算法</a></p><p><img src="https://img.mahaofei.com/img/202112231933950-opencv-knn-1.png" alt=""></p><p>  K=3时，x最近的三个图形包括两个三角形、一个圆形，因为2&gt;1，所以x更有可能是三角形。</p><p><img src="https://img.mahaofei.com/img/202112231934427-opencv-knn-2.png" alt=""></p><p>  K=5时，x最近的五个图形包括两个三角形、三个圆形，因为3&gt;2，所以x更有可能是圆形。</p></blockquote><p>  同理类比到图像识别方面，<strong>使用KNN算法前我们需要有大量的训练样本，并且知道每个样本所属的类别。</strong>（例如大量的数字图片，并且知道每个图片代表数字几）。当我们要识别数字时，本质上就是在训练样本中找与要识别的图像最接近的K个样本，然后统计出K个样本中出现最多的数字是哪个，那就是要识别的数字。</p><h3 id="1-2-KNN的关键参数">1.2 KNN的关键参数</h3><p><strong>① 寻找多少最近邻样本 - K的选择</strong></p><p>  K值决定着图像识别过程中，寻找的最近邻的图像个数，由上面的例子可以看出，选择不同的K，识别结果可能完全不同，因此K值是KNN算法中最关键的参数之一，它直接影响着模型的性能。</p><p>  K值如果过小，那么此时识别结果就会很受样本质量的影响。如果训练样本存在某些错误或噪音，而寻找最近邻样本时正好找到了这些项，那么识别结果一定是错的，而增大K值，多寻找样本，会有效降低样本噪音的影响。</p><p>  K值如果过大，假设K值等于训练样本数，那么无论要识别的图片是什么，识别结果都是样本中最多的那个类别。</p><p>  那么K值应该如何选择呢？理论上来说K值与识别准确率的关系是存在一个极值的，可以通过多次实验，根据结果选择一个最好的K值。（例如K=3时准确率72；K=5时准确率91；K=8时准确率81，那么选择K=5会是一个相对较好的选择）</p><p><strong>② 如何判断“接近”程度 - 距离的计算</strong><br>  距离计算函数一般使用曼哈顿距离或欧氏距离。</p><p>  曼哈顿距离就是样本特征每一个维度的差值之合。（对应于图像，就是两图像每个像素做差）</p><p><img src="https://img.mahaofei.com/img/202112231934104-opencv-knn-3.png" alt=""></p><p>  欧式距离是样本特征在每一个维度上差值的平方和的根。</p><p><img src="https://img.mahaofei.com/img/202112231935896-opencv-knn-4.png" alt=""></p><h2 id="二、KNN算法识别手写数字">二、KNN算法识别手写数字</h2><blockquote><p>KNN算法识别手写数字的源程序 - <a href="https://huffie.lanzoui.com/iQaVetwgsoj">点此下载</a></p></blockquote><h3 id="2-1-训练过程代码详解">2.1 训练过程代码详解</h3><p>  首先，我们要获得训练样本。OpenCV安装目录中给我们提供了手写数字的样本图片<code>opencv\sources\samples\data\digits.png</code>。这个图片中每个数字有5x100个样本，并且每个数字所占的像素均为20x20，因此可以从这个图片中提取我们需要的训练样本。</p><p>  我们按列裁剪样本图片，<strong>每裁剪一个样本，就将其添加到data中，并同时将对应的数字添加到lable中</strong>。这样一来，我们就获得了图片和数字一一对应的data和lable数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/data/digits.png&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, gray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> m = gray.rows / b;   <span class="comment">//原图为1000*2000</span></span><br><span class="line"><span class="type">int</span> n = gray.cols / b;   <span class="comment">//裁剪为5000个20*20的小图块</span></span><br><span class="line">Mat data, labels;   <span class="comment">//特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> offsetCol = i * b; <span class="comment">//列上的偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> offsetRow = j * b;  <span class="comment">//行上的偏移量</span></span><br><span class="line">                              <span class="comment">//截取20*20的小块</span></span><br><span class="line">        Mat tmp;</span><br><span class="line">        <span class="built_in">gray</span>(<span class="built_in">Range</span>(offsetRow, offsetRow + b), <span class="built_in">Range</span>(offsetCol, offsetCol + b)).<span class="built_in">copyTo</span>(tmp);</span><br><span class="line">        <span class="comment">//reshape  0：通道不变  其他数字，表示要设置的通道数</span></span><br><span class="line">        <span class="comment">//reshape  表示矩阵行数，如果设置为0，则表示保持原有行数不变，如果设置为其他数字，表示要设置的行数</span></span><br><span class="line">        data.<span class="built_in">push_back</span>(tmp.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">//序列化后放入特征矩阵</span></span><br><span class="line">        labels.<span class="built_in">push_back</span>((<span class="type">int</span>)j / <span class="number">5</span>);  <span class="comment">//对应的标注</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  利用这个训练样本就可以创建KNN模型了。</p><p>  如果需要测试模型的识别准确度，可以从刚才获得的5000个样本中，选择前3000个样本作为训练数据，后2000个作为测试数据。用KNN模型计算测试数据的在样本中的识别正确情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">data.<span class="built_in">convertTo</span>(data, CV_32F); <span class="comment">//uchar型转换为cv_32f</span></span><br><span class="line"><span class="type">int</span> samplesNum = data.rows;</span><br><span class="line"><span class="type">int</span> trainNum = <span class="number">500</span>;</span><br><span class="line">Mat trainData, trainLabels;</span><br><span class="line">trainData = <span class="built_in">data</span>(<span class="built_in">Range</span>(<span class="number">0</span>, trainNum), Range::<span class="built_in">all</span>());   <span class="comment">//前3000个样本为训练数据</span></span><br><span class="line">trainLabels = <span class="built_in">labels</span>(<span class="built_in">Range</span>(<span class="number">0</span>, trainNum), Range::<span class="built_in">all</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用KNN算法</span></span><br><span class="line"><span class="type">int</span> K = <span class="number">5</span>;</span><br><span class="line">Ptr&lt;TrainData&gt; tData = TrainData::<span class="built_in">create</span>(trainData, ROW_SAMPLE, trainLabels);</span><br><span class="line">model = KNearest::<span class="built_in">create</span>();</span><br><span class="line">model-&gt;<span class="built_in">setDefaultK</span>(K);</span><br><span class="line">model-&gt;<span class="built_in">setIsClassifier</span>(<span class="literal">true</span>);</span><br><span class="line">model-&gt;<span class="built_in">train</span>(tData);</span><br><span class="line"><span class="comment">//预测分类</span></span><br><span class="line"><span class="type">double</span> train_hr = <span class="number">0</span>, test_hr = <span class="number">0</span>;</span><br><span class="line">Mat response;</span><br><span class="line"><span class="comment">// compute prediction error on train and test data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; samplesNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Mat sample = data.<span class="built_in">row</span>(i);</span><br><span class="line">    <span class="type">float</span> r = model-&gt;<span class="built_in">predict</span>(sample);   <span class="comment">//对所有行进行预测</span></span><br><span class="line">                                        <span class="comment">//预测结果与原结果相比，相等为1，不等为0</span></span><br><span class="line">    r = std::<span class="built_in">abs</span>(r - labels.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(i)) &lt;= FLT_EPSILON ? <span class="number">1.f</span> : <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; trainNum)</span><br><span class="line">        train_hr += r;  <span class="comment">//累积正确数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        test_hr += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_hr /= samplesNum - trainNum;</span><br><span class="line">train_hr = trainNum &gt; <span class="number">0</span> ? train_hr / trainNum : <span class="number">1.</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;</span>,</span><br><span class="line">    train_hr * <span class="number">100.</span>, test_hr * <span class="number">100.</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-预测分类的实现过程">2.2 预测分类的实现过程</h3><p>  训练样本制作完毕后，预测分类就非常简单了，将要识别的图像读取进来，进行二值化处理，然后调整大小到与样本图片一样大（20x20）。将处理好的图片push到test中，就可以直接使用刚才创建的KNN模型进行预测了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预测分类</span></span><br><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/test/4.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">cvtColor</span>(img, img, COLOR_BGR2GRAY);</span><br><span class="line"><span class="comment">//threshold(src, src, 0, 255, CV_THRESH_OTSU);</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">resize</span>(img, img, <span class="built_in">Size</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">Mat test;</span><br><span class="line">test.<span class="built_in">push_back</span>(img.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">test.<span class="built_in">convertTo</span>(test, CV_32F);</span><br><span class="line"><span class="type">int</span> result = model-&gt;<span class="built_in">predict</span>(test);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="三、KNN算法识别印刷数字">三、KNN算法识别印刷数字</h2><blockquote><p>KNN算法识别印刷数字的源程序 -<a href="https://huffie.lanzoui.com/iXh7Ktwgsvg">点此下载</a><br>  识别印刷体数字与识别手写数字的原理相同，只是训练样本有区别。这里我制作了1000张不同字体的训练样本，加载方式例如：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//训练结果不存在，重新训练</span></span><br><span class="line"><span class="type">int</span> add_image_num = <span class="number">1000</span>;   <span class="comment">//扩充训练数据的文件夹个数</span></span><br><span class="line"><span class="type">int</span> filenum = <span class="number">0</span>;</span><br><span class="line">Mat data, labels;   <span class="comment">//特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; add_image_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Mat addimg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/data/&quot;</span> + <span class="built_in">to_string</span>(filenum) + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">cvtColor</span>(addimg, addimg, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//threshold(src, src, 0, 255, CV_THRESH_OTSU);</span></span><br><span class="line">    <span class="built_in">resize</span>(addimg, addimg, <span class="built_in">Size</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    data.<span class="built_in">push_back</span>(addimg.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">//序列化后放入特征矩阵</span></span><br><span class="line">    labels.<span class="built_in">push_back</span>((<span class="type">int</span>)((filenum++) % <span class="number">10</span>));  <span class="comment">//对应的标注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  训练样本加载完毕后，使用与上面相同的方式创建KNN模型，然后进行预测识别即可。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解opencv摄像头数字识别</title>
      <link href="/post/985d20fe.html"/>
      <url>/post/985d20fe.html</url>
      
        <content type="html"><![CDATA[<p>  本文的目标是实现<strong>识别摄像头图像中的数字</strong>。实际应用场景包括<strong>车牌号识别</strong>，部分竞赛的<strong>A4纸打印数字识别</strong>。项目实现结果如下，完整工程文件<a href="https://download.csdn.net/download/weixin_44543463/22349857">点此下载</a>：</p><p><img src="https://img.mahaofei.com/img/202112231926851-digital-recognize-1.png" alt=""></p><blockquote><p>  <strong>摄像头数字识别分为两个步骤：</strong></p><ol><li>提取图像中的ROI区域，如截取车牌的矩形区域，或截取A4纸的图像。</li><li>对ROI区域进行数字识别。</li></ol></blockquote><p>  数字识别相对来说较为简单，先介绍数字识别的方法和原理。</p><h2 id="一、数字识别的两种方式">一、数字识别的两种方式</h2><h3 id="1-1-轮廓提取法">1.1 轮廓提取法</h3><p>  实现思路为对ROI区域进行轮廓提取，然后将所有找到的轮廓与模板逐一匹配识别，相似度大于所设阈值，可视为识别成功。</p><p>  寻找轮廓所使用的函数为findContours()，利用此函数将所有寻找到的轮廓保存在contours中，然后使用循环画出包围每一个轮廓的最小矩形。</p><p>  利用每一个小矩形，提取图像中的每一个轮廓图像，将其与模板做差，如果差值越小，说明像素越接近，相似程度越高，以此来实现数字匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮廓提取主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取一张图像，转换为灰度图并进行二值化处理</span></span><br><span class="line">    Mat srcImage = <span class="built_in">imread</span>(<span class="string">&quot;E://Program//OpenCV//vcworkspaces//ogr_test//images//txt.jpg&quot;</span>);  <span class="comment">//读取图片</span></span><br><span class="line">    Mat dstImage, grayImage, binImage;</span><br><span class="line">    srcImage.<span class="built_in">copyTo</span>(dstImage);  <span class="comment">//将读取到的图片，深拷贝为dstImage</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage, grayImage, COLOR_BGR2GRAY);                  <span class="comment">//转换灰度图</span></span><br><span class="line">    <span class="built_in">threshold</span>(grayImage, binImage, <span class="number">100</span>, <span class="number">255</span>, cv::THRESH_BINARY_INV);     <span class="comment">//转换二值图，设置阈值，高于100认为255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找轮廓</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;  <span class="comment">//定义轮廓和层次结构</span></span><br><span class="line">    vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">    <span class="built_in">findContours</span>(binImage, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE); <span class="comment">//寻找轮廓</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt;::iterator It;</span><br><span class="line">    Rect a4rect[<span class="number">15</span>];<span class="comment">//假设最多不会超过15个轮廓</span></span><br><span class="line"><span class="keyword">for</span> (It = contours_rec.<span class="built_in">begin</span>(); It &lt; contours_rec.<span class="built_in">end</span>(); It++) &#123;                        <span class="comment">//画出包围数字的最小矩形</span></span><br><span class="line">a4rect[i].x = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().x;</span><br><span class="line">a4rect[i].y = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().y;</span><br><span class="line">a4rect[i].width = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">br</span>().x - (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().x;</span><br><span class="line">a4rect[i].height = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">br</span>().y - (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().y;</span><br><span class="line"><span class="keyword">if</span> ((a4rect[i].height &gt; <span class="number">80</span>) &amp;&amp; (a4rect[i].width &gt; <span class="number">50</span>) &amp;&amp; (a4rect[i].height &lt; <span class="number">300</span>) &amp;&amp; (a4rect[i].width &lt; <span class="number">300</span>)) &#123;</span><br><span class="line"><span class="built_in">rectangle</span>(dstImage, a4rect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//在原图像中用红框画出识别到的各轮廓</span></span><br><span class="line"><span class="built_in">rectangle</span>(binImage, a4rect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;dstImage&quot;</span>, dstImage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将图像轮廓逐一与模板匹配</span></span><br><span class="line">Mat num[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> matchingNum = <span class="number">0</span>;<span class="comment">//匹配到的数字</span></span><br><span class="line"><span class="type">int</span> matchingRate = <span class="number">0</span>;<span class="comment">//相似率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="built_in">a4binImg</span>(a4rect[j]).<span class="built_in">copyTo</span>(num[j]);<span class="comment">//提取包围数字的矩形区域至num[j]</span></span><br><span class="line">        <span class="built_in">imgMatch</span>(num[j], matchingRate, matchingNum);<span class="comment">//数字匹配</span></span><br><span class="line">        <span class="keyword">if</span> (matchingRate &lt; <span class="number">400000</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; matchingNum &lt;&lt; <span class="string">&quot;\t匹配率：&quot;</span> &lt;&lt;  matchingRate &lt;&lt; endl;</span><br><span class="line"><span class="comment">//imwrite(to_string(matchingNum) + &quot;.jpg&quot;, num[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  两图像相减之前，需要先制作一张模板，你可以自己在记事本里敲0-9的数字，截图，使用上面的函数imwrite出来一份模板。也可以到我的<a href="https://github.com/HuffieMa/digital_recongize/tree/master/images">github中下载</a>，其中0.jpg-9.jpg就是模板文件。</p><p><img src="https://img.mahaofei.com/img/202112231927793-digital-recognize-2.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有像素点和，用于求两图像相减后所得图像的所有像素之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPixelSum</span><span class="params">(Mat&amp; image)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; image.rows; row++) &#123;</span><br><span class="line">uchar* current_pixel = image.<span class="built_in">ptr</span>&lt;uchar&gt;(row);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; image.cols; col++) &#123;</span><br><span class="line">a += *current_pixel++;<span class="comment">//指针遍历像素点反转颜色</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板匹配函数，两图像做差</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">imgMatch</span><span class="params">(Mat&amp; image, <span class="type">int</span>&amp; rate, <span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">Mat imgSub;</span><br><span class="line"><span class="type">double</span> min = <span class="number">10e6</span>;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line">rate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">Mat templatimg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/OGR/images/&quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot;.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line"><span class="built_in">resize</span>(image, image, <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">48</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);<span class="comment">//将两图像大小调至相同</span></span><br><span class="line"><span class="built_in">resize</span>(templatimg, templatimg, <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">48</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);</span><br><span class="line"><span class="built_in">absdiff</span>(templatimg, image, imgSub);</span><br><span class="line">rate = <span class="built_in">getPixelSum</span>(imgSub);</span><br><span class="line"><span class="keyword">if</span> (rate &lt; min) &#123;</span><br><span class="line">min = rate;</span><br><span class="line">num = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-行列扫描法">1.2 行列扫描法</h3><p>  此方法主要参考<a href="https://blog.csdn.net/LTG01/article/details/50492556">opencv 数字识别详细教程</a>这篇文章，在此感谢LTG01大佬的无私分享。</p><p>  <br>  <strong>基本过程为：</strong></p><ol><li>将图像二值化处理，使数字部分为白色，其余部分为黑色。</li><li>对一个图像先<strong>逐行扫描求和</strong>，如果第一行像素和为0，则继续向下扫描，直到碰到像素和不为0的行，将行数记下来，此为数字的顶部。</li><li>继续向下扫描，此时会从上到下逐渐扫描数字所在的每一行，当行像素和再次为0时，再将行数记录下来，代表已经到了数字的底部，将顶部与底部之间的区域截取出来。</li><li>，对截取出来的图像进行<strong>逐列扫描求和</strong>，过程同上，记录出数字的左右列号，根据左右列号即可从刚才截取出的图像中，取出包含数字的最小图像。</li><li>利用此最小图像与模板匹配。</li></ol><p><img src="https://img.mahaofei.com/img/202112231928486-digital-recognize-3.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取图像并进行二值化处理</span></span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/ogr_test/images/txt.jpg&quot;</span>,IMREAD_GRAYSCALE);</span><br><span class="line">    Mat grayImage;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">    <span class="built_in">threshold</span>(src, grayImage, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY_INV);     <span class="comment">//转换二值图，设置阈值，高于50认为255</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;grayimg&quot;</span>, grayImage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行行列扫描</span></span><br><span class="line">    Mat leftImg, rightImg, topImg, bottomImg;</span><br><span class="line">    <span class="type">int</span> topRes = <span class="built_in">cutTop</span>(grayImage, topImg, bottomImg);<span class="comment">//对二值图像逐行扫描，获得行像素之和&gt;0的部分topImg，以及剩余部分bottomImg</span></span><br><span class="line">    <span class="type">int</span> matchNum = <span class="number">-1</span>, matchRate = <span class="number">10e6</span>;</span><br><span class="line"><span class="keyword">while</span> (topRes == <span class="number">0</span>)<span class="comment">//当仍存在行像素和&gt;0的部分时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> leftRes = <span class="built_in">cutLeft</span>(topImg, leftImg, rightImg);<span class="comment">//对行像素之和&gt;0的部分topImg逐列扫描，获得列像素之和&gt;0的部分leftImg，以及剩余部分rightImg</span></span><br><span class="line">        <span class="keyword">while</span> (leftRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">imgMatch</span>(leftImg, matchNum, matchRate);<span class="comment">//数字识别</span></span><br><span class="line"><span class="comment">//getSubtract(topImg);</span></span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;num&quot;</span>, leftImg);</span><br><span class="line">            <span class="keyword">if</span> (matchRate &lt; <span class="number">300000</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; matchNum &lt;&lt; <span class="string">&quot;\t\t匹配度：&quot;</span> &lt;&lt; matchRate &lt;&lt; endl;</span><br><span class="line">                <span class="comment">//imwrite(to_string(matchingNum) + &quot;.jpg&quot;, num[j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">Mat srcTmp = rightImg.<span class="built_in">clone</span>();</span><br><span class="line">            leftRes = <span class="built_in">cutLeft</span>(srcTmp, leftImg, rightImg);<span class="comment">//对剩余部分rightImg继续逐列扫描</span></span><br><span class="line">        &#125;</span><br><span class="line">        Mat srcTmp = bottomImg.<span class="built_in">clone</span>();</span><br><span class="line">        topRes = <span class="built_in">cutTop</span>(srcTmp, topImg, bottomImg);<span class="comment">//对剩余部分bottomImg继续逐行扫描</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  有关扫描法识别数字的完整代码见我的<a href="https://github.com/HuffieMa/digital_recongize/tree/scan">Github的scan分支</a>。</p><h2 id="二、提取图像中的ROI区域">二、提取图像中的ROI区域</h2><p>  提取ROI区域的步骤如下：</p><ol><li>读取摄像头每一帧图像</li><li>对图像进行二值化处理</li><li>对图像进行形态学处理</li><li>设置限制条件寻找目标区域，并框选（这一步是重点）</li></ol><h3 id="2-1-读取摄像头图像">2.1 读取摄像头图像</h3><p>  摄像头的读取原理在之前的文章中已有介绍<a href="https://blog.csdn.net/weixin_44543463/article/details/119054844">《摄像头视频的读取与存储》</a>。主要使用函数为 <code>capture.read()</code>，此函数用于捕获视频的每一帧，并返回刚刚捕获的帧。示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类，打开电脑默认摄像头传参0，如果有外置摄像头参数为1</span></span><br><span class="line">    <span class="type">int</span> frame_width = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH);<span class="comment">//获取摄像头的宽、高、帧数、FPS</span></span><br><span class="line">    <span class="type">int</span> frame_height = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line">    Mat frame;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line">        <span class="comment">//flip(frame, frame, 1);//将读取的视频左右反转</span></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//每次循环显示一帧图像，frame就是每帧图像</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">333</span>);<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    capture.<span class="built_in">release</span>();<span class="comment">//释放视频</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231928575-digital-recognize-4.png" alt=""></p><h3 id="2-2-对图像进行二值化处理">2.2 对图像进行二值化处理</h3><p>  通过每个像素的颜色分量将图片进行二值化。正常曝光情况下<strong>A4纸的BGR均为215左右</strong>，<strong>车牌的颜色信息大约为B=138，G=63，R=23</strong>。但是在不同环境下颜色信息可能会有偏差，因此需要将条件在一定程度上放宽，再通过其他一些条件来准确查找目标区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图像二值化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryProc</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pixelB, pixelG, pixelR;  <span class="comment">//记录各通道值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> DifMax = <span class="number">40</span>;             <span class="comment">//基于颜色区分的阈值设置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> WhiteMax = <span class="number">50</span>;   <span class="comment">//判断白色</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> B = <span class="number">215</span>, G = <span class="number">215</span>, R = <span class="number">215</span>; <span class="comment">//各通道的阈值设定，针对与A4纸</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; image.rows; i++)   <span class="comment">//通过颜色分量将图片进行二值化处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; image.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">pixelB = image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]; <span class="comment">//获取图片各个通道的值</span></span><br><span class="line">pixelG = image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">pixelR = image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">abs</span>(B - pixelB) &lt; DifMax) &amp;&amp; (<span class="built_in">abs</span>(G - pixelG) &lt; DifMax) &amp;&amp; (<span class="built_in">abs</span>(R - pixelR) &lt; DifMax) &amp;&amp; <span class="built_in">abs</span>(pixelB - pixelG) &lt; WhiteMax &amp;&amp; <span class="built_in">abs</span>(pixelG - pixelR) &lt; WhiteMax &amp;&amp; <span class="built_in">abs</span>(pixelB - pixelR) &lt; WhiteMax)</span><br><span class="line">&#123;                                           <span class="comment">//将各个通道的值和各个通道阈值进行比较</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">255</span>;     <span class="comment">//符合颜色阈值范围内的设置成白色</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">0</span>;        <span class="comment">//不符合颜色阈值范围内的设置为黑色</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231928141-digital-recognize-5.png" alt=""></p><h3 id="2-3-形态学处理">2.3 形态学处理</h3><p>  可以看出二值画处理后已经比较明显完整的显示出A4纸区域，但是仍然存在一些噪点，此时进行形态学处理，以消除这些噪点干扰。对图像<strong>先膨胀再腐蚀</strong>，可以填充细小空间，连接临近物体和平滑边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形态学处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">morphTreat</span><span class="params">(Mat&amp; binImg)</span> </span>&#123;</span><br><span class="line">Mat BinOriImg;     <span class="comment">//形态学处理结果图像</span></span><br><span class="line">Mat element = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">//设置形态学处理窗的大小</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(binImg, binImg, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);     <span class="comment">//进行多次膨胀操作</span></span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"></span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);      <span class="comment">//进行多次腐蚀操作</span></span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="comment">//imshow(&quot;形态学处理后&quot;, BinOriImg);        //显示形态学处理之后的图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(binImg, binImg, CV_BGR2GRAY);   <span class="comment">//将形态学处理之后的图像转化为灰度图像</span></span><br><span class="line"><span class="built_in">threshold</span>(binImg, binImg, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY); <span class="comment">//灰度图像二值化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  矩形窗的大小与膨胀腐蚀的次数会影响处理结果，处理完的结果大致如下。</p><p><img src="https://img.mahaofei.com/img/202112231929044-digital-recognize-6.png" alt=""></p><h3 id="2-4-设置限制条件寻找目标区域">2.4 设置限制条件寻找目标区域</h3><p>  经过形态学处理，图像中已经可以明显看到A4纸所在的区域，但是图像中仍然不可避免存在其他与A4纸颜色接近的物体，在这里也会显示为白色。<strong>这时就需要我们根据A4纸区域的特点设置限制条件，从这些白色区域中找到代表A4纸所在的区域。</strong></p><p>  在这里我使用的限制条件主要有以下几个：</p><ol><li>矩形面积在一定范围内</li><li>长宽比A4纸为1.414，一定程度放宽后作为限制条件</li><li>短边长度在一定范围内</li></ol><p>  首先寻找图像中的轮廓，利用轮廓面积初步判断，对轮廓面积符合条件的进一步获取其外接矩形。计算此矩形的各个参数（顶点坐标、长宽、面积、倾斜角度等），然后根据限制条件对此矩形进行判别。<br>  如果矩形区域符合条件，那么就需要将其截取出来，并根据先前计算的倾斜角度将A4纸图像摆正，便于后续对其中的数字进行识别。旋转图像的函数需要一些数学知识，旋转前后的图像的长宽有一定函数关系。（h’、w’为旋转后图像高、宽）</p><p><img src="https://img.mahaofei.com/img/202112231929478-digital-recognize-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231930121-digital-recognize-8.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图像旋转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotateProc</span><span class="params">(Mat&amp; image, <span class="type">double</span> angle)</span> </span>&#123;</span><br><span class="line">Mat M;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line">M = <span class="built_in">getRotationMatrix2D</span>(<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), angle, <span class="number">1.0</span>);<span class="comment">//定义变换矩阵M</span></span><br><span class="line"><span class="type">double</span> cos = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//求cos值</span></span><br><span class="line"><span class="type">double</span> sin = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//求sin值</span></span><br><span class="line"><span class="type">int</span> nw = <span class="built_in">abs</span>(cos * w - sin * h) / <span class="built_in">abs</span>(cos * cos - sin * sin);<span class="comment">//计算新的长、宽</span></span><br><span class="line"><span class="type">int</span> nh = <span class="built_in">abs</span>(cos * h - sin * w) / <span class="built_in">abs</span>(cos * cos - sin * sin);</span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) += (nw / <span class="number">2</span> - w / <span class="number">2</span>);<span class="comment">//计算新的中心</span></span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) += (nh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">warpAffine</span>(image, image, M, <span class="built_in">Size</span>(nw, nh), INTER_LINEAR, <span class="number">0</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//imshow(&quot;Rotation&quot;, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************** 提取A4纸区域并识别数字 *****************************/</span></span><br><span class="line"><span class="type">double</span> length, area, rectArea;     <span class="comment">//定义轮廓周长、面积、外界矩形面积</span></span><br><span class="line"><span class="type">double</span> long2Short = <span class="number">0.0</span>;           <span class="comment">//长边/短边</span></span><br><span class="line">Rect rect;           <span class="comment">//外界矩形</span></span><br><span class="line">RotatedRect box;  <span class="comment">//外接矩形</span></span><br><span class="line">CvPoint2D32f pt[<span class="number">4</span>];    <span class="comment">//矩形定点变量</span></span><br><span class="line">Mat pts;    <span class="comment">//矩形定点变量</span></span><br><span class="line"><span class="type">double</span> axisLong = <span class="number">0.0</span>, axisShort = <span class="number">0.0</span>;<span class="comment">//矩形的长边和短边</span></span><br><span class="line"><span class="type">double</span> Length;     <span class="comment">//中间变量</span></span><br><span class="line"><span class="type">float</span>  angle = <span class="number">0</span>;      <span class="comment">//记录倾斜角度</span></span><br><span class="line"><span class="type">double</span> location_x = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> location_y = <span class="number">0.0</span>;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt;hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(binImg, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//绘制轮廓的最小外接矩形  </span></span><br><span class="line">length = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);      <span class="comment">//获取轮廓周长</span></span><br><span class="line">area = <span class="built_in">contourArea</span>(contours[i]);<span class="comment">//获取轮廓面积</span></span><br><span class="line"><span class="keyword">if</span> (area &gt; <span class="number">2000</span> &amp;&amp; area &lt; <span class="number">300000</span>)<span class="comment">//矩形区域面积大小判断，符合条件的继续</span></span><br><span class="line">&#123;</span><br><span class="line">rect = <span class="built_in">boundingRect</span>(contours[i]);<span class="comment">//计算矩形边界</span></span><br><span class="line">box = <span class="built_in">minAreaRect</span>(contours[i]);<span class="comment">//获取轮廓的矩形</span></span><br><span class="line"><span class="built_in">boxPoints</span>(box, pts);<span class="comment">//获取矩形四个顶点坐标（左上，右上，右下，左下）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; pts.rows; row++) &#123;<span class="comment">//从列表中依次读出四个顶点坐标</span></span><br><span class="line">pt[row].x = pts.<span class="built_in">at</span>&lt;uchar&gt;(row, <span class="number">0</span>);</span><br><span class="line">pt[row].y = pts.<span class="built_in">at</span>&lt;uchar&gt;(row, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">angle = box.angle;              <span class="comment">//得到倾斜角度</span></span><br><span class="line"><span class="keyword">if</span> (angle &gt; <span class="number">45</span>) &#123;<span class="comment">//对于逆时针偏转的情况，倾斜角度为-(90-angle)</span></span><br><span class="line">angle = angle - <span class="number">90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axisLong = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pt[<span class="number">1</span>].x - pt[<span class="number">0</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(pt[<span class="number">1</span>].y - pt[<span class="number">0</span>].y, <span class="number">2</span>));  <span class="comment">//计算长轴（勾股定理）</span></span><br><span class="line">axisShort = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pt[<span class="number">2</span>].x - pt[<span class="number">1</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(pt[<span class="number">2</span>].y - pt[<span class="number">1</span>].y, <span class="number">2</span>)); <span class="comment">//计算短轴（勾股定理）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (axisShort &gt; axisLong)<span class="comment">//如果短轴大于长轴，交换数据</span></span><br><span class="line">&#123;</span><br><span class="line">Length = axisLong;</span><br><span class="line">axisLong = axisShort;</span><br><span class="line">axisShort = Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rectArea = axisLong * axisShort;<span class="comment">//计算矩形的实际面积</span></span><br><span class="line"></span><br><span class="line">long2Short = axisLong / axisShort;<span class="comment">//计算长宽比</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 长宽比A4纸为1.414，利用长宽比、矩形面积和短边长度作为限制条件</span></span><br><span class="line"><span class="keyword">if</span> (long2Short &gt; <span class="number">1</span> &amp;&amp; long2Short &lt; <span class="number">1.8</span>  &amp;&amp; rectArea &gt; <span class="number">5000</span> &amp;&amp; rectArea &lt; <span class="number">300000</span> &amp;&amp; axisShort &gt; <span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(frame, rect, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//在摄像头图像中画出矩形区域</span></span><br><span class="line"><span class="keyword">if</span> (rect.width &gt; <span class="number">100</span> &amp;&amp; rect.height &gt; <span class="number">100</span> &amp;&amp; axisShort&gt;<span class="number">100</span>) &#123;<span class="comment">//缩小矩形范围，便于数字识别</span></span><br><span class="line">rect.x += <span class="number">40</span>;</span><br><span class="line">rect.y += <span class="number">40</span>;</span><br><span class="line">rect.width -= <span class="number">40</span>;</span><br><span class="line">rect.height -= <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//显示摄像头拍摄画面</span></span><br><span class="line">location_x = rect.x + rect.width / <span class="number">2</span>;<span class="comment">//获得矩形中心坐标，即A4纸中心坐标</span></span><br><span class="line">location_y = rect.y + rect.height / <span class="number">2</span>;</span><br><span class="line">Mat a4Img = <span class="built_in">frame</span>(rect);<span class="comment">//提取A4纸区域</span></span><br><span class="line">Mat a4binImg;</span><br><span class="line"><span class="built_in">cvtColor</span>(a4Img, a4binImg, CV_BGR2GRAY);   <span class="comment">//将A4纸区域转化为灰度图像</span></span><br><span class="line"><span class="built_in">threshold</span>(a4binImg, a4binImg, <span class="number">120</span>, <span class="number">255</span>, THRESH_BINARY); <span class="comment">//灰度图像二值化</span></span><br><span class="line"><span class="built_in">colorReverse</span>(a4binImg);<span class="comment">//颜色反转</span></span><br><span class="line"><span class="built_in">rotateProc</span>(a4binImg, angle);<span class="comment">//根据前所计算角度，对图像进行旋转，保证数字水平存在</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;A4&quot;</span>, a4binImg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************  数字识别方法  ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所获得的a4binImg就是经过二值化处理后的A4纸区域</span></span><br><span class="line"><span class="comment">//使用上面介绍的数字识别方法即可级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231933401-digital-recognize-9.gif" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231933798-digital-recognize-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加Follow me on CSDN效果</title>
      <link href="/post/666fc0fa.html"/>
      <url>/post/666fc0fa.html</url>
      
        <content type="html"><![CDATA[<p>  <a href="http://huffie.cn/">http://huffie.cn/</a>这是我的博客，可以在此查看效果。</p><h3 id="简介">简介</h3><p>  效果图如下（右上角）：</p><p><img src="https://img.mahaofei.com/img/202112231924025-fellowme-csdn-1.png" alt=""></p><p>  网络上比较多的是Fork me on Github效果，其实要实现Follow me on CSDN原理是一样的。</p><p>  只需要将想要的效果图片下载下来ps一下，然后再上传到某个图床（或者说上传到CSDN），就可以得到此图片的url，替换到代码中即可。如下是我制作的两张图片，需要的小伙伴直接拿。（源代码见文末）</p><p><img src="https://img-blog.csdnimg.cn/abe3797b7d77419b81ecc02dd1bf8c34.png" alt=""><br><img src="https://img-blog.csdnimg.cn/1f8e1ef9be9f4f7db01fe3a2d57829de.png" alt=""><br>  更多的效果图片可以在<a href="https://github.blog/2008-12-19-github-ribbons/">项目地址</a>下载，想要其他效果的自己p一下就可以了。</p><h3 id="实现方法">实现方法</h3><p>粘贴复制如下的代码到<code>themes\hexo-theme-next\layout\_layout.njk</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面 如图)，并把href改为你的csdn主页</p><p>黑色版本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Follow me on CSDN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">width</span>=<span class="string">&quot;149&quot;</span> <span class="attr">height</span>=<span class="string">&quot;149&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 0; right: 0; border: 0;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img-blog.csdnimg.cn/abe3797b7d77419b81ecc02dd1bf8c34.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;attachment-full size-full&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Fork me on GitHub&quot;</span> <span class="attr">data-recalc-dims</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>白色版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Follow me on CSDN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">width</span>=<span class="string">&quot;149&quot;</span> <span class="attr">height</span>=<span class="string">&quot;149&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 0; right: 0; border: 0;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img-blog.csdnimg.cn/1f8e1ef9be9f4f7db01fe3a2d57829de.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;attachment-full size-full&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Fork me on GitHub&quot;</span> <span class="attr">data-recalc-dims</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231925595-fellowme-csdn-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+next的侧边栏背景与字体颜色设置方法</title>
      <link href="/post/f8e8e418.html"/>
      <url>/post/f8e8e418.html</url>
      
        <content type="html"><![CDATA[<p>  由于next主题经过了几次更新，查阅了许多资料都说要修改<font color="red"> custom.styl </font>这个配置文件，但是我的主题内没有此文件，经过翻阅大量的资料，终于找到了侧边栏的配置文件位置。</p><p>  对于<font color="red"> Muse </font>和<font color="red"> Mist</font>主题，其侧边栏的配置文件为<code>Hexo\themes\hexo-theme-next\source\css\_schemes\Muse\_sidebar.styl</code>。</p><p>  对于<font color="red"> Pisces</font>和<font color="red"> Gemini</font>主题，其侧边栏的配置文件为<code>Hexo\themes\hexo-theme-next\source\css\_schemes\Pisces\_sidebar.styl</code>。</p><p>  在此配置文件中，可以找到<font color="red"> .sidebar</font>，修改其内部的属性参数即可实现<strong>设置侧边栏背景图片和字体颜色</strong>的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">sidebar</span> &#123;</span><br><span class="line">  <span class="comment">//设置背景图片，图片放在Hexo\themes\hexo-theme-next\source\images目录下</span></span><br><span class="line">  <span class="attr">background</span>:<span class="title function_">url</span>(<span class="regexp">/images/</span>sidebar-bg.<span class="property">jpg</span>);</span><br><span class="line">  background-<span class="attr">size</span>: cover;</span><br><span class="line">  background-<span class="attr">position</span>:center;</span><br><span class="line">  background-<span class="attr">repeat</span>:no-repeat;</span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (not hexo-<span class="title function_">config</span>(<span class="string">&#x27;back2top.sidebar&#x27;</span>)) &#123;</span><br><span class="line">    box-<span class="attr">shadow</span>: inset <span class="number">0</span> 2px 6px black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">transition</span>: all $transition-ease-out;</span><br><span class="line">  <span class="attr">width</span>: $sidebar-desktop;</span><br><span class="line">  z-<span class="attr">index</span>: $zindex-<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  a &#123;</span><br><span class="line">    <span class="comment">//设置文字颜色</span></span><br><span class="line">border-bottom-<span class="attr">color</span>: #<span class="variable constant_">FFFFFF</span>;</span><br><span class="line"><span class="attr">color</span>: #<span class="variable constant_">FFFFFF</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">  border-bottom-<span class="attr">color</span>: $FFFFFF;</span><br><span class="line">  <span class="attr">color</span>: #<span class="variable constant_">FFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231923871-hexo-sidebar-1.png" alt=""></p><p>  另外，侧边栏中头像下方的作者姓名和描述的字体颜色，可以在根目录下的站点配置文件中<code>_config.yml</code>中修改。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Half_A</span> <span class="string">Studio</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Huffie&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="comment"># 例如设置白色字体的description</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&lt;font</span> <span class="string">color=&quot;#FFFFFF&quot;&gt;Done</span> <span class="string">is</span> <span class="string">better</span> <span class="string">than</span> <span class="string">perfect.&lt;/font&gt;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Control</span> <span class="string">Robot</span> <span class="string">Programming</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Huffie</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>设置完成后效果如下：</p><p><img src="https://img.mahaofei.com/img/202112231924723-hexo-sidebar-2.png" alt=""></p><p><a href="http://huffie.cn/">http://huffie.cn/</a>这是我的博客，可以在此查看效果。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo为文章设置目录与标签的方法</title>
      <link href="/post/c30fb19e.html"/>
      <url>/post/c30fb19e.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建目录页">1. 创建目录页</h3><p>  在网站根目录下执行以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>  <font color='red'> Hexo\source</font> 目录中会生成一个<font color='red'> categories </font>文件夹，文件夹内有一个<font color='red'> <a href="http://index.md">index.md</a> </font>文件，打开此文件，将其中的<font color='red'> type</font> 修改为<font color='red'> categories</font> 即可。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h3 id="2-创建标签页">2. 创建标签页</h3><p>  创建标签页与创建目录页方法相同。在网站根目录下执行以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>  <font color='red'> Hexo\source</font> 目录中会生成一个<font color='red'> tags</font>文件夹，文件夹内也有一个<font color='red'> <a href="http://index.md">index.md</a> </font>文件，打开此文件，将其中的<font color='red'> type</font> 修改为<font color='red'> tags</font> 即可。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h3 id="3-为文章设置目录与标签">3. 为文章设置目录与标签**</h3><p>  在<font color='red'> Hexo\source_posts</font> 目录中创建.md文件即新建了一篇博客，在文章的开头部分添加如下代码</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 这里是文章的标题</span><br><span class="line">date: 这里是发表时间，如：2021-08-15 08:15:16</span><br><span class="line">description: 这里填写摘要。也可以把摘要这一段删去，在文章中想要截断的地方加入&lt;!--more--&gt;，这样在首页就只显示开头到截断的内容，而不会显示全文</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 分类</span><br><span class="line"><span class="bullet">-</span> 子分类</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> 标签1</span><br><span class="line"><span class="section">- 标签2</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中next主题的个性化配置</title>
      <link href="/post/27cabb08.html"/>
      <url>/post/27cabb08.html</url>
      
        <content type="html"><![CDATA[<p>  Hexo与next主题的安装方法，网上有很多教程，这里不再赘述，直接开始next主题的配置方法。<br>  在Hexo中一般有两个_config.yml文件，一个在根目录下，我称之为网站配置文件，一个在主题目录中，我称之为主题配置文件。</p><h2 id="一、主题常用配置">一、主题常用配置</h2><p>next 主题的配置一般是指修改主题配置文件 <font color='red'> Hexo\themes\hexo-theme-next_config.yml </font> 文件。<br>在_config.yml 中可以修改许多常见的设置。</p><h3 id="1-更换主题（Scheme-Setting）">1. 更换主题（Scheme Setting）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主题</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 黑暗模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-菜单设置（Menu-Settings）">2. 菜单设置（Menu Settings）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用：菜单图标和项目徽章</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-侧边栏设置（Sidebar-Settings）">3. 侧边栏设置（Sidebar Settings）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 侧边栏位置</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 手动定义侧边栏宽度。如果注释，将默认为</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">240</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏显示 (只对 Muse | Mist 主题生效), 可用的变量有:</span></span><br><span class="line">  <span class="comment">#  - post    自动展开（默认值）</span></span><br><span class="line">  <span class="comment">#  - always  在所有页面显示侧边栏</span></span><br><span class="line">  <span class="comment">#  - hide    仅在单击侧边栏切换图标时展开</span></span><br><span class="line">  <span class="comment">#  - remove  完全删除侧边栏，包括侧边栏切换</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏填充像素</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="comment"># 侧边栏与顶部菜单栏的偏移量(像素) (只对 Pisces | Gemini 主题生效).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">b2t:</span> <span class="literal">true</span> <span class="comment">#是否提供一键置顶</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span> <span class="comment">#是否显示当前阅读进度</span></span><br></pre></td></tr></table></figure><h3 id="4-侧边栏头像（Sidebar-Avatar）">4. 侧边栏头像（Sidebar Avatar）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 侧边栏头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 替换默认图像并在这里设置头像的url</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># 如果为true，头像将以圆圈显示</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 如果为true，鼠标悬停在头像上时，头像将会旋转</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="5-社交链接（Social-Links）">5. 社交链接（Social Links）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/weixin_44543463</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-cuttlefish</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/HuffieMa</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:haofei_ma@163.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/huffie65380272</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure><blockquote><p>这里可能会需要自定义图标，可以在<a href="https://fontawesome.com/v5.15/icons">fontawesome</a>网站中搜索想要的图标，然后在这里使用 <code>fa fa-图标名称</code> 或  <code>fab fa-图标名称</code> 来调取所需要的图标。（如 <code>fab fa-cuttlefish</code> 、 <code>fa fa-grip-lines-vertical</code>）</p></blockquote><h2 id="二、网站配置">二、网站配置</h2><p>网站配置一般是指修改配置文件 <font color='red'> Hexo_config.yml </font> 文件。<br>在_config.yml 中可以修改许多常见的设置。</p><h3 id="1-网站基本配置（网站名称、作者名字、中英文切换）">1. 网站基本配置（网站名称、作者名字、中英文切换）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Half_A</span> <span class="string">Studio</span>  <span class="comment">#浏览器顶部标签栏的显示</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Huffie</span><span class="comment">#侧边栏中的作者名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#讲此处修改为zh-CN即可切换中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-主页显示文章数">2. 主页显示文章数</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure><h2 id="三、翻译设置">三、翻译设置</h2><p>网站切换为中文后，我们发现一些翻译不太符合我的要求，比如它把每一篇博客叫做日志，如果想修改，可以打开翻译配置文件 <font color='red'> Hexo\themes\hexo-theme-next\languages\zh-CN.yml</font> 进行修改</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】人脸检测的实现方法</title>
      <link href="/post/30c67132.html"/>
      <url>/post/30c67132.html</url>
      
        <content type="html"><![CDATA[<p>  <strong>本文的目标是实现对于摄像头内的人脸进行实时检测。</strong></p><h2 id="一、文件准备">一、文件准备</h2><p>  首先需要到opencv的<a href="https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector">github网站</a>上下载<code>opencv/samples/dnn/face_detector/</code>中所有的文件，并覆盖到本地的<code>...\opencv\sources\samples\dnn\face_detector</code>这个目录中。然后用记事本打开weights.meta4文件，下载其中两个url对应的文件。</p><p>  由于下载过程可能需要<strong>科学上网</strong>，因此我将所需要的文件打包 <a href="https://download.csdn.net/download/weixin_44543463/21068345">face_detector.zip</a>，大家将压缩包解压后将里面所有文件复制到本地目录<code>...\opencv\sources\samples\dnn\face_detector</code>中即可。</p><p><img src="https://img.mahaofei.com/img/202112231922222-opencv-notes15-1.png" alt=""></p><h2 id="二、程序设计">二、程序设计</h2><h3 id="2-1-主要函数">2.1 主要函数</h3><p><strong>1. blobFromImage()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">blobFromImage</span>(InputArray image, <span class="comment">//输入神经网络进行处理的图片</span></span><br><span class="line">  <span class="type">double</span>  scalefactor=<span class="number">1.0</span>, <span class="comment">//对像素值进行一定的尺度缩放</span></span><br><span class="line">      <span class="type">const</span>  Size&amp; size = <span class="built_in">Size</span>(),<span class="comment">//神经网络在训练的时候要求输入的图片尺寸</span></span><br><span class="line">  <span class="type">const</span>  Scalar&amp; mean = <span class="built_in">Scalar</span>(), <span class="comment">//需要将图片整体减去的平均值</span></span><br><span class="line">  <span class="type">bool</span> swapRB = <span class="literal">false</span>, <span class="comment">//BGR的顺序是否要交换，如果为true则为RGB</span></span><br><span class="line">  <span class="type">bool</span>  crop = <span class="literal">false</span>,<span class="comment">//是否需要裁剪</span></span><br><span class="line">  <span class="type">int</span>  ddepth = CV_32F</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>2. net.forward()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat probs = net.forward(); </span><br></pre></td></tr></table></figure><p>其输出有四个维度</p><ul><li>第一个维度：所有图像中每个图像的index</li><li>第二个维度：当前图像是第几个批次batchid，第几张图imageid</li><li>第三个维度：框的个数；</li><li>第四个维度：每个框有七个值，前两个是类型和dst，第三个是置信度，最后四个是矩形的左上角和右下角</li></ul><h3 id="2-2-示例程序-2">2.2 示例程序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::faceDetector_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建VideoCapture类</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">Mat frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">////读取模型和配置参数</span></span><br><span class="line">std::string root_dir = <span class="string">&quot;E:/Program/OpenCV/opencv/sources/samples/dnn/face_detector/&quot;</span>;</span><br><span class="line">dnn::Net net = dnn::<span class="built_in">readNetFromTensorflow</span>(root_dir+<span class="string">&quot;opencv_face_detector_uint8.pb&quot;</span>, root_dir+<span class="string">&quot;opencv_face_detector.pbtxt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实时检测</span></span><br><span class="line"><span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line"><span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line"><span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line">Mat blob = dnn::<span class="built_in">blobFromImage</span>(frame, <span class="number">1.0</span>, <span class="built_in">Size</span>(<span class="number">300</span>, <span class="number">300</span>), <span class="built_in">Scalar</span>(<span class="number">104</span>, <span class="number">177</span>, <span class="number">123</span>), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//scalefactor=1.0表示图像的色彩保存在0到255之间；size和mean参数保存在models.yml中。两个false表示不需要rgb的转换也不需要剪切</span></span><br><span class="line">net.<span class="built_in">setInput</span>(blob);<span class="comment">//将数据读入模型中。（blob结果是NCHW。N是个数，C通道数，H高度，W宽度）</span></span><br><span class="line">Mat probs = net.forward(); </span><br><span class="line"><span class="comment">//输出的第一个纬度所有图像中，每个图像的index；</span></span><br><span class="line"><span class="comment">//第二纬度，当前图像是第几个批次batchid，第几张图imageid；</span></span><br><span class="line"><span class="comment">//第三个纬度表示有多少个框；</span></span><br><span class="line"><span class="comment">//第四个纬度，每个框有七个值，前两个是类型和dst，第三个是置信度，最后四个是矩形的左上角和右上角</span></span><br><span class="line"><span class="function">Mat <span class="title">detectionMat</span><span class="params">(probs.size[<span class="number">2</span>], probs.size[<span class="number">3</span>], CV_32F, probs.ptr())</span></span>;</span><br><span class="line"><span class="comment">//框的个数为行数，每个框的七个值为每行的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; detectionMat.rows; i++) &#123;</span><br><span class="line"><span class="type">float</span> confidence = detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">2</span>);<span class="comment">//取出第三个值：置信度</span></span><br><span class="line"><span class="keyword">if</span> (confidence &gt; <span class="number">0.6</span>) &#123;</span><br><span class="line"><span class="comment">//再乘以图像的宽度或高度才能变为真实的</span></span><br><span class="line"><span class="type">int</span> x1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">3</span>) * frame.cols);</span><br><span class="line"><span class="type">int</span> y1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">4</span>) * frame.rows);</span><br><span class="line"><span class="type">int</span> x2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">5</span>) * frame.cols);</span><br><span class="line"><span class="type">int</span> y2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">6</span>) * frame.rows);</span><br><span class="line"><span class="function">Rect <span class="title">box</span><span class="params">(x1, y1, x2 - x1, y2 - y1)</span></span>;</span><br><span class="line"><span class="built_in">rectangle</span>(frame, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Face Dector&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">33</span>);<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231922622-opencv-notes15-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像的模糊处理方法（均值滤波与高斯模糊）</title>
      <link href="/post/f5f492d2.html"/>
      <url>/post/f5f492d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、均值滤波">一、均值滤波</h2><h3 id="1-1-均值滤波的原理">1.1 均值滤波的原理</h3><p>  均值滤波用到的是图像卷积原理。由下图所示，卷积核为三阶单位矩阵时，进行均值滤波，原图像的每个三阶子矩阵都会求其均值，并将均值赋给中间的元素。</p><p>  以左上角为例：<br>（$A_{11}$·1+$A_{12}$·1+$A_{13}$·1+<br> $A_{21}$·1+$A_{22}$·1+$A_{23}$·1+<br> $A_{31}$·1+$A_{32}$·1+$A_{33}$·1 ）/  9 -&gt;$A_{22}$</p><p><img src="https://img.mahaofei.com/img/202112231920160-opencv-notes14-1.png" alt=""></p><h3 id="1-2-OpenCV中的均值滤波">1.2 OpenCV中的均值滤波</h3><p>  在OpenCV/C++中，提供了blur函数用于实现上述的均值滤波操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">blur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size ksize,<span class="comment">//卷积核Size类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">Point anchor=Point(<span class="number">-1</span>,<span class="number">-1</span>),<span class="comment">//Point类型的锚点（-1表示锚点在核中心）</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> borderType=BORDER_DEFAULT<span class="comment">//边界模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>  其中 <code>Size(w, h)</code>来表示内核的大小，w 为像素宽度，h为像素高度。</p><p>  根据上面的 <code>blur()</code> 函数的定义，可以写出均值滤波的测试代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::blur_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">blur</span>(image, dst, <span class="built_in">Size</span>(<span class="number">10</span>, <span class="number">10</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Blur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  下图是卷积核为 <code>Size(10,10)</code> 的效果。</p><p><img src="https://img.mahaofei.com/img/202112231920250-opencv-notes14-2.png" alt=""></p><p>  下图为卷积核为 <code>Size(1,15)</code> 的效果。</p><p><img src="https://img.mahaofei.com/img/202112231921584-opencv-notes14-3.png" alt=""></p><h2 id="二、高斯模糊">二、高斯模糊</h2><p>  有时候我们并不希望模糊处理时卷积核的系数都一样。而高斯模糊就是用于解决这类问题的一个方法。高斯模糊产生的系数在中心最大，离中心越远系数越小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::GaussianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图片，可以使是任意通道数，该函数对通道是独立处理的</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图片</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size ksize,<span class="comment">//高斯内核大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> sigmaX,<span class="comment">//高斯内核在X方向的标准偏差</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> sigmaY,<span class="comment">//高斯内核在Y方向的标准偏差</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> borderType<span class="comment">//判断图像边界的模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>ksize</code>的行数和列数允许不相同，但必须是正奇数。<br>如果sigmaY为0，他将和sigmaX的值相同，如果他们都为0，那么他们由ksize的行数列数计算得出。</p><p>示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::gaussianBlur_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">GaussianBlur</span>(image, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;GaussianBlur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231921544-opencv-notes14-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】什么是图像的直方图？如何获取直方图？</title>
      <link href="/post/b524babf.html"/>
      <url>/post/b524babf.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是图像直方图">一、什么是图像直方图</h2><p>  图像直方图是图像像素值的统计学特征、计算代价较小，具有图像平移、旋转、缩放不变性等众多优点，广泛地应用于图像处理的各个领域，特别是灰度图像的阈值分割、基于颜色的图像检索以及图像分类、反向投影跟踪。常见的分为灰度直方图和颜色直方图。</p><p>  简单来说，图像对计算机来说就是一个一个像素点的数值，像素值又有一定的取值范围，所以我们可以统计出来这些像素值出现的频率，统计结果就是一个直方图。</p><p>  对图像进行平移、旋转等操作后，图像的直方图信息不会变化。因此即使两张图像的直方图完全一样，图像有可能不是同一个图像。</p><h2 id="二、如何计算图像直方图">二、如何计算图像直方图</h2><p>OpenCV中提供了如下的函数用于计算图像的直方图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcHist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Mat* images,<span class="comment">//源图像组</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nimages,<span class="comment">//源图像组图像个数</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">int</span>* channels,<span class="comment">//图像信道</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArray mask,<span class="comment">//可选的掩码，如果不为空，则必须是8-bit数组，而且大小和原图像相同</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray hist,<span class="comment">//输出直方图数组</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> dims,<span class="comment">//处理直方图的维数正数</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">int</span>* histSize,<span class="comment">//每一维的直方图的尺寸大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">float</span>** ranges,<span class="comment">//直方图每一维的数据大小范围</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> uniform=<span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> accumulate=<span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::histShow_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 三通道分离，用于分别绘制三个通道的直方图</span></span><br><span class="line">std::vector&lt;Mat&gt; bgr_plane;</span><br><span class="line"><span class="built_in">split</span>(image, bgr_plane);</span><br><span class="line"><span class="comment">// 定义参数变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> channels[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bins[<span class="number">1</span>] = &#123; <span class="number">256</span> &#125;;</span><br><span class="line"><span class="type">float</span> hranges[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">255</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span>* ranges[<span class="number">1</span>] = &#123; hranges &#125;;</span><br><span class="line">Mat b_hist;</span><br><span class="line">Mat g_hist;</span><br><span class="line">Mat r_hist;</span><br><span class="line"><span class="comment">// 计算Blue, Green, Red通道的直方图</span></span><br><span class="line"><span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), b_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"><span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), g_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"><span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), r_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示直方图</span></span><br><span class="line"><span class="type">int</span> hist_w = <span class="number">512</span>;</span><br><span class="line"><span class="type">int</span> hist_h = <span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> bin_w = <span class="built_in">cvRound</span>((<span class="type">double</span>)hist_w / bins[<span class="number">0</span>]);</span><br><span class="line">Mat histImage = Mat::<span class="built_in">zeros</span>(hist_h, hist_w, CV_8UC3);</span><br><span class="line"><span class="comment">// 归一化直方图数据</span></span><br><span class="line"><span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"><span class="built_in">normalize</span>(g_hist, g_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"><span class="built_in">normalize</span>(r_hist, r_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"><span class="comment">// 绘制直方图曲线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bins[<span class="number">0</span>]; i++) &#123;</span><br><span class="line"><span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line"><span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line"><span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line"><span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示直方图</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Histogram Demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Histogram Demo&quot;</span>, histImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231918681-opencv-notes13-1.png" alt=""></p><h2 id="三、二维直方图">三、二维直方图</h2><p>  我们知道RGB虽然有三个通道，但转到HSV色彩空间中只有H和S表示颜色，而V表示亮度。因此要表示一个图像的颜色只有两个维度H和S，因此可以组成一个平面的直方图形式。</p><p>  二维直方图的计算调用函数与一维直方图相同，使用的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::histShow2_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 2D 直方图</span></span><br><span class="line">Mat hsv, hs_hist;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//RGB转HSV</span></span><br><span class="line"><span class="type">int</span> hbins = <span class="number">30</span>, sbins = <span class="number">32</span>;<span class="comment">//设置二维直方图的直方个数</span></span><br><span class="line"><span class="type">int</span> hist_bins[] = &#123; hbins, sbins &#125;;</span><br><span class="line"><span class="type">float</span> h_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;<span class="comment">//H：0-180</span></span><br><span class="line"><span class="type">float</span> s_range[] = &#123; <span class="number">0</span>, <span class="number">256</span> &#125;;<span class="comment">//S：0-256</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span>* hs_ranges[] = &#123; h_range, s_range &#125;;</span><br><span class="line"><span class="type">int</span> hs_channels[] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;<span class="comment">//选择通道0和通道1</span></span><br><span class="line"><span class="built_in">calcHist</span>(&amp;hsv, <span class="number">1</span>, hs_channels, <span class="built_in">Mat</span>(), hs_hist, <span class="number">2</span>, hist_bins, hs_ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行归一化</span></span><br><span class="line"><span class="type">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">minMaxLoc</span>(hs_hist, <span class="number">0</span>, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//找到最大值</span></span><br><span class="line"><span class="type">int</span> scale = <span class="number">10</span>;</span><br><span class="line">Mat hist2d_image = Mat::<span class="built_in">zeros</span>(sbins * scale, hbins * scale, CV_8UC3);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; hbins; h++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; sbins; s++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> binVal = hs_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(h, s);</span><br><span class="line"><span class="type">int</span> intensity = <span class="built_in">cvRound</span>(binVal * <span class="number">255</span> / maxVal);</span><br><span class="line"><span class="built_in">rectangle</span>(hist2d_image, <span class="built_in">Point</span>(h * scale, s * scale),</span><br><span class="line"><span class="built_in">Point</span>((h + <span class="number">1</span>) * scale - <span class="number">1</span>, (s + <span class="number">1</span>) * scale - <span class="number">1</span>),</span><br><span class="line">Scalar::<span class="built_in">all</span>(intensity),</span><br><span class="line"><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">applyColorMap</span>(hist2d_image, hist2d_image, COLORMAP_JET);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;H-S Histogram&quot;</span>, hist2d_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231919044-opencv-notes13-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】摄像头视频的读取与存储</title>
      <link href="/post/4182df17.html"/>
      <url>/post/4182df17.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-如何读取摄像头">1. 如何读取摄像头</h3><p>  在图像处理中，读取视频并进行处理是必不可少的操作，在OpenCV中，读取摄像头的视频所用到的主要函数为 <code>capture()</code>。<br>  ①VideoCapture类的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>()</span><br><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">const</span> string&amp; filename)</span><br><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">int</span> device)</span><br></pre></td></tr></table></figure><p>  ②读取摄像头视频的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">VideoCapture&amp; capture.<span class="built_in">read</span>(Mat&amp; image)</span><br></pre></td></tr></table></figure><p>此函数用于捕获视频的每一帧，并返回刚刚捕获的帧如果没有视频帧被捕获，返回false。<br>  <br>  读取摄像头视频的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::video_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类</span></span><br><span class="line">Mat frame;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line"><span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line"><span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//每次循环显示一帧图像</span></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">10</span>);<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">capture.<span class="built_in">release</span>();<span class="comment">//释放视频</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-视频的存储">2. 视频的存储</h3><p>  视频的存储所用到的是 <code>VideoWriter </code> 类。所使用到的类属性和方法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> string&amp; filename,<span class="comment">//文件路径</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> fourcc,<span class="comment">//四个字符用来表示压缩帧的codec</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> fps,<span class="comment">//被创建视频流的帧率</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size frameSize,<span class="comment">//视频流的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> isColor=<span class="literal">true</span><span class="comment">//True则每一帧为彩色图，否则为灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中fourcc编码格式可选参数如下：</p><table><thead><tr><th>参数</th><th>编码格式</th></tr></thead><tbody><tr><td>CV_FOURCC(‘P’,‘I’,‘M’,‘1’)</td><td>MPEG-1</td></tr><tr><td>CV_FOURCC(‘M’,‘J’,‘P’,‘G’)</td><td>motion-jpeg</td></tr><tr><td>CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’)</td><td>MPEG-4.2</td></tr><tr><td>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘3’)</td><td>MPEG-4.3</td></tr><tr><td>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘X’)</td><td>MPEG-4</td></tr><tr><td>CV_FOURCC(‘U’, ‘2’, ‘6’, ‘3’)</td><td>H263</td></tr><tr><td>CV_FOURCC(‘I’, ‘2’, ‘6’, ‘3’)</td><td>H263I</td></tr><tr><td>CV_FOURCC(‘F’, ‘L’, ‘V’, ‘1’)</td><td>FLV1</td></tr><tr><td>-1</td><td>弹出一个编码器选择框</td></tr></tbody></table><p>保存摄像头视频的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::video_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类</span></span><br><span class="line"><span class="type">int</span> frame_width = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH);<span class="comment">//获取摄像头的宽、高</span></span><br><span class="line"><span class="type">int</span> frame_height = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line"></span><br><span class="line">VideoWriter writer;<span class="comment">//创建VideoWriter类</span></span><br><span class="line"><span class="type">int</span> fourcc = writer.<span class="built_in">fourcc</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;X&#x27;</span>);<span class="comment">//定义编码格式</span></span><br><span class="line">writer.<span class="built_in">open</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/test.mp4&quot;</span>, fourcc, <span class="number">30</span>, <span class="built_in">Size</span>(frame_width, frame_height), <span class="literal">true</span>);<span class="comment">//保存视频</span></span><br><span class="line"></span><br><span class="line">Mat frame;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line"><span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line"><span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line"><span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">writer.<span class="built_in">write</span>(frame);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//每次循环显示一帧图像</span></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">33</span>);<span class="comment">//两帧读取的间隔时间 1s/30fps=33ms</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">capture.<span class="built_in">release</span>();<span class="comment">//释放视频</span></span><br><span class="line">writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231918357-opencv-notes12-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像变换方法总结（放缩、翻转、旋转）</title>
      <link href="/post/81619dc7.html"/>
      <url>/post/81619dc7.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、图像放缩Resize">一、图像放缩Resize</h3><p><strong>1.1 基本知识</strong><br>  图像放缩用到了许多插值方法，常见的差值算法有线性插值、立方差值、双立方差值、采样放缩算法等等。<br>  所使用的API为 <code>resize()</code>，函数的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size dsize,<span class="comment">//输出尺寸</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> fx=<span class="number">0</span>,<span class="comment">//水平缩放比例</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> fy=<span class="number">0</span>,<span class="comment">//垂直缩放比例</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> interpolation=INTER_LINEAR<span class="comment">//插值方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>其中dsize为0时，fx和fy均不可为零；fx和fy为0时，输出图像按dsize输出</li><li>interpolation内插方式有以下四种：<ul><li>CV_INTER_NEAREST  最邻近插值点法</li><li>CV_INTER_LINEAR   双线性插值法</li><li>CV_INTER_AREA    邻域像素再取样插补</li><li>CV_INTER_CUBIC     双立方插补，4*4大小的补点</li></ul></li></ul></blockquote><p><strong>1.2 示例程序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::resize_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat zoomin, zoomout;<span class="comment">//定义输出图像</span></span><br><span class="line"><span class="type">int</span> h = image.rows;<span class="comment">//获取原图像的宽高</span></span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="built_in">resize</span>(image, zoomin, <span class="built_in">Size</span>(w * <span class="number">1.5</span>, h * <span class="number">1.5</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);<span class="comment">//图像放大1.5倍</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;zoomin&quot;</span>, zoomin);</span><br><span class="line"><span class="built_in">resize</span>(image, zoomout, <span class="built_in">Size</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);<span class="comment">//图像缩小2倍</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;zoomout&quot;</span>, zoomout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231913042-opencv-notes11-1.png" alt=""></p><h3 id="二、图像翻转flip">二、图像翻转flip</h3><p>  图像反转就是将图像左右或上下反转镜像。所用到的函数是 <code>flip()</code>，函数的定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::flip</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">cv::InputArray src, <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv::OutputArray dst, <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flipCode = <span class="number">0</span><span class="comment">// &gt;0: 沿y轴翻转, 0: 沿x轴翻转, &lt;0: x、y轴同时翻转</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>测试程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::flip_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">flip</span>(image, dst, <span class="number">0</span>);<span class="comment">//上下翻转</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;上下翻转&quot;</span>, dst);</span><br><span class="line"><span class="built_in">flip</span>(image, dst, <span class="number">1</span>);<span class="comment">//左右翻转</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;左右翻转&quot;</span>, dst);</span><br><span class="line"><span class="built_in">flip</span>(image, dst, <span class="number">-1</span>);<span class="comment">//对角线翻转（180°旋转）</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;对角线翻转（180°旋转）&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231916215-opencv-notes11-2.png" alt=""></p><h3 id="三、图像旋转warpAffine">三、图像旋转warpAffine</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpAffine</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArray M,<span class="comment">//变换矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">Sizedsize,<span class="comment">//输出图像大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>flags = INTER_LINEAR,<span class="comment">//插值方式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> borderMode = BORDER_CONSTANT,<span class="comment">//图像边缘像素模式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar&amp;borderValue = Scalar()<span class="comment">//边界填充值</span></span></span></span><br></pre></td></tr></table></figure><p>其中M变换矩阵可以通过如下函数获得，旋转矩阵的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M=cv2.<span class="built_in">getRotationMatrix2D</span>(center, angle, scale)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231916903-opencv-notes11-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231917769-opencv-notes11-4.png" alt=""></p><p>由于旋转之后，图像的大小会发生变化，因此需要重新计算图像的长宽，计算方法可以参考下图：</p><p><img src="https://img.mahaofei.com/img/202112231917211-opencv-notes11-5.png" alt=""></p><p>图像旋转的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::rotate_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst, M;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line">M = <span class="built_in">getRotationMatrix2D</span>(<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">45</span>, <span class="number">1.0</span>);<span class="comment">//定义变换矩阵M</span></span><br><span class="line"><span class="type">double</span> cos = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//求cos值</span></span><br><span class="line"><span class="type">double</span> sin = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//求sin值</span></span><br><span class="line"><span class="type">int</span> nw = cos * w + sin * h;<span class="comment">//计算新的长、宽</span></span><br><span class="line"><span class="type">int</span> nh = sin * w + cos * h;</span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) += (nw / <span class="number">2</span> - w / <span class="number">2</span>);<span class="comment">//计算新的中心</span></span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) += (nh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">warpAffine</span>(image, dst, M, <span class="built_in">Size</span>(nw,nh), INTER_LINEAR,<span class="number">0</span>,<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Rotation&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231917301-opencv-notes11-6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像像素数据类型的转换与归一</title>
      <link href="/post/f4ce9480.html"/>
      <url>/post/f4ce9480.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是归一化">一、什么是归一化</h2><p>  归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在一定范围的之内。为了后面数据处理的方便，其次是保证程序运行时收敛加快。<br>  归一化的目的，是使得没有可比性的数据变得具有可比性，同时又保持相比较的两个数据之间的相对关系，如大小关系；或是为了作图，原来很难在一张图上作出来，归一化后就可以很方便的给出图上的相对位置等。</p><h2 id="二、归一化的方式">二、归一化的方式</h2><h3 id="2-1-基本API">2.1 基本API</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">normalize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArray dst, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> alpha = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> beta = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> norm_type = NORM_L2, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> dtype = <span class="number">-1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray mask = noArray()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>src</td><td>输入数组</td></tr><tr><td>dst</td><td>输出数组</td></tr><tr><td>alpha</td><td>归一化最小值</td></tr><tr><td>beta</td><td>归一化最大值</td></tr><tr><td>norm_type</td><td>归一化的类型</td></tr><tr><td>dtype</td><td>负数时输出数组的type与输入数组的type相同</td></tr><tr><td>mask</td><td>指示函数是否仅仅对指定的元素进行操作</td></tr></tbody></table><p>其中norm_type有以下几种类型：</p><ul><li>NORM_MINMAX:数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。</li><li>NORM_INF:此类型的定义没有查到，根据OpenCV 1的对应项，可能是归一化数组的C-范数(绝对值的最大值)</li><li>NORM_L1 :  归一化数组的L1-范数(绝对值的和)</li><li>NORM_L2: 归一化数组的(欧几里德)L2-范数</li></ul><h3 id="2-2-示例程序">2.2 示例程序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::normalize_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line">std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;<span class="comment">//CV_8UC3</span></span><br><span class="line">image.<span class="built_in">convertTo</span>(image, CV_32F);<span class="comment">//像素数据转换为浮点数数据</span></span><br><span class="line">std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;<span class="comment">//CV_32FC3</span></span><br><span class="line"><span class="built_in">normalize</span>(image, dst, <span class="number">0</span>, <span class="number">1.0</span>, NORM_MINMAX);<span class="comment">//归一化</span></span><br><span class="line">std::cout &lt;&lt; dst.<span class="built_in">type</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Normalize&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】在OpenCV中响应键盘与鼠标操作</title>
      <link href="/post/a8150f32.html"/>
      <url>/post/a8150f32.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、键盘的响应">一、键盘的响应</h2><h3 id="1-1-基本知识-2">1.1 基本知识</h3><p>  按键的读取只需要使用waitKey()函数就可以实现，十分简单。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> waitKey（<span class="type">int</span> delay=<span class="number">0</span>）</span><br></pre></td></tr></table></figure><p>  <strong>函数参数为延时时间(ms)</strong>。<br>  delay&lt;=0时，等待时间无限长，按下按键时函数结束，<strong>返回按键的键值</strong>。·<br>  delay&gt;0时，等待delay毫秒按键响应，等待时间结束仍未按下按键则返回-1。</p><blockquote><p>本人opencv4+vs2019实操时，没有按键时不返回值，有按键按下时返回对应键值。</p></blockquote><h3 id="1-2-确定按键响应值">1.2 确定按键响应值</h3><p>  使用如下代码，可以测试自己的键盘对应的键值是多少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::key_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; k &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231911085-opencv-notes9-1.png" alt=""></p><h3 id="1-3-按键调节亮度">1.3 按键调节亮度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按下1时：图片亮度增大</span></span><br><span class="line"><span class="comment">按下2时，图片亮度减小</span></span><br><span class="line"><span class="comment">按下q时，程序退出*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::key_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(),image.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);<span class="comment">//增大或减小图片亮度的变化量</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">// Quit</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;1&#x27;</span>) &#123;<span class="comment">//Key 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;You enter key 1 - Lightness Up.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">add</span>(image, m, image);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;2&#x27;</span>) &#123;<span class="comment">//Key 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;You enter key 2 - Lightness Down.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">subtract</span>(image, m, image);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Key&quot;</span>, image);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、鼠标的响应">二、鼠标的响应</h2><h3 id="1-1-基本知识-3">1.1 基本知识</h3><p>  鼠标响应所使用的函数主要是 <code>setMouseCallback()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMousecallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> string&amp; winname,<span class="comment">//窗口的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function"> MouseCallback onMouse,<span class="comment">//鼠标响应回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">void</span>* userdata=<span class="number">0</span><span class="comment">//传给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>  其中onMouse响应回调函数函数，作用为指定窗口里每次鼠标时间发生的时候，被调用的函数指针。 这个函数的原型应该为的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_Mouse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> event,<span class="comment">//事件回传代号</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> x,<span class="comment">//鼠标指针在图像坐标系的坐标x</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>y,<span class="comment">//鼠标指针在图像坐标系的坐标y</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flags,<span class="comment">//CV_EVENT_FLAG的组合</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span>* userdata<span class="comment">//传递的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Event</th><th>作用</th></tr></thead><tbody><tr><td>EVENT_MOUSEMOVE</td><td>滑动</td></tr><tr><td>EVENT_LBUTTONDOWN</td><td>左键点击</td></tr><tr><td>EVENT_RBUTTONDOWN</td><td>右键点击</td></tr><tr><td>EVENT_MBUTTONDOWN</td><td>中键点击</td></tr><tr><td>EVENT_LBUTTONUP</td><td>左键放开</td></tr><tr><td>EVENT_RBUTTONUP</td><td>右键放开</td></tr><tr><td>EVENT_MBUTTONUP</td><td>中键放开</td></tr><tr><td>EVENT_LBUTTONDBLCLK</td><td>左键双击</td></tr><tr><td>EVENT_RBUTTONDBLCLK</td><td>右键双击</td></tr><tr><td>EVENT_MBUTTONDBLCLK</td><td>中键双击</td></tr></tbody></table><h3 id="1-2-示例程序">1.2 示例程序</h3><p>  在图像上实现拖动绘制矩形的画板功能。</p><p><img src="https://img.mahaofei.com/img/202112231912888-opencv-notes9-2.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">sp</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;<span class="comment">//起始点（初始值-1，-1）</span></span><br><span class="line"><span class="function">Point <span class="title">ep</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;<span class="comment">//结束点（初始值-1，-1）</span></span><br><span class="line">Mat temp;<span class="comment">//原图的克隆，用于实时刷新图片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_draw</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* userdata)</span> </span>&#123;</span><br><span class="line">Mat bg = *(Mat*)userdata;<span class="comment">//回调函数传过来的图像数据</span></span><br><span class="line"><span class="keyword">if</span> (event == EVENT_LBUTTONDOWN) &#123;<span class="comment">//如果左键被按下</span></span><br><span class="line">sp.x = x;<span class="comment">//保存左键按下时的xy值</span></span><br><span class="line">sp.y = y;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Start point: &quot;</span> &lt;&lt; sp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_LBUTTONUP) &#123;<span class="comment">//如果左键被抬起</span></span><br><span class="line">ep.x = x;<span class="comment">//保存左键抬起时的xy值</span></span><br><span class="line">ep.y = y;</span><br><span class="line"><span class="type">int</span> dx = ep.x - sp.x;<span class="comment">//计算矩形长宽</span></span><br><span class="line"><span class="type">int</span> dy = ep.y - sp.y;</span><br><span class="line"><span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>) &#123;<span class="comment">//当矩形长宽都为正数时</span></span><br><span class="line"><span class="function">Rect <span class="title">box</span><span class="params">(sp.x, sp.y, dx, dy)</span></span>;</span><br><span class="line"><span class="built_in">rectangle</span>(bg, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//绘制矩形</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, bg);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;ROI&quot;</span>, <span class="built_in">temp</span>(box));<span class="comment">//显示ROI区域（被框选的区域）</span></span><br><span class="line">sp.x = <span class="number">-1</span>;<span class="comment">//起始点坐标复位</span></span><br><span class="line">sp.y = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_MOUSEMOVE) &#123;</span><br><span class="line"><span class="keyword">if</span> (sp.x &gt; <span class="number">0</span> &amp;&amp; sp.y &gt; <span class="number">0</span>) &#123;<span class="comment">//当起始点坐标不是初始值，且鼠标移动时</span></span><br><span class="line">ep.x = x;</span><br><span class="line">ep.y = y;</span><br><span class="line"><span class="type">int</span> dx = ep.x - sp.x;</span><br><span class="line"><span class="type">int</span> dy = ep.y - sp.y;</span><br><span class="line"><span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="function">Rect <span class="title">box</span><span class="params">(sp.x, sp.y, dx, dy)</span></span>;</span><br><span class="line">temp.<span class="built_in">copyTo</span>(bg);<span class="comment">//刷新屏幕，清除上一循环绘制的矩形</span></span><br><span class="line"><span class="built_in">rectangle</span>(bg, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//绘制新矩形</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, bg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::mouseDrawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, WINDOW_AUTOSIZE);<span class="comment">//创建一个窗口</span></span><br><span class="line"><span class="built_in">setMouseCallback</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, on_draw,(<span class="type">void</span>*)(&amp;image));<span class="comment">//调用鼠标回调函数</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, image);</span><br><span class="line">temp = image.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】随机数的使用与随机线条的生成</title>
      <link href="/post/62112aac.html"/>
      <url>/post/62112aac.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、随机数的使用方法">一、随机数的使用方法</h2><p>  C和C++中提供了 <code>rand()</code> 和 <code>srand()</code> 函数用于产生随机数，使用C++编写OpenCV代码时也可以使用。同时OpenCV自身也提供了生成随机数的类RNG，使用起来也十分方便，以下主要介绍RNG类的使用方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RNG类对象的创建</span></span><br><span class="line"> <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="type">int</span> seed)</span></span>;<span class="comment">//使用种子seed产生一个RNG类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//产生一个在区间[a,b)的均匀分布的整数随机数</span></span><br><span class="line"><span class="type">int</span> x = rng.<span class="built_in">uniform</span>(a, b);</span><br><span class="line"><span class="comment">//产生一个在区间[0,1)的均匀分布的浮点随机数</span></span><br><span class="line"><span class="type">int</span> x = rng.<span class="built_in">uniform</span>(<span class="number">0.f</span>,<span class="number">1.f</span>);</span><br><span class="line"><span class="comment">//产生一个均值为0，标准差为2的高斯分布的随机数</span></span><br><span class="line"><span class="type">int</span> x = rng.<span class="built_in">gaussian</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="二、生成随机线条示例程序">二、生成随机线条示例程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::random_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);<span class="comment">//创建背景</span></span><br><span class="line"><span class="type">int</span> width = bg.cols;</span><br><span class="line"><span class="type">int</span> height = bg.rows;</span><br><span class="line"><span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">666</span>)</span></span>;<span class="comment">//种子随意设置</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//等待按键按下，同时限制两线条生成间隔实现</span></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x1 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, width);</span><br><span class="line"><span class="type">int</span> y1 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, height);</span><br><span class="line"><span class="type">int</span> x2 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, width);</span><br><span class="line"><span class="type">int</span> y2 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, height);</span><br><span class="line"><span class="type">int</span> b = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">int</span> g = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">int</span> r = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">line</span>(bg, <span class="built_in">Point</span>(x1, y1), <span class="built_in">Point</span>(x2, y2), <span class="built_in">Scalar</span>(b, g, r), <span class="number">1</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Randow image&quot;</span>, bg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231911051-opencv-notes8-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】几何图形的绘制方法</title>
      <link href="/post/904f4dcd.html"/>
      <url>/post/904f4dcd.html</url>
      
        <content type="html"><![CDATA[<p>  在正文开始之前，首先要知道屏幕中 <strong>(0, 0) 坐标点</strong>在左上角，最大坐标在右下角。</p><h2 id="一、基本图形的绘制">一、基本图形的绘制</h2><h3 id="1-矩形">1. 矩形</h3><p>  OpenCV中绘制矩形的函数为 <code>rectangle()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect rec, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>InputOutputArray img</td><td>要绘制的目标图像</td></tr><tr><td>Rect rec</td><td>rect类对象</td></tr><tr><td>const Scalar&amp; color</td><td>线条的颜色</td></tr><tr><td>int thickness = 1</td><td>正数表示线条宽度，-1表示填充矩形</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr><tr><td>int shift = 0</td><td>坐标点的小数点位数</td></tr></tbody></table><p>绘制矩形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制矩形</span></span><br><span class="line">Rect rect;</span><br><span class="line">rect.x = <span class="number">250</span>;<span class="comment">//左上端点x坐标</span></span><br><span class="line">rect.y = <span class="number">170</span>;<span class="comment">//左上端点x坐标</span></span><br><span class="line">rect.width = <span class="number">100</span>;<span class="comment">//宽度</span></span><br><span class="line">rect.height = <span class="number">100</span>;<span class="comment">//高度</span></span><br><span class="line"><span class="built_in">rectangle</span>(image, rect, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231909891-opencv-notes7-1.png" alt=""></p><h3 id="2-圆形">2. 圆形</h3><p>  OpenCV中绘制圆形的函数为 <code>rectangle()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::circle</span> <span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>InputOutputArray img</td><td>要绘制的目标图像</td></tr><tr><td>Point center</td><td>圆心坐标</td></tr><tr><td>int radius</td><td>圆的半径</td></tr><tr><td>const Scalar &amp;color</td><td>圆的颜色</td></tr><tr><td>int thickness=1</td><td>正数表示线条宽度，-1表示填充圆</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr><tr><td>int shift = 0</td><td>坐标点的小数点位数</td></tr></tbody></table><p>绘制圆形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制圆</span></span><br><span class="line"><span class="built_in">circle</span>(image, <span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">170</span>), <span class="number">20</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231909156-opencv-notes7-2.png" alt=""></p><p>  </p><h3 id="3-直线">3. 直线</h3><p>  OpenCV中绘制直线的函数为 <code>rectangle()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>InputOutputArray img</td><td>要绘制的目标图像</td></tr><tr><td>Point pt1r</td><td>端点1的坐标</td></tr><tr><td>Point pt2</td><td>端点2的坐标</td></tr><tr><td>const Scalar &amp;color</td><td>线条的颜色</td></tr><tr><td>int thickness=1</td><td>线条宽度</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr><tr><td>int shift = 0</td><td>坐标点的小数点位数</td></tr></tbody></table><p>绘制圆形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制直线</span></span><br><span class="line"><span class="built_in">line</span>(image, <span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">170</span>), <span class="built_in">Point</span>(<span class="number">350</span>, <span class="number">270</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231909658-opencv-notes7-3.png" alt="">  </p><h3 id="4-椭圆">4. 椭圆</h3><p>  OpenCV中绘制椭圆的函数为 <code>ellipse()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp;img, <span class="type">const</span> RotatedRect&amp;box, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>Mat&amp;img</td><td>要绘制的目标图像</td></tr><tr><td>const RotatedRect&amp;box</td><td>椭圆类</td></tr><tr><td>const Scalar &amp;color</td><td>椭圆的颜色</td></tr><tr><td>int thickness=1</td><td>正数表示线条宽度，-1表示填充圆</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr></tbody></table><blockquote><p>其中椭圆类RotatedRect的属性如下（示例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;RotatedRect rrt;<span class="comment">//创建对象</span></span><br><span class="line">&gt;rrt.center = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);<span class="comment">//椭圆中心点</span></span><br><span class="line">&gt;rrt.size = <span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);<span class="comment">//椭圆大小（横轴，纵轴长度）</span></span><br><span class="line">&gt;rrt.angle = <span class="number">0</span>;<span class="comment">//旋转角度</span></span><br></pre></td></tr></table></figure></blockquote><p>绘制圆形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制椭圆</span></span><br><span class="line">RotatedRect rrt;</span><br><span class="line">rrt.center = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">rrt.size = <span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">rrt.angle = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ellipse</span>(image, rrt, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910341-opencv-notes7-4.png" alt=""></p><p>  </p><h2 id="二、多边形绘制方法">二、多边形绘制方法</h2><p>  多边形绘制的本质是定义一个由多个点组成的点集，以此连接点集中的各个点，从而形成多边形。</p><h3 id="2-1-多边形边框">2.1 多边形边框</h3><p>  绘制多边形的边框使用到的函数是 <code>ploylines()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::polylines</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArrayimg,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrayspts,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span>isClosed,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>img</td><td>要绘制的目标图像</td></tr><tr><td>pts</td><td>提前构造的点集</td></tr><tr><td>isClosed</td><td>多边形是否是封闭图形</td></tr><tr><td>color</td><td>多边形边框的颜色</td></tr><tr><td>thickness</td><td>线条宽度（只能为正数）</td></tr><tr><td>lineType</td><td>线条的类型</td></tr><tr><td>shift</td><td>坐标点的小数点位数</td></tr></tbody></table><p>示例程序：绘制五边形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建画布</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">std::vector&lt;Point&gt; pts;</span><br><span class="line">pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制多边形边框</span></span><br><span class="line"><span class="built_in">polylines</span>(bg, pts, <span class="literal">true</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>pts.push_back</code> 用于将点加入到点集数组中，用于不知道点集数量的情况。本程序已知共五个点，因此也可以使用如下的代码创建点集：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Point&gt; <span class="title">pts</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">pts[<span class="number">0</span>] = p1;</span><br><span class="line">pts[<span class="number">1</span>] = p2;</span><br><span class="line">pts[<span class="number">2</span>] = p3;</span><br><span class="line">pts[<span class="number">3</span>] = p4;</span><br><span class="line">pts[<span class="number">4</span>] = p5;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910682-opencv-notes7-5.png" alt=""></p><h3 id="2-2-多边形填充">2.2 多边形填充</h3><p>  绘制填充的多边形使用到的函数是 <code>fillPoly()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::fillPoly</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArrayimg,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrayspts,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>img</td><td>要绘制的目标图像</td></tr><tr><td>pts</td><td>提前构造的点集</td></tr><tr><td>color</td><td>多边形边框的颜色</td></tr><tr><td>lineType</td><td>线条的类型</td></tr><tr><td>shift</td><td>坐标点的小数点位数</td></tr></tbody></table><p>示例程序：绘制填充的五边形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建画布</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">std::vector&lt;Point&gt; pts;</span><br><span class="line">pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制封闭的五边形</span></span><br><span class="line"><span class="built_in">fillPoly</span>(bg, pts, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910612-opencv-notes7-6.png" alt=""></p><h3 id="2-3-绘制多个多边形">2.3 绘制多个多边形</h3><p>  绘制多个多边形使用到的函数是 <code>drawContours()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArray image,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> contourIdx,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> thickness=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> lineType=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray hierarchy=noArray(),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> maxLevel=INT_MAX,</span></span></span><br><span class="line"><span class="params"><span class="function">Point offset=Point() )</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>img</td><td>要绘制的目标图像</td></tr><tr><td>contours</td><td>输入的轮廓组，每一组轮廓由点vector构成</td></tr><tr><td>contourIdx</td><td>画第几个轮廓，如果该参数为负值，则画全部轮廓</td></tr><tr><td>color</td><td>线条的颜色</td></tr><tr><td>thickness</td><td>线条宽度，负值或CV_FILLED表示填充轮廓内部</td></tr><tr><td>lineType</td><td>线条的类型</td></tr></tbody></table><p>示例程序：绘制一个五边形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建画布</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">std::vector&lt;Point&gt; pts;</span><br><span class="line">pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加点集到contours</span></span><br><span class="line"><span class="comment">//（相当于contours是点集的集合）</span></span><br><span class="line">std::vector&lt;std::vector&lt;Point&gt;&gt; contours;</span><br><span class="line">contours.<span class="built_in">push_back</span>(pts);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制多边形</span></span><br><span class="line"><span class="built_in">drawContours</span>(bg, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910132-opencv-notes7-7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】教你替换绿幕背景</title>
      <link href="/post/a5e6c283.html"/>
      <url>/post/a5e6c283.html</url>
      
        <content type="html"><![CDATA[<p>绿幕图像的背景替换需要经历①色彩空间转换、②提取绿幕区域、③反转绿幕区域、④复制图像，其中遇到的各种函数和代码也都在本文有详细介绍。</p><h2 id="一、色彩空间转换">一、色彩空间转换</h2><p>  要去除绿幕图像中的绿幕，首先需要<strong>将图像转换到hsv色彩空间</strong>，这样方便后续对图像的处理。使用 <code>cvtcolor()</code> 函数可以完成色彩空间的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> code,<span class="comment">//转换方式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> dstCn = <span class="number">0</span><span class="comment">//目标图像通道数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>一般的使用方法如下，图像转换至hsv色彩空间的示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat hsv;<span class="comment">//存储转换后的hsv图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//进行色彩空间转换</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;hsv_image&quot;</span>, hsv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、提取绿幕区域">二、提取绿幕区域</h2><p>  图像转换到hsv色彩空间后，就可以进行色彩区域的提取了，这里使用的函数是 <code>inRange()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inRange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArraylowerb,<span class="comment">//下边界数组阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayupperb,<span class="comment">//上边界数组阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，由于HSV的取值范围为H(0-180)、S(0-255)、V(0-255)。因此上下边界数组阈值可以通过如下表格获取</p><table><thead><tr><th> </th><th>黑</th><th>灰</th><th>白</th><th>红</th><th>橙</th><th>黄</th><th>绿</th><th>青</th><th>蓝</th><th>紫</th></tr></thead><tbody><tr><td>hmin</td><td>0</td><td>0</td><td>0</td><td>0/156</td><td>11</td><td>26</td><td>35</td><td>78</td><td>100</td><td>125</td></tr><tr><td>hmax</td><td>180</td><td>180</td><td>180</td><td>10/180</td><td>25</td><td>34</td><td>77</td><td>99</td><td>124</td><td>155</td></tr><tr><td>smin</td><td>0</td><td>0</td><td>0</td><td>43</td><td>43</td><td>43</td><td>43</td><td>43</td><td>43</td><td>43</td></tr><tr><td>smax</td><td>255</td><td>43</td><td>30</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td></tr><tr><td>vmin</td><td>0</td><td>46</td><td>221</td><td>46</td><td>46</td><td>46</td><td>46</td><td>46</td><td>46</td><td>46</td></tr><tr><td>vmax</td><td>46</td><td>220</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td></tr></tbody></table><p>  由于本文要替换绿幕，所以选择绿色的阈值，分别是：hmin=35、hmax=77、smin=43、smax=255、vmin=46、vmax=255。因此可以得到<strong>下边界数组为 <code>Scalar(35, 43, 46)</code> ，上边界数组为 <code>Scalar(77, 255, 255)</code></strong> 。</p><p>  因此提取绿幕的程序如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat hsv;<span class="comment">//存储转换后的hsv图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//进行色彩空间转换</span></span><br><span class="line">Mat mask;<span class="comment">//存储提取绿幕区域后的图像</span></span><br><span class="line"><span class="built_in">inRange</span>(hsv, <span class="built_in">Scalar</span>(<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>), <span class="built_in">Scalar</span>(<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231907880-opencv-notes6-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231907662-opencv-notes6-2.png" alt=""></p><h2 id="三、替换背景">三、替换背景</h2><p>  前面已经完成了对绿幕区域的提取，接下来只需要对提取的区域反转，选择人物的区域，进而将人物复制到新背景即可。<br>  反转选择区域使用的是 <code>bitwise_not()</code> 函数。<br>  复制图像使用的是 <code>image.copyTo(newimage，mask)</code> 方法，作用是把mask和image重叠以后把mask中像素值为0（黑色）的点对应的image中的点变为透明，而保留其他点，将保留的点拷贝到newimage中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换色彩空间</span></span><br><span class="line">Mat hsv;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取绿幕区域</span></span><br><span class="line">Mat mask;</span><br><span class="line"><span class="built_in">inRange</span>(hsv, <span class="built_in">Scalar</span>(<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>), <span class="built_in">Scalar</span>(<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转提取人物区域</span></span><br><span class="line"><span class="built_in">bitwise_not</span>(mask, mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//人物复制到新背景中</span></span><br><span class="line">Mat bg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/plantbg.jpg&quot;</span>);<span class="comment">//背景图片</span></span><br><span class="line">image.<span class="built_in">copyTo</span>(bg, mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Finished&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231908540-opencv-notes6-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231908875-opencv-notes6-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像通道的分离、合并与混合方法（C++）</title>
      <link href="/post/54b66be1.html"/>
      <url>/post/54b66be1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像通道的分离">一、图像通道的分离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> cv::Mat&amp; image, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;Mat&gt;&amp; mv <span class="comment">// 输出的多通道序列（n个单通道序列）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>  输出的多通道序列一般使用 <code>std::vector&lt;Mat&gt; mv;</code> 来存储，<code>mv[0]</code> 、<code>mv[1]</code>、<code>mv[2]</code>、分别对应BGR三个通道。<br>  <br>  示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">std::vector&lt;Mat&gt; mv;</span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Blue Channel&quot;</span>, mv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Green Channel&quot;</span>, mv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Red Channel&quot;</span>, mv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231906925-opencv-notes5-1.png" alt=""></p><h2 id="二、通道的合并">二、通道的合并</h2><p>  但是现在显示的相当于是三张单通道的图像，也就相当于三张灰度图像。要想让三张图像恢复直观意义上的色彩，就需要使用下面通道合并的方法了。</p><p>  通道的合并需要用到 <code>merge()</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> vector&lt;cv::Mat&gt;&amp; mv, <span class="comment">// 输入的多通道序列(n个单通道序列)</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv::OutputArray dst <span class="comment">// 输出图像，包含mv</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>  根据 <code>merge()</code> 函数的定义，我们只需要控制输入的多通道数组 <code>mv[]</code> 中的三个值，就可以实现通道的合并。</p><p>  示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">std::vector&lt;Mat&gt; mv;</span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line"></span><br><span class="line">Mat m1,m2,m3;</span><br><span class="line">mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">mv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(mv, m1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Blue Channel&quot;</span>, m1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line">mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">mv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(mv, m2);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Green Channel&quot;</span>, m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line">mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(mv, m3);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Red Channel&quot;</span>, m3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231906838-opencv-notes5-2.png" alt=""></p><p>  我们已经知道如何将图像的三个通道提取出来了，因此我们可以将三个通道进行任意组合，合并出我们想要的图片。</p><h2 id="三、通道的混合">三、通道的混合</h2><p>  通道的混合也是将三个通道进行任意排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="type">void</span> <span class="title">mixChannels</span><span class="params">(<span class="type">const</span> Mat*src, <span class="type">size_t</span> nsrcs, Mat* dst, <span class="type">size_t</span> ndsts, <span class="type">const</span> <span class="type">int</span>* fromTo, <span class="type">size_t</span> npairs)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>src</td><td>输入矩阵</td></tr><tr><td>nsrcs</td><td>输入矩阵的个数</td></tr><tr><td>dst</td><td>输出矩阵</td></tr><tr><td>ndsts</td><td>输出矩阵的个数</td></tr><tr><td>fromTo</td><td>序号对向量</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line"><span class="type">int</span> ft[] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span> &#125;;<span class="comment">//互换1、3通道</span></span><br><span class="line"><span class="built_in">mixChannels</span>(&amp;image,<span class="number">1</span>, &amp;dst,<span class="number">1</span>, ft,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mix&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231906612-opencv-notes5-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】滚动条Trackbar的创建与使用详解</title>
      <link href="/post/9a77b96c.html"/>
      <url>/post/9a77b96c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Trackbar的创建方法">一、Trackbar的创建方法</h2><h3 id="1-1-createTrackbar">1.1 createTrackbar</h3><p>  OpenCV中使用<code>createTrackbar()</code>来创建滚动条，函数的使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">createTrackbar</span>(<span class="type">const</span> String&amp; trackbarname, <span class="type">const</span> String&amp; winname,<span class="type">int</span> value, <span class="type">int</span> count,TrackbarCallback onChange = <span class="number">0</span>,<span class="type">void</span> userdata = <span class="number">0</span>); </span><br></pre></td></tr></table></figure><table><thead><tr><th>位置</th><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>trackbar name</td><td>滚动条的名字</td></tr><tr><td>2</td><td>winname</td><td>绑定的窗口名字</td></tr><tr><td>3</td><td>value</td><td>滑块的初始位置</td></tr><tr><td>4</td><td>count</td><td>滑块的最大位置</td></tr><tr><td>5</td><td>TrackbarCallback</td><td>回调函数，拨动Trackbar返回的函数</td></tr><tr><td>6</td><td>userdata</td><td>用户传给回调函数的数据，不用默认为0</td></tr></tbody></table><h3 id="1-2-回调函数">1.2 回调函数</h3><p>  第五个参数回调函数TrackbarCallback，是指拨动Trackbar会产生一个事件，系统会捕捉这个事件，然后发送给相应的处理者，因此需要定义一个函数进行相应的处理。回调函数的定义规范如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callbackfunc</span><span class="params">(<span class="type">int</span> value, <span class="type">void</span>* userdata)</span></span>;</span><br></pre></td></tr></table></figure><p>value传入的是滑块位置变量。<br>userdata是打包的其他数据，可以通过如结构体的方法打包数据发送给回调函数。当createTrackbar函数最后一个参数为0时表示不使用userdata，这时可以通过全局变量为回调函数传递数据。</p><h2 id="二、使用Trackbar调节图片亮度">二、使用Trackbar调节图片亮度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分代码</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onTrack</span><span class="params">(<span class="type">int</span> lightness, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">Mat src = *(Mat*)data;<span class="comment">//将void类型指针转换为Mat类型指针，然后再取数据</span></span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(lightness, lightness, lightness);</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(src, m, dst);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Change Lightness&quot;</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::checkBar_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Change Lightness&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lightness = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> max_value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Value Bar&quot;</span>, <span class="string">&quot;Change Lightness&quot;</span>, &amp;lightness, max_value, onTrack,(<span class="type">void</span> *)&amp;image);<span class="comment">//最后一个参数强制转换为void类型指针</span></span><br><span class="line"><span class="built_in">onTrack</span>(lightness, &amp;image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231905321-opencv-notes4-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】如何操作图像中的像素?</title>
      <link href="/post/3b23ab0d.html"/>
      <url>/post/3b23ab0d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、读写操作">一、读写操作</h2><h3 id="1-1-数组遍历">1.1 数组遍历</h3><p>  由于图像本质就是Mat矩阵，因此要读写像素点，可以<strong>采用数组遍历的方式访问</strong>Mat矩阵内的每一个元素。但我们要注意，灰度图和彩色图的通道数是不一样的，<strong>灰度图是单通道的，彩色图是三通道的</strong>。因此读写像素点就分为了读写灰度图像素和读写彩色图像素两种情况。</p><p>① 读写灰度图像素</p><p>  灰度图内每一个像素点对应Mat矩阵的一个值，因此访问灰度图的像素就相当于访问Mat矩阵的元素。其语法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读灰度图像素</span></span><br><span class="line"><span class="type">int</span> pv = image.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line"><span class="comment">//写灰度图像素（反转颜色）</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br></pre></td></tr></table></figure><p>  其中由于每个灰度图像素为1个字节（0-255），因此使用uchar。其中的row代表Mat矩阵行数，col代表列数。</p><p>② 读写彩色图像</p><p>  彩色图像中每个像素点对应Mat矩阵的三个值，访问方式类似灰度图像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读彩色图像素</span></span><br><span class="line">Vec3b bgr = image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line"><span class="comment">//写彩色图像素（反转颜色）</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - bgr[<span class="number">0</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - bgr[<span class="number">1</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - bgr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>  由于访问彩色图像素点需要一次性读取三个值，因此我们使用了Vec3b这个结构（可以看成一个数组），可以直接将访问得到的三个值存储在Vec3b这个结构定义的变量中。<br>  如果彩色像素点的值是整型，需要用Vec3i；如果是浮点数类型，需要用vec3f。</p><p>③ 示例程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::pixelVisit_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> pv = image.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line">image.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//彩色图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">Vec3b bgr = image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - bgr[<span class="number">0</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - bgr[<span class="number">1</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - bgr[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Pixel Visit Demo&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231901936-opencv-notes3-1.png" alt=""></p><h3 id="1-2-指针遍历">1.2 指针遍历</h3><p>  指针遍历的原理与数组遍历类似。定义一个指针指向当前行的首地址，然后利用此指针即可遍历访问本行所有像素点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::pixelVisit_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line">uchar* current_row = image.<span class="built_in">ptr</span>&lt;uchar&gt;(row);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//彩色图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Pixel Visit Demo&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>current_row</code>随着循环的进行指向每一行的首地址。<br><code>*current_row++ = 255 - *current_row;</code>是指将 current_row 指向的值（灰度图的像素点或彩色图像素点的一个通道）色彩反转，然后令指针+1，使其指向下一个像素或像素的下一个通道。</p><h2 id="二、算术操作">二、算术操作</h2><h3 id="2-1-像素的">2.1 像素的</h3><p>  对一个图像Mat矩阵可以直接进行加减乘除（注意彩色图加法需要Scalar），<strong>加减法处理的结果就是增大/减小图像的亮度，乘除法同理</strong>，但要注意在处理时可能会使像素值<strong>超出(0~255)的范围，可以使用saturate_cast函数进行截断</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//image * m -&gt; dst</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::operators_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> pv = image.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line">image.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//彩色图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">Vec3b p1 = image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line">Vec3b p2 = m.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(p1[<span class="number">0</span>] * p2[<span class="number">0</span>]);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(p1[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(p1[<span class="number">2</span>] * p2[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;operator&quot;</span>,dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231901960-opencv-notes3-2.png" alt=""></p><h3 id="2-2-图像算术操作API">2.2 图像算术操作API</h3><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>加法</td><td>add(img1, img2, imgout);</td></tr><tr><td>减法</td><td>subtract(img1, img2, imgout);</td></tr><tr><td>乘法</td><td>multiply(img1, img2, imgout);</td></tr><tr><td>除法</td><td>divide(img1, img2, imgout);</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::operators_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add(image, m, dst);</span></span><br><span class="line"><span class="comment">//subtract(image, m, dst);</span></span><br><span class="line"><span class="built_in">multiply</span>(image, m, dst);</span><br><span class="line"><span class="comment">//divide(image, m, dst);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;operator&quot;</span>,dst);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、逻辑操作">三、逻辑操作</h2><h3 id="3-1-基本知识—真值表">3.1 基本知识—真值表</h3><table><thead><tr><th>A</th><th>B</th><th>与</th><th>或</th><th>异或</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h3 id="3-2-画个矩形">3.2 画个矩形</h3><p>  为了更直观的显示像素逻辑运算的结果，我们可以画两个矩形，让两个矩形的相交区域进行逻辑运算。<br>  画矩形方法很简单，只需要先创建一个空白图像，然后调用rectangle函数就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(被处理图像, 左上点坐标, 颜色, 线宽, 线型, 坐标点的小数点位数);</span><br></pre></td></tr></table></figure><p>示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::bitWise_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m1 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(m2, <span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-逻辑运算">3.3 逻辑运算</h3><table><thead><tr><th>运算</th><th>函数</th></tr></thead><tbody><tr><td>与</td><td>bitwise_and(m1, m2, dst);</td></tr><tr><td>或</td><td>bitwise_or(m1, m2, dst);</td></tr><tr><td>非</td><td>bitwise_not(m1, dst);</td></tr><tr><td>异或</td><td>bitwise_xor(m1, m2, dst);</td></tr></tbody></table><p>以“与”操作为例，试验代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::bitWise_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m1 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(m2, <span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">bitwise_and</span>(m1, m2, dst);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;bitWise&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>区域</th><th>颜色</th></tr></thead><tbody><tr><td>背景</td><td>Scalar(0, 0, 0)</td></tr><tr><td>矩形1</td><td>Scalar(255, 255, 0)</td></tr><tr><td>矩形2</td><td>Scalar(0, 255, 255)</td></tr><tr><td>相交区域</td><td>Scalar(0, 255, 0)</td></tr><tr><td>其他区域</td><td>Scalar(0, 0, 0)</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/202112231904528-opencv-notes3-3.png" alt=""></p><p>  其他的“或”、“非”、“异或”操作类似，有兴趣的可以自己尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像的基本操作</title>
      <link href="/post/49c93445.html"/>
      <url>/post/49c93445.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像色彩空间转换">一、图像色彩空间转换</h2><h3 id="1-1-基本知识">1.1 基本知识</h3><ol><li>色彩空间转换函数：cvtColor</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2GRAY = <span class="number">6</span><span class="comment">//6彩色到灰度</span></span><br><span class="line">COLOR_GRAY2BGR = <span class="number">8</span><span class="comment">//8灰度到彩色</span></span><br><span class="line">COLOR_BGR2HSV = <span class="number">40</span><span class="comment">//40BGR到HSV</span></span><br><span class="line">COLOR_HSV2BGR = <span class="number">54</span><span class="comment">//54HSV到BGR</span></span><br></pre></td></tr></table></figure><blockquote><p>GRAY：指灰度，只有一个参数灰度值Channel<br>BGR：指BGR颜色空间，以红绿蓝三基色(0~255)为基础，叠加形成各种颜色<br>HSV：指六角椎体模型，色调Hue用角度度量（0~180），饱和度Saturation（0 ~ 255），亮度Value（0 ~ 255）</p><p><img src="https://img.mahaofei.com/img/202112231855797-opencv-notes2-1.png" alt=""></p></blockquote><ol start="2"><li>图像保存函数：imwrite</li></ol><blockquote><p>第一个参数是图像保存路径<br>第二个参数是图像内存对象</p></blockquote><h3 id="1-2-创建类">1.2 创建类</h3><p>①首先添加一个头文件。</p><p><img src="https://img.mahaofei.com/img/202112231855462-opencv-notes2-2.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231855694-opencv-notes2-3.png" alt=""><br>  </p><p>②头文件内定义一个MyDemo类，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorSpace_Demo</span><span class="params">(Mat &amp;image)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>③添加包含目录。首先在项目名称上<strong>右键-属性</strong>，打开属性页后，编辑<strong>VC++目录-&gt;包含目录</strong>这一项，新建项为头文件所在的目录如图。</p><p><img src="https://img.mahaofei.com/img/202112231856379-opencv-notes2-4.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231856267-opencv-notes2-5.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231856561-opencv-notes2-6.png" alt=""></p><p>  </p><p>④创建一个cpp文件，实现刚才定义的类。</p><p><img src="https://img.mahaofei.com/img/202112231856499-opencv-notes2-7.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::colorSpace_Demo</span><span class="params">(Mat &amp;image)</span> </span>&#123;</span><br><span class="line">Mat gray, hsv;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);</span><br><span class="line"><span class="built_in">cvtColor</span>(image, gray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;HSV Image&quot;</span>, hsv);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Gray Image&quot;</span>, gray);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/hsv.png&quot;</span>, hsv);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/gray.png&quot;</span>, gray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-编写主函数">1.3 编写主函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/opencv.jpg&quot;</span>);<span class="comment">//自己找一张图片</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;opencv.jpg&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">MyDemo demo;</span><br><span class="line">demo.<span class="built_in">colorSpace_Demo</span>(src);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-测试结果">1.4 测试结果</h3><p><img src="https://img.mahaofei.com/img/202112231857455-opencv-notes2-8.png" alt=""></p><p>  </p><blockquote><p>使用技巧：由于RGB三个参数仅代表颜色，HSV分别代表色调、饱和度、亮度。<br>因此对于一个图片想要调整亮度，可以先转换到HSV色彩空间调节亮度，再返回RGB色彩空间即可。</p></blockquote><h2 id="二、图像对象的创建与复制">二、图像对象的创建与复制</h2><h3 id="2-1-什么是Mat">2.1 什么是Mat</h3><blockquote><p>关于Mat的问题</p><ol><li>如何操作读进来的图像</li><li>如何遍历访问图像的每个像素点</li><li>如何创建一个空图像</li></ol></blockquote><p>在OpenCV中Mat的数据分为两个部分，<strong>头部和数据部分</strong>。头部包括数据类型、通道数量。</p><h3 id="2-2-创建空白图像">2.2 创建空白图像</h3><p><strong>创建图像的过程</strong><br>①所用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat m_new = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br></pre></td></tr></table></figure><p>函数中的参数CV_8UC1，表示8位、unsigned char型、Channel通道数为1。</p><p>②添加头文件</p><p>接下来写demo尝试创建图像，在头文件内添加一行函数的声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorSpace_Demo</span><span class="params">(Mat&amp; image)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matCreation_Demo</span><span class="params">()</span></span>;<span class="comment">//这一行是新加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>③实现创建图像的函数</p><p>在mydemo.cpp文件中添加以下代码实现此函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白图像</span></span><br><span class="line">Mat m_new = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;width = &quot;</span> &lt;&lt; m_new.cols &lt;&lt; <span class="string">&quot;\theight = &quot;</span> &lt;&lt; m_new.rows &lt;&lt; <span class="string">&quot;\tchannels = &quot;</span> &lt;&lt; m_new.<span class="built_in">channels</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; m_new &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④主函数调用并测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyDemo demo;</span><br><span class="line">demo.<span class="built_in">matCreation_Demo</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图所示，是一个8x8的矩阵：<br><img src="https://img.mahaofei.com/img/202112231857465-opencv-notes2-9.png" alt=""></p><p><strong>注意事项：</strong><br>  <br>如果将通道数改为3，也就是<code>Mat m_new = Mat::zeros(Size(8, 8),CV_8UC3);</code>，那么输出结果会变成8x24的矩阵，也就是每个像素点会有三个值：</p><p><img src="https://img.mahaofei.com/img/202112231857776-opencv-notes2-10.png" alt=""><br>  </p><p>如果对三通道使用ones进行初始化，那么只会使每个像素点的第一个通道初始化为1，第二、第三通道仍然初始化为0.</p><p><img src="https://img.mahaofei.com/img/202112231857740-opencv-notes2-11.png" alt=""><br>  </p><p>可以通过使用<code>Scalar</code>函数对图像所有像素点同时进行赋值。<strong>Scalar的三个参数分别为B、G、R</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白图像</span></span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC3);</span><br><span class="line">m_new = <span class="built_in">Scalar</span>(<span class="number">66</span>, <span class="number">66</span>, <span class="number">66</span>);</span><br><span class="line">std::cout &lt;&lt; m_new &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231858306-opencv-notes2-12.png" alt=""></p><p>  </p><p><strong>图像在哪里</strong><br>刚才我们通过io输出，在控制台将图像的像素点值一个一个打印出来。我们当然也可以将它作为一个图像进行输出。只需要将cout换成imshow即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白图像</span></span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">800</span>, <span class="number">600</span>),CV_8UC3);</span><br><span class="line">m_new = <span class="built_in">Scalar</span>(<span class="number">66</span>, <span class="number">66</span>, <span class="number">66</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;new image&quot;</span>,m_new);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们生成出来的一个图像</p><p><img src="https://img.mahaofei.com/img/202112231858552-opencv-notes2-13.png" alt=""></p><h3 id="2-3-图像的复制">2.3 图像的复制</h3><p>对于Mat对象进行赋值操作时，只是相当于两个指针指向了同一块内存空间，只有进行<strong>克隆和拷贝</strong>操作时，才是真正的复制。</p><p>①克隆：clone</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_clone = image.<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure><p>②拷贝：copyTo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.<span class="built_in">copyTo</span>(m_copy);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】Win10下OpenCV4.5+VS2019安装与环境搭建（详细过程）</title>
      <link href="/post/d2828609.html"/>
      <url>/post/d2828609.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、软件准备">一、软件准备</h2><h3 id="1-1-下载并解压OpenCV">1.1 下载并解压OpenCV</h3><p>  建议到<a href="https://opencv.org/">opencv的官网</a>下载windows版本的安装包。</p><p><img src="https://img.mahaofei.com/img/202112231843882-opencv-notes1-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231843681-opencv-notes1-2.png" alt=""></p><p>  下载完之后，双击运行这个文件，<strong>注意解压的路径，一定要是一个英文路径</strong>，等待一段时间解压完成即可。</p><p><img src="https://img.mahaofei.com/img/202112231844664-opencv-notes1-3.png" alt=""></p><h3 id="1-2-下载并安装Visual-Studio">1.2 下载并安装Visual Studio</h3><p>  这里我使用的是Visual Studio 2019 专业版，<a href="https://visualstudio.microsoft.com/zh-hans/vs/">官网</a>就可以下载。使用其他版本的VS也可以，没有特别要求。</p><p>  安装时勾选<strong>使用C++的桌面开发</strong>，然后修改安装位置，其他配置都可以默认。</p><p><img src="https://img.mahaofei.com/img/202112231844878-opencv-notes1-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231844934-opencv-notes1-5.png" alt=""></p><blockquote><p>安装完成后，如果需要VS2019 Pro注册码：<code>NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y</code></p></blockquote><h2 id="二、配置OpenCV环境">二、配置OpenCV环境</h2><h3 id="2-1-创建项目">2.1 创建项目</h3><p>  新建一个<strong>控制台项目</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231845061-opencv-notes1-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231845142-opencv-notes1-7.png" alt=""></p><p>  配置如下图中为<strong>Release</strong>和<strong>x64</strong>版本。</p><p><img src="https://img.mahaofei.com/img/202112231846358-opencv-notes1-8.png" alt=""></p><h3 id="2-2-配置属性">2.2 配置属性</h3><p>  打开<strong>视图-其他窗口-属性管理器</strong>（其他版本的VS可能是视图-属性管理器）。</p><p><img src="https://img.mahaofei.com/img/202112231846533-opencv-notes1-9.png" alt=""></p><p>  在属性管理器内<strong>右键“Microsoft Cpp x64 user”并点击属性</strong>，打开它的属性页。</p><p><img src="https://img.mahaofei.com/img/202112231846979-opencv-notes1-10.png" alt=""></p><p>  ①配置<strong>VC++ 目录-&gt;包含目录</strong></p><p><img src="https://img.mahaofei.com/img/202112231847544-opencv-notes1-11.png" alt=""></p><p>  在编辑页面添加两个新行，第一个是解压的opencv下面的  <strong><code>opencv/build/include</code></strong>  这个目录，第二个是  <strong><code>opencv/build/include/opencv2</code></strong>  这个目录，添加完成后点击确定回到属性页。</p><p><img src="https://img.mahaofei.com/img/202112231847282-opencv-notes1-12.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231847556-opencv-notes1-13.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231848108-opencv-notes1-14.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231848973-opencv-notes1-15.png" alt=""></p><p>  ②继续配置<strong>VC++目录-&gt;库目录</strong></p><p><img src="https://img.mahaofei.com/img/202112231849542-opencv-notes1-16.png" alt=""></p><p>  在编辑页面添加项  <strong><code>opencv/build/x64/vc15</code></strong>  ，添加完成后同样点击确定回到属性页。</p><blockquote><p>这里如果是vs2019，那么用最新的vc15会好一些，如果是之前的版本，可以选择vc14目录</p></blockquote><p><img src="https://img.mahaofei.com/img/202112231849165-opencv-notes1-17.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231850283-opencv-ontes1-18.png" alt=""></p><p>  ③继续配置<strong>链接器-&gt;输入-&gt;附加依赖性</strong></p><p><img src="https://img.mahaofei.com/img/202112231850837-opencv-notes1-19.png" alt=""></p><p>  复制release版本的lib文件名，在编辑项中粘贴即可</p><p><img src="https://img.mahaofei.com/img/202112231851269-opencv-notes1-20.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231851586-opencv-notes1-21.png" alt=""></p><p>  完成以上配置之后，点击右下角的<strong>应用-确定</strong>就可以了。</p><p><img src="https://img.mahaofei.com/img/202112231851285-opencv-notes1-22.png" alt=""></p><h3 id="2-3-配置环境变量">2.3 配置环境变量</h3><p>  复制bin文件夹目录。</p><p><img src="https://img.mahaofei.com/img/202112231852406-opencv-notes1-23.png" alt=""></p><p>  回到桌面，<strong>右键计算机-属性-高级系统设置</strong>，打开环境变量。</p><p><img src="https://img.mahaofei.com/img/202112231852254-opencv-notes1-24.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231852926-opencv-notes1-25.png" alt=""></p><p>  找到系统变量中的Path，点击编辑。</p><p><img src="https://img.mahaofei.com/img/202112231853801-opencv-notes1-26.png" alt=""></p><p>  添加一项新项，将刚才复制的bin文件夹目录粘贴过来，然后确定。</p><p><img src="https://img.mahaofei.com/img/202112231853227-opencv-notes1-27.png" alt=""></p><p>  <strong>关掉Visual Studio，再重新打开软件</strong>。</p><h2 id="三、测试程序">三、测试程序</h2><p>  在创建的cpp文件中，添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;F:/NutStore/Documents/素材库/Logo/Huffie.jpg&quot;</span>);<span class="comment">//自己找一张图片</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;input&quot;</span>, src);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成解决方案，如果没有报错，那么恭喜你！如果出现错误，那么请自习搜索一下错误原因，或者仔细检查以上的每一步。</p><p><img src="https://img.mahaofei.com/img/202112231854239-opencv-notes1-28.png" alt=""></p><p>测试-&gt;开始执行（不调试）</p><p><img src="https://img.mahaofei.com/img/202112231854619-opencv-notes1-29.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231854767-opencv-notes1-30.png" alt=""></p><p>  </p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 视觉 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proteus8.9 下载与安装教程</title>
      <link href="/post/abdfd22a.html"/>
      <url>/post/abdfd22a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>百度网盘链接：<a href="https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA">https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA</a><br>提取码: pr89</p><p>（百度网盘不限速下载方法：<a href="https://www.mahaofei.com/post/e5808c6a.html">https://www.mahaofei.com/post/e5808c6a.html</a>）</p></blockquote><ol><li><p>右键压缩包，进行解压。进入解压的文件夹，右键<strong>p8.9.sp0.exe</strong>文件，使用管理员身份打开。</p><p><img src="https://img.mahaofei.com/img/202112231758580-proteus89-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231759359-proteus89-2.png" alt=""></p><p>这里可能有些机器会先弹出安装Visual C++的一个界面，一定要安装这些勾选的组件，否则后续安装会出现问题。</p><p><img src="https://img.mahaofei.com/img/202112231759267-proteus89-3.png" alt=""></p></li><li><p>莫得选择，next</p><p><img src="https://img.mahaofei.com/img/202112231759476-proteus89-4.png" alt=""></p></li><li><p>I accept，然后next</p><p><img src="https://img.mahaofei.com/img/202112231800247-proteus89-5.png" alt=""></p></li><li><p>选择使用本地的激活证书license key。</p><p><img src="https://img.mahaofei.com/img/202112231800437-proteus89-6.png" alt=""></p></li><li><p>继续next</p><p><img src="https://img.mahaofei.com/img/202112231801080-proteus89-7.png" alt=""></p></li><li><p>这里会打开一个激活证书管理界面，点击左下角【Browse For Key File】，找到刚才解压出来的文件夹，里面解压后的【Proteus 8.9】文件夹中的【Crack】文件夹下的【Licence.lxk】文件，点击【打开】。</p><p><img src="https://img.mahaofei.com/img/202112231801887-proteus89-8.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231801966-proteus89-9.png" alt=""></p></li><li><p>点击 【<strong>install</strong>】，在弹出的对话框询问是否继续，选择 【<strong>是</strong>】，安装完成后点击【<strong>Close</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231802780-proteus89-10.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231802906-proteus89-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231802103-proteus89-12.png" alt=""></p></li><li><p>都不用勾选，直接【<strong>next</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231803096-proteus89-13.png" alt=""></p></li><li><p>这里选择安装方式，选择【<strong>Custom</strong>】，然后选择要安装的路径，<strong>注意：两个路径一定要一样，否则后期软件使用时会闪退</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231803498-proteus89-14.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231803440-proteus89-15.png" alt=""></p></li><li><p>这里不用管，默认【<strong>Next</strong>】就可以。</p><p><img src="https://img.mahaofei.com/img/202112231804160-proteus89-16.png" alt=""></p></li><li><p>继续【<strong>Next</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231804265-proteus89-17.png" alt=""></p></li><li><p>点击【<strong>Install</strong>】开始安装，安装耗时一分钟左右。</p><p><img src="https://img.mahaofei.com/img/202112231804748-proteus89-18.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231805753-proteus89-19.png" alt=""></p></li><li><p>点击【<strong>Close</strong>】，不要运行Proteus</p><p><img src="https://img.mahaofei.com/img/202112231805229-proteus89-20.png" alt=""></p></li><li><p>再次进入安装包解压后的【<strong>Proteus 8.9</strong>】文件夹中的【<strong>Crack</strong>】文件夹，选择所有文件【<strong>复制</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231805733-proteus89-21.png" alt=""></p></li><li><p>在桌面找到【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231806316-proteus89-22.png" alt=""></p></li><li><p>在空白处【<strong>右键-粘贴</strong>】，将刚才那三个文件复制过来。</p><p><img src="https://img.mahaofei.com/img/202112231806975-proteus89-23.png" alt=""></p></li><li><p>右键<strong>粘贴后</strong>的【<strong>pp8.9</strong>】选择【<strong>以管理员身份运行</strong>】。（运行完成后不会弹出任何对话窗，运行一下就可以），建议关闭各种安全管家之后再运行。</p><p><img src="https://img.mahaofei.com/img/202112231806092-proteus89-24.png" alt=""></p></li><li><p>再次打开解压后的【Proteus 8.9】文件夹，鼠标右击【Translations】选择【复制】。</p><p><img src="https://img.mahaofei.com/img/202112231806438-proteus89-25.png" alt=""></p></li><li><p>再次右键桌面【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231807721-proteus89-26.png" alt=""></p></li><li><p>点击路径中的【<strong>Proteus</strong>】文件夹，回到上一级。</p><p><img src="https://img.mahaofei.com/img/202112231807086-proteus89-27.png" alt=""></p></li><li><p>在空白处【<strong>右键-粘贴</strong>】，将刚才复制的Translation文件夹粘过来，可能会有27/28个同名文件，点击【<strong>替换目标中的文件</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231807620-proteus89-28.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231808223-proteus89-29.png" alt=""></p></li><li><p>进入【<strong>C:\Program Files (x86)\Labcenter Electronics</strong>】目录下，有一个【<strong>Proteus 8 Professional</strong>】文件夹，进入此文件夹，【<strong>全选-复制这两个文件夹</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231808875-proteus89-30.png" alt=""></p></li><li><p>回到Proteus的安装路径（同19、20步），【<strong>右键粘贴，替换目标文件</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231808897-proteus89-31.png" alt=""></p></li></ol><p><strong>至此，安装完成！</strong></p><p><img src="https://img.mahaofei.com/img/202112231809916-proteus89-32.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proteus </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview状态机的介绍与程序示例</title>
      <link href="/post/d55fc503.html"/>
      <url>/post/d55fc503.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、状态机简介">一、状态机简介</h2><p>  状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。<br>  Labview状态机是由<strong>一个While循环、一个条件结构和一个移位寄存器</strong>组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。</p><h2 id="二、状态机的基本框架">二、状态机的基本框架</h2><p>  在程序框图中创建一个while循环，并在while循环上添加移位寄存器，然后再while循环内创建一个条件结构，条件结构的选择端是一个枚举常量。</p><p><img src="https://img.mahaofei.com/img/202112231754270-labview-statemachine-1.png" alt=""></p><h2 id="三、例程">三、例程</h2><h3 id="3-1-运行效果">3.1 运行效果</h3><p>按下开始按钮后，LED开始以输入的时间间隔闪烁，按下停止按钮，程序停止运行。</p><p><img src="https://img.mahaofei.com/img/202112231755605-labview-statemachine-2.png" alt=""></p><h3 id="3-2-程序框图">3.2 程序框图</h3><p><strong>程序框图如下：</strong></p><p><img src="https://img.mahaofei.com/img/202112231755931-labview-statemachine-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231755009-labview-statemachine-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231756725-labview-statemachine-5.png" alt=""></p><p><strong>枚举类型的分支情况如下：</strong><br>  设置三项分别为：“开始”、“亮”、灭。然后在条件结构的分支处，<strong>右键-为每个值添加分支</strong><br>  其中左侧初始值与”开始“分支内的都是同一个枚举常量（即通过复制粘贴得到的）。</p><p><img src="https://img.mahaofei.com/img/202112231756475-labview-statemachine-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231757621-labview-statemachine-7.png" alt=""></p><h3 id="3-3-程序逻辑">3.3 程序逻辑</h3><ul><li><p>初始条件的输入值为“开始”，进入“开始”的条件分支进行判断。</p><ul><li>如果按钮按下，输出“亮”，并作为下一次条件的输入；</li><li>如果按钮未按下，输出“开始”，并作为下一次条件的输入，即保持原状态。</li></ul></li><li><p>如果条件的输入为“亮”，此时条件输出“灭”，并作为下一次的输入。</p></li><li><p>如果条件的输入为“灭”，此时条件输出“亮”，并作为下一次的输入。</p></li></ul><p>在“开始”和“灭”分支进行期间，为LED赋值False；在“亮”分支期间，为LED赋值True。</p><p>这样就实现了：启动程序后，程序一直循环执行“开始”分支，LED灯灭。按下按钮后，程序在“亮”分支和”灭“分支交替执行，实现LED灯的亮灭变化。</p><p>可以通过为while循环添加等待延时调整LED闪烁时间。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview子VI的创建与调用</title>
      <link href="/post/adea5358.html"/>
      <url>/post/adea5358.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="一、什么是子VI">一、什么是子VI</h2><p>  程序设计中很重要的一个思想就是模块化思想，也就是将程序划分为若干个区块，这样对程序某个区块进行修改就不会影响到其它区块。在Labview中，我们通过子VI来实现模块化的编程。</p><p>  任何一个VI本身就可以作为子VI被其他VI调用，子VI只是需要在普通VI的基础上定义连接端子和图标即可。当一个VI被其它VI调用，则该VI被称为子VI，子VI相当于程序语言中的子程序。</p><h2 id="二、子VI的创建与调用">二、子VI的创建与调用</h2><p>  这里以角度转弧度的函数为例，说明子VI的创建和调用方法。</p><h3 id="2-1-子VI的创建">2.1 子VI的创建</h3><p>  如下图是一个将角度转为弧度值的简单程序。</p><p><img src="https://img.mahaofei.com/img/202112231751031-labview-subvi-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231751951-labview-subvi-2.png" alt=""></p><p><strong>（1）定义接线端</strong><br>  在前面板中右上角的小框框中，点击选择一个接线端的位置，然后再点击这个接线端要对应的输入输出控件，若方块变红，说明这个接线端设置完成了。</p><p><img src="https://img.mahaofei.com/img/202112231752167-labview-subvi-3.png" alt=""></p><p>  例如，先点击小框框左上角的小方块，会发现点击的小方块变黑，然后点击角度控件，会看到小方块变橙色，这就说明子VI左上角的接线端被设定为角度输入。同理可设置右上角的接线端为弧度输出。</p><p><img src="https://img.mahaofei.com/img/202112231752811-labview-subvi-4.png" alt=""></p><p><strong>（2）设置图标</strong><br>  双击右上角的图标，可以打开一个图标编辑器。这里可以使用Labview的模板图标，也可以自己画图标，画图标的方法与windows中的画图工具很类似。</p><p><img src="https://img.mahaofei.com/img/202112231752559-labview-subvi-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231753259-labview-subvi-6.png" alt=""></p><h3 id="2-2-子VI的调用">2.2 子VI的调用</h3><p>  新建一个VI，在程序框图的空白处<strong>右键-选择VI…</strong>，打开刚才保存的子VI程序，可以看到我们刚刚创建的子VI被调用出来了。</p><p><img src="https://img.mahaofei.com/img/202112231753319-labview-subvi-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231753218-labview-subvi-8.png" alt=""></p><p>  可以利用这个子VI创建一个简单的正弦曲线。</p><p><img src="https://img.mahaofei.com/img/202112231754560-labview-subvi-9.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview实现画板</title>
      <link href="/post/eced631e.html"/>
      <url>/post/eced631e.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="一、所用控件介绍">一、所用控件介绍</h2><h3 id="1-1-二维图片">1.1 二维图片</h3><p>  添加方法：前面板右键，图形-控件-二维图片。<br>  二维图片控件可实现像素级控制，能用于创建几乎任何图形对象。如需在二维图片控件中显示图像，必须通过编程向该控件写入一个图像。可使用图片函数VI进行绘制。</p><h3 id="1-2-属性节点">1.2 属性节点</h3><p>  控件的属性节点和控件本身的属性是相同的，在控件上右键单击，选择  创建-属性节点-值，即可创建一个value属性节点</p><h2 id="二、使用二维图片空间画画">二、使用二维图片空间画画</h2><h3 id="2-1-目的">2.1 目的</h3><p><img src="https://img.mahaofei.com/img/202112231745172-labview-drawpad-1.png" alt=""></p><h3 id="2-2-程序设计思路">2.2 程序设计思路</h3><p>（1）使用二维图片的鼠标位置属性节点，获取当前鼠标的位置。<br>（2）使用图片函数中的绘制点函数，对传入的鼠标位置画点。<br>（3）利用移位寄存器将画好点的图片传入下一次循环，作为下一次循环时画点的画布。<br>（4）使用二维图片的鼠标按下属性节点，通过条件结构判断鼠标是否按下，以此控制是否画点。<br>（5）清屏可以使用一个条件结构，清屏按钮按下时，将空白画布传给移位寄存器。</p><h3 id="2-3-程序实现过程">2.3 程序实现过程</h3><p><strong>（1）获取鼠标位置</strong><br>  首先，在前面板创建一个二维图片（右键-图形-控件-二维图片）。然后在<strong>程序框图中</strong>右键二维图片控件，<strong>右键-创建-属性节点-鼠标</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231745410-labview-drawpad-2.png" alt=""></p><p>  将二维图片的属性节点按名称解绑，然后在Mouse Position的输出端点创建显示控件。这样就实现了获取鼠标位置。为整体添加一个while循环，运行看一下效果。</p><p><img src="https://img.mahaofei.com/img/202112231746815-labview-drawpad-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231746645-labview-drawpad-4.png" alt=""></p><p><strong>（2）画出当前点</strong><br>  在程序框图中，<strong>右键-图形与声音-图片函数-绘制点</strong>，将解绑出来的鼠标位置作为输入，二维图片空间作为输出。然后在颜色、画笔两个接线端上右键-创建输入控件。</p><p><img src="https://img.mahaofei.com/img/202112231746622-labview-drawpad-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231747657-labview-drawpad-6.png" alt=""></p><p><strong>（3）画出连续的点，即保存之前鼠标经过的点</strong><br>  将刚才画好点的二维图片，通过移位寄存器传入下一次循环，作为下一次循环要画点的初始图片。（注意：移位寄存器使用时一定要初始化）</p><p><img src="https://img.mahaofei.com/img/202112231747597-labview-drawpad-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231748368-labview-drawpad-8.png" alt=""></p><p><strong>（4）实现鼠标按下时画点</strong><br>  利用二维图片的鼠标属性节点的另一个属性，将鼠标按下这个属性节点拖出来，左键点击，选择<strong>Mouse Modifiers-Button Down</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231748577-labview-drawpad-9.png" alt=""></p><p>  这个属性节点的输出值是一个布尔值，因此我们使用条件结构实现此功能。条件为真，即按键按下时，画当前点；条件为假，即按键未按下时，不做任何操作。</p><p><img src="https://img.mahaofei.com/img/202112231749773-labview-drawpad-10.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231749016-labview-drawpad-11.png" alt=""></p><p><strong>（5）设置清屏按钮</strong><br>  清屏操作十分简单，只需要在前面板添加一个布尔按钮，然后在后面板利用条件结构判断按钮状态，如果按下，就将一个空白图片传给二维图片控件，如果未按下，则不进行任何操作。</p><p><img src="https://img.mahaofei.com/img/202112231749583-labview-drawpad-12.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231750002-labview-drawpad-13.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231750575-labview-drawpad-14.png" alt=""></p><p><strong>（5）调整一下面板布局、颜色和风格</strong></p><p><img src="https://img.mahaofei.com/img/202112231751449-labview-drawpad-15.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview多点正弦运动轨迹</title>
      <link href="/post/cc58d31e.html"/>
      <url>/post/cc58d31e.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="〇、须知">〇、须知</h2><h3 id="0-1-移位寄存器">0.1 移位寄存器</h3><p>  在循环结构的边框上右键，可以创建移位寄存器。</p><p>  移位寄存器用于将上一次循环产生的值传递至下一次循环。移位寄存器以成对接线端的形式出现，分别位于循环两侧的边框上，位置相对。</p><p>  右侧接线端含有一个向上的箭头，用于存储每次循环结束时的数据。LabVIEW会将连接到右侧寄存器的数据传递到下一次循环中。循环执行完毕后，右侧接线端将返回移位寄存器最后一次保存的值。</p><p>  移位寄存器需要初始化，即需要设置移位寄存器传递给第一次循环的值。</p><p><img src="https://img.mahaofei.com/img/202112231741015-labview-sine-1.png" alt=""></p><h3 id="0-2-NaN的使用">0.2 NaN的使用</h3><p>  NaN：Not a Number。使用时直接创建常量输入NaN即可。<br>  在绘制曲线时，NaN不会被显示在波形图上。</p><h3 id="0-3-启用索引与禁用索引">0.3 启用索引与禁用索引</h3><p>  将数组元素传入循环结构时，再循环结构的边框上会出现一个连接端子。<br>  启用索引：指每循环一次，数组的值依次传入一个，此时连接端子为空心。<br>  禁用索引：指无论循环如何，每次循环都会将整个数组传入，此时连接端子为实心。</p><p><img src="https://img.mahaofei.com/img/202112231741147-labview-sine-2.png" alt=""></p><h2 id="一、连续五个点正弦运动">一、连续五个点正弦运动</h2><h3 id="1-1-目标">1.1 目标</h3><p>  在波形图中生成正弦曲线的基础上，实现连续5个点在正弦曲线上跑的效果，如下图所示。</p><p><img src="https://img.mahaofei.com/img/202112231742682-labview-sine-3.png" alt=""></p><h3 id="1-2-实现思路">1.2 实现思路</h3><p>（1）产生一个正弦信号数组，数组的索引代表时间，数组的内容代表正弦信号值。<br>（2）将正弦信号数组，和一个长度相等、元素为NaN的数组同时传入循环结构。<br>（3）依次索引正弦信号数组的当前传入值和前4个值（如果有的话），并将NaN数组的对应位置用这五个数替换。<br>（4）正弦信号数组每传入一个数字，NaN数组就替换一次，同时更新一次波形，这样就实现了连续5个点在正弦曲线上运动的效果。</p><h3 id="1-3-程序框图设计过程">1.3 程序框图设计过程</h3><p><strong>（1）产生正弦信号数组</strong><br>  正弦信号数组的长度为360，相当于每个i对应1°，用正弦角度转弧度的公式即可计算出正弦值，360次循环就输出了一个周期的正弦数组。</p><p><img src="https://img.mahaofei.com/img/202112231742223-labview-sine-4.png" alt=""></p><p><strong>（2）创建一个长度相等、元素为NaN的数组</strong><br>  用到了<strong>数组大小</strong>和<strong>初始化数组</strong>这两个控件。数组大小控件传入一个数组，输出数组中元素的个数。初始化数组传入初始化元素和数组长度，输出一个数组。<br>  这里将正弦信号数组传入，然后初始化一个长度相同，元素全为NaN的数组。</p><p><img src="https://img.mahaofei.com/img/202112231742973-labview-sine-5.png" alt=""></p><p><strong>（3）索引前4个数并于当前值打包成一个数组</strong>（用于接下来按这个数组进行元素替换）<br>  先创建一个for循环，在循环结构的边框上右键-添加移位寄存器，然后拖拉左边的移位寄存器，使左边为4个端子，右边为一个端子，然后为移位寄存器添加初始值。<br>  将正弦数组传入for循环，然后连接到右侧移位寄存器上。（默认是以索引的方式传入数组，即每一次循环传入一个数据）<br>  使用创建数组控件，将当前值和前4个值打包成一个数组。</p><p><img src="https://img.mahaofei.com/img/202112231743979-labview-sine-6.png" alt=""></p><p>  这样实现的功能为：数组每传入一个值，会将传入的值和前4个值打包成一个数组，同时这个值会进入移位寄存器，更新移位寄存器中的四个值。<br><strong>（4）替换NaN数组的元素</strong><br>  这一步的目的是将NaN数组中的对应位置，替换成前5个打包好的值。这样一来，随着每次循环更新，NaN只有的这5个数也随着更新，表现在图上就是5个点在正弦曲线上跑。<br>  这一步的关键在于找到5个数的索引（即在数组中的位置）。由先前的逻辑可知，右侧for循环的 <strong>i</strong> 就是5个数中最后一个数的索引，前四个数是通过移位寄存器获得的，因此前4个数的索引是依次 -1。</p><p><img src="https://img.mahaofei.com/img/202112231743676-labview-sine-7.png" alt=""></p><p>  使用<strong>替换数组子集</strong>这个控件，其输入参数有三个：原数组，替换元素的索引，替换的元素。<br>  其中，原数组就是前面的NaN数组，因为每次循环，都需要传入整个数组，因此要<strong>禁用索引</strong>。并且由于内层for循环单次循环只替换一个数，需要将替换后的数组通过<strong>移位寄存器</strong>传到下一次循环继续进行元素替换。<br>  替换的元素，刚才打包的数组通过索引的方式，依次传入到内层for循环中，作为要替换的元素。同时for循环的次数也由这个数组长度确定了。<br>  替换元素的索引使用外层循环的 i （最后一个数的索引），减内层循环的 i （从0~4五次循环对应五个数）。<br><strong>（5）将原先的正弦数组和替换后的NaN数组打包显示</strong><br>  在前面板创建一个波形图控件。在程序框图使用创建数组控件连接两个数组和波形图控件即可。（注意：正弦数组也是每次循环传入全部数组，禁用索引）<br>  然后为大循环添加一个等待延时，否则一旦运行就直接执行完毕，看不到点的运动过程。</p><p><img src="https://img.mahaofei.com/img/202112231744293-labview-sine-8.png" alt=""></p><p><strong>注：前面板的曲线1（5个点）最好修改成其它线型，否则看不出效果</strong></p><p><img src="https://img.mahaofei.com/img/202112231744517-labview-sine-9.png" alt=""></p><h3 id="1-3-运行结果">1.3 运行结果</h3><p><img src="https://img.mahaofei.com/img/202112231744382-labview-sine-10.png" alt=""></p><h2 id="二、间隔五个点正弦运动">二、间隔五个点正弦运动</h2><h3 id="2-1-目标">2.1 目标</h3><p>  仍然是五个点在正弦曲线上跑，但是这次五个点不是连续的，而是有间隔的。</p><p><img src="https://img.mahaofei.com/img/202112231744824-labview-sine-11.png" alt=""></p><h3 id="2-2-实现思路">2.2 实现思路</h3><p>  因为目标是将NaN数组中的不连续点替换成相应的正弦坐标值。因此只需要将内循环的替换数组的索引乘一个系数，就可以实现不连续点的索引替换。比如系数为5，则之前外i-内i的结果是0-1-2-3-4，现在外i-内i的结果是0-5-15-20-25。<br>  虽然索引变了，但是替换的元素没有变，仍然是上一个元素，这样不是我们要的结果，我们需要将传入的数组也等间隔缩短同样的倍数，再配合移位寄存器找到前4个值，<strong>抽取数组</strong>这个控件可以实现我们的目的。</p><h3 id="2-3-程序框图">2.3 程序框图</h3><p><img src="https://img.mahaofei.com/img/202112231745651-labview-sine-12.png" alt=""></p><h3 id="拓展——香农采样定律">拓展——香农采样定律</h3><p>  为了不失真地恢复模拟信号，采样频率应该不小于模拟信号频谱中最高频率的2倍。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SLAM笔记】如何使用Eigen进行矩阵运算</title>
      <link href="/post/d41b04ed.html"/>
      <url>/post/d41b04ed.html</url>
      
        <content type="html"><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p><hr><h2 id="一、Eigen库的介绍与安装">一、Eigen库的介绍与安装</h2><h3 id="1-1-Eigen是什么">1.1 Eigen是什么</h3><p>  Eigen是一个C++开源的线性代数库，提供了快速的矩阵线性代数运算，解方程等功能。许多上层软件库也使用Eigen进行矩阵运算。<br>  Eigen是一个纯用头文件搭建起来的库，因此使用的时候，只需要引用它的头文件即可，不需要链接库文件。</p><h3 id="1-2-Eigen的安装">1.2 Eigen的安装</h3><p>  如果你的电脑上没有安装Eigen，可以输入下面的命令进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libeigen3-dev</span><br></pre></td></tr></table></figure><h2 id="二、Eigen库的基本使用">二、Eigen库的基本使用</h2><h3 id="2-1-Eigen库的引用">2.1 Eigen库的引用</h3><p>在cpp文件的开头插入如下两个头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure><p>在CMakeLists.txt内指定Eigen的头文件目录（如果把Eigen安装在了不同位址，就必须修改这里的头文件目录）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-Eigen的基本语法">2.2 Eigen的基本语法</h3><table><thead><tr><th>功能</th><th>语法</th></tr></thead><tbody><tr><td>声明一个m行n列的 float 矩阵</td><td><code>eigen Eigen::Matrix&lt;float,m,n&gt; matrix_name;</code></td></tr><tr><td>声明一个三维列向量</td><td><code>Eigen::Vector3d vector_name;</code></td></tr><tr><td>声明一个三阶方阵</td><td><code>Eigen::Matrix3d matrix_name;</code></td></tr><tr><td>动态大小矩阵</td><td><code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_name;</code></td></tr><tr><td>初始化矩阵为零矩阵</td><td><code>Eigen::Matrix3d matrix_name = Eigen::Matrix3d::Zero();</code></td></tr><tr><td>输入数据</td><td><code>matrix_name &lt;&lt; 1,2,3,4,5,6;</code></td></tr><tr><td>输出数据</td><td><code>cout &lt;&lt; matrix_name &lt;&lt; endl;</code></td></tr><tr><td>数据类型转换</td><td><code>matrix_name.cast&lt;double&gt;()</code></td></tr><tr><td>矩阵乘法</td><td><code>matrix_name1 * matrix_name2</code></td></tr><tr><td>转置</td><td><code>matrix_name.transpose();</code></td></tr><tr><td>各元素和</td><td><code>matrix_name.sum()</code></td></tr><tr><td>迹</td><td><code>matrix_name.trace()</code></td></tr><tr><td>逆</td><td><code>matrix_name.inverse()</code></td></tr><tr><td>行列式</td><td><code>matrix_name.determinant()</code></td></tr><tr><td>共轭矩阵</td><td><code>matrix_name.conjugate()</code></td></tr><tr><td>伴随矩阵</td><td><code>matrix_adjoint()</code></td></tr><tr><td>求特征值</td><td><code>Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; eigenSolver(matrix3d);</code></td></tr><tr><td>特征值</td><td><code>eigenSolver.eigenvalues()</code></td></tr><tr><td>特征向量</td><td><code>eigenSolver.eigenvectors()</code></td></tr></tbody></table><h3 id="2-3-使用Eigen实现旋转变换">2.3 使用Eigen实现旋转变换</h3><ol><li><strong>三维旋转矩阵</strong>：创建一个三维矩阵即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：创建一个三阶单位矩阵</span></span><br><span class="line">Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>旋转向量</strong>：使用AngleAxis，可以使用这个它乘向量实现旋转操作（因为定义了运算符重载），括号内是旋转向量的角度和旋转轴</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个绕z轴旋转45°的旋转向量</span></span><br><span class="line"><span class="function">Eigen::AngleAxisd <span class="title">rotation_vector</span><span class="params">(M_PI/<span class="number">4</span>,Eigen::Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>旋转向量转换为三维旋转矩阵</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将rotation_vector这个旋转向量转换为旋转矩阵并打印出来</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;rotation matrix = \n&quot;</span>&lt;&lt;rotation_vector.<span class="built_in">matrix</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">//或通过toRotationMatrix转换为旋转矩阵</span></span><br><span class="line">rotation_matrix = rotation_vector.<span class="built_in">toRotationMatrix</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>旋转矩阵转换为欧拉角</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将旋转矩阵转换为ZYX顺序的欧拉角，即yaw-pitch-roll</span></span><br><span class="line">Eigen::Vector3d euler_angles = rotation_matrix.<span class="built_in">eulerAngles</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;yaw pitch roll = &quot;</span>&lt;&lt;euler_angles.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>使用旋转向量进行坐标变换</strong>：因为对进行了运算符重载，旋转操作直接乘向量即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个x方向的向量，用前面定义的旋转向量进行旋转，然后输出旋转后的结果。</span></span><br><span class="line"><span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">Eigen::Vector3d v_rotated = rotation_vector * v;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;(1,0,0) after rotation = &quot;</span>&lt;&lt;v_rotated.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>用旋转矩阵进行坐标变换</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v_rotated = rotation_matrix * v;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;(1,0,0) after rotation = &quot;</span>&lt;&lt;v_rotated.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>使用变换矩阵进行坐标变换</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为T的变换矩阵,虽说是3d，但实际是4x4矩阵，Identity说明旋转是0，平移也是0</span></span><br><span class="line">Eigen::Isometry3d T=Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line"><span class="comment">//将左上角的旋转矩阵设为按旋转向量rotation_vector旋转</span></span><br><span class="line">T.<span class="built_in">rotate</span>(rotation_vector);</span><br><span class="line"><span class="comment">//设置右上角的平移矩阵为[1,3,4]（旋转前平移）</span></span><br><span class="line">T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">//因为运算符重载，变换矩阵可以直接乘三维向量</span></span><br><span class="line">Eigen::Vector3d v_transformed = T*v;</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>使用四元数</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个四元数</span></span><br><span class="line">Eigen::Quaterniond q;</span><br><span class="line"><span class="comment">//可以直接把旋转向量赋值给四元数</span></span><br><span class="line">q = Eigen::<span class="built_in">Quaterniond</span>(rotation_vector);</span><br><span class="line"><span class="comment">//也可以把旋转矩阵赋值给它</span></span><br><span class="line">q=Eigen::<span class="built_in">Quaterniond</span>(rotation_matrix);</span><br><span class="line"><span class="comment">//使用四元数旋转一个向量</span></span><br><span class="line">v_rotated = q*v;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SLAM笔记】三维刚体运动</title>
      <link href="/post/98891cce.html"/>
      <url>/post/98891cce.html</url>
      
        <content type="html"><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p><hr><h2 id="一、旋转矩阵">一、旋转矩阵</h2><h3 id="1-1-向量">1.1 向量</h3><p>  向量与坐标是两个不同的概念。向量只是有大小和方向的量。只有当指定了三维空间中某个坐标系的时候，才能谈论向量在此坐标系下的坐标。<strong>因此向量的坐标，既和向量本身有关，也和坐标系的选取有关。</strong><br>  向量的内积描述了向量之间的投影关系。</p><p><img src="https://img.mahaofei.com/img/202112231726158-slam-notes2-1.png" alt=""></p><p>  向量的外积，方向垂直于这两个向量，大小为|a||b|sin&lt;a,b&gt;。</p><p><img src="https://img.mahaofei.com/img/202112231727876-slam-notes2-2.png" alt=""></p><h3 id="1-2-欧氏变换">1.2 欧氏变换</h3><p>  两个坐标系之间的旋转、平移关系，统称为坐标系之间的变换关系。机器人运动过程中，往往会设定一个惯性坐标系（即世界坐标系），可以认为它是固定不动的。机器人则是一个移动坐标系。<br>  如果需要知道某个向量在机器人坐标系中与世界坐标系中如何转换的，就需要先得到该向量对机器人坐标系的坐标值，再根据机器人位姿转换到世界坐标系中，这个转换关系用矩阵T来描述。<br>  机器人移动是一个刚体运动，即同一个向量在各个坐标系下的长度和夹角都不会发生变化，这种变化就是<strong>欧式变换</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231727349-slam-notes2-3.png" alt=""></p><p><strong>（1）旋转矩阵</strong><br>  假设某个单位正交基($\boldsymbol{e_1}$,$\boldsymbol {e_2}$,$\boldsymbol{e_3}$)经过了一次旋转，变成了($\boldsymbol {e_1}‘$,$\boldsymbol{e_2}’$,$\boldsymbol {e_3}'$)，则对于同一个向量$\boldsymbol{a}$（该向量没有随坐标系旋转而运动），则可知</p><p>用矩阵表示如下</p><p><img src="https://img.mahaofei.com/img/202112231727592-slam-notes2-4.png" alt=""></p><p> <img src="https://img.mahaofei.com/img/202112231727422-slam-notes2-5.png" alt=""></p><p> 为了表示两个坐标之间的变换关系，等式两边同乘[$\boldsymbol{e_1}^T$ $\boldsymbol{e_2}^T$ $\boldsymbol{e_3}^T$]T，则左侧矩阵变成了单位矩阵：</p><p><img src="https://img.mahaofei.com/img/202112231728395-slam-notes2-6.png" alt=""></p><p>  中间这个行列式为1的正交矩阵，就是所谓的旋转矩阵。<br>  同时，此旋转矩阵的逆描述了一个相反的旋转。</p><p><img src="https://img.mahaofei.com/img/202112231729153-slam-notes2-7.png" alt=""></p><p><strong>（2)平移矩阵</strong><br>  平移矩阵十分简单，只需要将平移量加到旋转之后的坐标上就可以了。</p><p><img src="https://img.mahaofei.com/img/202112231729229-slam-notes2-8.png" alt=""></p><h3 id="1-3-变换矩阵">1.3 变换矩阵</h3><p>  使用下面这种形式进行变换时，变化多次之后往往会变得过于复杂且不满足线性关系。</p><p><img src="https://img.mahaofei.com/img/202112231729425-slam-notes2-9.png" alt=""></p><p>  因此通常我们会使用如下的齐次坐标和变换矩阵进行变换。即把三维向量末尾加一，变成四维向量，称为齐次坐标$\tilde{a}$。将旋转矩阵和平移矩阵写在同一个矩阵里面，这个矩阵T称为变换矩阵。</p><p><img src="https://img.mahaofei.com/img/202112231730503-slam-notes2-10.png" alt=""></p><p>  引入齐次坐标就可以实现多个变换矩阵的连乘，得到一个总的变换矩阵，实现多次变换的累加。</p><p><img src="https://img.mahaofei.com/img/202112231731355-slam-notes2-11.png" alt=""></p><h2 id="二、角轴和欧拉角">二、角轴和欧拉角</h2><h3 id="2-1-问题提出">2.1 问题提出</h3><p>  旋转矩阵有九个量，但一次旋转只有三个自由度，变换矩阵用十六个量表达六自由度变换，表达方式可能冗余。同时旋转矩阵本身要求必须是正交矩阵，变换矩阵一样都需要约束条件，有些情况下这些约束会使求解变得困难。</p><h3 id="2-2-角轴">2.2 角轴</h3><p><strong>（1）定义</strong><br>  <strong>任意旋转都可以用一个旋转轴和一个旋转角来刻画</strong>。我们可以使用一个向量，其方向与旋转轴一致，长度等于旋转角，这种向量就称为旋转向量或角轴。<br>  使用角轴表示方法只需要一个三维向量即可描述旋转。同样对于变换矩阵，我们使用一个角轴和一个平移向量即可表达。<br><strong>（2）角轴与旋转矩阵的转换</strong><br>  假设有一个旋转轴为$\boldsymbol {n}$，角度为θ的旋转，显然旋转向量为θ$\boldsymbol {n}$。由角轴转化为旋转矩阵，可以使用罗德里格斯公式：</p><p><img src="https://img.mahaofei.com/img/202112231731480-slam-notes2-12.png" alt=""></p><p>  同样也可以计算从旋转矩阵到角轴的转换。（由于旋转轴上的向量旋转后不发生变化，因此旋转轴就是旋转矩阵$\boldsymbol {R}$的特征值1对应的特征向量）。</p><p><img src="https://img.mahaofei.com/img/202112231732000-slam-notes2-13.png" alt=""></p><h3 id="2-3-欧拉角">2.3 欧拉角</h3><p>  旋转矩阵和角轴都不太直观，而欧拉角的表达方式比较利于人的理解。（但是在程序中不常用）<br>  欧拉将将旋转分解为三次不同轴上的转动，例如按Z-Y-X顺序转动，可以得到yaw-pitch-roll角。</p><blockquote><ol><li>绕物体的 Z 轴旋转，得到偏航角 yaw；</li><li>绕旋转之后的 Y 轴旋转，得到俯仰角 pitch；</li><li>绕旋转之后的 X 轴旋转，得到滚转角 roll。</li></ol></blockquote><p><img src="https://img.mahaofei.com/img/202112231732937-slam-notes2-14.png" alt=""></p><p>  欧拉角存在万向锁的问题，例如在ZYX顺序中，第一次绕Z轴旋转，第二次绕Y轴旋转90°，这时候x轴和系统初始时的Z轴重合了，导致第三次旋转和第一次是绕同一个轴旋转，丢失了一个自由度。所以程序中很少用欧拉角表示机器人的位姿。</p><p><img src="https://img.mahaofei.com/img/202112231732880-slam-notes2-15.png" alt=""></p><h2 id="三、四元数">三、四元数</h2><h3 id="3-1-简介">3.1 简介</h3><p>  四元数是一种扩展的复数。我们知道复数可以表示复平面内的旋转，乘i表示复平面内逆时针转90度，单位圆上的复数可以表达二维平面的旋转。<br>  四元数有三个虚部，可以表达三维空间中的旋转。</p><p><img src="https://img.mahaofei.com/img/202112231733226-slam-notes2-16.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231733270-slam-notes2-17.png" alt=""></p><p>  四元数的虚部相乘，类似于虚数i的相乘，也有对应的关系，且其关系很想三维空间中的叉积。</p><p><img src="https://img.mahaofei.com/img/202112231734265-slam-notes2-18.png" alt=""></p><h3 id="3-2-四元数的运算">3.2 四元数的运算</h3><table><thead><tr><th>运算</th><th>公式</th></tr></thead><tbody><tr><td>加减法</td><td><img src="https://img.mahaofei.com/img/202112231734688-slam-notes2-19.png" alt=""></td></tr><tr><td>乘法</td><td><img src="https://img.mahaofei.com/img/202112231734564-slam-notes2-20.png" alt=""></td></tr><tr><td>共轭</td><td><img src="https://img.mahaofei.com/img/202112231735700-slam-notes2-21.png" alt=""></td></tr><tr><td>模长</td><td><img src="https://img.mahaofei.com/img/202112231735117-slam-notes2-22.png" alt=""></td></tr><tr><td>逆</td><td><img src="https://img.mahaofei.com/img/202112231736441-slam-notes2-23.png" alt=""></td></tr><tr><td>数乘</td><td><img src="https://img.mahaofei.com/img/202112231736563-slam-notes2-24.png" alt=""></td></tr><tr><td>点乘</td><td><img src="https://img.mahaofei.com/img/202112231736291-slam-notes2-25.png" alt=""></td></tr></tbody></table><h4 id="3-3-用四元数表示旋转">3.3 用四元数表示旋转</h4><p><strong>（1）四元数与角轴、旋转矩阵的转换</strong></p><table><thead><tr><th>转换</th><th>公式</th></tr></thead><tbody><tr><td>角轴到四元数：</td><td><img src="https://img.mahaofei.com/img/202112231740376-slam-notes2-26.png" alt=""></td></tr><tr><td>四元数到角轴</td><td><img src="https://img.mahaofei.com/img/202112231740724-slam-notes2-27.png" alt=""></td></tr><tr><td>四元数到旋转矩阵</td><td><img src="https://img.mahaofei.com/img/202112231740443-slam-notes2-28.png" alt=""></td></tr></tbody></table><p><strong>（2）使用四元数表示旋转</strong></p><p>  四元数有三个虚部i, j, k，将三个坐标值作为三个虚部的系数，另实部为零，这样就将一个三维空间坐标转换为纯虚四元数表示的坐标。</p><p>  用一个四元数$\boldsymbol{q}$表示旋转。</p><p><img src="https://img.mahaofei.com/img/202112231740466-slam-notes2-29.png" alt=""></p><p>  空间点的旋转可以用四元数的乘法表示，旋转后的点$\boldsymbol{p’}$如下</p><p><img src="https://img.mahaofei.com/img/202112231741907-slam-notes2-30.png" alt=""></p><blockquote><p>参考：<strong>高翔-视觉SLAM十四讲</strong><br>相关Github：<a href="https://github.com/gaoxiang12/slambook">https://github.com/gaoxiang12/slambook</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview生成三维曲面 | 花瓶</title>
      <link href="/post/f3f368c1.html"/>
      <url>/post/f3f368c1.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="一、程序思路">一、程序思路</h2><p>花瓶这种回转曲面生成的本质是<strong>轮廓沿引导线扫描</strong>。<br><img src="https://img.mahaofei.com/img/202112231723953-labview-vise-1.png" alt=""><br>而对于花瓶来说，其生成方法就是一个圆沿一条曲线进行扫描</p><h3 id="1-1-底面圆轮廓的生成">1.1 底面圆轮廓的生成</h3><p><strong>圆的生成方法如下：</strong><br>循环总数为360，对应360度，i则对应从0~360的每一角度。将i转换为弧度制，即可得到圆上各点的x坐标和y坐标，将两个坐标进行捆绑，得到的就是圆这个曲线。<br><img src="https://img.mahaofei.com/img/202112231723797-labview-vise-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231724316-labview-vise-3.png" alt=""></p><h3 id="1-2-引导线的生成">1.2 引导线的生成</h3><p>花瓶的生成，就是平面曲线圆的基础上，再加一个z轴曲线，作为圆的扫描引导线，这里以正弦曲线作为圆的扫描引导线。<br><img src="https://img.mahaofei.com/img/202112231724512-labview-vise-4.png" alt=""></p><h3 id="1-3-圆沿引导线扫描">1.3 圆沿引导线扫描</h3><p>基本思路为：<br>在刚才生成圆的循环外，再套一个循环。循环的输入是引导线输出的数组。<br>引导线上每一个点位数据进入大循环时，内循环就画一个以此数据为半径的圆。<br>当引导线上所有数据都进入循环，生成了一个一次为半径的圆时，花瓶的侧面就完成了。<br>在前面板插入三维图形中的曲面控件即可看到生成的侧面。<br><img src="https://img.mahaofei.com/img/202112231724504-labview-vise-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231724697-labview-vise-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231725898-labview-vise-7.png" alt=""><br>生成哑铃状图像的原因是，刚才是以z轴正弦曲线的各个数据作为半径画圆，因此根据正弦图像，可以知道在<strong>起始、终止以及中间位置半径为零</strong>，画出来的图形也就是现在所看到的哑铃。<br><img src="https://img.mahaofei.com/img/202112231725038-labview-vise-8.png" alt=""><br>要解决这个问题，只需要将正弦曲线整体向上平移即可。<br><img src="https://img.mahaofei.com/img/202112231725571-labview-vise-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231725803-labview-vise-10.png" alt=""></p><h2 id="二、改进方法">二、改进方法</h2><h3 id="2-1-修复裂缝">2.1 修复裂缝</h3><p>可以看到生成的曲面上有一条裂缝，原因是起始点和终止点没有重合。<br><img src="https://img.mahaofei.com/img/202112231726918-labview-vise-11.png" alt=""><br>**解决方法：**将起始点添加到终止点，手动实现曲面封闭。索引数组中的第一个元素，将其添加到原数组的最后。<br><img src="https://img.mahaofei.com/img/202112231726775-labview-vise-12.png" alt=""></p><h3 id="2-2-添加底面">2.2 添加底面</h3><p>添加底面的方法十分简单，因为labview的三维曲面生成是连接相邻的点组成曲面，因此只需要在底面最中心添加一个点即可。<br><img src="https://img.mahaofei.com/img/202112231726743-labview-vise-13.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview绘制圆/椭圆</title>
      <link href="/post/b19eb912.html"/>
      <url>/post/b19eb912.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h3 id="一、介绍">一、介绍</h3><p>1.1 for循环<br>for循环是固定次数的循环，其也有条件接线端，可以提前结束while循环，相当于C语言的break语句。for循环与数组操作是密不可分的，for循环最重要的功能就是处理数组数据。<br><img src="https://img.mahaofei.com/img/202112231720495-labview-circles-1.png" alt=""><br>1.2 XY图<br>将x数组和y数组进行捆绑，形成一系列x和y组合的数据，将捆绑后的结果传递给xy图，即可生成一条曲线。<br><img src="https://img.mahaofei.com/img/202112231721452-labview-circles-2.png" alt=""><br>1.3 创建数组<br>创建数组这个控件的作用是将元素添加入数组，或连接多个数组。向下拖动此控件，会自动增加新的输入端和输出端。<br><img src="https://img.mahaofei.com/img/202112231722169-labview-circles-3.png" alt=""><br>1.4 移位寄存器<br>添加移位寄存器后，循环结构的左右两侧的平行位置将各增加一个包含三角形的方框。左侧的方框代表上一次循环的运行结果，右侧的代表本次循环要输入的结果。<br><img src="https://img.mahaofei.com/img/202112231722025-labview-circles-4.png" alt=""></p><h3 id="二、实验目标">二、实验目标</h3><p>显示x坐标随角度的变化曲线，y坐标随角度的变化曲线。同时实时绘制一个椭圆，展示椭圆绘制的全过程。<br><img src="https://img.mahaofei.com/img/202112231722218-labview-circles-5.png" alt=""></p><h3 id="三、实验思路">三、实验思路</h3><p>以循环次数i作为角度变化，每循环一次相当于角度+1，角度从0到360，因此循环总数设置为360。<br>考虑圆的参数方程，x=r·cos(φ)，y=r·sin(φ)，这里以r=1为例。<br>因为循环次数作为角度，故每个循环对应的x和y的值的计算方法为：$\frac{iπ}{180}$<br>将生成的数据添加到移位寄存器传过来的数组中，再将x数据数组和y数据数组捆绑送给xy图即可。<br><img src="https://img.mahaofei.com/img/202112231722087-labview-circles-6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】220V转5V向单片机供电</title>
      <link href="/post/706260b4.html"/>
      <url>/post/706260b4.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、所用元器件介绍">一、所用元器件介绍</h3><p>1.1 仿真电源Alternator：用于仿真220v交流电源<br><img src="https://img.mahaofei.com/img/202112231717027-proteus-220to5-1.png" alt=""><br>1.2 变压器Tran-2p2s：对220v交流电源进行降压<br><img src="https://img.mahaofei.com/img/202112231717703-proteus-220to5-2.png" alt=""><br>1.3 桥式整流器2W005G：用于将交流电整流为直流电<br><img src="https://img.mahaofei.com/img/202112231718392-proteus-220to5-3.png" alt=""><br>1.4 无极性电容CAP<br><img src="https://img.mahaofei.com/img/202112231718821-proteus-220to5-4.png" alt=""><br>1.5 电解电容CAP-ELEC<br><img src="https://img.mahaofei.com/img/202112231718469-proteus-220to5-5.png" alt=""><br>1.6 三端稳压芯片7805<br><img src="https://img.mahaofei.com/img/202112231719763-proteus-220to5-6.png" alt=""></p><h3 id="二、接线方法">二、接线方法</h3><p><img src="https://img.mahaofei.com/img/202112231719201-proteus-220to5-7.png" alt=""></p><h3 id="三、仿真结果">三、仿真结果</h3><p><img src="https://img.mahaofei.com/img/202112231719617-proteus-220to5-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SLAM笔记】SLAM概述</title>
      <link href="/post/47f7138e.html"/>
      <url>/post/47f7138e.html</url>
      
        <content type="html"><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p><h2 id="一、引言">一、引言</h2><p>对于一个移动机器人来说，我们往往需要它知道两件事：</p><ul><li>我在什么地方——定位</li><li>周围环境是什么样——建图</li></ul><h3 id="1-1-定位方法">1.1 定位方法</h3><p>对于定位来说，有许多方法可以使机器人确定自己的位置。主要分为两类：</p><ol><li>携带与机器人本体上的：轮式编码器、相机、激光等</li><li>安装于环境中的：导引线、二维码等</li></ol><p>其中安装于环境中的设备约束了外部环境，对环境要求较高，无法提供通用普遍的解决方案。而携带于机器人本体的传感器则可适用于未知环境。</p><p>在视觉SLAM中，我们更加注重考虑如何用相机解决定位和建图的问题。</p><h3 id="1-2-相机">1.2 相机</h3><p>相机按照工作方式可以分为三类。</p><p>单目相机：只使用一个摄像头进行SLAM。它获取的数据是一张张照片，照片以二维的形式反映了三维的世界，因此在单张图像里，无法确定一个物体的真实大小和物体的距离。如果我们想恢复三维结构，就必须转动相机的视角。</p><p>双目相机：使用两个摄像头测量。这样就消除了单目相机的尺度不确定性，可以测量物体的大小。并且两个摄像头间距（基线）越大，测量范围就越远。其缺点是配置和标定十分复杂，非常消耗计算资源。</p><p>深度相机：通过红外结构光或ToF原理，主动向物体发射并接受返回的光，测出物体离相机的距离。其通过物理手段测量，节省了大量的计算量，但缺点是测量范围窄、噪声大、事业小、易受日光干扰、无法测量投射材料等。</p><h2 id="二、经典SLAM框架">二、经典SLAM框架</h2><p><img src="https://img.mahaofei.com/img/202112231715582-slam-notes1-1.png" alt=""></p><h3 id="2-1-传感数据读取">2.1 传感数据读取</h3><p>传感数据信息读取主要为图像信息的读取和预处理，还可能有马盘、惯性传感器等信息的读取和同步。</p><h3 id="2-2-前端视觉里程计">2.2 前端视觉里程计</h3><p>视觉里程计的任务是估算相邻图像间相机的运动。由于是估计两张图间相机的运动，然后串联起来得到的机器人轨迹，所以仅通过视觉里程计来估算轨迹，不可避免会出现累计误差。为了解决这个问题所以有了后端优化和回环检测。</p><h3 id="2-3-后端优化">2.3 后端优化</h3><p>后端优化的任务是接受视觉里程计测得的相机位姿，接合回环检测的新息，得到全局一致的轨迹和地图。<br>后端优化主要是指处理SLAM过程中噪声的问题，主要是滤波和非线性优化算法等。</p><h3 id="2-4-回环检测">2.4 回环检测</h3><p>目的是判断机器人是否曾到达过先前的位置。主要解决位置随时间漂移的问题。</p><h3 id="2-5-建图">2.5 建图</h3><p>根据估计的轨迹，建立于任务要求对应的地图。地图的形式主要有两种：</p><ul><li>度量地图：用稀疏和稠密对他们分类。稀疏地图进行了一定程度的抽象，可以满足定位的需求。而导航时，我们需要稠密的地图，稠密地图由小方块或小格子表示，每个小块有占据、空闲、未知三种状态，这种地图可以用于各种导航算法。</li><li>拓扑地图：只由节点和边组成，只考虑节点之间的连通性。去掉了细节问题，是一种更紧凑的表达方式，但无法表达具有复杂结构的地图。</li></ul><h2 id="三、SLAM问题的数学表述">三、SLAM问题的数学表述</h2><p>机器人携带传感器在未知环境内运动时，相机会在离散的时刻采集一系列数据。</p><h3 id="3-1-运动方程——定位问题">3.1 运动方程——定位问题</h3><p>在这些离散时刻机器人的位置，用$x$表示机器人的位置。<br>由于传感器的不同，某时刻机器人的位置没有确定的计算方程，但可以知道<strong>每一时刻的位置都取决于上一时刻的位置以及传感器采集的数据</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231715709-slam-notes1-2.png" alt=""></p><p>其中，$u_k$为传感器读数，$w_k$为噪声。</p><h3 id="3-2-观测方程——建图问题">3.2 观测方程——建图问题</h3><p>设地图由多个路标组成，每个时刻传感器会测量到一部分路标点，得到这些点的观测数据。即机器人在$x_k$位置上测量到路标点$y_j$，产生了观测数据$z_{k,j}$。</p><p><img src="https://img.mahaofei.com/img/202112231716217-slam-notes1-3.png" alt=""></p><p>其中$v_{k,j}$为观测时的噪声。</p><h3 id="3-3-方程求解方法">3.3 方程求解方法</h3><p>按照运动和观测方程是否为线性，分为<strong>线性/非线性系统</strong>。<br>按照噪声是否服从高斯分布分类，分为<strong>高斯/非高斯系统</strong>。</p><ol><li>对于线性高斯系统，无偏最优估计可由卡尔曼滤波器给出。</li><li>对于复杂的非线性非高斯系统，使用扩展卡尔曼滤波和非线性优化两类方法解决。</li></ol><h2 id="四、Linux基础">四、Linux基础</h2><h3 id="4-1-编写程序Hello-SLAM">4.1 编写程序Hello SLAM</h3><p>在根目录下创建文件夹<code>/slam/ch01</code><br>使用vim或gedit或nano等编辑器，输入以下代码，保存为<code>helloSLAM.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello SLAM!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用cmake">4.2 使用cmake</h3><p>仍然在此目录下创建一个文件<code>CMakeLists.txt</code>，输入以下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#声明要求的cmake最低版本</span><br><span class="line">cmake_minimum_required( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line">#声明一个cmake工程</span><br><span class="line">project( HelloSLAM )</span><br><span class="line"></span><br><span class="line">#添加一个可执行程序语法：add_executable( 可执行程序名 源代码文件名 )</span><br><span class="line">add_executable( helloSLAM helloSLAM.cpp )</span><br></pre></td></tr></table></figure><p>创建一个文件夹<code>mkdir build</code>用于保存变异生成的中间文件<br>进入<code>build</code>文件夹，使用以下代码进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>此时产生了一个名为<code>helloSLAM</code>的可执行文件，使用<code>./helloSLAM</code>即可执行此程序看到正确的输出。</p><h3 id="4-3-使用库">4.3 使用库</h3><p>C++中只有带有main函数的文件才会生成可执行程序，而其他代码，我们只需把它打包成库，供程序调用即可。<br><strong>（1）创建库</strong><br>在刚才的ch01文件夹下，创建一个名为<code>libHelloSLAM.cpp</code>的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello SLAM!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个库文件提供了一个printHello函数，但它没有main函数，因此不会生成可执行文件，我们需要告诉cmake，我想把这个文件编译成叫“hello”的库。在CmakeLists.txt内添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(hello_shared SHARED libHelloSLAM.cpp)</span><br></pre></td></tr></table></figure><blockquote><p>这里创建的是共享库。<br>在Linux中，库文件分成<strong>静态库</strong>和<strong>动态库</strong>两种。<br>静态库以.a后缀，每次被调用都会生成一个副本。<br>共享库以.so后缀，只有一个副本，更省空间。</p></blockquote><p>此时编译的话，可以得到一个libhello_shared.so的库文件</p><p><strong>（2）创建头文件</strong><br>创建一个名为<code>libHelloSLAM.cpp</code>的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>（3）创建主程序</strong><br>创建一个名为<code>useHello.cpp</code>的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libHelloSLAM.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printHello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CMakeLists.txt中添加生成可执行程序的生成命令，链接到刚才我们使用的库上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable( useHello useHello.cpp )</span><br><span class="line">target_link_libraries( useHello hello_shared )</span><br></pre></td></tr></table></figure><p>进行编译，得到<code>useHello</code>这个可执行文件。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS定位</title>
      <link href="/post/ebe88fe2.html"/>
      <url>/post/ebe88fe2.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、为什么需要定位">一、为什么需要定位</h4><p>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。</p><p>当滚动窗口时，某些模块是固定在屏幕中的某个位置。</p><p>以上两个效果通过标准流和浮动都无法快速实现，此时需要定位来实现。</p><h4 id="二、定位组成">二、定位组成</h4><p>定位：将盒子定在某一位置</p><p>定位 = 定位模式 + 边偏移</p><p>（定位模式用于指定元素在文档中的定位方式，边偏移则决定了该元素的最终位置）</p><p><strong>2.1 定位模式</strong></p><p>定位模式决定元素的定位方式，通过CSS的position属性设置</p><table><thead><tr><th>值</th><th>语义</th></tr></thead><tbody><tr><td>static</td><td>静态定位</td></tr><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolute</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table><p><strong>2.2 边偏移</strong></p><p>边偏移就是定位盒子移动到最终位置，有top、bottom、left、right四个属性</p><table><thead><tr><th>边偏移属性</th><th>示例</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>top: 80px</td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素上边线的距离</td></tr><tr><td>bottom</td><td>bottom: 80x</td><td><strong>底部</strong>偏移量，定义元素相对于其父元素下边线的距离</td></tr><tr><td>left</td><td>left: 80px</td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素左边线的距离</td></tr><tr><td>right</td><td>right: 80px</td><td>右侧偏移量，定义元素相对于其父元素右边线的距离</td></tr></tbody></table><h4 id="三、静态定位-static">三、静态定位 static</h4><p>静态定位是元素的默认定位方式，无定位的意思。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: static; &#125;</span><br></pre></td></tr></table></figure><ul><li>静态定位按照标准流摆放位置，没有边偏移</li></ul><h4 id="四、相对定位-relative">四、相对定位 relative</h4><p>相对定位是元素在移动位置的时候，是相对于它原来的位置来说的。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; positon: relative; &#125;</span><br></pre></td></tr></table></figure><ul><li>相对定位是相对自己原来的位置进行移动</li><li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。即<strong>相对定位并没有脱标</strong>。</li></ul><h4 id="五、绝对定位-absolute">五、绝对定位 absolute</h4><p>绝对定位是元素在移动位置的时候，相对于它祖先元素来说的。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位</p></li><li><p>父级有定位时（相对、绝对、固定定位），就会以最近一级带有定位的元素为参考点移动位置</p></li><li><p><strong>绝对定位不在占有原先位置</strong>。</p></li></ul><h4 id="六、子绝父相">六、子绝父相</h4><p>子级用绝对定位，父级用相对定位。</p><ol><li>子级绝对位置，不占有位置，可以放到父盒子里面的每一个地方，不会影响到其它的兄弟盒子</li><li>父盒子需要加定位限制子盒子在父盒子内显示</li><li>父盒子布局时，需要占有位置，因此父亲只能是相对定位</li></ol><h4 id="七、固定定位">七、固定定位</h4><p>固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: fixed; &#125;</span><br></pre></td></tr></table></figure><ol><li>以浏览器的可视窗口为参照点移动元素</li></ol><ul><li>跟父元素没有关系</li><li>不随着滚动条的滚动而滚动</li></ul><ol start="2"><li>固定定位不再占有原先的位置，也是脱标的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode中HTML与CSS代码的快速写法</title>
      <link href="/post/f28961f5.html"/>
      <url>/post/f28961f5.html</url>
      
        <content type="html"><![CDATA[<p>Emmet语法的前身是Zen coding，它使用缩写来提高html/css的编写速度，vscode内部已经集成该语法</p><h3 id="1-快速生成Html结构">1. 快速生成Html结构</h3><ul><li><p>生成标签，直接输入标签名，按<code>tab</code>键即可，比如div然后按tab键，就可以生成<code>&lt;div&gt;&lt;/div&gt;</code></p></li><li><p>如果想要生成多个相同标签，加上<code>*</code>就可以了，比如<code>div*3</code>可以快速生成三个div</p></li><li><p>如果有父子级关系的标签，可以用<code>&gt;</code>，比如ul &gt; li</p></li><li><p>如果有兄弟关系的标签，用<code>+</code>，比如div+p</p></li><li><p>如果生成带有类名或者id名的，直接写<code>.demo</code>或者<code>#two</code>，再按tab键即可，例如<code>div.banner</code></p></li><li><p>如果生成的div类名是有顺序的，可以使用自增符号<code>$</code>，例如<code>div.demo$*5</code></p></li><li><p>如果想要在生成的标签内部写内容可以用{}biaoshi</p></li></ul><h3 id="2-快速生成CSS样式">2. 快速生成CSS样式</h3><p>CSS取每个单词得首字母简写即可：</p><p>比如，ti2em，按tab，可以生成text-indent: 2em;</p><p>比如，w200，按tab，可以生成width: 200px;</p><h3 id="3-格式化代码">3. 格式化代码</h3><p>在VSCode中，保存时默认格式化代码，如果没有自动格式化可以按照如下步骤设置：</p><blockquote><p>【新版本】：</p><p>打开文件-首选项-设置，搜索format，勾选保存自动格式化。</p><p>【旧版本】：</p><p>打开：文件-&gt;首选项-&gt;设置</p><p>搜索：emmet.include</p><p>在setting.json下的【用户】中添加以下语句</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;editor.formatOnType&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>设置好以后，保存时都会格式化文档</p></blockquote><p>也可以手动格式化文档：右键-格式化文档，或者<code>Shift+Alt+F</code></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS浮动</title>
      <link href="/post/dfc42a6d.html"/>
      <url>/post/dfc42a6d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、浮动">一、浮动</h2><h3 id="1-1-传统网页布局的三种方式">1.1 传统网页布局的三种方式</h3><p>CSS提供了三种传统布局方式：</p><ol><li>普通流（标准流）</li><li>浮动</li><li>定位</li></ol><p>三种布局方式都是用来摆放盒子的，盒子摆放到合适的位置，布局自然就完成了。</p><p>实际开发中，一个页面基本都包含了这三种布局方式（移动端有新的布局方式）</p><h3 id="1-2-标准流">1.2 标准流</h3><p>所谓标准流：就是标签按照规定好的默认方式排列</p><ol><li>块级元素独占一行，从上向下顺序排序<ul><li>div、hr、p、h1~h6、ul、ol、dl、form、table</li></ul></li><li>行内元素会按照顺序，从左到右顺序排序，碰到父元素边缘则会自动换行<ul><li>span、a、i、em</li></ul></li></ol><p>标准流是最基本的布局方式</p><h3 id="1-3-为什么需要浮动">1.3 为什么需要浮动</h3><p>有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排序方式。</p><p><strong>浮动的典型应用：块级元素横向排列</strong></p><p>多个块级元素纵向排列用标准流，多个块级元素横向排列找浮动。</p><h3 id="1-4-什么是浮动">1.4 什么是浮动</h3><p><strong>float</strong>属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">float</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动（默认值）</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h3 id="1-5-浮动的特性">1.5 浮动的特性</h3><p><strong>（1）浮动元素会脱离标准流</strong></p><ul><li><p>多利标准流的控制，移动到指定位置（浮动）</p></li><li><p>浮动的盒子不再保留原先的位置</p><blockquote><p>如果有两个盒子一个设置浮动，一个没有</p><p><img src="https://img.mahaofei.com/img/202112231713946-html-notes5-1.png" alt=""></p></blockquote></li></ul><p><strong>（2）浮动的元素会在一行内显示并且元素顶部对齐</strong></p><ul><li>要在一行内显示，各个元素都要设置浮动特性</li><li>浮动的元素是互相贴靠在一起的，如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐</li></ul><p><strong>（3）浮动的元素会具有行内块元素的特性</strong></p><ul><li>任何元素都可以浮动，不管原先是什么元素，添加浮动之后都具有行内块元素相似的特性</li></ul><h3 id="1-6-浮动元素经常和标准流父级搭配使用">1.6 浮动元素经常和标准流父级搭配使用</h3><p>为了约束浮动元素位置，网页布局一般采取的策略是：</p><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。<br><img src="https://img.mahaofei.com/img/202112231713850-html-notes5-2.png" alt=""></p><h2 id="二、常见网页布局">二、常见网页布局</h2><h3 id="2-1-常见网页布局">2.1 常见网页布局</h3><p><img src="https://img.mahaofei.com/img/202112231713951-html-notes5-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231713771-html-notes5-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231714289-html-notes5-5.png" alt=""></p><h3 id="2-2-浮动布局注意点">2.2 浮动布局注意点</h3><p><strong>（1）浮动和标准流父盒子配合使用</strong></p><p>先用标准流的父元素排列上下位置，之后内部子元素用浮动排列左右位置</p><p><strong>（2）一个元素浮动了，理论上其余的兄弟元素也要浮动</strong></p><p>一个盒子里面有多个滋贺子，如果其中一个盒子浮动了，那么其他兄弟元素也应该浮动，以防止引起问题。</p><p>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。</p><h2 id="三、清除浮动">三、清除浮动</h2><h3 id="3-1-为什么需要清除浮动">3.1 为什么需要清除浮动</h3><p>由于父盒子在很多情况下，不方便给高度，但是子盒子浮动又不占有位置，导致父盒子高度为0，进而影响下面的标准流盒子。<br><img src="https://img.mahaofei.com/img/202112231714645-html-notes5-6.png" alt=""></p><ul><li>浮动元素不在占用原标准流位置，所以会对后面元素的排版产生影响</li></ul><h3 id="3-2-清除浮动本质">3.2 清除浮动本质</h3><ul><li><p>清除浮动的本质就是清除浮动元素造成的影响</p></li><li><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了</p></li></ul><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">clear</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table><p>实际工作中，几乎只用<code>clear:both</code></p><p>清除浮动的策略是：闭合浮动</p><h3 id="3-3-清除浮动的方法">3.3 清除浮动的方法</h3><p><strong>（1）额外标签法，也称为隔墙法</strong></p><p>额外标签法会在浮动元素末尾添加一个空标签。如<code>&lt;div style=&quot;&quot;clear:both&gt;&lt;/div&gt;</code>或其它标签<code>&lt;br/&gt;</code>等。</p><ul><li>优点：通俗易懂，书写方便</li><li>缺点：添加许多无意义的钱钱，结构化较差</li><li>注意：新增的空标签必须是一个块级元素。</li></ul><p><strong>（2）父级添加 overflow 属性</strong></p><p>可以给父级添加overflow属性，将其属性设置为hidden、auto或scroll。<code>overflow: hidden;</code></p><p>注意：给父元素添加代码</p><ul><li>优点：代码简洁</li><li>缺点：无法显示溢出的部分</li></ul><p><strong>（3）父级添加 after 伪元素</strong></p><p>:after 方式是额外标签发的升级版。也是给父元素添加。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加如下样式 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123; <span class="comment">/* IE6、7专有 */</span></span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为父元素添加clearfix类 */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;clearfix&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>优点：没有增加标签，结构更简单</li><li>缺点：照顾低版本浏览器</li></ul><p>（4）父级添加双伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加如下样式 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为父元素添加clearfix类 */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;clearfix&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>优点：代码更简洁</li><li>缺点：照顾低版本浏览器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS盒子模型</title>
      <link href="/post/eb803673.html"/>
      <url>/post/eb803673.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、盒子模型">一、盒子模型</h2><p>网页布局学习有三大核心，盒子模型，浮动和定位，学习盒子模型可以帮助我们很好的布局页面。</p><h3 id="1-1-网页布局的本质">1.1 网页布局的本质</h3><p>网页布局过程：</p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子Box</li><li>利用CSS设置盒子样式，然后摆放到相应位置</li><li>往盒子里面装内容</li></ol><p>因此网页布局的本质：利用CSS摆盒子</p><h3 id="1-2-盒子模型的组成">1.2 盒子模型的组成</h3><p>CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距和实际内容</p><ol><li>border边框</li><li>content内容</li><li>padding内边距</li><li>margin外边距</li></ol><p><img src="https://img.mahaofei.com/img/202112231711309-html-notes4-1.png" alt=""></p><h3 id="1-3-边框border">1.3 边框border</h3><p><strong>boder</strong>可以设置元素的边框。边框有三部分组成：边框粗细、边框样式、边框颜色</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: border-width || border-style || border-color</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>border-width</td><td>定义边框粗细，单位是px</td></tr><tr><td>border-style</td><td>边框的样式（none默认无|solid实线|dashed虚线|dotted点线）</td></tr><tr><td>border-color</td><td>边框颜色（默认黑色）</td></tr></tbody></table><p><strong>（1）边框的复合写法：</strong>（没有顺序）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure><p><strong>（2）边框的分开写法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure><p><strong>（3）表格的细线边框</strong></p><p><strong>border-collapse</strong>属性控制浏览器绘制表格边框的方式。（绘制表格时两个单元格的边框重叠在一起，边框宽度会变粗）</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>-collpse: collapse;</span><br></pre></td></tr></table></figure><ul><li>collpse单词是合并的意思</li><li>border-collapse: collapse;表示相邻边框合并在一起</li></ul><p><strong>（4）边框会影响盒子大小</strong></p><p>边框会额外增加盒子的实际大小，因此我们有两种方案解决：</p><ol><li>测量盒子大小的时候，不量边框</li><li>如果测量的时候包含了边框，则需要width/height减去边框宽度</li></ol><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231711571-html-notes4-2.png" alt=""></p><h3 id="1-4-内边距padding">1.4 内边距padding</h3><p>padding属性用于设置内边距，即边框与内容之间的距离。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>padding-left</td><td>左内边距</td></tr><tr><td>padding-right</td><td>右内边距</td></tr><tr><td>padding-top</td><td>上内边距</td></tr><tr><td>padding-bottom</td><td>下内边距</td></tr></tbody></table><p><strong>padding简写</strong>：</p><table><thead><tr><th>值的个数</th><th>释义</th></tr></thead><tbody><tr><td>padding: 5px;</td><td>1个值，代表上下左右都有5px内边距</td></tr><tr><td>padding: 5px 10px;</td><td>2个值，代表上下内边距是5px，左右内边距是10px</td></tr><tr><td>padding: 5px 10px 20px;</td><td>3个值，代表上内边距5px，左右内边距10px，下内边距20px</td></tr><tr><td>padding: 5px 10px 20px 30px;</td><td>4个值，上是5px，右是10px，下是20px，左是30px（顺时针）</td></tr></tbody></table><p><strong>padding影响了盒子实际大小</strong></p><p>如果盒子已经有了宽度和高度，此时再指定内边框，会增大盒子。即内容不变只能使盒子变大。</p><p>解决方案：width/height减去多出来的内边距大小</p><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231712713-html-notes4-3.png" alt=""></p><h3 id="1-5-外边距margin">1.5 外边距margin</h3><p><strong>margin</strong>属性用于设置外边距，即控制盒子和盒子之间的距离</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>margin-left</td><td>左外边距</td></tr><tr><td>margin-right</td><td>右外边距</td></tr><tr><td>margin-top</td><td>上外边距</td></tr><tr><td>margin-bottom</td><td>下外边距</td></tr></tbody></table><p>margin的简写方式与padding一致。</p><p><strong>（1）外边距的典型应用</strong></p><p>margin可以让<strong>块级盒子水平居中</strong>，但必须满足两个条件：</p><ol><li>盒子必须指定宽度（width）</li><li>盒子左右的外边距都设置为auto。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123; <span class="attribute">width</span>: <span class="number">960px</span>; <span class="attribute">margin</span>: <span class="number">0</span> auto; &#125;</span><br></pre></td></tr></table></figure><p>以下三种写法都可以：</p><ul><li>margin-left:auto; margin-right:auto;</li><li>margin: auto;</li><li>margin: 0 auto;</li></ul><p><strong>行内元素或行内块元素水平居中</strong>：给父元素添加 text: align:center 即可。</p><p><strong>（2）外边距合并</strong></p><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p><ol><li>相邻块元素垂直外边距的合并</li></ol><p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则它们之间的垂直间距不是两者之和。<strong>取两个值中较大者，这种现象被称为相邻块元素垂直外边距的合并。</strong></p><p>解决方案：尽量只给一个盒子添加margin值。</p><ol start="2"><li>嵌套块元素垂直外边距的塌陷</li></ol><p>对于两个嵌套关系（父子关系）的元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><p><img src="https://img.mahaofei.com/img/202112231712550-html-notes4-4.png" alt=""></p><p>解决方案：</p><ol><li>为父元素定义上边框</li><li>为父元素定义上内边距</li><li>为父元素添加overflow:hidden</li></ol><h3 id="1-6-清除内外边距">1.6 清除内外边距</h3><p>网页元素很多都带有默认的内外编剧，而且不同浏览器默认的值也不一致。因此我们在布局前，首先要清除网页元素的内外边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</p><h2 id="二、特殊样式">二、特殊样式</h2><h3 id="2-1-圆角边框">2.1 圆角边框</h3><p>CSS3中新增了圆角边框杨适，这样我们的盒子就可以变圆角了。</p><p><strong>border-radius</strong>属性用于设置元素的外边框圆角</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>:length;</span><br></pre></td></tr></table></figure><ul><li><p>参数值可以为数值或百分比</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果是正方形，想要设置为一个圆，把数值修改为高度或宽度的一般即可，或者直接写为50%</p><p>同理如果是个矩形，半径设置为高度的一般就成了圆角矩形</p></li><li><p>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角。跟两个值，分别代表左上右下、右上左下。</p></li><li><p>圆角边框也可以分开写：如border-top-left-radius</p></li></ul><p><img src="https://img.mahaofei.com/img/202112231712931-html-notes4-5.png" alt=""></p><h3 id="2-2-盒子阴影">2.2 盒子阴影</h3><p>CSS3中新增了盒子阴影，可以使用box-shadown属性为盒子添加阴影。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必须。水平阴影的位置，允许负值。</td></tr><tr><td>v-shadow</td><td>必须。垂直阴影的位置，允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>spread</td><td>可选。阴影的尺寸。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr><tr><td>inset</td><td>可选。将外部阴影outset改为内部阴影</td></tr></tbody></table><ul><li>默认是外阴影outset，但是不可以写outset，否则会使阴影失效</li><li>盒子阴影不占用空间，不影响其他盒子的位置</li></ul><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> -<span class="number">3px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231712448-html-notes4-6.png" alt=""></p><h3 id="2-3-文字阴影">2.3 文字阴影</h3><p><strong>text-shadow</strong>属性可以将阴影应用于文本</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-show blur color;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必须。水平阴影的位置，允许负值。</td></tr><tr><td>v-shadow</td><td>必须。垂直阴影的位置，允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr></tbody></table><blockquote><p>本文参考了黑马程序员pink老师的视频教程<br><strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS进阶</title>
      <link href="/post/e36aeffb.html"/>
      <url>/post/e36aeffb.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS的复合选择器">一、CSS的复合选择器</h2><h3 id="1-1-复合选择器">1.1 复合选择器</h3><p>CSS中根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合而成的。</p><ul><li><p>复合选择器可以更准确、更高效的选择目标标签</p></li><li><p>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的。</p></li><li><p>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等</p></li></ul><h3 id="1-2-后代选择器">1.2 后代选择器</h3><p>后代选择器又称包含选择器，可以选择父元素里面的子元素。其写法就是把<strong>外层元素写在前面</strong>，<strong>内层元素写在后面</strong>，<strong>中间用空格分离</strong>。放标签发生嵌套时，内层标签就成为外层标签的后代。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素1 元素2 &#123;属性1: 属性值1...&#125;</span><br></pre></td></tr></table></figure><p>上述语法表示：<strong>选择元素1里面的所有元素2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例:选择ul里面所有li标签 --&gt;</span></span><br><span class="line">ul li &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><ul><li><p>元素2可以是子元素，也可是子元素的子元素,只要是元素1的后代即可</p></li><li><p>元素1和元素2可以是任意基础选择器，例如<code>.nav li a</code> {}</p></li></ul><h3 id="1-3-子选择器">1.3 子选择器</h3><p>子元素选择器，只能选择某元素的最近一级元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素1&gt;元素2 &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><p>上述语法表示：<strong>选择元素1里面的所有直接后代元素2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例:选择div里面所有最近一级p标签 --&gt;</span></span><br><span class="line">div&gt;p &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-并集选择器">1.4 并集选择器</h3><p>并集选择器可以选择多组标签，通常用于集体声明</p><p>并集选择器是各选择器通过<strong>英文逗号“，”连接而成</strong>，<strong>任何形式的选择器都可以</strong>作为并集选择器的一部分</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素1, 元素2 &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><p>上述语法表示<strong>选择元素1和元素2</strong></p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择u1和div标签元素 --&gt;</span></span><br><span class="line">u1, div &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-伪类选择器">1.5 伪类选择器</h3><p>伪类选择器用于向某些选择器添加特殊效果，比如给链接添加特殊效果，或者选择第1个，第n个元素</p><p>伪类选择器书写的最大特点是用**冒号“:”表示，比如<code>:first-child</code>，<code>:hover</code></p><p>伪类选择器有很对，如链接伪类、结构伪类等。</p><p><strong>（1）链接伪类选择器</strong></p><p>链接伪类选择器常用于，鼠标经过链接时，链接的颜色或其他样式发生改变。</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>a:link</td><td>选择所有未被访问的链接</td></tr><tr><td>a:visited</td><td>选择所有已被访问的链接</td></tr><tr><td>a:hover</td><td>选择鼠标指针位于其上的链接</td></tr><tr><td>a:active</td><td>选择活动链接（鼠标按下未弹起的链接）</td></tr></tbody></table><p>注意事项：</p><ul><li>为了确保生效，请按照<strong>LVHA</strong>的顺序声明：link - visited - hover active</li><li>因为a链接在浏览器中有默认的样式，因此实际工作中都需要给链接单独指定样式</li></ul><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">color: gray;</span><br><span class="line">text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">color: skyblue;</span><br><span class="line">text-decoration: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）:focus伪类选择器</strong></p><p><strong>:focus伪类选择器</strong>用于选取获得焦点的表单元素</p><p>焦点就是光标，一般情况<code>&lt;input&gt;</code>类表单元素才能获取，因此这个选择器也主要针对表单元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input:focus &#123;</span><br><span class="line">background-color: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-复合选择器总结">1.6 复合选择器总结</h3><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择后代元素</td><td>可以是子、孙</td><td>较多</td><td>符号是<strong>空格</strong>，.nav a</td></tr><tr><td>子代选择器</td><td>选择最近一级元素</td><td>只选子</td><td>较少</td><td>符号是<strong>大于</strong>，.nav&gt;p</td></tr><tr><td>并集选择器</td><td>选择某些相同样式的元素</td><td>可以用于集体声明</td><td>较多</td><td>符号是<strong>逗号</strong>，.nav, .header</td></tr><tr><td>链接伪类选择器</td><td>选择不同状态的链接</td><td>跟链接相关</td><td>较多</td><td>重点记住a{}和a:hover实际开发的写法</td></tr><tr><td>:focus选择器</td><td>选择获得光标的表单</td><td>跟表单相关</td><td>较少</td><td>input:focus</td></tr></tbody></table><h2 id="二、CSS的元素显示模式">二、CSS的元素显示模式</h2><h3 id="2-1-什么是元素显示模式">2.1 什么是元素显示模式</h3><p>网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好地布局我们的网页。</p><p>元素显示模式就是元素（标签）以什么形式进行显示，比如<code>&lt;div&gt;</code>自己占一行，而一行可以放多个<code>&lt;span&gt;</code></p><p>HTML元素一般分为<strong>块元素</strong>和<strong>行内元素</strong>两种类型</p><h3 id="2-2-块元素">2.2 块元素</h3><p>常见的块元素有 <code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等，其中<code>div</code>是最典型的块元素</p><ul><li>块元素子集独占一行</li><li>高度，宽度，外边距，内边距都可以控制</li><li>宽度默认是容器父级的100%</li><li>是一个容器或盒子，里面可以放行内元素或块元素</li></ul><p>注意：文字类的元素内不能使用块级元素，<code>&lt;p&gt;</code>内不能放块级元素<code>&lt;div&gt;</code>等，同理<code>&lt;h1&gt;~&lt;h6&gt;</code>等都是文字类块级标签，里面也不能放其他块级元素。</p><h3 id="2-3-行内元素">2.3 行内元素</h3><p>常见的行内元素有<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;span&gt;</code>等，其中<code>&lt;span&gt;</code>是最典型的行内元素，有些地方也称行内元素为内联元素。</p><ul><li>相邻行内元素在一行上，一行可以放多个行内元素</li><li>高、宽直接设置是无效的</li><li>默认宽度就是本身内容的宽度</li><li>行内元素只能容纳文本或其他行内元素</li></ul><p>注意：链接里面不能再放链接，但特殊情况下a标签内可以放块级元素。</p><h3 id="2-4-行内块元素">2.4 行内块元素</h3><p>在行内元素中有几个特殊的标签：<code>&lt;img&gt;</code>、<code>&lt;imput&gt;</code>、<code>&lt;td&gt;</code>，他们同时具有块元素和行内元素的特点。</p><ul><li>和相邻行内元素或行内块元素在一行上，但是它们之间会有空隙，一行可以显示多个</li><li>默认宽度是本身内容的宽度</li><li>高度、行高、外边距和内边距都可以控制</li></ul><h3 id="2-5-元素显示模式总结">2.5 元素显示模式总结</h3><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置宽度高度</td><td>容器的100%</td><td>可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以直接设置宽度高度</td><td>本身内容的宽度</td><td>只可以包含行内元素</td></tr><tr><td>行内块元素</td><td>一行可以放多个行内块元素</td><td>可以直接设置宽度高度</td><td>本身内容的宽度</td><td></td></tr></tbody></table><h3 id="2-6-元素显示模式的转换">2.6 元素显示模式的转换</h3><p>特殊情况下，我们需要元素模式的转换，简单理解就是，一个模式的元素需要另外一种模式的特性</p><p>例如，想要增大链接<code>&lt;a&gt;</code>的触发范围</p><p><strong>转换为块元素：<code>display:block</code></strong></p><p>转换为行内元素：<code>display:inline</code></p><p><strong>转换为行内块元素：<code>display:inline-block</code></strong></p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、CSS的背景">三、CSS的背景</h2><p>通过CSS背景属性可以为页面内元素添加背景样式</p><p>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p><h3 id="3-1-背景颜色">3.1 背景颜色</h3><p><strong>background-color</strong> 可以设置背景颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-color: 颜色值</span><br></pre></td></tr></table></figure><p>颜色参数：transparent 透明（默认）或color</p><h3 id="3-2-背景图片">3.2 背景图片</h3><p><strong>background-image</strong> 属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片或者超大的背景图片，优点是非常便于控制位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: none|url</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>无背景（默认）</td></tr><tr><td>url</td><td>使用绝对或相对地址指定背景图像</td></tr></tbody></table><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-image: url(images/background.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-背景平铺">3.3 背景平铺</h3><p><strong>background-repeat</strong> 使HTML页面上对背景图像进行平铺</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-repeat: repeat | no-repeat | repeat-x | repeat-y</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>repeat</td><td>背景图像在纵向和横向上平铺（默认）</td></tr><tr><td>no-repeat</td><td>背景图像不平铺</td></tr><tr><td>repeat-x</td><td>背景图像在横向平铺</td></tr><tr><td>repeat-y</td><td>背景图像在纵向平铺</td></tr></tbody></table><p>页面元素既可以添加背景颜色，也可以添加背景图片，背景图片在上层。</p><h3 id="3-4-背景位置">3.4 背景位置</h3><p><strong>background-position</strong> 可以改变图片在背景中的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position: x y;</span><br></pre></td></tr></table></figure><p>参数是：x坐标和y坐标，可以使用方位名词或者精确单位</p><table><thead><tr><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>百分数|由浮点数字和单位标识符组成的长度值</td></tr><tr><td>position</td><td>top|center|bottom|left|center|right 等方位名词</td></tr></tbody></table><p><strong>（1）参数为方位名词</strong></p><ul><li>如果指定的两个词都是方位名词，则两个值前后顺序无关，比如left top和top left效果一致</li><li>如果只指定了一个方位名词，另一个忽略，则第二个默认居中对齐</li></ul><p><strong>（2）参数为精确单位</strong></p><ul><li>如果参数值是精确坐标，那么第一个一定是x坐标，第二个一定是y坐标</li><li>如果只指定了一个数值，则数值一定指x，y坐标默认垂直居中</li></ul><p><strong>（3）参数为混合单位</strong></p><ul><li>如果指定的两个值是精确单位和方位名词混合使用，第一个值一定是x坐标，第二个是y坐标</li></ul><h3 id="3-5-背景固定">3.5 背景固定</h3><p><strong>background-attachment</strong> 属性设置背景图像是否固定或者随着页面的区域部分滚动，可以制作视差滚动的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-attachment: scroll | fixed</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>scroll</td><td>背景图像是否随对象内容滚动（默认）</td></tr><tr><td>fixed</td><td>背景图像固定</td></tr></tbody></table><h3 id="3-6-背景属性复合写法">3.6 背景属性复合写法</h3><p>为了简化背景属性的代码，我们可以将这些属性合并简写在同一个background属性中，减少代码量。</p><p>当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：</p><p><strong>background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</strong></p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: transparent url(image.jpg) repeat-none fixed top center</span><br></pre></td></tr></table></figure><h3 id="3-7-背景色半透明">3.7 背景色半透明</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(0, 0, 0, 0.3);</span><br></pre></td></tr></table></figure><p>四个参数分别为<strong>r，g，b和alpha透明度</strong>，最后一个alpha透明度取值范围为0~1，0代表完全透明。</p><p>此属性只是让背景颜色半透明，里面的内容不受影响。</p><h3 id="3-8-背景总结">3.8 背景总结</h3><table><thead><tr><th>属性</th><th>作用</th><th>值</th></tr></thead><tbody><tr><td>background-color</td><td>背景颜色</td><td>预定义的颜色值/十六进制/RGB代码</td></tr><tr><td>background-image</td><td>背景图片</td><td>url(图片路径)</td></tr><tr><td>background-repeat</td><td>是否平铺</td><td>repeat/no-repeat/repeat-x/repeat-y</td></tr><tr><td>background-position</td><td>背景位置</td><td>length/position 分别是x 和 y坐标</td></tr><tr><td>background-attachment</td><td>背景附着</td><td>scroll背景滚动、fixed背景固定</td></tr><tr><td>背景简写</td><td>减少代码量</td><td>背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</td></tr><tr><td>背景色半透明</td><td>颜色半透明</td><td>background: rgba(0,0,0,0.3);</td></tr></tbody></table><p>背景图片：实际开发中常用于装饰性的小图片，或者超大的背景图片，优点是非常便于控制位置。</p><h2 id="四、CSS三大特性">四、CSS三大特性</h2><p>CSS由三个非常重要的特性：层叠性、继承性、优先级</p><h3 id="4-1-层叠性">4.1 层叠性</h3><p>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。</p><p>层叠的原则是：</p><ul><li>样式冲突，遵循就近原则，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，则不会层叠</li></ul><h3 id="4-2-继承性">4.2 继承性</h3><p>子标签会继承父标签的某些样式，如文本颜色和字号等。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>div内的p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时如果设置div的样式，则p标签也会继承div的样式。</p><p>可继承的样式有：text-，font-，line-这些元素开头的可以继承，以及color属性。</p><p><strong>行高的继承性</strong>：</p><p>行高可以跟单位，也可以不跟单位</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">font: 12px/1.5;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的1.5代表当前元素文字大小的1.5倍。即div中的行高是21px，body中其它标签的行高默认是18px。</p><h3 id="4-3-优先级">4.3 优先级</h3><p>当同一个元素指定多个选择器，就会有优先级的产生。</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，则根据选择器权重执行</li></ul><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承 或 通配符选择器*</td><td>0,0,0,0</td></tr><tr><td>元素选择器</td><td>0,0,0,1</td></tr><tr><td>类选择器，伪类选择器</td><td>0,0,1,0</td></tr><tr><td>ID选择器</td><td>0,1,0,0</td></tr><tr><td>行内样式 style=“”</td><td>1,0,0,0</td></tr><tr><td>!important</td><td>最大</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: greenyellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: pink;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总而言之，<strong>作用范围越大，权重越低，作用范围越小，权重越高。</strong></p><p><strong>权重叠加</strong>：</p><p>如果是复合选择器，则会有权重叠加，需要计算权重</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ul内的li权重是0,0,0,1+0,0,0,1=0,0,0,2 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: darkcyan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* li的权重是0,0,0,1 */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* .nav内的li权重是0,0,1,0+0,0,0,1=0,0,1,1 */</span></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>权重只会叠加，不会进位</li><li>权重比较是从左到右逐位进行比较</li></ul><blockquote><p>本文参考了黑马程序员pink老师的视频教程<br><strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS基础</title>
      <link href="/post/4d1b2e53.html"/>
      <url>/post/4d1b2e53.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS简介">一、CSS简介</h2><p>CSS的主要使用目的就是美化网页，布局页面</p><h3 id="1-1-HTML的局限性">1.1 HTML的局限性</h3><p>HTML只关注内容的语义，比如<code>&lt;h1&gt; </code>只表明这是一个标题，<code>&lt;p&gt; </code>只表明这是一个段落等。</p><p>只用HTML时，网页显示效果很不好看。因为HTML可以做简单的样式，但是十分繁琐和臃肿。</p><p><strong>即，HTML主要做结构，显示元素内容。</strong></p><h3 id="1-2-CSS的作用">1.2 CSS的作用</h3><p>CSS是层叠样式表的简称，也成为CSS样式表或级联样式表。</p><p>CSS也是一种标记语言，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p><p><strong>简单来说，CSS可以美化HTML，让页面布局更简单。</strong></p><h3 id="1-3-CSS语法规范">1.3 CSS语法规范</h3><p>CSS规则有两个主要部分组成：选择器以及一条或多条声明。</p><p><code>选择器 &#123;属性:值 属性:值&#125;</code></p><p>选择器是用于指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式。</p><p>属性和属性值以“键值对”的形式出现</p><h3 id="1-4-CSS代码风格">1.4 CSS代码风格</h3><p>代码风格推荐</p><ol><li><p>样式格式书写</p><ul><li><p>展开格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h3 &#123;</span><br><span class="line">color: blue;</span><br><span class="line">font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>样式大小写</p><ul><li>样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外。</li></ul></li><li><p>空格规范</p><ul><li>在属性值前面，冒号后面，保留一个空格；</li><li>选择器和大括号中间保留空格</li></ul></li></ol><h2 id="二、CSS基础选择器">二、CSS基础选择器</h2><h3 id="2-1-CSS选择器的作用">2.1 CSS选择器的作用</h3><p>选择器就是根据不同需求把不同的标签选出来，这就是选择器的作用，简单来说，<strong>就是选择标签用的</strong>。</p><h3 id="2-2-选择器的分类">2.2 选择器的分类</h3><p>选择器分为<strong>基础选择器和复合选择器</strong></p><p>其中，基础选择器是由单个选择器组成的</p><p>基础选择器又包括：标签选择器、类选择器、id选择器和通配符选择器</p><h3 id="2-3-标签选择器">2.3 标签选择器</h3><p>使用<strong>HTML标签名</strong>作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标签名 &#123;</span><br><span class="line">属性1: 属性值1;</span><br><span class="line">属性2: 属性值2;</span><br><span class="line">属性3: 属性值3;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：把某一类标签全部选择出来，例如所有的<code>&lt;div&gt;</code>标签，所有的<code>&lt;p&gt;</code>标签。</p><p><strong>优点</strong></p><p>能快速为页面中同类型的标签统一设置样式。</p><p><strong>缺点</strong></p><p>不能差异化设置，只能选择全部的当前标签。</p><h3 id="2-4-类选择器">2.4 类选择器</h3><p>如果想要差异化选择不同的标签，单独选一个或者选几个标签，可以使用类选择器。</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">属性1: 属性值1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=`<span class="attr">red</span>`&gt;</span> 红色 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>类选择器口诀</strong>：样式点定义，结构类调用，一个或多个，开发最常用。</p></blockquote><p><strong>注意事项</strong></p><ol><li>长名称或词组可以使用短横线来表示。</li><li>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</li><li>命名要有意义，尽量使别人一眼就知道这个类名的目的。</li></ol><p><strong>多类名</strong></p><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，简单理解就是一个标签有多个名字。</p><ol><li><p>多类名使用方式</p><p><code>&lt;div class=&quot;red fong35&quot;&gt;Huffie&lt;/div&gt;</code></p><ul><li>在标签class属性中写多个类名</li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ul></li><li><p>多类名的优点</p><ul><li>节省CSS代码，统一修改也非常方便</li><li>多类名选择器在后期布局比较复杂的情况下，使用比较多</li></ul></li></ol><h3 id="2-5-id选择器">2.5 id选择器</h3><p>id选择器可以为标有特定id的HTML元素指定特定的样式</p><p>HTML元素以<strong>id属性</strong>来设置id选择器，CSS中id选择器以&quot;<strong>#</strong>&quot;来定义</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id名&#123;</span><br><span class="line">属性: 属性值1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>口诀：样式#定义，结构id调用，只能调用一次，别人切勿使用</p></blockquote><h3 id="2-6-通配符选择器">2.6 通配符选择器</h3><p>在CSS中，通配符选择器使用&quot;*&quot;定义，他表示选取页面中的所有元素</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">属性1: 属性值1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通配符选择器不需要调用，自动就给所有的元素使用样式</li><li>特殊情况下才使用</li></ol><h3 id="2-7-基础选择器总结">2.7 基础选择器总结</h3><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签</td><td>不能差异化选择</td><td>较多</td><td>p {color: red;}</td></tr><tr><td>类选择器</td><td>可以选出1个或多个标签</td><td>可以根据需求选择</td><td>非常多</td><td>.nav{color: red;}</td></tr><tr><td>id选择器</td><td>一次只能选择1个标签</td><td>ID属性只能在每个HTML文档中出现一次</td><td>一般和js搭配</td><td>#nav{color: red;}</td></tr><tr><td>通配符选择器</td><td>选择所有标签</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td>* {color: red;}</td></tr></tbody></table><h2 id="三、CSS字体属性">三、CSS字体属性</h2><p>CSS Fonts字体属性用于定义字体系列、大小、粗细和文字样式。</p><h3 id="3-1-字体系列">3.1 字体系列</h3><p>CSS使用<strong>font-family</strong>属性定义文本的字体系列。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h2 &#123;font-family: &quot;Microsoft Yahei&quot;;&#125;</span><br><span class="line">p &#123;font-family: Arial, &quot;Times New Roman&quot;;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以写多个字体，字体之间用英文逗号分隔</p><p>浏览器会优先使用第一个字体，如果用户电脑上没有安装第一个字体，则会按顺序检索。</p></li><li><p>如果字体名由多个单词组成，用引号包含</p></li><li><p>尽量使用系统默认的字体，保证任何用户的浏览器都能正确显示</p><p>常用字体：“Microsoft Yahei”, tahoma, arial, “Hiragino Sans GB”</p></li></ul><h3 id="3-2-字体大小">3.2 字体大小</h3><p>CSS使用font-size属性定义字体大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;font-size 20px;&#125;</span><br></pre></td></tr></table></figure><ul><li>谷歌浏览器默认文字大小为16px</li><li>不同浏览器可能默认现实的字号大小不一致，我们尽量给字体大小一个明确值</li><li>可以给body指定整个页面文字的大小</li></ul><h3 id="3-3-字体粗细">3.3 字体粗细</h3><p>CSS使用font-weight属性设置文本字体的粗细</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.bold &#123;font-weight: bold;&#125;</span><br><span class="line">.bold &#123;font-weight: 700;&#125;</span><br></pre></td></tr></table></figure><p>参数：normal正常，bold加粗，数字100-900也可表示字体粗细</p><p>实际开发中我们提倡使用数字：<strong>400 正常，700 加粗</strong></p><h3 id="3-4-文字样式">3.4 文字样式</h3><p>CSS使用font-style属性设置文本的风格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>normal</td><td>默认值，浏览器会显示标准的字体样式</td></tr><tr><td>italic</td><td>浏览器会显示斜体的字体样式</td></tr></tbody></table><p>注意：我们很少给文字加斜体，反而要给斜体标签(em, i)改为正常</p><h3 id="3-5-字体复合属性">3.5 字体复合属性</h3><p>字体属性可以把文字样式综合起来写，这样可以更节约代码</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;font: font-style font-weight font-size/line-height font-family;&#125;</span><br></pre></td></tr></table></figure><p><strong>例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: italic 700 16px &quot;Microsoft Yahei&quot;</span><br></pre></td></tr></table></figure><ul><li>使用font属性时，必须按照上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开</li><li>不需要设置属性可以省略，但必须保留font-size和font-family属性，否则font属性不起作用</li></ul><h3 id="3-6-字体属性总结">3.6 字体属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>font-size</td><td>字号</td><td>通常的单位是px像素，一定要加单位</td></tr><tr><td>font-family</td><td>字体</td><td>“Microsoft Yahei”, tahoma, arial, “Hiragino Sans GB”</td></tr><tr><td>font-weight</td><td>粗细</td><td>加粗是700/bold，不加粗是400/normal，数字没有单位</td></tr><tr><td>font-style</td><td>样式</td><td>倾斜是italic，正常是normal，常用normal</td></tr><tr><td>font</td><td>复合属性</td><td>符合属性是有顺序的，不能随意换位置，字号和字体必须有</td></tr></tbody></table><h2 id="四、CSS文本属性">四、CSS文本属性</h2><p>CSS Text文本属性可以定义文本的外观，别如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="4-1-文本颜色">4.1 文本颜色</h3><p><strong>color属性</strong>用于定义文本的颜色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;color: red;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表示形式</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色值</td><td>red, green, blue, pink</td></tr><tr><td>十六进制</td><td>#FF0000, #123456, #666666</td></tr><tr><td>RGB代码</td><td>rgb(255,0,0)或rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="4-2-对齐文本">4.2 对齐文本</h3><p><strong>text-align属性</strong>用于设置元素内文本内容的水平对齐方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;text-align: center;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中</td></tr></tbody></table><h3 id="4-3-装饰文本">4.3 装饰文本</h3><p><strong>text-decoration属性</strong>规定添加到文本的装饰，可以给文本添加下划线、删除线、上划线等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;text-decoration: underline;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>无（最常用，超链接去下划线）</td></tr><tr><td>underline</td><td>下划线（常用）</td></tr><tr><td>overline</td><td>上划线（几乎不用）</td></tr><tr><td>line-through</td><td>删除线（几乎不用）</td></tr></tbody></table><h3 id="4-4-文本缩进">4.4 文本缩进</h3><p><strong>text-indent属性</strong>用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;text-indent: 2em;&#125;</span><br></pre></td></tr></table></figure><p>通过设置该属性，该元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p><p>em是一个相对单位，是当前元素的文字大小。</p><h3 id="4-5-行间距">4.5 行间距</h3><p><strong>line-height属性</strong>用于设置行间的距离（行高），可以控制文字行与行之间的距离</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;line-height: 26px;&#125;</span><br></pre></td></tr></table></figure><p>行间距=上间距+文本高度+下间距，行高改变的是上下两个间距。</p><h3 id="4-6-文本属性总结">4.6 文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>通常使用16进制</td></tr><tr><td>text-align</td><td>文本对齐</td><td>可以设定文字水平的对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>用于设定段落首行缩进两字符 text-indent: 2em</td></tr><tr><td>text-decoration</td><td>文本修饰</td><td>添加下划线underline，取消下划线none</td></tr><tr><td>line-height</td><td>行高</td><td>控制行与行的距离</td></tr></tbody></table><h2 id="五、CSS的引入方式">五、CSS的引入方式</h2><h3 id="5-1-CSS的三种样式表">5.1 CSS的三种样式表</h3><p>按照CSS样式书写的位置（或者引入的样式），CSS样式表可以分为三大类：</p><ol><li>行内样式表（行内式）</li><li>内部样式表（嵌入式）</li><li>外部样式表（链接式）</li></ol><h3 id="5-2-内部样式表">5.2 内部样式表</h3><p>内部样式表是写到html页面内部，将所有的CSS代码抽取出来，单独放到一个<code>&lt;style&gt;</code>标签中。内部样式表设定CSS，也被称为嵌入式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>理论上<code>&lt;style&gt;</code>标签可以放到任何位置，但一般放在<code>&lt;head&gt;</code>标签。</li><li>这种方式可以控制整个页面的元素样式</li><li>代码结构清晰，但并没有实现结构和样式的完全分离</li></ul><h3 id="5-3-行内样式表">5.3 行内样式表</h3><p>行内样式表是在元素标签内部的style属性中设定CSS杨适。适合于修改简单样式。通常也称为行内式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>Hello world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>style其实就是标签的属性</li><li>在双引号中间，写法要符合CSS规范</li><li>只可以控制当前标签样式</li><li>书写过于繁琐，不推荐大量使用，只有对当前元素添加简单样式的时候考虑使用。</li></ul><h3 id="5-4-外部样式表">5.4 外部样式表</h3><p>实际开发都是外部样式表，适合样式比较多的情况，核心是：样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。</p><p>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为.css的样式文件，把所有CSS代码都放入此文件中。</li><li>在HTML页面中，使用<code>&lt;link&gt;</code>标签引入这个文件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>rel</td><td>定义当前文档与被链接文档之间的关系，这里需要指定为&quot;stylesheet&quot;，即被链接的文档是一个样式表文件</td></tr><tr><td>href</td><td>定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</td></tr></tbody></table><h3 id="5-5-CSS引入方式总结">5.5 CSS引入方式总结</h3><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>结构样式混写</td><td>较少</td><td>控制一个标签</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多</td><td>控制多个页面</td></tr></tbody></table><h2 id="六、Chrome调试工具">六、Chrome调试工具</h2><p>Chrome浏览器提供了一个非常好用的调试工具，可以用来调试我们的HTML结构和CSS样式。</p><h3 id="6-1-打开调试工具">6.1 打开调试工具</h3><p>在页面右键点击审查元素，或者按F12</p><h3 id="6-2-使用调试工具">6.2 使用调试工具</h3><ol><li>左边是HTML，右边是CSS杨适</li><li>使用<code>Ctrl+滚轮</code>可以放大代码字体大小</li><li>右边CSS样式可以改动数值和查看颜色</li><li><code>Ctrl+0</code>复原浏览器大小</li><li>如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误</li><li>如果有样式，但是样式前面有黄色感叹号提示，则是样式属性书写错误</li></ol><blockquote><p>本文参考了黑马程序员pink老师的视频教程<br><strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | HTML基础</title>
      <link href="/post/8861e96a.html"/>
      <url>/post/8861e96a.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、HTML的介绍">一、HTML的介绍</h3><h4 id="1-1-什么是HTML">1.1 什么是HTML</h4><p>HTML是用来描述网页的一种语言</p><p>HTML指超文本标记语言</p><p>HTML不是编程语言，是一种标记语言</p><h4 id="1-2-HTML5的新特性">1.2 HTML5的新特性</h4><p>用于绘画的canvas标签</p><p>用于媒介回放的video和audio元素</p><p>对本地离线存储的更好支持</p><p>新的特殊内容：article、footer、header、nav、section</p><p>新的表单控件：calendar、date、time、email、url、search</p><p>浏览器的支持：Safari、Chrome、Firefox以及Opera包括IE9以上</p><h3 id="二、HTML基础">二、HTML基础</h3><h4 id="2-1-声明">2.1 声明</h4><p><strong>声明：</strong><code>&lt;!DOCTYPE html&gt;</code></p><p>HTML有多个不同的版本，只有明白页面使用的确切的HTML版本，浏览器才能完全正确的显示出HTML页面。</p><blockquote><p>HTML5：<code>&lt;!DOCTYPE html&gt;</code></p><p>HTML4.01:<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;  &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></p></blockquote><h4 id="2-2-基础标签">2.2 基础标签</h4><p><strong>基础标签：</strong><code>&lt;head&gt; &amp; &lt;body&gt;</code></p><ol><li>head：定义头部。如编码格式(UTF-8)、标题(title)、文字的显示形式，</li><li>body：页面的内容，其他的标签等</li></ol><h4 id="2-3-HTML标题">2.3 HTML标题</h4><p><strong>标题：</strong><code>&lt;h1&gt; &lt;h2&gt;……&lt;h6&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题h4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题h5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题h6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231706893-html-notes1-1.png" alt=""></p><h4 id="2-4-HTML段落">2.4 HTML段落</h4><p><strong>段落：</strong><code>&lt;p&gt;</code></p><p>定义一个段落</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello World</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231706461-html-notes1-2.png" alt=""></p><h4 id="2-5-HTML链接">2.5 HTML链接</h4><p><strong>链接：</strong><code>&lt;a&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span>Half_A的CSDN主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231706044-html-notes1-3.png" alt=""></p><h4 id="2-6-HTML图像">2.6 HTML图像</h4><p><strong>图像：</strong><code>&lt;img&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/Huffie.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231707957-html-notes1-4.png" alt=""></p><h3 id="三、HTML元素、属性和格式化">三、HTML元素、属性和格式化</h3><h4 id="3-1-元素">3.1 元素</h4><p>元素是指从开始标签到结束标签的所有内容</p><table><thead><tr><th>开始标签</th><th>元素内容</th><th>结束标签</th></tr></thead><tbody><tr><td><code>&lt;p&gt;</code></td><td>this is my page</td><td><code>&lt;/p&gt;</code></td></tr></tbody></table><blockquote><p><code>&lt;p&gt;&lt;/p&gt;</code>是段落标记，<code>&lt;br/&gt;</code>是换行符</p><p>二者虽然都可以实现换行，但其行间距不一样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is my webpage<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> Hello,world<span class="tag">&lt;<span class="name">br</span>/&gt;</span>Huffie</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231707062-html-notes1-5.png" alt=""></p></blockquote><ul><li>元素内容是指从开始标签到结束标签之间的内容</li><li>空元素在开始标签中进行关闭（如<code>&lt;br/&gt;</code>）</li><li>大多数HTML元素可拥有属性</li><li>大多数HTML元素都是可以嵌套的</li></ul><h4 id="3-2-HTML属性">3.2 HTML属性</h4><ol><li><p>标签可以拥有属性为元素提供更多的信息</p></li><li><p>属性以键/值对的形式出现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">href=&quot;www.huffie.top&quot;</span><br></pre></td></tr></table></figure></li><li><p>常用标签属性</p><p><code>&lt;h1&gt;:align</code> ：对齐方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><body>:bgcolor`  背景颜色  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#ebebeb&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：bgcolor设置背景颜色，background设置背景图片</p><p><code>&lt;a&gt;:target</code>  规定在何处打开链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通用属性</p><table><thead><tr><th>通用属性</th><th>作用</th></tr></thead><tbody><tr><td>class</td><td>规定元素的类名</td></tr><tr><td>id</td><td>规定元素唯一ID</td></tr><tr><td>style</td><td>规定元素样式</td></tr><tr><td>title</td><td>规定元素的额外信息</td></tr></tbody></table></li></ol><h4 id="3-3-格式化">3.3 格式化</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;b&gt;</code></td><td>定义粗体文本</td></tr><tr><td><code>&lt;big&gt;</code></td><td>定义大号字</td></tr><tr><td><code>&lt;em&gt;</code></td><td>定义着重文字</td></tr><tr><td><code>&lt;i&gt;</code></td><td>定义斜体字</td></tr><tr><td><code>&lt;small&gt;</code></td><td>定义小号字</td></tr><tr><td><code>&lt;strong&gt;</code></td><td>定义加重语气</td></tr><tr><td><code>&lt;sub&gt;</code></td><td>定义下标字</td></tr><tr><td><code>&lt;sup&gt;</code></td><td>定义上标字</td></tr><tr><td><code>&lt;ins&gt;</code></td><td>定义插入字</td></tr><tr><td><code>&lt;del&gt;</code></td><td>定义删除字</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello, I&#x27;m huffie!<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>标签 b：欢迎来到我的博客<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">big</span>&gt;</span>标签 big: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">big</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>标签 em: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>标签 i: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>标签 small: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>标签 strong: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 标签 sub: 欢迎来到<span class="tag">&lt;<span class="name">sub</span>&gt;</span>这是上标<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>我的博客</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 标签 sup: 欢迎来到<span class="tag">&lt;<span class="name">sup</span>&gt;</span>这是下标<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>我的博客</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ins</span>&gt;</span>标签 ins: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">del</span>&gt;</span>标签 del: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231707703-html-notes1-6.png" alt=""></p><h3 id="四、样式、链接和表格">四、样式、链接和表格</h3><h4 id="4-1-样式">4.1 样式</h4><ol><li><p>标签：</p><ul><li><code>&lt;style&gt;</code>：样式定义</li><li><code>&lt;link&gt;</code>：资源引用</li></ul></li><li><p>属性：</p><ul><li>rel=“stylesheet”：外部样式表</li><li>type=“text/css”：引入文档的类型</li><li>margin-left：边距</li></ul></li><li><p>样式的插入方式</p><ul><li><p>外部样式表</p><p><strong>语法：</strong><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></p><p>即指定外部引用资源，文档类型为css，具体位置为mystyle.css</p><p>**例：**index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mystyle.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231707135-html-notes1-7.png" alt=""></p><ul><li><p>内部样式表</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>欢迎来到我的博客<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img.mahaofei.com/img/202112231708041-html-notes1-8.png" alt=""></p><ul><li><p>内联样式表</p><p><strong>语法：</strong><code>    &lt;p style=&quot;color: blueviolet;&quot;&gt;点击我跳转到CSDN&lt;/a&gt;</code></p><p><strong>例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blueviolet;&quot;</span>&gt;</span>点击我跳转到CSDN<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-链接">4.2 链接</h4><ol><li><p>链接数据包括 文本链接、图片链接</p></li><li><p>属性：</p><ul><li>href属性：指向另一个文档的链接</li><li>name属性：创建文档内的链接</li></ul></li><li><p>img标签属性：</p><ul><li>alt：替换文本属性</li><li>width：宽</li><li>height：高</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.huffie.top&quot;</span>&gt;</span>点击我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.huffie.top&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/Huffie.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;huffie.jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;tips&quot;</span>&gt;</span>页内锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#tip&quot;</span>&gt;</span>跳转到页内锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231708036-html-notes1-9.png" alt=""></p><h4 id="4-3-表格">4.3 表格</h4><p><strong>（1）表格标签：</strong></p><table><thead><tr><th>表格</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;table&gt;</code></td><td>定义表格</td></tr><tr><td><code>&lt;caption&gt;</code></td><td>定义表格标题</td></tr><tr><td><code>&lt;th&gt;</code></td><td>定义表格的表头</td></tr><tr><td><code>&lt;tr&gt;</code></td><td>定义表格的行</td></tr><tr><td><code>&lt;td&gt;</code></td><td>定义表格单元</td></tr><tr><td><code>&lt;thead&gt;</code></td><td>定义表格的页眉</td></tr><tr><td><code>&lt;tbody&gt;</code></td><td>定义表格的主体</td></tr><tr><td><code>&lt;tfoot&gt;</code></td><td>定义表格的页脚</td></tr><tr><td><code>&lt;col&gt;</code></td><td>定义表格的列属性</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231708632-html-notes1-10.png" alt=""></p><p><strong>（2）表格属性</strong></p><ol><li><p>边框属性：border例：<code>&lt;table border=&quot;1&quot;&gt;</code></p></li><li><p>表格中的列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>单元格大小：cellpadding    例：<code>&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;</code></p></li></ol><p><img src="https://img.mahaofei.com/img/202112231708556-html-notes1-11.png" alt=""></p><ol start="4"><li>单元格间距：cellspacing    例：<code>&lt;table border=&quot;1&quot; cellspacing=&quot;10&quot;&gt;</code></li></ol><p><img src="https://img.mahaofei.com/img/202112231708504-html-notes1-12.png" alt=""></p><ol start="5"><li>单元格背景颜色：bgcolor    例：<code>&lt;table border=&quot;1&quot; bgcolor=&quot;#cccccc&quot;&gt;</code></li><li>单元格背景图片：background    例：<code>&lt;table border=&quot;1&quot; background=&quot;huffie.jpg&quot;&gt;</code></li></ol><h3 id="五、HTML列表、块和布局">五、HTML列表、块和布局</h3><h4 id="5-1-列表">5.1 列表</h4><p><strong>（1）标签</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;ol&gt;</code></td><td>有序列表</td></tr><tr><td><code>&lt;ul&gt;</code></td><td>无序列表</td></tr><tr><td><code>&lt;li&gt;</code></td><td>列表项</td></tr><tr><td><code>&lt;dl&gt;</code></td><td>列表</td></tr><tr><td><code>&lt;dt&gt;</code></td><td>列表项</td></tr><tr><td><code>&lt;dd&gt;</code></td><td>描述</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231709158-html-notes1-13.png" alt=""></p><p><strong>（2）属性</strong></p><ol><li><p>无序列表</p><ul><li><p>标签：<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code></p></li><li><p>属性：实心圆disc、空心圆circle、方块square（默认是实心圆）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231709341-html-notes1-15.png" alt=""></p><ol start="2"><li><p>有序列表</p><ul><li><p>标签：<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></p></li><li><p>属性：A、a、l、i（序号：默认是数字），start（开始位置：默认从1开始）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231709077-html-notes1-16.png" alt=""></p><ol start="3"><li><p>嵌套列表</p><ul><li>标签：<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></li></ul></li><li><p>自定义列表</p><ul><li><p>标签：<code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231710198-html-notes1-17.png" alt=""></p><h4 id="5-2-块">5.2 块</h4><ol><li><p>块元素</p><p>块元素在显示时，通常会以新行开始。如<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code></p></li><li><p>内联元素</p><p>内联元素通常不会以新行开始。如<code>&lt;b&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code></p></li><li><p><code>&lt;div&gt;</code>元素</p><p><code>&lt;div&gt;</code>元素也被称为块元素，其主要是组合HTML元素的容器</p></li><li><p><code>&lt;span&gt;</code>元素</p><p><code>&lt;spac&gt;</code>元素是内联元素，可作为文本的容器</p></li></ol><h4 id="5-3-布局">5.3 布局</h4><ol><li>使用<code>&lt;div&gt;</code>布局</li><li>使用<code>&lt;table&gt;</code>布局</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: cornsilk;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#heading</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: cyan;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#content_menu</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#content_body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: darkgray;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#footing</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: darkslateblue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content_menu&quot;</span>&gt;</span>内容菜单<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content_body&quot;</span>&gt;</span>内容主体<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footing&quot;</span>&gt;</span>内容底部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231710586-html-notes1-18.png" alt=""></p><h3 id="六、HTML表单">六、HTML表单</h3><ol><li><p>表单用于获取不同类型的用户输入</p></li><li><p>常用表单标签</p><table><thead><tr><th>标签</th><th>解释</th></tr></thead><tbody><tr><td><code>&lt;form&gt;</code></td><td>表单</td></tr><tr><td><code>&lt;input&gt;</code></td><td>输入域</td></tr><tr><td><code>&lt;textarea&gt;</code></td><td>文本域</td></tr><tr><td><code>&lt;label&gt;</code></td><td>控制标签</td></tr><tr><td><code>&lt;fieldset&gt;</code></td><td>定义域</td></tr><tr><td><code>&lt;legend&gt;</code></td><td>域的标题</td></tr><tr><td><code>&lt;select&gt;</code></td><td>选择列表</td></tr><tr><td><code>&lt;optgroup&gt;</code></td><td>选项组</td></tr><tr><td><code>&lt;option&gt;</code></td><td>下拉列表中的选项</td></tr><tr><td><code>&lt;button&gt;</code></td><td>按钮</td></tr></tbody></table></li><li><p>常见表单</p><ul><li><p>复选框：<code>&lt;input type=&quot;checkbox&quot;&gt;</code></p></li><li><p>单选框：</p><p><code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;</code></p><p>单选框的几个选项需要有相同的name</p><p>默认勾选要添加属性<code>checked=&quot;checked&quot;</code></p></li><li><p>下拉列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文本域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>文本内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建按钮：<code>&lt;input type=&quot;button&quot; value=&quot;按钮内容&quot;&gt;</code></p></li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line">        账号:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 密码:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>已阅读并同意《用户使用须知》</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">        请选择您的性别： 男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 女 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">        请选择居住地区</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;人机验证&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>请填写个人简介<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    &lt;b/r&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231710839-html-notes1-19.png" alt=""><br>ps.如果利用表格搭配表单，可以写出更规范的注册页面</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】文件操作</title>
      <link href="/post/751a9034.html"/>
      <url>/post/751a9034.html</url>
      
        <content type="html"><![CDATA[<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件<code>#include&lt;fstream&gt;</code></p><p>文件类型分为两种：</p><ul><li>文本文件：文件以文本的ASCII码形式存储在计算机中</li><li>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂</li></ul><p>文件的操作：</p><ol><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ol><h3 id="一、文本文件">一、文本文件</h3><h4 id="1-1-写文件">1.1 写文件</h4><p>写文件步骤如下</p><ol><li><p>包含头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>创建流对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br></pre></td></tr></table></figure></li><li><p>打开文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 打开方式)</span><br></pre></td></tr></table></figure><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p>文件打开方式可以配合使用，利用|操作符<br>例如：<code>ios::binary | ios::out</code></p></li><li><p>写数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs &lt;&lt; <span class="string">&quot;写入的数据&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs.close</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-2-读文件">1.2 读文件</h4><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>创建流对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br></pre></td></tr></table></figure></li><li><p>打开文件并判断文件是否打开成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 打开方式)</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, buf))&#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, buf))&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、二进制文件">二、二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为<code>ios::binary</code></p><h4 id="2-1-写文件">2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数<code>write</code></p><p>函数原型：<code>ostream&amp; write(const char * buffer, int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将Person类中的数据写入文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary)</span></span>;</span><br><span class="line">Person p = &#123;<span class="string">&quot;Huffie&quot;</span>, <span class="number">21</span>&#125;;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-读文件">2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数<code>read</code></p><p>函数原型：<code>istream&amp; read(const char * buffer, int len);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：读取文件中的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】继承</title>
      <link href="/post/f22ba72b.html"/>
      <url>/post/f22ba72b.html</url>
      
        <content type="html"><![CDATA[<p><strong>继承是面向对象的三大特性之一</strong></p><p>定义类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p><h4 id="6-1-继承的基本语法">6.1 继承的基本语法</h4><p>作用：减少代码重复量</p><p>语法：<code>class 子类 : 继承方式 父类</code></p><p>例：<code>class MyPage : public BasePage </code></p><blockquote><p>子类也称为派生类、父类也称为基类</p><p>派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过来的表现其共性，新增的表现其个性</p></blockquote><h4 id="6-2-继承方式">6.2 继承方式</h4><p>继承方式一共有三种：</p><ul><li>公共继承<ul><li>父类中的公共权限成员，子类中也是公共权限</li><li>父类中的保护权限成员，子类中也是保护权限</li><li>父类的私有权限成员，子类无法访问</li></ul></li><li>保护继承<ul><li>父类中的公共权限成员，子类中也是保护权限</li><li>父类中的保护权限成员，子类中也是保护权限</li><li>父类的私有权限成员，子类无法访问</li></ul></li><li>私有继承<ul><li>父类中的公共权限成员，子类中是私有权限</li><li>父类中的保护权限成员，子类中是私有权限</li><li>父类的私有权限成员，子类无法访问<br><img src="https://img.mahaofei.com/img/202112231705496-cpp-notes7-1.png" alt=""></li></ul></li></ul><h4 id="6-3-继承中的对象模型">6.3 继承中的对象模型</h4><p>父类中所有非静态成员属性都会被子类继承下去。父类中私有成员属性，是被编译器隐藏了，因此是访问不到，但是确实被继承下去了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果：16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-继承中构造和析构顺序">6.4 继承中构造和析构顺序</h4><p>子类继承父类后，创建子类对象，也会调用父类的构造函数</p><p>继承中的构造和析构顺序如下：</p><ul><li>构造：先构造父类，在构造子类</li><li>析构：顺序与构造相反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Base</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Son</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Base的构造函数</span><br><span class="line">Son的构造函数</span><br><span class="line">Son的析构函数</span><br><span class="line">Base的析构函数</span><br></pre></td></tr></table></figure><h4 id="6-5-继承同名成员处理方式">6.5 继承同名成员处理方式</h4><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><p>例：<code>s.Base::m_A</code>或<code>s.Base::func()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base func 函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son func 函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son : m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base : m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>如果子类中出现和父类同名的成员函数，子类中的同名成员会隐藏掉父类中所有同名成员函数（包括重载）。如果先要访问父类同名成员，需要加作用域</p></blockquote><h4 id="6-6-继承同名静态成员处理方式">6.6 继承同名静态成员处理方式</h4><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - m_A =  &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第一个::代表通过类名方式访问第二个::代表访问父类作用域下的成员</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-7-多继承语法">6.7 多继承语法</h4><p>C++允许一个类继承多个类</p><p>语法：<code>class 子类 : 继承方式 父类1, 继承方式 父类2...</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br></pre></td></tr></table></figure><p>如果多继承中父类出现了同名情况，子类使用时要加作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1 - m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base2 - m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="6-8-菱形继承">6.8 菱形继承</h4><p><strong>概念</strong>：</p><ol><li>两个派生类继承同一个类</li><li>又有某个类同时继承这两个类</li><li>这种继承称为菱形继承</li></ol><p><strong>菱形继承的问题</strong>：</p><ol><li><p>Son1继承了Base的数据，Son2也继承了Base的数据，当GrandSon使用数据时，就会产生二义性</p><blockquote><p>解决方法：两个父类因为相同的数据，需要加以作用域区分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.Son1::m_A = <span class="number">100</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>GrandSon继承来自Base的数据有两份，但实际上有一份就可以</p><blockquote><p>利用虚继承，解决菱形继承数据重复的问题。发生虚继承之后，数据只有一个，且可以不加作用域直接访问。</p><p>在继承前加上关键字virtual。此时的Base称为虚基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】运算符重载</title>
      <link href="/post/65592f98.html"/>
      <url>/post/65592f98.html</url>
      
        <content type="html"><![CDATA[<p>运算符重载的目的是对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型。</p><h3 id="一、加号运算符重载">一、加号运算符重载</h3><p>作用：实现两个自定义数据类型的加法运算</p><p><strong>1.1 通过成员函数重载+号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    Person <span class="keyword">operator</span>+(Person &amp;p)&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方法：</p><ol><li>本质调用：<code>Person p3 = p1.operator+(p2);</code></li><li>简化调用：<code>Person p3 = p1 + p2;</code></li></ol><p><strong>1.2 通过全局函数重载+号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, Person &amp;p2)&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, <span class="type">int</span> num)&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p1.m_A + num;</span><br><span class="line">temp.m_B = p1.m_B + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：</p><ol><li>本质调用：<code>Person p3 = operator+(p1, p2);</code></li><li>简化调用：<code>Person p3 = p1 + p2;</code></li></ol><p>运算符重载也可以发生函数重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p3 = p1 + p2;</span><br><span class="line">Person p4 = p1 + <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>1.3 注意事项</strong>：</p><ul><li>对于内置的数据类型的表达式的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul><h3 id="二、左移运算符重载">二、左移运算符重载</h3><p><strong>通过全局函数重载&lt;&lt;左移运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p.m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p.m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选中cout，右键转到声明，可以看到cout属于ostream这个类</li><li>返回cout是为了实现链式编程，使得可以无限追加&lt;&lt;</li><li>不通过成员函数重载是因为，成员函数重载只能实现p.operator&lt;&lt;(cout)，即p&lt;&lt;cout，与预期不符。</li></ul><p>调用方法：</p><p><code>cout &lt;&lt; p &lt;&lt; endl;</code></p><h3 id="三、递增运算符重载">三、递增运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>()&#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载前置++运算符</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">++m_Num;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载后置++运算符此处的int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前置++：</p><ul><li>返回值是引用，是因为需要实现++(++a)，保证自增的都是同一个数据</li></ul><p>后置++：</p><ul><li>因为后置++要先返回当前值，再递增。因此先把当前值记录下来，递增之后，再返回记录值。</li><li>返回值以值传递形式，是因为返回的是局部对象temp，局部对象不能通过引用返回。</li></ul><h3 id="四、赋值运算符重载">四、赋值运算符重载</h3><p>c++编译器至少给一个类添加四个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。</p><p>解决方法：利用深拷贝，解决浅拷贝带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line"><span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)&#123;</span><br><span class="line"><span class="comment">//先判断是否有属性在堆区，如果有，先释放干净，再深拷贝</span></span><br><span class="line"><span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行深拷贝</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_Age = &quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_Age = &quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_Age = &quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>重载=的逻辑是，如p2=p1，先释放p2内的属性（因为浅拷贝p2和p1内的m_Age指向同一块内存），然后再重新开辟内存空间进行深拷贝。</li><li>返回值是Person&amp;，是为了连续赋值操作</li></ul><h3 id="五、关系运算符重载">五、关系运算符重载</h3><p>**作用：**重载关系运算符时，可以让两个自定义类型对象进行对比操作。（如==、!=）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：重载==运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp;p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、函数调用运算符重载">六、函数调用运算符重载</h3><ul><li>函数调用运算符是()</li><li>由于重载后使用方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：重载()实现自定义打印</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">---------</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">MyPrint myprint;</span><br><span class="line"><span class="built_in">myprint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>重载()很像函数调用，比如上面的功能也可以用函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">---------</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】友元</title>
      <link href="/post/803a8532.html"/>
      <url>/post/803a8532.html</url>
      
        <content type="html"><![CDATA[<p>有些私有属性，可需要让类外特殊的一些函数或类进行访问，就需要利用友元。</p><p>友元的关键字为fiend</p><p>友元的三种实现方法</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h3 id="一、全局函数作友元">一、全局函数作友元</h3><p>将全局函数的声明写在类的定义内，并在前面添加关键字friend。</p><p>例：<code>friend void func(Person *person);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">//goodFriend全局函数可以访问Person中的私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodFriend</span><span class="params">(Person *person)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">m_Money = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend</span><span class="params">(Person *person)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Friends is getting:&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Friends is getting:&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、类作友元">二、类作友元</h3><p>语法：<code>friend class className;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodFriend</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>()&#123;</span><br><span class="line">m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">m_Money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//goodFriend类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">goodFriend</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//获取函数，获取Person中的属性</span></span><br><span class="line"></span><br><span class="line">Person * person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">goodFriend::<span class="built_in">goodFriend</span>()&#123;</span><br><span class="line">person = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend::get</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;goodFriend类正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;goodFriend类正在访问：&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">goodFriend gf;</span><br><span class="line">gf.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、成员函数作友元">三、成员函数作友元</h3><p>例：<code>friend void className::func();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">goodFriend</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get1</span><span class="params">()</span></span>;<span class="comment">//让get函数可以访问Person中私有成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get2</span><span class="params">()</span></span>;<span class="comment">//让get函数不可以访问Person中私有成员</span></span><br><span class="line"></span><br><span class="line">Person * person;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodFriend::get1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>();</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>()&#123;</span><br><span class="line">m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">m_Money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodFriend::<span class="built_in">goodFriend</span>()&#123;</span><br><span class="line">person = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend::get1</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend::get2</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;get函数正在访问：&quot; &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">goodFriend gf;</span><br><span class="line">gf.<span class="built_in">get1</span>();</span><br><span class="line">gf.<span class="built_in">get2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】对象模型和this指针</title>
      <link href="/post/5388c9e9.html"/>
      <url>/post/5388c9e9.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、成员变量和成员函数分开存储">一、成员变量和成员函数分开存储</h3><p>C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象</p><ol><li><p>空对象也会占用内存</p><p>C++编译器会给每个空对象也分配一个字节空间，是为了标志此对象占内存的位置。每个空对象也应该有一个独一无二的内存地址</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>空对象占用1个字节内存</p></blockquote></li><li><p><strong>只有</strong>类的非静态成员变量，属于类的对象</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>只含一个int非静态成员变量的对象占用4个字节内存</p></blockquote></li><li><p>类的静态成员变量，不属于类的对象</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>对象还是占用4个字节内存</p></blockquote></li><li><p>成员变量和成员函数是分开存储的</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>对象还是占用4个字节内存</p></blockquote></li></ol><h3 id="二、this指针">二、this指针</h3><p>有上述可知，C++中成员变量和成员函数是分开存储的。</p><p>每一个非静态成员函数只会产生一份函数实例，也就是多个同类型的对象会共用一块代码，而代码如何区分哪个对象调用自己。</p><p>这里就用到了this指针，<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li><p>形参和成员变量同名时，可以用this指针来区分</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用return *this</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> money)&#123;</span><br><span class="line"><span class="comment">//this指针指向被调用的成员函数所属的对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;money = money;<span class="comment">//如果不加this，则赋值两侧会认为是同一个money</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddMoney</span><span class="params">(Person &amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;money += p.money;<span class="comment">//将传入的p对象的money加到此对象上</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//this是指向对象的指针，*this就是指向对象本体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的财产为：&quot;</span> &lt;&lt; p1.money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddMoney</span>(p1).<span class="built_in">PersonAddMoney</span>(p1).<span class="built_in">PersonAddMoney</span>(p1);<span class="comment">//链式编程</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的财产为：&quot;</span> &lt;&lt; p2.money &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、空指针访问成员函数">三、空指针访问成员函数</h3><p>C++中空指针也可以调用成员函数，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加判断保证代码的健壮性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is Person class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;<span class="comment">//报错原因是传入的指针为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">showClassName</span>();<span class="comment">//空指针也可以正常执行</span></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge</span>();<span class="comment">//如果不加if语句会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、const修饰成员函数">四、const修饰成员函数</h3><p><strong>常函数：</strong></p><ul><li><p>成员函数后加const后我们称为这个函数为常函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>常函数不可以修改成员属性</p><blockquote><p>常函数也存在this指针，而<strong>this指针的本质是指针常量</strong>，指针的指向是不可修改的。</p><p>在成员函数后面加this，修饰的是this指向，让指针指向的值也不可以修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="number">100</span>;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>成员属性声明时加关键字mutable，在常函数中依然可以修改</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;</span><br></pre></td></tr></table></figure><p>创建了一个特殊的变量，即使在常函数中也可以修改，常对象也可以修改</p></blockquote></li></ul><p><strong>常对象</strong></p><ul><li><p>对象前加const，创建的是常对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Person p;</span><br></pre></td></tr></table></figure></li><li><p>常对象无法修改成员变量，值可以修改加mutable的变量</p></li><li><p>常对象只能调用常函数，不能调用普通成员函数，因为普通成员函数可以修改属性</p><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】构造函数与析构函数相关知识</title>
      <link href="/post/cf29751c.html"/>
      <url>/post/cf29751c.html</url>
      
        <content type="html"><![CDATA[<p>每个对象需要有初始设置以及对象销毁前的清理数据的设置。</p><h3 id="一、构造函数和析构函数">一、构造函数和析构函数</h3><p>对象的<strong>初始化和清理</strong>是两个非常重要的安全问题。</p><ul><li>一个对象或变量没有初始状态，对其使用后果未知</li><li>使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li></ul><p>C++使用<strong>构造函数和析构函数</strong>解决这两个问题，这<strong>两个函数会被编译器自动调用</strong>，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此<strong>如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现</strong>。</p><ul><li>构造函数：创建对象时为对象的成员属性赋值</li><li>析构函数：对象销毁前执行清理工作</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次。</li></ol><p><strong>析构函数语法：</strong><code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同，在名称前加上~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数，进行初始化操作</span></span><br><span class="line"><span class="comment">//构造函数没有返回值 不用写void</span></span><br><span class="line"><span class="comment">//函数名与类名相同</span></span><br><span class="line"><span class="comment">//构造函数可以有参数，可以发生重载</span></span><br><span class="line"><span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数，执行清理操作</span></span><br><span class="line"><span class="comment">//没有返回值，不写void</span></span><br><span class="line"><span class="comment">//函数名和类名相同，前面加~</span></span><br><span class="line"><span class="comment">//不可以有参数，不可以发生重载</span></span><br><span class="line"><span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line">Person p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、构造函数的分类及调用">二、构造函数的分类及调用</h3><p>分类方式：</p><ul><li>按参数分：有参构造和无参构造</li><li>按类型分：普通构造和拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通构造、无参构造（默认构造）</span></span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通构造、有参构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line"><span class="comment">//将传入的类中所有的属性传到此对象上</span></span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><ul><li>括号法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//调用有参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p>注：调用默认构造函数的时候，不要加()</p><p>因为 <code>Person p1();</code> ，编译器会认为是一个函数的声明</p></blockquote><ul><li>显示法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//调用无参构造函数</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//调用有参构造函数</span></span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Person(10)</code> 是匿名对象。</p><p>特点：当前行执行结束后，系统会立即回收掉匿名对象。</p></blockquote><blockquote><p>不要用拷贝构造函数初始化匿名对象</p><p><code>Person(p3);//报错重定义</code></p><p>编译器会认为 Person (p3) 等价于 Person p3;</p></blockquote><ul><li>隐式转换法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//调用无参构造函数</span></span><br><span class="line">Person p2 = <span class="number">10</span>;<span class="comment">//调用有参构造函数</span></span><br><span class="line">Person p3 = p2;<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Person p2 = 10;</code> 相当于 <code>Person p2 = Person(10);</code></p></blockquote><h3 id="三、拷贝构造函数调用时机">三、拷贝构造函数调用时机</h3><p>C++中拷贝构造函数的调用时机通常有以下情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>以值传递的方式给函数参数传值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">m_Age = age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">m_Age = p.m_Age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用已经创建完毕的对象初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span>&#123;&#125;<span class="comment">//值传递相当于 Person p = p 的隐式写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="built_in">doWork</span>(p);<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line">test03;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、构造函数调用规则">四、构造函数调用规则</h3><p>默认情况下，c++中类至少有三个函数</p><ul><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性值进行拷贝</li></ul><p>构造函数调用规则：</p><ul><li>如果用户定义了有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><h3 id="五、深拷贝与浅拷贝">五、深拷贝与浅拷贝</h3><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>：浅拷贝的问题，此程序的问题是，m_Height指向的区域，经过两次析构函数的调用，被重复释放了。</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)&#123;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line"><span class="comment">//析构函数，将堆区开辟的数据做释放操作</span></span><br><span class="line"><span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Height;</span><br><span class="line">m_Height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="type">int</span> *m_Height;<span class="comment">//身高数据开辟到堆区</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">21</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot;\t身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot;\t身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决方法：自己实现拷贝构造函数，解决浅拷贝带来的问题</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">m_Age = p.m_Age;</span><br><span class="line"><span class="comment">//m_Height = p.m_Height;//编译器默认实现的是这行代码</span></span><br><span class="line">m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="六、初始化列表">六、初始化列表</h3><p>**作用：**为类中的属性进行初始化操作</p><p><strong>语法：</strong><code>构造函数(): 属性1(值1),属性2(值2)...&#123;&#125;</code></p><p>**优点：**类成员存在常量时，只能初始化而不能赋值；类成员存在引用时，只能初始化不能赋值；提高效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传统的初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c)&#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表进行初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c):<span class="built_in">m_A</span>(a),<span class="built_in">m_B</span>(b),<span class="built_in">m_C</span>(c)&#123;&#125;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、类对象作为类成员">七、类对象作为类成员</h3><p>C++中类的成员可以是另一个类的对象，<strong>一般称该成员为对象成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当其它类的对象作为本类成员</p><p>构造时：先构造类对象，再构造自身。</p><p>析构时：顺序与构造相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string brand)&#123;</span><br><span class="line">m_Brand = brand;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Brand;<span class="comment">//品牌</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//这里的m_Phone(brand)相当于使用括号法Phone m_Phone(brand)创建对象</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string brand):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(brand)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Huffie&quot;</span>,<span class="string">&quot;Huawei&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; p.m_Phone.m_Brand &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、静态成员">八、静态成员</h3><p>静态成员就是在成员变量和成员函数前加上static</p><ul><li>静态成员变量：<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存（全局区）</li><li>类内声明，类外初始化</li></ul></li></ul><blockquote><p>静态成员变量有两种访问方式（若为私有权限，类外无法访问）：</p><ol><li><p>通过对象访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>通过类名访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//类内声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; p1.m_A &lt;&lt; endl;<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; p1.m_A &lt;&lt; endl;<span class="comment">//输出200，说明数据共享</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象，所有对象都共享同一份数据，因此静态成员变量有两种访问方式</span></span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; Person::m_B &lt;&lt; endl;错误，私有权限类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><blockquote><p>静态成员函数有两种访问方式（若为私有权限，类外同样无法访问）：</p><ol><li><p>通过对象访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li><li><p>通过类名访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 200;静态成员函数不可以访问非静态成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="comment">//非静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func2的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2();类外无法访问私有的静态成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】封装的意义，结构体和类的区别</title>
      <link href="/post/16d89721.html"/>
      <url>/post/16d89721.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、封装的意义">一、封装的意义</h4><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>1.1 设计类时，属性和行为写在一起，表现事物</strong></p><p><strong>语法：</strong><code>class 类名&#123; 访问权限: 属性/行为 &#125;;</code></p><p>类中的属性和行为统一称为成员，属性也称为成员属性或成员变量，行为也成为成员函数或成员方法；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class代表设计一个类，类后面紧跟着类名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="comment">//行为</span></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calcuPerimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过圆类，创建具体的圆对象</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//给圆对象的属性赋值</span></span><br><span class="line">    c1.r = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Perimeter is &quot;</span> &lt;&lt; c1.<span class="built_in">calcuPerimeter</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.2 类在设计时，可以把属性和行为放在不同的权限下加以控制</strong></p><p>访问权限有三种</p><ol><li>public：公共权限，类内可以访问，类外可以访问</li><li>protected：保护权限，类内可以访问，类外不可以访问</li><li>private：私有权限，类内可以访问，类外不可以访问</li></ol><blockquote><p>保护权限和私有权限区别主要在继承方面，子类可以访问父类的保护权限，而私有权限不可访问</p></blockquote><h4 id="二、struct和class的区别">二、struct和class的区别</h4><p>在C++种struct和class的唯一区别在于默认的访问权限不同</p><ul><li>struct：默认权限为公有</li><li>class：默认权限为私有</li></ul><p>尽管结构体可以包含成员函数，但它们很少这样做。所以，通常情况下，结构体声明只会声明成员变量。结构体声明通常不包括public或private的访问修饰符。</p><h4 id="三、成员属性设置为私有">三、成员属性设置为私有</h4><ul><li>将所有成员属性设置为私有，可以自己控制读写权限</li><li>对于写权限，我们可以检测数据的有效性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置性别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setGender</span><span class="params">(string gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gender == <span class="string">&quot;Male&quot;</span> <span class="keyword">or</span> gender == <span class="string">&quot;Female&quot;</span>)&#123;</span><br><span class="line">            m_Gender = gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Wrong Gender!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_Gender = <span class="string">&quot;Male&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取性别</span></span><br><span class="line">    <span class="function">string <span class="title">getGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名  可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//性别  可读可写 修改选项只能是 &quot;Male&quot; &quot;Female&quot;</span></span><br><span class="line">    string m_Gender;</span><br><span class="line">    <span class="comment">//年龄  只写</span></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;Huffie&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:\t&quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setGender</span>(<span class="string">&quot;Male&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Gender:\t&quot;</span> &lt;&lt; p.<span class="built_in">getGender</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">21</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.getAge() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】函数的用法：函数的默认参数、占位参数、函数重载</title>
      <link href="/post/1845ba15.html"/>
      <url>/post/1845ba15.html</url>
      
        <content type="html"><![CDATA[<h3 id="函数的默认参数">函数的默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code>返回值类型 函数名 (参数=默认值)&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给形参传入了数据，就用自己的数据；如果没有，就用默认值</p><p><strong>注意事项：</strong></p><ul><li><p>如果某个位置已经有了默认参数，那么从这个位置往后，必须都有默认值。（即有默认参数的形参必须放在最后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数的声明有了默认参数，函数实现就不能有默认参数。（即声明和实现只能有一个有默认参数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">error C2572: <span class="string">&quot;func2&quot;</span>：重定义默认参数</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数占位参数">函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p>语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);<span class="comment">//这里必须要传两个数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>占位参数还可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a function.&quot;</span> &lt;&lt;endl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载">函数重载</h3><h4 id="1-函数重载概述">1. 函数重载概述</h4><p>**作用：**函数名可以相同，提高复用性</p><p><strong>函数重载满足条件</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同、个数不同、顺序不同</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//func函数都在全局作用域下</span></span><br><span class="line"><span class="comment">//func函数名称相同</span></span><br><span class="line"><span class="comment">//func函数参数类型不同、或个数不同、或顺序不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func().&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a, double b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-函数重载注意事项">2. 函数重载注意事项</h4><ul><li><p>函数的返回值不可以作为函数重载的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="comment">//无法重载仅按返回类型区分的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用作为重载条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数类型不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int &amp;a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(const int &amp;a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);<span class="comment">//调用func(int &amp;a)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用func(const int &amp;a)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数重载碰到默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a, int b).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//X 当函数重载碰到默认参数，出现二义性报错，尽量避免重载时使用默认参数</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);<span class="comment">//√</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（十二）常用可视化工具</title>
      <link href="/post/bc15620d.html"/>
      <url>/post/bc15620d.html</url>
      
        <content type="html"><![CDATA[<h3 id="Qt工具箱">Qt工具箱</h3><h4 id="1-rqt-console">1. rqt_console</h4><p>（1）回到系统内，首先启动海龟例程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rqt_console</span><br></pre></td></tr></table></figure><p>上面的窗口显示日志的输出信息，info信息、warning警告、error错误等<br><img src="https://img.mahaofei.com/img/202112231703320-ros-notes12-1.png" alt=""></p><p>（2）运行键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>当小海龟碰到边界时，可以看到控制台会输出warning<br><img src="https://img.mahaofei.com/img/202112231703366-ros-notes12-2.png" alt=""></p><h4 id="2-rqt-plot">2. rqt_plot</h4><p>关闭rot_console控制台，再在终端输入<code>rqt_plot</code></p><p>在Topic栏输入<code>/turtle1/pose</code></p><p>可以看到小海龟的位姿信息都会被输出出来<br><img src="https://img.mahaofei.com/img/202112231704699-ros-notes12-3.png" alt=""></p><blockquote><p>如果打不开的可以在终端输入rqt，进入后选择plugin-visualization-plot打开</p><p>如果出现核心已转：运行<code>sudo apt-get install python-pip</code>和<code>python -m pip install -U matplotlib</code></p></blockquote><h4 id="3-rqt-image-view">3. rqt_image_view</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_image_view</span><br></pre></td></tr></table></figure><p>需要驱动摄像头，在这里显示镜头的图像，选择图像的信息后会渲染出来。<br><img src="https://img.mahaofei.com/img/202112231704369-ros-notes12-4.png" alt=""></p><h4 id="4-rqt">4. rqt</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt</span><br></pre></td></tr></table></figure><p>集成了所有rqt工具，在plugins可以看到所有插件。<br><img src="https://img.mahaofei.com/img/202112231704839-ros-notes12-5.png" alt=""></p><h3 id="Rviz">Rviz</h3><p>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun rviz rviz</span><br></pre></td></tr></table></figure><p>Rviz是一款三维可视化工具，可以很好的兼容基域ROS软件框架的机器人平台。</p><ul><li>在Rviz中，可以使用扩展标记语言XML对机器人、周围物体等任何实物进行尺寸、质量、位置、材质等属性的描述，并在界面中显示出来。</li><li>Rviz可以通过图形化的方式显示机器人传感器信息、机器人运动状态、环境信息等。</li></ul><p>Rviz界面主要包括：3D视图区，视角设置区，工具栏，显示项列表，时间显示区</p><p>Rviz是数据显示平台，所以显示数据时，需要选择Topic。<br><img src="https://img.mahaofei.com/img/202112231704368-ros-notes12-6.png" alt=""></p><h3 id="Gazebo">Gazebo</h3><p>Gazebo是一款功能强大的三位物理仿真平台，用来仿真机器人、传感器、环境的平台。</p><p>在Gazebo也包括：0-3D视图区，1-工具栏，2-模型列表，3-模型属性，4-时间显示区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch gazebo_ros willow</span><br></pre></td></tr></table></figure><p>可能运行不成功，Gazebo对计算机性能要求较高，而且第一次加载会从远程服务器下载一些材质包、环境等。</p><p><img src="https://img.mahaofei.com/img/20220410103348.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（十一）launch启动文件的使用方法</title>
      <link href="/post/cfdda38f.html"/>
      <url>/post/cfdda38f.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Launch文件作用">一、Launch文件作用</h3><ul><li>通过XML文件实现多节点的配置和启动。</li><li>同时可以自动启动ROS Master（不需要单独<code>roscore</code>）。</li></ul><h3 id="二、Launch文件语法">二、Launch文件语法</h3><h4 id="1-launch">1. <code>&lt;launch&gt;</code></h4><p>launch文件中的根元素采用<code>&lt;launch&gt;</code>标签定义</p><h4 id="2-node">2. <code>&lt;node&gt;</code></h4><p>启动节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;executable-name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node-name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>pkg：节点所在功能包名称</li><li>type：节点的可执行文件名称</li><li>name：节点运行时的名称</li><li>其他可选属性：<ul><li>output（是否打印日志信息）</li><li>respawn（是否在出现错误时重启）</li><li>require（是否要求某个节点必须启动）</li><li>ns（namespace定义命名空间，避免命名冲突）</li><li>args（给每个节点输入参数）</li></ul></li></ul><h4 id="3-参数设置">3. 参数设置</h4><ul><li><p><code>&lt;param&gt;</code>或<code>&lt;param&gt;</code></p><p>设置系统中的参数，存储在参数服务器中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abcd&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>加载参数文件中的多个参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;params&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;arg&gt;</code></p><p>launch文件内部的局部变量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;arg-name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;arg-value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-重映射-remap">4. 重映射<code>&lt;remap&gt;</code></h4><p>重映射ROS计算图资源的命名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-嵌套-include">5. 嵌套<code>&lt;include&gt;</code></h4><p>包含其他launch文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、Launch示例">三、Launch示例</h3><h4 id="1-新建一个功能包">1. 新建一个功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_launch</span><br></pre></td></tr></table></figure><h4 id="2-创建launch文件夹">2. 创建launch文件夹</h4><p>在learning_launch文件夹下新建一个名为<code>launch</code>的文件夹。</p><h4 id="3-创建launch文件">3. 创建launch文件</h4><p>在刚才创建的文件夹内新建一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchs simple.launch</span><br></pre></td></tr></table></figure><p>其内容为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_subscriber&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231702958-ros-notes11-1.png" alt=""></p><h4 id="4-运行launch文件">4. 运行launch文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch learning_launch simple.launch</span><br></pre></td></tr></table></figure><p>可以看到两个节点都运行起来了。<br><img src="https://img.mahaofei.com/img/202112231702374-ros-notes11-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（十）ROS中的坐标系管理系统</title>
      <link href="/post/6c3b819e.html"/>
      <url>/post/6c3b819e.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、机器人中的坐标变换">一、机器人中的坐标变换</h3><p>TF功能包用来管理所有的坐标系。它可以记录十秒钟之内所有坐标系之间的关系，可以展示夹取的物体相对于机器人中心坐标系的位置在哪里。</p><h3 id="二、举例：小海龟跟随实验">二、举例：小海龟跟随实验</h3><h4 id="1-小海龟跟随">1. 小海龟跟随</h4><p>两只海龟出现之后，一只海龟在中心点，另一只海龟出现在下方，可以控制中心的海龟进行运动，下方的海龟会自动跟随我们控制的海龟进行运动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-turtle-tf</span><br><span class="line">roslaunch turtle_tf turtle_tf_demo.launch</span><br><span class="line"><span class="comment">#rosrun turtlesim turtle_teleop_key</span></span><br></pre></td></tr></table></figure><p>其中roslaunch用来启动脚本文件，启动其中的很多节点<br>其中的noetic为ROS版本号</p><p>在terminal中按方向键即可控制被跟随的乌龟。<br><img src="https://img.mahaofei.com/img/202112231659245-ros-notes10-1.png" alt=""></p><blockquote><p>如果ubuntu20.04 noetic版本出现报错可以参考下面的方法解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">sudo rm -r python# 有的可能没有这个文件，就省略这一步</span><br><span class="line">sudo cp python3 python</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-查看tf关系">2. 查看tf关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf view_frames</span><br></pre></td></tr></table></figure><p>等待5秒，生成一个pdf文件，打开可以看到当前系统中tf坐标的位置关系。<br><img src="https://img.mahaofei.com/img/202112231659486-ros-notes10-2.png" alt=""></p><p>其中world是全局坐标系，另外的turtle1和turtle2是两只海龟上的坐标系。例程的目的是使两个坐标系在坐标上是重叠的。</p><blockquote><p>此步如果出错则需要执行修改报错的文件<br><code>sudo gedit /opt/ros/noetic/lib/tf/view_frames </code><br>在第88行<code>print(vstr)</code>上方添加一句<code>vstr=str(vstr)</code>就可以了</p></blockquote><h4 id="3-tf-echo坐标关系">3. tf_echo坐标关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf tf_echo turtle1 turtle2</span><br></pre></td></tr></table></figure><p>输出两个坐标系之间的关系，描述turtle2坐标系如何变换到turtle1坐标系。包括Translation平移和Rotation旋转（四元数、弧度、角度三种方式描述旋转）。<br><img src="https://img.mahaofei.com/img/202112231659014-ros-notes10-3.png" alt=""></p><h4 id="4-rviz三维可视化显示平台">4. rviz三维可视化显示平台</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rviz rviz -d <span class="string">&#x27;rospack find turtle_tf&#x27;</span> /rviz/turtle_rviz.rviz</span><br></pre></td></tr></table></figure><p>首先将左侧Fixed Frame改成world</p><p>点击左下方Add，添加一个TF，用来显示TF位置关系<br><img src="https://img.mahaofei.com/img/202112231659046-ros-notes10-4.png" alt=""></p><p>控制海龟运动，可以看到图中两个坐标系在运动<br><img src="https://img.mahaofei.com/img/202112231701272-ros-notes10-5.png" alt=""></p><h3 id="三、TF坐标系广播与监听的编程实现">三、TF坐标系广播与监听的编程实现</h3><h4 id="1-创建功能包-3">1. 创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_tf roscpp rospy tf turtlesim</span><br></pre></td></tr></table></figure><h4 id="2-创建tf广播器代码">2. 创建tf广播器代码</h4><p>打开<code>learning_tf/src/</code>目录，在其中创建一个<code>turtle_tf_broadcaster.cpp</code></p><p>其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> * REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建tf的广播器</span></span><br><span class="line"><span class="type">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化tf数据</span></span><br><span class="line">tf::Transform transform;</span><br><span class="line">transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">tf::Quaternion q;</span><br><span class="line">q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-创建监听器listener代码">3. 创建监听器listener代码</h4><p>同样的，再创建一个<code>turtle_tf_listener.cpp</code>，其内容为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> * REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求产生turtle2</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">ros::Publisher turtle_vel = node.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tf的监听器</span></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">tf::StampedTransform transform;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (tf::TransformException &amp;ex) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-配置tf广播器与监听器代码编译规则">4. 配置tf广播器与监听器代码编译规则</h4><p>配置<code>learning_tf</code>中的<code>CMakeLists.txt</code>，在图示位置添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(turtle_tf_listener src/turtle_tf_listener.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_tf_listener $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231701891-ros-notes10-6.png" alt=""></p><p>即分别把两个cpp文件编译成两个可执行文件，然后对库进行链接。</p><h4 id="5-编译">5. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h4 id="6-运行程序">6. 运行程序</h4><p>以下程序每一行均需要一个单独的terminal运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2</span><br><span class="line">rosrun learning_tf turtle_tf_listener</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231701727-ros-notes10-7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（九）参数的使用与编程方法</title>
      <link href="/post/b8ca2ffd.html"/>
      <url>/post/b8ca2ffd.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、参数模型">一、参数模型</h3><p>在ROS Master中有一个Parameter Server参数服务器，它是一个全局字典，用来保存各种配置参数，配置参数是各个节点都可以全局访问的。</p><h3 id="二、使用方法">二、使用方法</h3><h4 id="1-列出当前所有参数">1. 列出当前所有参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><h4 id="2-显示某个参数值">2. 显示某个参数值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam get param_key</span><br></pre></td></tr></table></figure><h4 id="3-设置某个参数值">3. 设置某个参数值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span> param_key param_value</span><br></pre></td></tr></table></figure><h4 id="4-保存参数到文件">4. 保存参数到文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam dump file_name</span><br></pre></td></tr></table></figure><h4 id="5-从文件读取参数">5. 从文件读取参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam load file_name</span><br></pre></td></tr></table></figure><h4 id="6-删除参数">6. 删除参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam delete param_key</span><br></pre></td></tr></table></figure><h3 id="三、举例">三、举例</h3><h4 id="1-创建功能包-2">1. 创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_parameter roscpp rospy std_srvs</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656763-ros-notes9-1.png" alt=""></p><h4 id="2-打开小海龟仿真器">2. 打开小海龟仿真器</h4><p>打开一个终端，启动roscore：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>再打开一个终端，运行小海龟仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656152-ros-notes9-2.png" alt=""></p><h4 id="3-rosparam命令行的使用">3. rosparam命令行的使用</h4><p>（1）查看参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><p>（2）得到变量的值：背景颜色RGB的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosparam get /turtlesim/background_r</span><br><span class="line">rosparam get /turtlesim/background_g</span><br><span class="line">rosparam get /turtlesim/background_b</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656272-ros-notes9-3.png" alt=""></p><p>（3）修改变量的值：更改背景颜色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span> /turtlesim/background_b 100</span><br></pre></td></tr></table></figure><p>重新发送请求，刷新背景颜色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656088-ros-notes9-4.png" alt=""></p><p>（4）保存参数到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam dump param.yaml</span><br></pre></td></tr></table></figure><p>参数默认保存到当前目录<br><img src="https://img.mahaofei.com/img/202112231657663-ros-notes9-5.png" alt=""></p><p>（5）加载参数文件</p><p>打开刚刚保存的参数文件，对其中的参数值进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam load param.yaml</span><br></pre></td></tr></table></figure><p>即可将文件里面的参数内容修改系统内的参数。<br><img src="https://img.mahaofei.com/img/202112231657124-ros-notes9-6.png" alt=""></p><p>（6）删除参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam delete /turtlesim/background_g</span><br></pre></td></tr></table></figure><p>查看参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><p>刷新小海龟仿真器背景颜色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231657366-ros-notes9-7.png" alt=""></p><h3 id="四、通过程序获取、设置参数的值">四、通过程序获取、设置参数的值</h3><h4 id="1-编写cpp程序">1. 编写cpp程序</h4><p>在learning_parameter/src/目录下创建一个<code>parameter_config.cpp</code>的文件</p><p>其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> * REFERENCE：www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">ros::ServiceClient clear_background = node.<span class="built_in">serviceClient</span>&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">std_srvs::Empty srv;</span><br><span class="line">clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231658670-ros-notes9-8.png" alt=""></p><h4 id="2-编译程序">2. 编译程序</h4><p>打开<code>learning_parameter/</code>下的<code>CMakeList.txt</code>文件，在其中添加编译规则。(install上方)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(parameter_config src/parameter_config.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(parameter_config $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231658934-ros-notes9-9.png" alt=""></p><p>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h4 id="3-运行程序">3. 运行程序</h4><p>运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>运行小海龟仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>运行刚才编写的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_parameter parameter_config</span><br></pre></td></tr></table></figure><p>发现小海龟的颜色被改变了，说明程序执行成功<br><img src="https://img.mahaofei.com/img/202112231658716-ros-notes9-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（八）服务数据的定义与使用</title>
      <link href="/post/65ca30a6.html"/>
      <url>/post/65ca30a6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的-4">一、目的</h3><p>Client每Request一次数据请求，Server发送一次数据。数据格式为个人信息，如姓名、性别等。</p><h3 id="二、自定义服务数据">二、自定义服务数据</h3><p>此步骤与<a href="https://blog.csdn.net/weixin_44543463/article/details/114108345">话题消息的定义与使用</a>过程类似</p><h4 id="1-定义srv文件">1. 定义srv文件</h4><p>再<code>learning_service</code>文件夹下新建一个文件夹<code>srv</code>，再在<code>srv</code>文件夹内新建一个<code>Person.srv</code>文件，内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8  age</span><br><span class="line">uint8  sex</span><br><span class="line"></span><br><span class="line">uint8 unknown = <span class="number">0</span></span><br><span class="line">uint8 male    = <span class="number">1</span></span><br><span class="line">uint8 female  = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">string result</span><br></pre></td></tr></table></figure><p>—以上是request的数据，—以下是response的数据<br><img src="https://img.mahaofei.com/img/202112231654771-ros-notes8-1.png" alt=""></p><h4 id="2-在package-xml中添加功能包依赖">2. 在package.xml中添加功能包依赖</h4><p>打开<code>learning_service/package.xml</code>，在文件最后部分添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231654282-ros-notes8-2.png" alt=""></p><h4 id="3-在CMakeLists-txt中添加编译选项">3. 在CMakeLists.txt中添加编译选项</h4><p>首先在<code>find_package</code>最后一行添加一条语句<code>message_generation</code>，用以添加依赖的功能包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231654047-ros-notes8-3.png" alt=""></p><p>在此函数下面再添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_service_files</span>(</span><br><span class="line">  FILES</span><br><span class="line">  Person.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">generate_messages</span>(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>add_message_files，将Person.srv作为定义的接口</p><p>generate_messages，在编译Person.srv文件时需要依赖的功能包<br><img src="https://img.mahaofei.com/img/202112231654750-ros-notes8-4.png" alt=""></p><p>然后在下方<code>catkin specific configuration</code>内的<code>catkin_packages</code>中，添加依赖<code>message_runtime</code>，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catkin_package</span>(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES learning_topic</span><br><span class="line">   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231655676-ros-notes8-5.png" alt=""></p><h4 id="4-编译生成相关文件-2">4. 编译生成相关文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="三、创建服务器代码">三、创建服务器代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个person_server.cpp`的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment">REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置反馈数据</span></span><br><span class="line">res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、创建客户端代码">四、创建客户端代码</h3><p>同样在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>person_client.cpp</code>的文件，其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment">REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">ros::ServiceClient person_client = node.<span class="built_in">serviceClient</span>&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">learning_service::Person srv;</span><br><span class="line">srv.request.name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">srv.request.age  = <span class="number">21</span>;</span><br><span class="line">srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line"> srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231655990-ros-notes8-6.png" alt=""></p><h3 id="五、配置服务器-客户端代码编译规则">五、配置服务器/客户端代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_client $&#123;PROJECT_NAME&#125;_gencpp)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231655263-ros-notes8-7.png" alt=""></p><h3 id="六、编译并运行发布者和订阅者">六、编译并运行发布者和订阅者</h3><p>首先进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行发布者和订阅者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun learning_service person_server</span><br><span class="line">rosrun learning_service person_client</span><br></pre></td></tr></table></figure><p>client每请求一次，会接受到一次数据<br><img src="https://img.mahaofei.com/img/202112231655403-ros-notes8-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（七）服务端Server的实现</title>
      <link href="/post/a31f0ac2.html"/>
      <url>/post/a31f0ac2.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的-3">一、目的</h3><p>Server端等待信号，每次接收到Client端的信号，海龟的运动状态就切换一次（运动→停止、停止→运动）</p><h3 id="二、创建服务器代码">二、创建服务器代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>turtle_command_server.cpp</code>的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span></span><br><span class="line"><span class="comment"> REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_srvs/Trigger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="type">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         std_srvs::Trigger::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置反馈数据</span></span><br><span class="line">res.success = <span class="literal">true</span>;</span><br><span class="line">res.message = <span class="string">&quot;Change turtle command state!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">turtle_vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line"><span class="keyword">if</span>(pubCommand)</span><br><span class="line">&#123;</span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照循环频率延时</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现过程：</p><ol><li>初始化ROS节点</li><li>创建Server实例</li><li>循环等待服务请求，进入回调函数</li><li>在回调函数中完成服务功能的处理，并反馈应答数据<br><img src="https://img.mahaofei.com/img/202112231653779-ros-notes7-1.png" alt=""></li></ol><h3 id="三、配置服务器代码编译规则">三、配置服务器代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(turtle_command_server src/turtle_command_server.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_command_server $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p>把turtle_command_server.cpp编译成turtle_command_server文件，同时去链接需要依赖的库文件。<br><img src="https://img.mahaofei.com/img/202112231653176-ros-notes7-2.png" alt=""></p><h3 id="四、编译并运行">四、编译并运行</h3><p>编译服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">cadkin_make</span><br></pre></td></tr></table></figure><p>生效环境变量（如果已经在<code>.bashrc</code>中<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">添加了环境变量</a>则不需要再执行此步）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><p>再运行以下代码（以下三行需要各自启动一个终端）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_command_server</span><br></pre></td></tr></table></figure><p>再启动一个终端，输入代码<code>rosservice call /turtle_command+空格+两次Tab</code>发送信号，海龟开始运动，<strong>再次发送同样的信号</strong>，小海龟停止。</p><p><img src="https://img.mahaofei.com/img/202112231653462-ros-notes7-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（六）客户端Client的编程实现</title>
      <link href="/post/9b3f197.html"/>
      <url>/post/9b3f197.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的-2">一、目的</h3><p>通过程序，发布服务请求。</p><p>即通过客户端的请求，发给服务端产生一个海龟，反馈回客户端。</p><h3 id="二、创建功能包-3">二、创建功能包</h3><p>回到<code>catkin_ws/src</code>文件夹下，创建一个名为<code>learning_service</code>的功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231651523-ros-notes6-1.png" alt=""></p><h3 id="三、创建客户端代码">三、创建客户端代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>turtle_spawn.cpp</code>的文件，其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spawn turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spawn turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码👆的实现过程如下：</p><ol><li>初始化ROS节点</li><li>创建一个Client实例</li><li>发布服务请求数据</li><li>等待Server处理之后的应答结果<br><img src="https://img.mahaofei.com/img/202112231652508-ros-notes6-2.png" alt=""></li></ol><h3 id="四、配置客户端代码编译规则">四、配置客户端代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(turtle_spawn src/turtle_spawn.cpp)</span><br><span class="line">target_link_libraries(turtle_spawn <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><p>add_executable添加编译规则，target_link_libraries链接一些需要的库<br><img src="https://img.mahaofei.com/img/202112231652255-ros-notes6-3.png" alt=""></p><h3 id="五、编译与运行">五、编译与运行</h3><p>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231652845-ros-notes6-4.png" alt=""></p><p>运行客户端，可以看到产生了第二个小海龟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_spawn</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231652468-ros-notes6-5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（五）话题消息的定义与使用</title>
      <link href="/post/28bcb558.html"/>
      <url>/post/28bcb558.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的">一、目的</h3><p>在ROS Master中，可以发布与订阅已经定义好的消息，比如海龟的运动、位姿等信息。但有时我们需要自己定义消息的类型。</p><p>本节主要目的为定义一个Person个人信息，Publisher发布个人信息，Subscriber订阅个人信息。</p><h3 id="二、自定义话题消息">二、自定义话题消息</h3><h4 id="1-定义msg文件">1. 定义msg文件</h4><p>在功能包<code>learning_topic</code>文件夹中新建一个文件夹<code>msg</code>，在此文件夹内创建一个<code>Person.msg</code>文件，在其中添加以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br><span class="line"></span><br><span class="line">uint8 unknown=<span class="number">0</span></span><br><span class="line">uint8 male=<span class="number">1</span></span><br><span class="line">uint8 female=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>注：<code>uint8</code>和<code>string</code>，在不同程序里面需要扩展成对应的格式，因此需要先进行一些配置。<br><img src="https://img.mahaofei.com/img/202112231649673-ros-notes5-1.png" alt=""></p><h4 id="2-在package-xml文件中添加功能包依赖">2. 在package.xml文件中添加功能包依赖</h4><p>在文件末尾部分，添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>build_depend，编译依赖，依赖一个动态产生message的功能包</p><p>exec_depend，执行依赖， 依赖message运行时间的功能包<br><img src="https://img.mahaofei.com/img/202112231650056-ros-notes5-2.png" alt=""></p><h4 id="3-在CMakeLists-txt添加编译选项">3. 在CMakeLists.txt添加编译选项</h4><p>首先在<code>find_package</code>内添加一条语句，用以添加依赖的功能包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231650566-ros-notes5-3.png" alt=""></p><p>在此函数下面再添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_message_files</span>(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">generate_messages</span>(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>add_message_files，将Person.msg作为定义的接口</p><p>generate_messages，在编译Person.msg文件时需要依赖的功能包<br><img src="https://img.mahaofei.com/img/202112231650214-ros-notes5-4.png" alt=""></p><p>然后在下方<code>catkin specific configuration</code>内的<code>catkin_packages</code>中，添加依赖<code>message_runtime</code>，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catkin_package</span>(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES learning_topic</span><br><span class="line">   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231650548-ros-notes5-5.png" alt=""></p><h4 id="4-编译生成相关文件">4. 编译生成相关文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="三、创建发布者">三、创建发布者</h3><p>在<code>~/catkin_ws/src/learning_topic/src</code>文件夹下创建<code>person_publisher.cpp</code>文件，内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.<span class="built_in">advertise</span>&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    learning_topic::Person person_msg;</span><br><span class="line">person_msg.name = <span class="string">&quot;huffie&quot;</span>;</span><br><span class="line">person_msg.age  = <span class="number">21</span>;</span><br><span class="line">person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、创建订阅者">四、创建订阅者</h3><p>在<code>~/catkin_ws/src/learning_topic/src</code>文件夹下创建<code>person_subscriber.cpp</code>文件，内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="type">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line"> msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231651965-ros-notes5-6.png" alt=""></p><h3 id="五、配置发布者-订阅者代码编译规则">五、配置发布者/订阅者代码编译规则</h3><p>在<code>CMakeLists.txt</code>文件的<code>build</code>区域内添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231651308-ros-notes5-7.png" alt=""></p><h3 id="六、编译与运行">六、编译与运行</h3><p>首先进行编译，回到主目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>运行订阅者Subscriber</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_topic person_subscriber</span><br></pre></td></tr></table></figure><p>运行发布者Publisher</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_topic person_Publisher</span><br></pre></td></tr></table></figure><p>可以看到发布者在发布个人信息，订阅者在接受信息。<br><img src="https://img.mahaofei.com/img/202112231651808-ros-notes5-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（四）订阅者Subscriber的实现</title>
      <link href="/post/57898ee9.html"/>
      <url>/post/57898ee9.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目标功能-2">一、目标功能</h3><p>订阅者订阅海龟的位姿信息。</p><h3 id="二、创建功能包-2">二、创建功能包</h3><p>首先创建工作空间，参考<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">【ROS学习笔记】（二）工作空间与功能包的创建</a></p><p>然后创建一个功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_creat_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><h3 id="三、创建订阅者代码">三、创建订阅者代码</h3><p>进入功能包的src文件夹下，创建一个cpp文件（也可以在图形界面直接创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/src</span><br><span class="line">touch pose_subscriber.cpp</span><br><span class="line">sudo gedit pose_subscriber.cpp</span><br></pre></td></tr></table></figure><p>输入以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">Copyright 2020 GuYueHome (www.guyuehome.com).</span><br><span class="line">***********************************************************************/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"><span class="comment">#include &lt;ros/ros.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;turtlesim/Pose.h&quot;</span></span><br><span class="line"></span><br><span class="line">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="line">void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    // 将接收到的消息打印出来</span><br><span class="line">    ROS_INFO(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化ROS节点</span><br><span class="line">    ros::init(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    // 创建节点句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br><span class="line">    ros::Subscriber pose_sub = n.subscribe(<span class="string">&quot;/turtle1/pose&quot;</span>, 10, poseCallback);</span><br><span class="line"></span><br><span class="line">    // 循环等待回调函数</span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码思路：</p><ol><li>初始化ROS节点</li><li>订阅需要的话题</li><li>循环等待话题消息，接收到消息后进入回调函数</li><li>在回调函数中完成消息处理<br><img src="https://img.mahaofei.com/img/202112231649178-ros-notes4-1.png" alt=""></li></ol><h3 id="四、配置订阅者代码编译规则">四、配置订阅者代码编译规则</h3><ol><li><p>设置需要编译的代码和生成的可执行文件</p></li><li><p>设置链接库</p></li></ol><p>在<code>Learning_topic/CMakeList.txt</code>文件的Build下方（Install上方），添加代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(pose_subscriber src/pose_subscriber.cpp)<span class="comment">#描述要把哪个程序文件编译成哪个可执行文件</span></span><br><span class="line">target_link_libraries(pose_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#把可执行文件和库做链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231649732-ros-notes4-2.png" alt=""></p><h3 id="五、编译并运行订阅者SubScriber">五、编译并运行订阅者SubScriber</h3><h4 id="1-编译-2">1. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><blockquote><p>可以在[.bash]文件最后添加source语句，这样就不用每次再在终端输入source命令</p><p>sudo vim ~/catkin_ws<br>source /home/huffie/catkin_ws/devel/setup.bash</p></blockquote><h4 id="2-运行-2">2. 运行</h4><p>打开小海龟的仿真程序，运行subscriber，同时让小海龟动起来，可以看到姿态坐标在实时改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic pose_subscriber</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231649325-ros-notes4-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（三）发布者Publisher的实现</title>
      <link href="/post/5bbac892.html"/>
      <url>/post/5bbac892.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目标功能">一、目标功能</h3><p>ROS Master内有两个节点，一个是Subscriber(turtlesim)，一个是Publisher，发布者通过程序实现发布Message，Message的内容包括线速度、角度，通过Topic管道，传递给Subscriber，从而控制小海龟的运动。</p><h3 id="二、创建功能包">二、创建功能包</h3><p>首先先创建一个工作空间，具体参考上一节<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">【ROS学习笔记】（二）工作空间与功能包的创建</a></p><p>然后创建一个功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647709-ros-notes3-1.png" alt=""></p><h3 id="三、创建发布者代码">三、创建发布者代码</h3><p>进入功能包的src文件夹下，创建一个cpp文件（也可以在图形界面直接创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/src</span><br><span class="line">touch velocity_publisher.cpp</span><br><span class="line">sudo gedit velocity_publisher.cpp</span><br></pre></td></tr></table></figure><p>输入以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ROS节点初始化</span></span><br><span class="line">ros::init(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率</span></span><br><span class="line">ros::Rate <span class="title function_">loop_rate</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">turtle_vel_pub.publish(vel_msg);</span><br><span class="line">ROS_INFO(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647723-ros-notes3-2.png" alt=""></p><h3 id="四、配置发布者代码编译规则">四、配置发布者代码编译规则</h3><ol><li><p>设置需要编译的代码和生成的可执行文件</p></li><li><p>设置链接库</p></li></ol><p>在<code>Learning_topic/CMakeList.txt</code>文件的Build下方（Install上方），添加代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(velocity_publisher src/velocity_publisher.cpp)<span class="comment">#描述要把哪个程序文件编译成哪个可执行文件</span></span><br><span class="line">target_link_libraries(velocity_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#把可执行文件和库做链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231648236-ros-notes3-3.png" alt=""></p><h3 id="五、编译并运行发布者Publisher">五、编译并运行发布者Publisher</h3><h4 id="1-编译">1. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><blockquote><p>可以在<code>~/.bashrc</code>文件最后添加source语句，这样就不用每次再在终端输入source命令创建环境变量（路径中替换成自己的用户名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/【Username】/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://img.mahaofei.com/img/202112231648682-ros-notes3-4.png" alt=""></p><h4 id="2-运行">2. 运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231648643-ros-notes3-5.png" alt=""></p><blockquote><p>参考教程：<strong>古月ROS入门21讲</strong><br>GitHub：<a href="https://github.com/guyuehome/ros_21_tutorials">https://github.com/guyuehome/ros_21_tutorials</a><br>Bilibili：<a href="https://www.bilibili.com/video/BV1zt411G7Vn">https://www.bilibili.com/video/BV1zt411G7Vn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（二）工作空间与功能包的创建</title>
      <link href="/post/bf2fd3f4.html"/>
      <url>/post/bf2fd3f4.html</url>
      
        <content type="html"><![CDATA[<h3 id="工作空间的概念">工作空间的概念</h3><p>工作空间是存放工程开发相关文件的文件夹，类似windows中使用ide时创建的工程。</p><h3 id="工作空间包括的文件夹">工作空间包括的文件夹</h3><p>^a357c1</p><ol><li>src：代码空间</li><li>build：编译空间，编译过程中的中间文件，一般用不到</li><li>devel：开发空间，放置开发过程中的可执行文件、库等</li><li>install：安装空间</li></ol><h3 id="创建工作空间">创建工作空间</h3><h4 id="1-创建工作空间">1. 创建工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h4 id="2-编译工作空间">2. 编译工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">catkin_make install <span class="comment">#产生install文件夹</span></span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量">3. 设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><h4 id="4-检查环境变量">4. 检查环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647957-ros-notes2-1.png" alt=""></p><h3 id="创建功能包">创建功能包</h3><p><code>catkin_creat_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</code></p><h4 id="1-创建功能包">1. 创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pkg std_msgs rospy roscpp</span><br></pre></td></tr></table></figure><p><em>注：功能包要放在src文件夹下，同一个工作空间不能有同名的功能包</em></p><p>创建功能包后，在功能包test_pkg文件夹下有<strong>src、include</strong>文件夹和<strong>package.xml、CMakeLists.txt</strong>文件</p><p>(1)src文件夹：放置代码文件<br>(2)include文件夹：放置头文件<br>(3)package.xml：与功能包相关的信息<br>（如名字、版本号、许可证、作者信息、功能包的依赖信息等）<br>(4)CMakeLists.txt：描述功能包的编译规则</p><p><strong>如果要写python代码，需要在程序包下新建</strong><code>scripts</code><strong>文件夹，并将python代码写在其中。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> scripts</span><br></pre></td></tr></table></figure><h4 id="2-编译功能包">2. 编译功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647602-ros-notes2-2.png" alt=""></p><blockquote><p>ps. 如果进行某些操作后重新编译工作空间出错时，可以尝试使用<code>catkin_make clean</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（一）常用命令的解释与举例</title>
      <link href="/post/208ac25a.html"/>
      <url>/post/208ac25a.html</url>
      
        <content type="html"><![CDATA[<h5 id="1-roscore">1. roscore</h5><p>roscore是用来启动ros master，是运行ros系统前首先运行的命令<br><img src="https://img.mahaofei.com/img/202112231644191-ros-notes1-1.png" alt=""></p><h5 id="2-rosrun">2. rosrun</h5><p>rosrun是用来运行某个功能包内的某个节点的指令，有两个参数，第一个参数是功能包名，第二个参数是节点名</p><blockquote><p><strong>例：仿真小海龟</strong><br>在一个终端中输入<code>rosrun turtlesim turtlesim_node</code><br>在另一个终端中输入<code>rosrun turtlesim turtle_teleop_key</code><br><img src="https://img.mahaofei.com/img/202112231644184-ros-notes1-2.png" alt=""></p></blockquote><h5 id="3-rosnode">3. rosnode</h5><p>rosnode，用来显示节点相关信息的指令</p><ul><li>rosnode list用来把系统中所有节点都列出来<br><img src="https://img.mahaofei.com/img/202112231645569-ros-notes1-3.png" alt=""></li><li>rosnode info *，查看节点的具体信息，如正在发布哪些话题、提供的服务、等其他信息<br><img src="https://img.mahaofei.com/img/202112231645955-ros-notes1-4.png" alt=""></li></ul><h5 id="4-rostopic">4. rostopic</h5><ul><li>rostopic list，输出当前系统中所有话题的列表<br><img src="https://img.mahaofei.com/img/202112231645086-ros-notes1-5.png" alt=""></li><li>rostopic pub 【话题名+tab补全】，显示发布的内容<br><img src="https://img.mahaofei.com/img/202112231645993-ros-notes1-6.png" alt=""></li></ul><blockquote><p><strong>例：通过发布话题(rostopic pub)控制小海龟运动</strong><br>输入代码：<code>rostopic pub -r 10 /turtle1/cmd_vel+两次tab补全</code><br>通过修改linear速度和angular角度，可以控制小海龟的运动。其中 -r 10 是话题发布的频率，每秒发布十次。<br><img src="https://img.mahaofei.com/img/202112231646567-ros-notes1-7.png" alt=""></p></blockquote><h5 id="5-rosservice">5. rosservice</h5><ul><li>roservice list 可以显示ros系统内所有服务的列表（所有服务端都是上面的海龟仿真器）</li><li>rosservice call 【服务名称+tab补全】发布请求</li></ul><blockquote><p>例：产生两只海龟（服务列表中/spawn是产生海龟的请求）<br>输入代码：<code>rosservice call /spawn+两次tab补全</code><br>其中x，y是新海龟的坐标（仿真器左下角为原点）<br><img src="https://img.mahaofei.com/img/202112231646126-ros-notes1-8.png" alt=""></p></blockquote><h5 id="6-rosbag">6. rosbag</h5><p>记录当前系统内所有话题数据，并在下次复现出来。</p><blockquote><p><strong>例：保存小海龟的运动</strong></p><ol><li>输入命令：<code>rosbag record -a -O cmd_record</code><br>其中record指做记录，-a指记录所有数据，-o指将数据保存成压缩包，最后是保存文件的名字</li><li>回到key终端，用键盘方向键控制小海龟进行运动</li><li>运动完成后使用<code>ctrl+C</code>中断rosbag record<br><img src="https://img.mahaofei.com/img/202112231646263-ros-notes1-9.png" alt=""></li></ol></blockquote><blockquote><p><strong>例：复现小海龟的运动</strong></p><ol><li>关掉之前打开的终端，重新打开一个终端，运行<code>roscore</code></li><li>再新开一个终端，启动小海龟的仿真：<code>rosrun turtlesim turtlesim_node</code>（这里不需要启动键盘输入）</li><li>再新开一个终端，实现小海龟的动作复现：<code>rosbag play cmd_record.bag</code><br><img src="https://img.mahaofei.com/img/202112231646907-ros-notes1-10.png" alt=""></li></ol></blockquote><p><strong>本文学习内容来自古月居</strong><br>官方论坛：<a href="https://www.guyuehome.com/">https://www.guyuehome.com/</a><br>学习视频：<a href="https://www.bilibili.com/video/BV1zt411G7Vn">https://www.bilibili.com/video/BV1zt411G7Vn</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS安装时rosdep_init与rosdep_update问题解决方法（2022.04.08亲测）</title>
      <link href="/post/88ab93d0.html"/>
      <url>/post/88ab93d0.html</url>
      
        <content type="html"><![CDATA[<p><strong>2022.4.8更新：</strong><br>运行下面的指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo pip3 install rosdepc</span><br><span class="line">sudo rosdepc init</span><br><span class="line">rosdepc update</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220408213139.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220408213126.png" alt=""></p><hr><p>==以下都是过时方法：==</p><p><strong>2021.9.19更新：</strong></p><p>最稳妥的解决方法还是找一个机场、节点，然后下载 ssr 或者 clash 等“加速”软件。<br>如果终端还是报错，却发现浏览器可以访问相应的资源网址，说明终端没有配置好代理，在终端窗口输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:12333&quot;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;https://127.0.0.1:12333&quot;</span></span><br></pre></td></tr></table></figure><p>再次<code>rosdep update</code>就可以了。</p><p><strong>原文：</strong></p><p>ROS安装过程可见我的上一篇博客<a href="https://blog.csdn.net/weixin_44543463/article/details/113862391">Ubuntu20.04安装ROS Noetic</a></p><p>安装过程中<strong>rosdep init</strong>出现【<strong>ERROR: cannot download default sources list from:…Website may be down.</strong>】<br><strong>rosdep update</strong>，总是出现<strong>超时</strong>问题无法更新。<br>最终找到了一种靠谱可用的方法。</p><p>这两个问题都是网络连接相关的问题，<strong>解决方法相同，都是修改host主机</strong>。</p><p>只是修改完成后rosdep init可以直接成功。而rosdep update还需要可靠的网络才行，如果update仍然失败，建议多试几次，或者试着更换手机热点网络</p><h5 id="1-打开ip查询网址">1. 打开ip查询网址</h5><blockquote><p><a href="https://site.ip138.com">https://site.ip138.com</a></p></blockquote><h5 id="2-输入raw-githubusercontent-com查询ip">2. 输入raw.githubusercontent.com查询ip</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231643086-rosdep-bug-1.png" alt=""></p><h5 id="3-将解析出来的IP地址全部添加到-etc-hosts文件最后，格式：185-199-109-133-raw-githubusercontent-com">3. 将解析出来的IP地址全部添加到/etc/hosts文件最后，格式：185.199.109.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/hosts</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231643217-rosdep-bug-2.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># The following lines are desirable for IPv6 capable hosts</span></span><br><span class="line">::1 ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">ff02::3 ip6-allhosts</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>保存回到命令行</p><h5 id="5-重新进行rosdep-update">5. 重新进行rosdep update</h5><p><img src="https://img.mahaofei.com/img/202112231643953-rosdep-bug-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04安装ROS Noetic</title>
      <link href="/post/b278544f.html"/>
      <url>/post/b278544f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考ros官网<a href="http://wiki.ros.org/">http://wiki.ros.org/</a>的有关<a href="http://wiki.ros.org/noetic/Installation/Ubuntu">安装教程</a></p></blockquote><h3 id="一、准备工作">一、准备工作</h3><h4 id="1-添加ROS软件源">1. 添加ROS软件源</h4><p>打开软件与更新，将下载选项前四个都选上。<br><strong>一定要确保都勾选上，不然后续安装时会出现依赖关系问题</strong><br><img src="https://img.mahaofei.com/img/202112231642871-ubuntu-ros-1.png" alt=""><br>然后执行以下命令添加软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-添加公钥">2. 添加公钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h4 id="3-更新索引">3. 更新索引</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="二、安装ROS">二、安装ROS</h3><h4 id="1-安装ROS">1. 安装ROS</h4><p>建议安装桌面完整版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><h4 id="2-设置环境变量">2. 设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="3-初始化rosdep">3. 初始化rosdep</h4><p>在使用许多ROS工具之前，需要初始化rosdep。rosdep是运行ROS中某些核心组件所必需的，首先安装rosdep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure><p>然后进行初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><blockquote><p>rosdep init如果出现【ERROR: cannot download default sources list from:…<br>Website may be down.】<br>rosdep update如果出现超时问题<br><strong>解决方法：</strong><br>1.<code>sudo apt-get install python3-pip</code><br>2.<code>sudo pip3 install rosdepc</code><br>3.<code>sudo rosdepc init</code><br>4.<code>rosdepc update</code></p></blockquote><h4 id="4-安装其它工具和依赖包">4. 安装其它工具和依赖包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br></pre></td></tr></table></figure><h3 id="三、测试-2">三、测试</h3><p><strong>打开</strong>终端，输入<code>roscore</code>，运行ros<br><strong>再打开</strong>一个新终端，输入：<code>rosrun turtlesim turtlesim_node</code>，可以看到小乌龟的仿真界面已经打开了。<strong>再打开</strong>一个新终端输入指令：<code>rosrun turtlesim turtle_teleop_key</code>，可以在这个key终端内，通过键盘的方向键控制小乌龟在界面中移动<br><img src="https://img.mahaofei.com/img/202112231643691-ubuntu-ros-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu使用VNC实现远程桌面</title>
      <link href="/post/c1d87973.html"/>
      <url>/post/c1d87973.html</url>
      
        <content type="html"><![CDATA[<hr><p>此方案已经弃用，更好的方案是使用xrdp远程连接，十分方便。</p><p>参考<a href="https://www.mahaofei.com/post/cdee659e.html">https://www.mahaofei.com/post/cdee659e.html</a>的2.1节</p><hr><h1>前言</h1><p>我是在树莓派4B上安装的Ubuntu20.10，想通过VNC实现远程桌面连接，进行接下来的试验。<br>但是在网上搜索了许多关于VNC连接的博客，也尝试了各种方法，但总是出现各种问题，要么连接不上，要么连接上了就黑屏灰屏，总之出现了各种问题，重装了n次系统，最终找到了一种实现的方法。<br><strong>注：已经试验过Ubunt18.04、Ubuntu20.04与Ubuntu20.10，均正常实现</strong></p><h1>Windows端</h1><p>安装VNC Viewer，进入其<a href="https://www.realvnc.com/en/connect/download/viewer/">VNC Viewer官网</a>下载安装。<br><img src="https://img.mahaofei.com/img/202112231640381-ubuntu-vnc-1.png" alt=""></p><h1>Ubuntu端</h1><p><strong>进行VNC设置之前，需要有图形界面，没有的可以执行以下代码安装图形界面</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br><span class="line">sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br><span class="line">sudo reboot <span class="comment">#重启即可看到图形界面</span></span><br></pre></td></tr></table></figure><h2 id="1-安装x11vnc程序">1. 安装x11vnc程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install x11vnc</span><br></pre></td></tr></table></figure><h2 id="2-安装lightdm">2. 安装lightdm</h2><p>因为使用的是gnome图形界面，为了保证x11vnc与图形界面的兼容性，这里需要安装lightdm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lightdm</span><br></pre></td></tr></table></figure><p>安装过程中会跳出一个界面，<strong>选择lightdm</strong>即可<br><img src="https://img.mahaofei.com/img/202112231640773-ubuntu-vnc-2.png" alt=""></p><h2 id="3-创建配置目录">3. 创建配置目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -pv /home/【USERNAME】/.vnc</span><br></pre></td></tr></table></figure><p>其中的**【USERNAME】<strong>替换成你的用户名</strong></p><h2 id="4-生成当前用户的VNC连接密码">4. 生成当前用户的VNC连接密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo x11vnc -storepasswd 【Password】 /home/【USERNAME】/.vnc/passwd</span><br></pre></td></tr></table></figure><p>其中的**【Password】<strong>处设置连接VNC时的密码，</strong>【USERNAME】**替换成你的用户名<br><img src="https://img.mahaofei.com/img/202112231641706-ubuntu-vnc-3.png" alt=""></p><h2 id="5-生成VNC配置文件">5. 生成VNC配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>&gt;x11vnc.service&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit] </span></span><br><span class="line"><span class="string">Description=Start x11vnc at startup. </span></span><br><span class="line"><span class="string">After=multi-user.target </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[Service] </span></span><br><span class="line"><span class="string">Type=simple </span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/【USERNAME】/.vnc/passwd -rfbport 5900 -shared </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[Install] </span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>配置文件生成后将其移动到<code>/lib/systemd/sydtem/</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> x11vnc.service /lib/systemd/system/x11vnc.service</span><br></pre></td></tr></table></figure><p>修改权限为root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> root:root /lib/systemd/system/x11vnc.service</span><br></pre></td></tr></table></figure><h2 id="6-重新加载服务配置文件">6. 重新加载服务配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>执行以下命令可以查看服务开启情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl list-unit-files | grep x11vnc</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231641384-ubuntu-vnc-4.png" alt=""></p><h2 id="7-开机启动VNC服务">7. 开机启动VNC服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> x11vnc.service</span><br></pre></td></tr></table></figure><h2 id="8-重启系统">8. 重启系统</h2><p>因为之前安装了lightdm图形管理程序，所以需要重启一下系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h2 id="9-查看一下监听端口">9. 查看一下监听端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ss -tunlp</span><br></pre></td></tr></table></figure><p>可以看到x11vnc的监听端口已经打开了<br><img src="https://img.mahaofei.com/img/202112231641133-ubuntu-vnc-5.png" alt=""></p><h2 id="10-共享剪切板">10. 共享剪切板</h2><p>由于VNC Viewer只能控制鼠标键盘，想要复制bug查询，或者复制代码的话，很不方便。</p><p>安装下面的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autocutsel</span><br></pre></td></tr></table></figure><p>然后使用下面的命令打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autocutsel</span><br></pre></td></tr></table></figure><p>或者将这条命令加入到开机自启动里面（在开始-Startu Applications里面可以设置）</p><p><img src="https://img.mahaofei.com/img/20220903193047.png" alt=""></p><h1>远程连接</h1><p>打开windows端的VNC Viewer，输入IP地址:5900即<code>192.168.6.6:5900</code>进行远程连接，密码是之前设置的密码。<br><img src="https://img.mahaofei.com/img/202112231641205-ubuntu-vnc-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231642992-ubuntu-vnc-7.png" alt=""></p><h1>解决不插显示器的远程桌面</h1><p>安装xserver-xorg-video-dummy，做一个虚拟的显示器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install xserver-xorg-video-dummy</span><br></pre></td></tr></table></figure><p>具体配置只要复制粘贴就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/X11/xorg.conf.d</span><br><span class="line">sudo vim xorg.conf</span><br></pre></td></tr></table></figure><p>建立xorg.conf文件，粘贴如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier &quot;DummyDevice&quot;</span><br><span class="line">    Driver &quot;dummy&quot;</span><br><span class="line">    VideoRam 256000</span><br><span class="line">EndSection</span><br><span class="line"> </span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">    Identifier &quot;DummyScreen&quot;</span><br><span class="line">    Device &quot;DummyDevice&quot;</span><br><span class="line">    Monitor &quot;DummyMonitor&quot;</span><br><span class="line">    DefaultDepth 24</span><br><span class="line">    SubSection &quot;Display&quot;</span><br><span class="line">        Depth 24</span><br><span class="line">        Modes &quot;1920x1080_60.0&quot;</span><br><span class="line">    EndSubSection</span><br><span class="line">EndSection</span><br><span class="line"> </span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">    Identifier &quot;DummyMonitor&quot;</span><br><span class="line">    HorizSync 30-70</span><br><span class="line">    VertRefresh 50-75</span><br><span class="line">    ModeLine &quot;1920x1080&quot; 148.50 1920 2448 2492 2640 1080 1084 1089 1125 +Hsync +Vsync</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure><p>然后重启即可。配置的1080分辨率的虚拟显示器和直接连接的物理机器一样</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs安装方法</title>
      <link href="/post/7349121e.html"/>
      <url>/post/7349121e.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><p>未正确安装nodejs，导致安装之后node -v有输出，npm -v无反应。</p><p>重新安装nodejs</p><h1>解决方法</h1><h2 id="卸载nodejs">卸载nodejs</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove nodejs</span><br><span class="line">sudo apt-get remove --purge npm</span><br><span class="line">sudo apt-get remove --purge nodejs</span><br></pre></td></tr></table></figure><p>进入 /usr/local/lib 删除所有 node 和 node_modules文件夹 <br>进入 /usr/local/include 删除所有 node 和 node_modules 文件夹<br>（这里我删除的是nodejs文件夹）</p><h2 id="安装nodejs">安装nodejs</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">node -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新的 node v10.x</span></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B安装Ubuntu20.04</title>
      <link href="/post/8bd23e63.html"/>
      <url>/post/8bd23e63.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、树莓派的准备">一、树莓派的准备</h2><ol><li>进入<a href="http://cdimage.ubuntu.com/ubuntu/releases/20.04/release/">Ubuntu官网</a>下载支持树莓派的Ubuntu版本安装包。<br><img src="https://img.mahaofei.com/img/202112231639061-raspberrypi-ubuntu20-1.png" alt=""></li><li>使用DiskGenius格式化SD卡，将所有扇区删除，然后格式化。<br><img src="https://img.mahaofei.com/img/202112231639964-raspberrypi-ubuntu20-2.png" alt=""></li><li><a href="https://downloads.raspberrypi.org/imager/imager.exe">下载官方烧录工具</a>，镜像选择刚才下载的.xz文件，SD卡选择自己的卡，写入即可。<br><img src="https://img.mahaofei.com/img/202112231639079-raspberrypi-ubuntu20-3.png" alt=""></li></ol><h2 id="二、Ubuntu系统配置">二、Ubuntu系统配置</h2><h3 id="2-1-进入Ubuntu系统">2.1 进入Ubuntu系统</h3><p>将TF卡插到树莓派上。可以通过显示器进行系统初始化配置，也可以用网线将树莓派和电脑连接起来，再进行远程配置。建议使用一个外接显示器，操作会简单许多。<strong>以使用外接屏幕+键盘为例</strong>（这些设备只使用一次就够了）</p><ol><li>将之前制作好的SD卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</li><li>开机，等待一段时间后进入系统，首先需要登录，<strong>初始用户名和密码都是ubuntu</strong>，登陆后会要求重新设置密码。</li></ol><h3 id="2-2-wifi设置">2.2 wifi设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/netplan</span><br></pre></td></tr></table></figure><p>在该目录下，如果是服务器，则会有一个50-cloud-init.yaml的文件，如果是桌面环境，会有一个01-network-manager-all.yaml<br>这里以50-cloud-init.yaml为例，编辑文件:<br>注意文件的缩进格式，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        eth0:</span><br><span class="line">            dhcp4: <span class="literal">true</span></span><br><span class="line">            optional: <span class="literal">true</span></span><br><span class="line">    wifis:</span><br><span class="line">        wlan0:</span><br><span class="line">            optional: <span class="literal">true</span></span><br><span class="line">            access-points:</span><br><span class="line">                <span class="string">&quot;WiFi名&quot;</span>:</span><br><span class="line">                    password: <span class="string">&quot;你wifi的密码&quot;</span></span><br><span class="line">            dhcp4: <span class="literal">true</span></span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure><p>然后执行命令使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan generate</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure><p>如果不行，重启。如果还不行，执行<code>sudo systemctl start wpa_supplicant</code>再重启。</p><p>输入命令<code>ifconfig</code>即可查看ip地址，使用远程访问工具进行访问。</p><h3 id="2-3-更新源">2.3 更新源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>source.list内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="2-4-安装桌面环境">2.4 安装桌面环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br><span class="line">sudo apt install xrdp</span><br></pre></td></tr></table></figure><h3 id="2-5-安装中文环境">2.5 安装中文环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install language-pack-zh-hans language-pack-zh-hans-base language-pack-gnome-zh-hans language-pack-gnome-zh-hans-base</span><br><span class="line">sudo apt install `check-language-support -l zh`</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="2-7-允许root登录">2.7 允许root登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root <span class="comment">#设置root密码</span></span><br><span class="line">sudo vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf <span class="comment">#编辑此文件</span></span><br></pre></td></tr></table></figure><p>添加下列两行到50-ubuntu.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line">allow-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-8-远程桌面连接">2.8 远程桌面连接</h3><p>在windows搜索框输入<code>远程桌面连接</code>，选择Xorg模式，输入用户名密码即可连接。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu系统Buglist（不定时更新）</title>
      <link href="/post/9ebf52e1.html"/>
      <url>/post/9ebf52e1.html</url>
      
        <content type="html"><![CDATA[<h1>一、环境/库</h1><h2 id="1-1-curl-error-while-loading-shared-libraries">1.1 curl: error while loading shared libraries</h2><ol><li>在机器上查找丢失的共享库</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name libssl.so.1.0.0</span><br></pre></td></tr></table></figure><p>得到返回值<code>/home/huffie/anaconda3/pkgs/openssl-1.0.2p-h14c3975_0/lib/libssl.so.1.0.0</code></p><ol start="2"><li>查看软件安装路径</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> curl</span><br></pre></td></tr></table></figure><p>得到返回值<code>~/anaconda3/bin/curl</code>，说明是使用anaconda安装的</p><ol start="3"><li>建立软连接</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /home/huffie/anaconda3/pkgs/openssl-1.0.2p-h14c3975_0/lib/libssl.so.1.0.0 ~/anaconda3/lib/libssl.so.1.0.0</span><br></pre></td></tr></table></figure><ol start="4"><li>同样的方法补全<code>libcrypto.so.1.0.0</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /home/huffie/anaconda3/pkgs/openssl-1.0.2p-h14c3975_0/lib/libcrypto.so.1.0.0 ~/anaconda3/lib/libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure><h2 id="1-2-调整Docker下载速度">1.2 调整Docker下载速度</h2><ol><li>备份配置文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/docker/daemon.json /etc/docker/daemon.json.backup</span><br></pre></td></tr></table></figure><ol start="2"><li>打开配置文件，删除所有内容，并添加以下内容</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-由于没有公钥，无法验证下列签名：NO-PUBKEY的解决方法">1.3 由于没有公钥，无法验证下列签名：NO_PUBKEY的解决方法</h2><p><strong>（1）问题描述</strong></p><p>今天运行apt-get update时突然出现了由于没有公钥，无法验证下列签名的问题，尝试了网上许多方法，最终找到了一种亲测有效的解决方法：</p><p><strong>（2）解决方法</strong></p><p><strong>在终端输入：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 76F1A20FF987672F</span><br></pre></td></tr></table></figure><p>其中最后的代码为报错语句中的最后一部分：由于没有公钥，无法验证下列签名： NO_PUBKEY <strong>76F1A20FF987672F</strong></p><p><strong>（3）解决结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executing: /tmp/apt-key-gpghome.uBwlOPqFFF/gpg.1.sh --keyserver hkp://keyserver.ubuntu.com:80 --recv 76F1A20FF987672F</span><br><span class="line">gpg: key 76F1A20FF987672F: 1 signature not checked due to a missing key</span><br><span class="line">gpg: 密钥 76F1A20FF987672F：公钥“WineHQ packages &lt;wine-devel@winehq.org&gt;”已导入</span><br><span class="line">gpg: 合计被处理的数量：1</span><br><span class="line">gpg:               已导入：1</span><br></pre></td></tr></table></figure><h2 id="1-4-Cmake-版本更新">1.4 Cmake 版本更新</h2><p>更新cmake</p><p><strong>（1）报错信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at CMakeLists.txt:15 (cmake_minimum_required):</span><br><span class="line">  CMake 3.13 or higher is required.  You are running version 3.10.2</span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure><p><strong>（2）解决方法</strong></p><p>首先尝试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>如果还不行，那么就到官网安装新版cmake。</p><p>到<a href="https://cmake.org/download/">cmake官网的下载页面</a>下载最新的cmake安装包，以<a href="https://cmake.org/files/v3.25/cmake-3.25.2.tar.gz">cmake-3.25.2.tar.gz</a>为例。</p><p>解压安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf cmake-3.25.2.tar.gz</span><br></pre></td></tr></table></figure><p>进入安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd cmake-3.25.2</span><br></pre></td></tr></table></figure><p>开始安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ./configure</span><br><span class="line">./configure</span><br><span class="line">make -j8 </span><br><span class="line">sudo make install</span><br><span class="line">sudo update-alternatives --install /usr/bin/cmake cmake /usr/local/bin/cmake 1 --force</span><br></pre></td></tr></table></figure><p><strong>（3）解决结果</strong></p><p>运行下列命令检查<code>cmake</code>是否正确安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><h2 id="1-5-cudnn问题，apt-upgrade出现警告-sbin-ldconfig-real">1.5 cudnn问题，apt upgrade出现警告/sbin/ldconfig.real</h2><p><strong>问题描述：</strong></p><p>安装软件，或使用<code>sudo apt upgrade</code>时，命令行出现警告信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_cnn_train.so.8 is not a symbolic link</span><br><span class="line"></span><br><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_ops_train.so.8 is not a symbolic link</span><br><span class="line"></span><br><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_adv_train.so.8 is not a symbolic link</span><br><span class="line"></span><br><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn.so.8 is not a symbolic link</span><br><span class="line"></span><br><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_ops_infer.so.8 is not a symbolic link</span><br><span class="line"></span><br><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_cnn_infer.so.8 is not a symbolic link</span><br><span class="line"></span><br><span class="line">/sbin/ldconfig.real: /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_adv_infer.so.8 is not a symbolic link</span><br></pre></td></tr></table></figure><p><strong>问题原因：</strong></p><p>CUDA和cuDNN库的符号链接失效，重新创建符号链接：</p><p><strong>解决方法：</strong></p><p>注意按照自己的报错信息修改路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_ops_train.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_ops_train.so.8</span><br><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_cnn_train.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_cnn_train.so.8</span><br><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_adv_train.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_adv_train.so.8</span><br><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn.so.8</span><br><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_ops_infer.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_ops_infer.so.8</span><br><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_cnn_infer.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_cnn_infer.so.8</span><br><span class="line">sudo ln -sf /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_adv_infer.so.8.9.1 /usr/local/cuda-12.1/targets/x86_64-linux/lib/libcudnn_adv_infer.so.8</span><br></pre></td></tr></table></figure><h2 id="1-6-conda环境导致的源码安装包问题">1.6 conda环境导致的源码安装包问题</h2><p><strong>问题描述：</strong></p><p>如果在conda环境下从源码编译安装某个包，在cmake阶段，可能会出现下面的问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CMake Warning at cmake/CMakeHelper.cmake:103 (add_executable):</span><br><span class="line">  Cannot generate a safe runtime search path for target colmap_main because</span><br><span class="line">  files in some directories may conflict with libraries in implicit</span><br><span class="line">  directories:</span><br><span class="line"></span><br><span class="line">    runtime library [libmpfr.so.6] in /usr/lib/x86_64-linux-gnu may be hidden by files in:</span><br><span class="line">      /home/mahaofei/anaconda3/lib</span><br><span class="line">    runtime library [libgmp.so.10] in /usr/lib/x86_64-linux-gnu may be hidden by files in:</span><br><span class="line">      /home/mahaofei/anaconda3/lib</span><br><span class="line">    runtime library [liblz4.so.1] in /usr/lib/x86_64-linux-gnu may be hidden by files in:</span><br><span class="line">      /home/mahaofei/anaconda3/lib</span><br><span class="line">    runtime library [libsqlite3.so.0] in /usr/lib/x86_64-linux-gnu may be hidden by files in:</span><br><span class="line">      /home/mahaofei/anaconda3/lib</span><br><span class="line">    runtime library [libgomp.so.1] in /usr/lib/gcc/x86_64-linux-gnu/9 may be hidden by files in:</span><br><span class="line">      /home/mahaofei/anaconda3/lib</span><br><span class="line"></span><br><span class="line">  Some of these libraries may not be found correctly.</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  src/colmap/exe/CMakeLists.txt:67 (COLMAP_ADD_EXECUTABLE)</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>退出conda环境，然后再编译安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时退出</span></span><br><span class="line">conda deactivate</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消终端自动进入conda</span></span><br><span class="line">conda config --set auto_activate_base false</span><br></pre></td></tr></table></figure><h2 id="1-7-the-provided-PTX-was-compiled-with-an-unsupported-toolchain">1.7 the provided PTX was compiled with an unsupported toolchain</h2><p><strong>问题描述：</strong></p><p>从源码编译安装某些包，完成之后无法使用，例如我的colmap一直报错如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CuTexImage::BindTexture:        invalid device symbol</span><br><span class="line">FilterH:        the provided PTX was compiled with an unsupported toolchain.</span><br><span class="line">E1220 10:33:57.020385 2392647 feature_extraction.cc:276] Failed to extract features.</span><br><span class="line">CuTexImage::BindTexture:        the provided PTX was compiled with an unsupported toolchain.</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>更新显卡驱动，亲测有效。</p><h1>二、ROS</h1><h2 id="2-1-使用其它工作空间的包，未加载其它工作空间的source">2.1 使用其它工作空间的包，未加载其它工作空间的source</h2><p><strong>（1）报错信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to load nodelet &#x27;/camera/realsense2_camera` of type `realsense2_camera/RealSenseNodeFactory` to manager `realsense2_camera_manager&#x27;</span><br></pre></td></tr></table></figure><p><strong>（2）报错原因</strong></p><p>原因是找不到realsense2_camera包，在安装D435的包时，以为bashrc文件里已存在要添加的路径故没有执行</p><p><strong>（3）解决方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="2-2-有多个-so文件同时被引用">2.2 有多个.so文件同时被引用</h2><p><strong>（1）报错信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbol lookup error: /home/huffie/catkin_ws/devel/lib//librealsense2_camera.so: undefined symbol: _ZN20ddynamic_reconfigure19DDynamicReconfigureC1ERKN3ros10NodeHandleE</span><br></pre></td></tr></table></figure><p><strong>（2）报错原因</strong></p><p>系统内librealsense2_camera.so的数量不唯一，在多个路径下都存在此库</p><p><strong>（3）解决方法</strong></p><p>查找一下动态库路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><p>将显示的其它工作空间的build和devel文件夹都删掉就可以了</p><h2 id="2-3-PCL要求C-11及以上">2.3 PCL要求C++11及以上</h2><p><strong>（1）报错信息</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: #error PCL requires C++14 or above</span><br></pre></td></tr></table></figure><p><strong>（2）报错原因</strong></p><p>CMakeLists.txt没有添加C++14的配置</p><p><strong>（3）解决方法</strong></p><p>在<code>CMakeLists.txt</code>中添加下面这几行代码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span> )</span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">14</span> )</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br></pre></td></tr></table></figure><h2 id="2-4-error-while-loading-shared-libraries">2.4 error while loading shared libraries</h2><p><strong>（1）报错信息</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/noetic/lib/rosout/rosout: error while loading shared libraries: libxmlrpcpp.so: cannot open shared object file: No such file or directory</span><br><span class="line">[rosout-1] process has died [pid 82803, exit code 127, cmd /opt/ros/noetic/lib/rosout/rosout __name:=rosout __log:=/home/huffie/.ros/log/834eb474-ba51-11ed-861b-470c5d943dac/rosout-1.log].</span><br><span class="line">log file: /home/huffie/.ros/log/834eb474-ba51-11ed-861b-470c5d943dac/rosout-1*.log</span><br></pre></td></tr></table></figure><p><strong>（2）问题原因</strong></p><p>链接器找不到库文件，搜索<code>libxmlrpcpp.so</code>，发现其位置为<code>/opt/ros/noetic/lib</code></p><p><strong>（3）解决方法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/ld.so.conf.d/libc.conf</span><br></pre></td></tr></table></figure><p>在其中添加<code>libxmlrpcpp.so</code>的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/ros/noetic/lib</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>就ok了</p><h1>三、系统问题</h1><h2 id="3-1-Windows-Ubuntu双系统，Win更新后Ubuntu引导项消失">3.1 Windows+Ubuntu双系统，Win更新后Ubuntu引导项消失</h2><p><strong>首先在BIOS里确定Ubuntu的启动顺序是不是在Windows之前，一定要启动ubuntu，然后才有引导</strong></p><p>插入ubuntu启动盘，重启电脑，选择U盘启动，进入后选择 try ubuntu without install</p><p>进入界面后连接网络</p><p>输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository ppa:yannubuntu/boot-repair</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install boot-repair</span><br></pre></td></tr></table></figure><p>安装成功后继续在终端输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot-repair</span><br></pre></td></tr></table></figure><p>期间会检索引导项，等待即可</p><p>完成后点击Recommended repair</p><p>等待一下，成功找回</p><h2 id="3-2-Ubuntu启动后左上角光标闪烁，且出现snd-hda-intel-cannot-probe-codecs的错误信息">3.2 Ubuntu启动后左上角光标闪烁，且出现snd_hda_intel cannot probe codecs的错误信息</h2><p><strong>问题描述：</strong></p><p>系统运行正常的情况下，重启了服务器，再开机就进入不了桌面了，一直左上角光标闪烁，并且等待一段时间后出现snd_hda_intel cannot probe codecs的报错。</p><p><strong>解决方法：</strong></p><p>清空回收站，本人遇到的问题是磁盘没有空间了，无法启动某个驱动，通过ssh连接系统后使用下面命令清空回收站即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf ~/.local/share/Trash/*</span><br></pre></td></tr></table></figure><h2 id="3-3-Kernel-panic-not-syncing-Attempted-to-kill-init">3.3 Kernel panic - not syncing: Attempted to kill init!</h2><p><strong>问题描述：</strong></p><p>我在正常使用电脑时，突然所有图标全都变成空白方框（左侧 dock 栏、右上角所有系统图标），系统完全卡死，所有软件包括命令行无法打开，设置无法打开，点击重启无效。</p><p>强制重启后，ubuntu 无法进入，显示许多行代码，最后一行为 <code>Kernel panic - not syncing: Attempted to kill init!</code>，此时双系统的 Win11 仍然正常。</p><p><strong>解决方法：</strong></p><p>经查阅资料，应该是系统自动更新内核导致的问题（也有的说是因为/boot 分区满了出现问题）。</p><p>开机后在引导界面选择 <code>Advance option for ubuntu</code>，前两个为最新版本的内核，不要选择这两个，选择第三个，进入旧版本的内核。</p><p>检查 <code>/boot</code> 分区是否占用为 100%</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure><p>查看所有已安装内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections| grep linux</span><br></pre></td></tr></table></figure><p>查看当前正在使用的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>删除最新的（有错误的/如果 boot 满了则删过老的）内核，我这里新内核版本相关的只有这两个包，请根据自己情况调整。==注意一定不要误删==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove --purge linux-modules-5.15.0-88-generic linux-image-5.15.0-88-generic</span><br></pre></td></tr></table></figure><p>完成后清理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -P linux-modules-5.15.0-88-generic</span><br><span class="line">sudo dpkg -P linux-image-5.15.0-88-generic</span><br></pre></td></tr></table></figure><h2 id="3-4-惠普暗影精灵9-光影精灵9，无法拓展显示器">3.4 惠普暗影精灵9/光影精灵9，无法拓展显示器</h2><p><strong>问题描述</strong></p><p>惠普暗影精灵9/光影精灵9，安装ubuntu20.04，已经正常安装显卡驱动，<code>nvidia-smi</code>输出正常，但是外接显示器不识别。</p><p>输入<code>xrandr</code>发现只有笔记本显示器。</p><p>打开nvidia控制面板，发现nvidia识别到了外接显示器。</p><p>尝试了切换显卡驱动无效，关闭<code>secure boot</code>无效。</p><p><strong>解决方法</strong></p><p>进入BIOS，在配置中，将独显直连（<code>NVIDIA ... Advance</code>，具体是什么记不清了），改为混合模式（<code>Discrete</code>），然后就可以了。</p><h2 id="3-5-系统启动后进入-initramfs">3.5 系统启动后进入(initramfs)</h2><p><strong>问题描述：</strong></p><p>我在 ubuntu+win 双系统中，使用 windows 访问了 ubuntu 的文件，再次启动 ubuntu 后发现出现错误，开机后进入了命令行界面，显示如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BusyBox v1.30.1 (Ubuntu 1:1.30.1-4ubuntu6.1) built-in shell (ash) </span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands.</span><br><span class="line"></span><br><span class="line">(initramfs)</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>参考 <a href="https://ostechnix.com/how-to-fix-busybox-initramfs-error-on-ubuntu/">How To Fix Busybox Initramfs Error On Ubuntu</a></p><p>使用 <code>fsck</code> 命令修复损坏分区中的文件系统：</p><p>（可以使用 <code>cat /proc/partitions</code> 或 <code>blkid</code> 或 <code>lsblk</code> 命令在 Busybox 中获取您的 Linux 分区详细信息。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 如果是机械硬盘，则为sdax，例如</span><br><span class="line">fsck /dev/sda1 -y</span><br><span class="line"># 如果是固态硬盘，则为nvmexnxpx</span><br><span class="line">fsck 则为nvme1n1p2 -y</span><br></pre></td></tr></table></figure><p>几分钟后，你会看到如下输出，说明修复完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/sda1: ***** FILE SYSTEM WAS MODIFIED *****</span><br><span class="line">/dev/sda1: 497733/30531584 files (1.5% non-contiguous), ........</span><br></pre></td></tr></table></figure><p>然后重启系统（如果 reboot 无效，输入 exit 后回车重启）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【个人网站搭建教程】阿里云服务器+宝塔+wordpress</title>
      <link href="/post/bd8011a0.html"/>
      <url>/post/bd8011a0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、服务器和域名的申请">一、服务器和域名的申请</h2><h3 id="1-1-服务器的购买">1.1 服务器的购买</h3><ol><li>进入阿里云官网，购买ECS云服务器（可以看看<a href="https://developer.aliyun.com/plan/promotion/1?spm=a2c6h.13813017.1364563.d100010001.5ab41d3cmWpHDS&amp;utm_content=g_1000199894">开发者成长计划</a>，虽然我当时是在618这里买的学生ECS）。服务器的系统选择CentOS或Ubuntu。<br><img src="https://img.mahaofei.com/img/202112231629303-ali-bt-wp-1.png" alt=""><br>购买完成后会进入<a href="https://ecs.console.aliyun.com/">控制台</a>，在这里可以看到自己刚才购买的服务器。<br><img src="https://img.mahaofei.com/img/202112231630259-ali-bt-wp-2.png" alt=""></li><li>服务器使用之前，我们需要先重置root用户密码。<br><img src="https://img.mahaofei.com/img/202112231630681-ali-bt-wp-3.png" alt=""></li><li>重置密码完成后就可以通过<strong>公网IP</strong>，使用xshell或者PuTTy或者阿里平台的远程连接工具登陆服务器了。</li></ol><h3 id="1-2-域名申请与备案">1.2 域名申请与备案</h3><ol><li>进入<a href="https://wanwang.aliyun.com/domain?utm_content=se_1008301712">域名注册平台</a>，选一个合适的域名，点击结算。（如果之前没有申请过域名的话，在结算时需要创建个人的信息模板，按要求填写信息即可）。<br><img src="https://img.mahaofei.com/img/202112231631536-ali-bt-wp-4.png" alt=""></li><li>购买后域名的注册就完成了，然后需要网站备案。进入阿里<a href="https://beian.aliyun.com/">备案首页</a>，开始备案。<br><img src="https://img.mahaofei.com/img/202112231631757-ali-bt-wp-5.png" alt=""></li><li>填写完成个人信息，点击信息校验（<strong>注意：要求域名注册后两到三天再来备案</strong>）<br><img src="https://img.mahaofei.com/img/202112231631006-ali-bt-wp-6.png" alt=""><br>然后按要求填写自己的信息，网站的信息，进行身份验证，提交审核。<strong>注意各项信息都要填写准确，不符合要求的后续还要打电话修改</strong>。</li><li>提交审核后，在一个工作日之内，阿里云的客服会打电话确认身份，同时告知备案信息需要修改的地方，这期间需要保持电话畅通。</li><li>阿里云初审完成后，会将备案信息提交管局，大概一天之内你会收到一条工信部的验证短信，根据短信上的验证码，进入<a href="https://beian.miit.gov.cn/#/Integrated/ComplaintA">工信部官网</a>验证。<br><img src="https://img.mahaofei.com/img/202112231631498-ali-bt-wp-7.png" alt=""></li><li>等待7-20天，管局审核完成后，备案也就ok了。<br><img src="https://img.mahaofei.com/img/202112231631767-ali-bt-wp-8.png" alt=""></li></ol><h2 id="二、宝塔面板的安装">二、宝塔面板的安装</h2><h3 id="2-1-准备工作-2">2.1 准备工作</h3><p>进入<a href="https://www.bt.cn/">宝塔官网</a>注册一个宝塔账号，后续需要使用。</p><h3 id="2-2-安装宝塔面板">2.2 安装宝塔面板</h3><blockquote><p>以下安装过程参考官网：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p></blockquote><ol><li><strong>开放服务器端口</strong><br>进入控制台，点击实例名称，进入安全组-安全组列表页面，点击配置规则。<br><img src="https://img.mahaofei.com/img/202112231632152-ali-bt-wp-9.png" alt=""><br>如下图所示，放行8888端口，并开放所有ip访问，点击保存即可<br><img src="https://img.mahaofei.com/img/202112231632312-ali-bt-wp-10.png" alt=""><br>另外在这里同时开启其他端口，点击快速添加，选择SSH、HTTP、HTTPS、MySQL添加，方便后续网站的访问。<br><img src="https://img.mahaofei.com/img/202112231632208-ali-bt-wp-11.png" alt=""></li><li><strong>安装面板</strong></li></ol><ul><li>CentOS 安装命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><ul><li>Ubuntu 安装命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure><blockquote><p>安装成功后可以看到显示宝塔后台的地址，以及用户名和密码。打开浏览器登录宝塔后台。</p></blockquote><ol start="3"><li><strong>宝塔面板设置</strong><br>为了安全考虑，进入面板后先修改宝塔面板用户和面板密码。（这里的面板用户和密码不是官网账户，而是每个云服务器访问宝塔面板需要用到的账户面板）<br><img src="https://img.mahaofei.com/img/202112231633585-ali-bt-wp-12.png" alt=""></li><li><strong>安装LNMP环境</strong><br>LNMP网站环境就是指Linux+Nginx+MySQL+PHP的组合，用来快速搭建各种开源的网站程序如Wordpress、Typecho等。<br><img src="https://img.mahaofei.com/img/202112231633033-ali-bt-wp-13.png" alt=""><br>安装需要10~20分钟，安装过程是自动完成的。稍等一段时间即可。<br><img src="https://img.mahaofei.com/img/202112231633644-ali-bt-wp-14.png" alt=""></li><li><strong>宝塔账号实名认证</strong><br>进入<a href="https://www.bt.cn/">宝塔官网</a>，点击右上角会员后台，或者点此链接进入后台<a href="https://www.bt.cn/admin/userinfo">https://www.bt.cn/admin/userinfo</a>。<br><img src="https://img.mahaofei.com/img/202112231633993-ali-bt-wp-15.png" alt=""><br>左侧选择账户管理，进行实名认证。<br><img src="https://img.mahaofei.com/img/202112231634655-ali-bt-wp-16.png" alt=""><br>6.<strong>添加站点</strong><br>点击左侧网站-添加站点<br><img src="https://img.mahaofei.com/img/202112231634375-ali-bt-wp-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231634033-ali-bt-wp-18.png" alt=""><br>网站站点添加成功后，就可以进入网站的根目录了。后面搭建网站都会在这个网站的根目录下进行。<br><img src="https://img.mahaofei.com/img/202112231635182-ali-bt-wp-19.png" alt=""></li></ol><h2 id="三、安装WordPress">三、安装WordPress</h2><h3 id="3-1-上传WordPress安装包">3.1 上传WordPress安装包</h3><ol><li>前往<a href="https://cn.wordpress.org/download/">WordPress中国官网</a>下载zip安装包</li></ol><blockquote><p>下载链接：<a href="https://cn.wordpress.org/latest-zh_CN.zip">https://cn.wordpress.org/latest-zh_CN.zip</a></p></blockquote><ol start="2"><li>回到宝塔，点击文件，进入域名的根目录，点击左上角上传文件，上传刚才下载的wordpress安装包。<br><img src="https://img.mahaofei.com/img/202112231635535-ali-bt-wp-20.png" alt=""></li><li>上传成功后，解压zip格式的安装包<br><img src="https://img.mahaofei.com/img/202112231635231-ali-bt-wp-21.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231635899-ali-bt-wp-22.png" alt=""></li></ol><h3 id="3-2-修改站点配置文件">3.2 修改站点配置文件</h3><p><img src="https://img.mahaofei.com/img/202112231636769-ali-bt-wp-23.png" alt=""></p><p>由于安装包解压到站点目录/wordpress下，因此配置文件中的root需要改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /www/wwwroot/huffie.top/wordpress;</span><br></pre></td></tr></table></figure><p>修改完成后，点击保存。</p><h3 id="3-3-域名解析绑定">3.3 域名解析绑定</h3><ol><li>进入阿里云的域名控制台<br><img src="https://img.mahaofei.com/img/202112231636690-ali-bt-wp-24.png" alt=""></li><li>添加记录<br><img src="https://img.mahaofei.com/img/202112231636345-ali-bt-wp-25.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231637130-ali-bt-wp-26.png" alt=""><br>ps.这里遇到了一个小问题，总是显示<strong>您的请求在Web服务器中没有找到对应的站点！</strong>，尝试了许多方法，最后是将PHP版本从7.4更改为5.6，然后成功的，不知道是不是因为这个原因，后来版本改回7.4后也可以继续访问了。</li></ol><h3 id="3-4-WordPress的在线安装">3.4 WordPress的在线安装</h3><p>在浏览器地址栏输入自己的域名，即可看到wordpress的欢迎页面。接下来的步骤就是进行wordpress的配置了。<br><img src="https://img.mahaofei.com/img/202112231637983-ali-bt-wp-27.png" alt=""></p><ol><li><strong>填写数据库信息</strong><br>数据库名、用户名、密码可以到宝塔控制台的数据库栏查到。<br><img src="https://img.mahaofei.com/img/202112231637649-ali-bt-wp-28.png" alt=""><br>按要求填写，填写完成后点击提交。<br><img src="https://img.mahaofei.com/img/202112231637587-ali-bt-wp-29.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231637349-ali-bt-wp-30.png" alt=""></li><li><strong>填写网站信息</strong><br><img src="https://img.mahaofei.com/img/202112231638637-ali-bt-wp-31.png" alt=""></li><li><strong>安装成功</strong><br>登陆后台，可以看到熟悉的wordpress管理界面。<br><img src="https://img.mahaofei.com/img/202112231638272-ali-bt-wp-32.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231638796-ali-bt-wp-33.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> WordPress </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABB RobotStudio6.08安装</title>
      <link href="/post/559e6eff.html"/>
      <url>/post/559e6eff.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>网盘链接<br>链接：<a href="https://pan.baidu.com/s/1yUpRG146dUXC9Gj1D94AHw">https://pan.baidu.com/s/1yUpRG146dUXC9Gj1D94AHw</a><br>提取码：rsaz</p></blockquote><h3 id="安装方法">安装方法</h3><ol><li>解压安装包，运行<code>ABB RobotStudio 6.08.msi</code>程序，按流程一步步安装<br><img src="https://img.mahaofei.com/img/202112231618492-robotstudio608-1.png" alt=""></li><li>安装完成后再根据自己电脑，解压<code>RobotStudio注册文件-64位系统</code>或者<code>RobotStudio注册文件-32位系统</code>压缩包，双击其中的注册表文件<code>RobotStudio注册.reg</code>。这样就完成了ABB RobotStudio的安装与破解了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio码垛机器人创建过程</title>
      <link href="/post/a3d18e39.html"/>
      <url>/post/a3d18e39.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、安装夹具">一、安装夹具</h3><ol><li>导入一个IRB2600机器人<br><img src="https://img.mahaofei.com/img/202112231608015-robotstudio-plie-1.png" alt=""></li><li>移动夹具的本地坐标原点，使原点位置为顶面中心（与法兰盘连接的部位）<br><img src="https://img.mahaofei.com/img/202112231608361-robotstudio-pile-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231609484-robotstudio-pile-3.png" alt=""></li><li>对齐夹爪Smart组件的本地坐标和机器人末端法兰盘的坐标，使夹具的本地坐标与法兰盘的本地坐标重合，为下一步安装夹具做准备。<br><img src="https://img.mahaofei.com/img/202112231609408-robotstudio-pile-4.png" alt=""></li><li>在布局菜单内，将夹具拖动到IRB2600机器人上，完成夹具的安装<br><img src="https://img.mahaofei.com/img/202112231609685-robotstudio-pile-5.png" alt=""></li></ol><h3 id="二、创建传送带">二、创建传送带</h3><ol><li>导入传送带并设定传送带的位置<br><img src="https://img.mahaofei.com/img/202112231610899-robotstudio-pile-6.png" alt=""></li><li>创建码垛用的物体，并将其移动到传送带的起点。<br><img src="https://img.mahaofei.com/img/202112231610645-robotstudio-pile-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231610831-robotstudio-pile-8.png" alt=""></li><li>创建一个Smart组件，用于传送带物体的运动。添加如下组件<br><img src="https://img.mahaofei.com/img/202112231610947-robotstudio-pile-9.png" alt=""></li><li>对各个组件进行设置<br><img src="https://img.mahaofei.com/img/202112231611124-robotstudio-pile-10.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112231611916-robotstudio-pile-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231611919-robotstudio-pile-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231612829-robotstudio-pile-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231612841-robotstudio-pile-14.png" alt=""></p><h3 id="三、创建码垛底盘">三、创建码垛底盘</h3><p><img src="https://img.mahaofei.com/img/202112231612709-robotstudio-pile-15.png" alt=""></p><h3 id="四、创建机器人系统">四、创建机器人系统</h3><p><img src="https://img.mahaofei.com/img/202112231613609-robotstudio-pile-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231613209-robotstudio-pile-17.png" alt=""><br>选项内选择如下选项<br><img src="https://img.mahaofei.com/img/202112231613116-robotstudio-pile-18.png" alt=""></p><h3 id="五、仿真系统设置">五、仿真系统设置</h3><ol><li><p>在仿真设定中，将机器人系统后面的框选去除。<br><img src="https://img.mahaofei.com/img/202112231613549-robotstudio-pile-19.png" alt=""></p></li><li><p>运行仿真，使物块到达面传感器处，然后停止仿真，捕捉几个目标点。（后面两个目标点是为了码垛时，物块会有两种拜访姿态，所以使用两个目标点）<br><img src="https://img.mahaofei.com/img/202112231614390-robotstudio-pile-20.png" alt=""></p></li><li><p>旋转第三个目标点，使其绕Z轴旋转-90度。<br><img src="https://img.mahaofei.com/img/202112231614934-robotstudio-pile-21.png" alt=""></p></li><li><p>为目标点配置参数<br><img src="https://img.mahaofei.com/img/202112231614719-robotstudio-pile-22.png" alt=""></p></li><li><p>使机器人回到机械原点，然后创建一个空路径，将三个目标点依次拖动到路径中。<br><img src="https://img.mahaofei.com/img/202112231615329-robotstudio-pile-23.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231615980-robotstudio-pile-24.png" alt=""></p></li><li><p>同步到工作站<br><img src="https://img.mahaofei.com/img/202112231615993-robotstudio-pile-25.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231616848-robotstudio-pile-26.png" alt=""></p></li><li><p>删除之前仿真出来的物块的copy物体。</p></li><li><p>添加两个信号，一个是到位信号，用于传送带的等待，另一个是夹具信号。添加完成后重启控制器。<br><img src="https://img.mahaofei.com/img/202112231616755-robotstudio-pile-27.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231616351-robotstudio-pile-28.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231617959-robostudio-pile-29.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231617558-robotstudio-pile-30.png" alt=""></p></li><li><p>打开控制器，可以看到RAPID/T_ROB1下的程序模块，接下来就可以进行程序编写了。</p></li></ol><h3 id="程序编写">程序编写</h3><p>main程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">MODULE Module1</span><br><span class="line">CONST robtarget Target_10:=[[<span class="number">347.037</span>,<span class="number">682.5</span>,<span class="number">875.06</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">CONST robtarget Target_20:=[[<span class="number">500</span>,<span class="number">-300</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">CONST robtarget Target_30:=[[<span class="number">500</span>,<span class="number">-300</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">VAR num layer:=<span class="number">1</span>;</span><br><span class="line">    VAR num x:=<span class="number">0</span>;</span><br><span class="line">    VAR num z:=<span class="number">0</span>;</span><br><span class="line">    PROC <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">        FOR i FROM 0 TO 20 DO</span><br><span class="line">            SetDO JiaJu0,0;</span><br><span class="line">            MoveJ <span class="title function_">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>)</span>,v500,fine,Tool1;</span><br><span class="line">            WaitDI DaoWei0,<span class="number">1</span>; </span><br><span class="line">            MoveL <span class="title function_">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span>,v500,fine,Tool1;</span><br><span class="line">            SetDO JiaJu0,<span class="number">1</span>;</span><br><span class="line">            WaitTime <span class="number">1</span>;</span><br><span class="line">            MoveL <span class="title function_">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>)</span>,v500,fine,Tool1;</span><br><span class="line"></span><br><span class="line">            IF layer MOD <span class="number">2</span> = <span class="number">1</span> THEN</span><br><span class="line">                IF i MOD <span class="number">5</span> &lt; <span class="number">4</span> and i MOD <span class="number">5</span> &lt;&gt; <span class="number">0</span> THEN</span><br><span class="line">                    MoveL Offs(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">300</span>+z),v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">210</span>;</span><br><span class="line">                    IF i MOD <span class="number">5</span> = <span class="number">3</span> THEN</span><br><span class="line">                        x:=<span class="number">0</span>;</span><br><span class="line">                    ENDIF</span><br><span class="line">                ELSE</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">300</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                IF i MOD <span class="number">5</span> = <span class="number">0</span> THEN</span><br><span class="line">                    layer:=<span class="number">2</span>;</span><br><span class="line">                    x:=<span class="number">0</span>;</span><br><span class="line">                    z:=z+<span class="number">100</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                </span><br><span class="line">            ELSE</span><br><span class="line">                IF i MOD <span class="number">5</span> &lt; <span class="number">3</span> THEN</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">300</span>;</span><br><span class="line">                    IF i MOD <span class="number">5</span> = <span class="number">2</span> THEN</span><br><span class="line">                        x:=<span class="number">0</span>;</span><br><span class="line">                    ENDIF</span><br><span class="line">                ELSE</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">210</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                IF i MOD <span class="number">5</span> = <span class="number">0</span> THEN</span><br><span class="line">                    layer:=<span class="number">1</span>;</span><br><span class="line">                    x:=<span class="number">0</span>;</span><br><span class="line">                    z:=z+<span class="number">100</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">            ENDIF</span><br><span class="line">                </span><br><span class="line">        ENDFOR</span><br><span class="line">        z:=<span class="number">0</span>;</span><br><span class="line">    ENDPROC</span><br><span class="line">ENDMODULE</span><br></pre></td></tr></table></figure><h3 id="仿真测试">仿真测试</h3><ol><li>将代码同步到工作站<br><img src="https://img.mahaofei.com/img/202112231617535-robotstudio-pile-31.png" alt=""></li><li>删除Path_10路径，只保留main路径<br><img src="https://img.mahaofei.com/img/202112231617120-robotstudio-pile-32.png" alt=""></li><li>设置工作站逻辑<br><img src="https://img.mahaofei.com/img/202112231618997-robotstudio-pile-33.png" alt=""></li><li>进行仿真</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio动态夹具的创建</title>
      <link href="/post/5278881.html"/>
      <url>/post/5278881.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建夹具的几何模型">创建夹具的几何模型</h2><p>如果你有其它建模软件如Solidworks等做的夹具模型，可以导入到RobotStudio中。<br>这里简单建模，主要展示动态夹具的创建流程。</p><ol><li>创建夹具的本体<br><img src="https://img.mahaofei.com/img/202112231601044-robotstudio-clamp-1.png" alt=""></li><li>将其移动到其他位置，准备创建夹具的其他部分<br><img src="https://img.mahaofei.com/img/202112231601381-robotstudio-clamp-2.png" alt=""></li><li>创建一个圆柱，作为夹具的法兰盘，与机器人的关节末端相连<br><img src="https://img.mahaofei.com/img/202112231602589-robotstudio-clamp-3.png" alt=""></li><li>移动长方体的位置。<br><img src="https://img.mahaofei.com/img/202112231602622-robotstudio-clamp-4.png" alt=""></li><li>将部件2的物体拖动到部件1上，将两个物体组合成一个部件。<br><img src="https://img.mahaofei.com/img/202112231602868-robotstudio-clamp-5.png" alt=""></li><li>创建夹爪<br><img src="https://img.mahaofei.com/img/202112231603355-robotstudio-clamp-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231603512-robotstudio-clamp-7.png" alt=""></li></ol><h2 id="创建机械装置">创建机械装置</h2><ol><li>点击创建机械装置，装置名称写“夹具”，装置类型选“工具”<br><img src="https://img.mahaofei.com/img/202112231603327-robotstudio-clamp-8.png" alt=""></li><li>添加链接，为刚才创建的三个部件分别添加链接。如果是导入的模型，也需要为各个部件添加链接。其中基座部分需要勾选BaseLink，其它部分不需要。<br><img src="https://img.mahaofei.com/img/202112231603495-robotstudio-clamp-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231604636-robotstudio-clamp-10.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112231604182-robotstudio-clamp-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231604040-robotstudio-clamp-12.png" alt=""></p><ol start="3"><li><p>创建接点<br><img src="https://img.mahaofei.com/img/202112231604329-robotstudio-clamp-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231605794-robotstudio-clamp-14.png" alt=""></p></li><li><p>创建工具数据<br><img src="https://img.mahaofei.com/img/202112231605742-robotstudio-clamp-15.png" alt=""></p></li><li><p>添加一个新姿态<br><img src="https://img.mahaofei.com/img/202112231605535-robotstudio-clamp-16.png" alt=""></p></li></ol><h2 id="Smart组件设置">Smart组件设置</h2><ol><li>创建Smart组件，将夹具拖动到Smart组件下，并将夹具设置为Smart组件的角色Role<br><img src="https://img.mahaofei.com/img/202112231605493-robotstudio-clamp-17.png" alt=""></li><li>添加以下组件<br><img src="https://img.mahaofei.com/img/202112231606527-robotstudio-clamp-18.png" alt=""></li><li>添加信号<br><img src="https://img.mahaofei.com/img/202112231606441-robotstudio-clamp-19.png" alt=""></li><li>对各个组件进行设置，首先先设置夹具不可由传感器检测<br><img src="https://img.mahaofei.com/img/202112231606430-robotstudio-clamp-20.png" alt=""></li><li>设置直线传感器，设置为图示圆柱状，用于检测夹具下方是否有物体<br><img src="https://img.mahaofei.com/img/202112231606894-robotstudio-clamp-21.png" alt=""></li><li>设置Attacher安装对象组件<br><img src="https://img.mahaofei.com/img/202112231607965-robotstudio-clamp-22.png" alt=""></li><li>设置PoseMover，机械装置运动的属性<br><img src="https://img.mahaofei.com/img/202112231607238-robotstudio-clamp-23.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231607713-robotstudio-clamp-24.png" alt=""></li><li>按图示设计程序框图<br><img src="https://img.mahaofei.com/img/202112231607859-robotstudio-clamp-25.png" alt=""></li></ol><blockquote><p>链接：<a href="https://pan.baidu.com/s/1pVwEuCmvoiwFlHMjRqEjLQ">https://pan.baidu.com/s/1pVwEuCmvoiwFlHMjRqEjLQ</a><br>提取码：rs04</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio碰撞检测的设定</title>
      <link href="/post/67c8f55a.html"/>
      <url>/post/67c8f55a.html</url>
      
        <content type="html"><![CDATA[<h4 id="碰撞检测的创建">碰撞检测的创建</h4><p>单击<strong>创建碰撞检测</strong>进行创建，创建完成后，<strong>ObjectA</strong>与<strong>ObjectB</strong>为进行检测的两个组，如果两个组的物体发生碰撞，则会发生颜色变化。<br><img src="https://img.mahaofei.com/img/202112231600684-robotstudio-crash-1.png" alt=""></p><h4 id="碰撞检测的设定">碰撞检测的设定</h4><p>可以在右键菜单中设置<strong>接近距离</strong>和<strong>变化颜色</strong><br><img src="https://img.mahaofei.com/img/202112231600582-robotstudio-crash-2.png" alt=""></p><h4 id="仿真演示">仿真演示</h4><ol><li>正常状态，焊枪与盒子未碰撞，颜色未改变。<br><img src="https://img.mahaofei.com/img/202112231600008-robotstudio-crash-3.png" alt=""></li><li>焊枪与盒子碰撞时，两物体颜色均改变成设定的颜色<br><img src="https://img.mahaofei.com/img/202112231601016-robotstudio-crash-4.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio机器人运行路径的创建与仿真</title>
      <link href="/post/c192e333.html"/>
      <url>/post/c192e333.html</url>
      
        <content type="html"><![CDATA[<p>本文在一个已经<strong>搭建好机械模型</strong>，同时<strong>完成机器人系统的创建</strong>后的机器人运行路径的创建过程。初始时的界面如下：<br><img src="https://img.mahaofei.com/img/202112231556681-robotstudio-path-1.png" alt=""></p><blockquote><p><strong>工程文件已上传到网盘</strong><br>包括：初始工程文件（03Practice_init.rspag）、完成后的工程文件（03Practice.rspag）、模型文件<br>链接：<a href="https://pan.baidu.com/s/1f0RL-iLBm2Kxd0NbLduv0Q">https://pan.baidu.com/s/1f0RL-iLBm2Kxd0NbLduv0Q</a><br>提取码：rs03</p></blockquote><h4 id="工件坐标的创建">工件坐标的创建</h4><p><img src="https://img.mahaofei.com/img/202112231557192-robotstudio-path-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231557471-robotstudio-path-3.png" alt=""></p><h4 id="运行路径的创建">运行路径的创建</h4><ol><li>首先创建一个空路径<br><img src="https://img.mahaofei.com/img/202112231557137-robotstudio-path-4.png" alt=""></li><li>改变机器人的姿态，使工具移动到目标点进行示教。<br><img src="https://img.mahaofei.com/img/202112231557648-robotstudio-path-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231558239-robotstudio-path-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231558386-robotstudio-path-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231558971-robotstudio-path-8.png" alt=""></li></ol><ul><li>动作类型<ul><li>Joint：机器人以点到点的形式到此点（不走直线，各轴自由运动）</li><li>Linear：机器人以直线运行方式从上一点运行到下一点</li></ul></li><li>Conc<ul><li>禁用：机器人会精确到达此点</li><li>启用：机器人会依据Zone的参数，略过此点</li></ul></li><li>Speed：机器人的运动速度</li><li>Zone：启用Conc时，机器人掠过目标点所经过圆弧轨迹的半径</li></ul><ol start="3"><li>测试到达能力并进行模拟运行<br><img src="https://img.mahaofei.com/img/202112231559740-robotstudio-path-9.png" alt=""></li></ol><h4 id="仿真与录像">仿真与录像</h4><ol><li>将工作站同步到Rapid代码<br><img src="https://img.mahaofei.com/img/202112231559244-robotstudio-path-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231559665-robotstudio-path-11.png" alt=""></li><li>进行仿真设定<br><img src="https://img.mahaofei.com/img/202112231559104-robotstudio-path-12.png" alt=""></li><li>播放并录制保存仿真视频。（录制的视频默认保存在 <strong>我的电脑/视频</strong> 目录下）<br><img src="https://img.mahaofei.com/img/202112231600619-robotstudio-path-13.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio双传送带系统的搭建</title>
      <link href="/post/f8aff6ba.html"/>
      <url>/post/f8aff6ba.html</url>
      
        <content type="html"><![CDATA[<h3 id="机械结构的搭建">机械结构的搭建</h3><ol><li>导入两个传送带，将第二个传送带以z轴旋转90°，再沿y轴偏移-3200mm。<br><img src="https://img.mahaofei.com/img/202112231547151-robotstudio-doubleconveyer-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231547014-robotstudio-doubleconveyer-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231548275-robotstudio-doubleconveyer-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231548997-robotstudio-doubleconveyer-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231549817-robotstudio-doubleconveyer-5.png" alt=""></li><li>导入机器人IRB120，将其移动到合适的位置上。<br><img src="https://img.mahaofei.com/img/202112231549242-robotstudio-doubleconveyer-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231550395-robotstudio-doubleconveyer-7.png" alt=""></li><li>创建工件的模型，将工件的第二部分内的物体拖动到第一部分中，形成一个部件<br><img src="https://img.mahaofei.com/img/202112231550097-robotstudio-doubleconveyer-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231551500-robotstudio-doubleconveyer-9.png" alt=""></li><li>将工件移动到合适的位置<br><img src="https://img.mahaofei.com/img/202112231552087-robotstudio-doubleconveyer-10.png" alt=""></li><li>导入夹具，将夹具旋转至与大地坐标系平行<br><img src="https://img.mahaofei.com/img/202112231552216-robotstudio-doubleconveyer-11.png" alt=""></li><li>设置夹具的本地坐标<br><img src="https://img.mahaofei.com/img/202112231554863-robotstudio-doubleconveyer-12.png" alt=""></li><li>在左侧布局栏中，将夹具拖动到机器人上，更新夹具的位置<br><img src="https://img.mahaofei.com/img/202112231554899-robotstudio-doubleconveyer-13.png" alt=""></li></ol><h3 id="创建机器人系统">创建机器人系统</h3><p><img src="https://img.mahaofei.com/img/202112231554707-robotstudio-doubleconveyer-14.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231554597-robotstudio-doubleconveyer-15.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231555421-robotstudio-doubleconveyer-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231555822-robotstudio-doubleconveyer-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231555519-robotstudio-doubleconveyer-18.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231556585-robotstudio-doubleconveyer-19.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231556315-robotstudio-doubleconveyer-20.png" alt=""></p><p>等待一段时间，等待系统创建完成即可进行传送带的试验。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio创建目标点时出现未找到有效配置的问题</title>
      <link href="/post/53fb1c42.html"/>
      <url>/post/53fb1c42.html</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述：">问题描述：</h4><p>RobotStudio在使用路径和目标点的创建目标点时，有时会出现<strong>无法跳转到目标点</strong>的问题，错误为<strong>未找到有效配置</strong>。<br><img src="https://img.mahaofei.com/img/202112231544276-robotstudio-noconfig-1.png" alt=""></p><h4 id="原因分析：">原因分析：</h4><ol><li><strong>未使用正确的工具坐标</strong></li><li>目标点的坐标与工具坐标无法对应，<strong>机器人不能实现运动</strong>到指定位置使两坐标系重合。</li></ol><h4 id="解决方法：">解决方法：</h4><ol><li>解决方法1：在基本-设置选择正确的工具坐标，例如夹具的工具坐标。</li><li>解决方法2：右键目标点-修改目标-旋转，将坐标系旋转至<strong>工具运动到此位置时的工具坐标系重合</strong>。如果仍然有问题可以多试几个方向，一般不止一个方向可以实现跳转到目标点。<br><img src="https://img.mahaofei.com/img/202112231545842-robotstudio-noconfig-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231546698-robotstudio-noconfig-3.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio传送带设计</title>
      <link href="/post/235f7d9b.html"/>
      <url>/post/235f7d9b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>工作站文件：<br>链接：<a href="https://pan.baidu.com/s/1kikAGbj-vVAH-IR9AWY1sg">https://pan.baidu.com/s/1kikAGbj-vVAH-IR9AWY1sg</a><br>提取码：robo</p></blockquote><h3 id="传送带模型的创建">传送带模型的创建</h3><ol><li>新建一个工作站，从设备中导入一个传送带<br><img src="https://img.mahaofei.com/img/202112231529116-robotstudio-conveyer-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231529421-robotstudio-conveyer-2.png" alt=""></li><li>创建一个正方体，作为传送带的传送对象<br><img src="https://img.mahaofei.com/img/202112231530401-robotstudio-conveyer-3.png" alt=""></li><li>将小方块拖动带传送带上我们要的位置处<br><img src="https://img.mahaofei.com/img/202112231530756-robotstudio-conveyer-4.png" alt=""></li><li>可以借助<strong>捕捉</strong>与<strong>设定位置</strong>精确定位小方块的位置<br><img src="https://img.mahaofei.com/img/202112231537698-robotstudio-conveyer-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231537983-robotstudio-conveyer-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231538014-robotstudio-conveyer-7.png" alt=""></li></ol><h3 id="简单传送带设计">简单传送带设计</h3><ol><li>建立一个Smart组件，先实现小方块的直线移动<br><img src="https://img.mahaofei.com/img/202112231538464-robotstudio-conveyer-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231538216-robotstudio-conveyer-9.png" alt=""></li><li>点击仿真-播放，然后点击Smart组件的Execute按钮，即可观察到小方块的直线运动。但是小方块无法自行停止，需要点击停止按钮，然后重置，才能回到初始状态。<br><img src="https://img.mahaofei.com/img/202112231539253-robotstudio-conveyer-10.png" alt=""></li><li>添加一个<strong>面传感器</strong>用于检测小方块的位置<br><img src="https://img.mahaofei.com/img/202112231539927-robotstudio-conveyer-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231539811-robotstudio-conveyer-12.png" alt=""></li><li>回到Smart组件的设计页面，设计逻辑程序，因为<strong>传送带的逻辑是输入端有高电平就运行，传感器的逻辑是有物体触碰就输出高电平，其他时间输出低电平</strong>。因此要实现传送带的要求，只需要将<strong>传感器的输出取非后传给传动带</strong>即可。<br><img src="https://img.mahaofei.com/img/202112231540286-robotstudio-conveyer-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231540964-robotstudio-conveyer-14.png" alt=""></li><li>进行仿真，发现传送带与小方块的运行效果符合预期。如果发现小方块不停止的话，将传送带的<strong>可由传感器检测</strong>取消掉就可以了<br><img src="https://img.mahaofei.com/img/202112231540116-robotstudio-conveyer-15.png" alt=""></li></ol><h3 id="多个物体的连续传送">多个物体的连续传送</h3><ol><li>添加一个Source组件用于实现小方块的复制，编辑它的属性<br><img src="https://img.mahaofei.com/img/202112231540663-robotstudio-conveyer-16.png" alt=""><br>复制源Source选择小方块，位置通过捕捉本地原点选择小方块的原点，点击应用。</li><li>然后进行复制小方块的程序设计由于<strong>Source组件的触发条件是上升沿</strong>，即低脉冲跃变到高脉冲时，才会触发复制效果。<br><img src="https://img.mahaofei.com/img/202112231541684-robotstudio-conveyer-17.png" alt=""><br>因此考虑添加一个脉冲信号的发生组件Timber，信号间隔暂定为5s。<br><img src="https://img.mahaofei.com/img/202112231541304-robotstudio-conveyer-18.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231541885-robotstudio-conveyer-19.png" alt=""></li><li>但是这样带来的问题是，在第一个小方块还未到终点时，因为时间已经到了5s，因此传送带会开始运送下一个小方块，仿真表现是所有小方块运动5s后会自动停止。因此选择使用队列这个组件来解决问题。<br><img src="https://img.mahaofei.com/img/202112231542233-robotstudio-conveyer-20.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231542450-robotstudio-conveyer-21.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231542707-robotstudio-conveyer-22.png" alt=""></li></ol><ul><li>back：将复制出来的小方块添加到队列后面</li><li>delete：删除队列中最前面的物体</li><li>enqueue：接收到复制完成的信号后开始将对象添加到队列中</li><li>传送带的传送对象需要改为整个队列</li></ul><p>仿真效果如下（可将原始方块部件_1取消可见，显示效果更好）<br><img src="https://img.mahaofei.com/img/202112231543116-robotstudio-conveyer-23.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio关于Ctrl+鼠标左键拖动速度慢的解决方法</title>
      <link href="/post/75ac34b3.html"/>
      <url>/post/75ac34b3.html</url>
      
        <content type="html"><![CDATA[<p>使用ABB RobotStudio的过程中，有时会遇到鼠标拖动平移视角的速度突然变慢的问题，不知道问题出在什么地方，但是发现了解决方法：<br><strong>工作站空白处右键，点击查看全部或查看中心</strong><br><img src="https://img.mahaofei.com/img/202112231528441-robotstudio-mouse-1.png" alt=""><br>然后就恢复正常了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（十）模块化程序</title>
      <link href="/post/fd5caa9a.html"/>
      <url>/post/fd5caa9a.html</url>
      
        <content type="html"><![CDATA[<p>当程序比较复杂，或者程序内存在重复的部分时，模块化程序设计往往是比较可行的办法。在RobotStudio中可以通过在主程序中调用不同的例行程序，达到使代码逻辑清晰的目的。</p><h3 id="将搬运工件的动作保存为例行程序">将搬运工件的动作保存为例行程序</h3><ol><li>进入例行程序，新建一个例行程序<br><img src="https://img.mahaofei.com/img/202112231523040-robotstudio-notes10-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231524731-robotstudio-notes10-2.png" alt=""></li><li>回到main程序，鼠标选中第一行，点击编辑-编辑，将main函数内的代码复制到新建的例行程序中<br><img src="https://img.mahaofei.com/img/202112231524737-robotstudio-notes10-3.png" alt=""></li><li>回到刚才新建的例行程序中，将main函数代码粘贴过来。<br><img src="https://img.mahaofei.com/img/202112231524541-robotstudio-notes10-4.png" alt=""></li><li>利用调试-pp移至例行程序，测试例行程序是否正确，没有问题的话，就将main函数的内容，用指令procall代替。<br><img src="https://img.mahaofei.com/img/202112231525965-robotstudio-notes10-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231525916-robotstudio-notes10-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231526799-robotstudio-notes10-7.png" alt=""></li></ol><h3 id="快速实现搬运第二个工件">快速实现搬运第二个工件</h3><ol><li>首先将搬运工件的例行程序复制一份<br><img src="https://img.mahaofei.com/img/202112231526330-robotstudio-notes10-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231527924-robotstudio-notes10-9.png" alt=""></li><li>因为工件的位置是利用仓库的工件坐标系通过偏倚确定的，因此只需要修改Offs函数的参数即可确定第二个工件的夹取位置。<br><img src="https://img.mahaofei.com/img/202112231527246-robotstudio-notes10-10.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（九）坐标偏移设置</title>
      <link href="/post/fa5adfbf.html"/>
      <url>/post/fa5adfbf.html</url>
      
        <content type="html"><![CDATA[<h3 id="Offs指令">Offs指令</h3><p><strong>功能</strong>：根据当前所选工件坐标以及基准点进行坐标偏移<br><strong>使用</strong>：Offs(变量, Δx, Δy, Δz)</p><h3 id="坐标偏移设置方法">坐标偏移设置方法</h3><ol><li>点击要偏移的robtarget数据，选择<strong>功能-Offs</strong><br><img src="https://img.mahaofei.com/img/202112231521620-robotstudio-notes9-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231522496-robotstudio-notes9-2.png" alt=""></li><li>例如让夹爪夹取工件后竖直上升50mm，则可按如下设置<br><img src="https://img.mahaofei.com/img/202112231522604-robotstudio-notes9-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231523048-robotstudio-notes9-4.png" alt=""><br>同理，其它坐标的偏移方式也可按相同的方法进行设置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（八）速度设置</title>
      <link href="/post/cd6881c8.html"/>
      <url>/post/cd6881c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、速度的直接设置">一、速度的直接设置</h3><p>在手动模式下，最大速度受到限制，最大时250mm/s。而程序中v1000在仿真和实际中是十分快的，因此修改工件拿起和放下时的速度，轻拿轻放。<br><img src="https://img.mahaofei.com/img/202112231512893-robotstudio-notes8-1.png" alt=""><br>实际操作时，手动调试完成后要先如下图，从25%速度开始测试，如果实物机器人运动没有问题，在逐步增大速度，直到100%。如果中间出现任何问题，就将程序中的速度参数修改成适合的值。<br><img src="https://img.mahaofei.com/img/202112231512860-robotstudio-notes8-2.png" alt=""></p><h3 id="二、速度数据的创建与替换">二、速度数据的创建与替换</h3><ol><li>点击<strong>菜单【三V】—&gt;数据类型—&gt;全部数据类型—speeddata—&gt;显示数据—&gt;新建</strong><br><img src="https://img.mahaofei.com/img/202112231513906-robotstudio-notes8-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231513221-robotstudio-notes8-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231513746-robotstudio-notes8-5.png" alt=""></li><li>设置变量的名字，然后修改初始值，其中v_tcp是直线运动速度（主要用这个），v_ori是重定位速度。<br><img src="https://img.mahaofei.com/img/202112231514409-robotstudio-notes8-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231515775-robotstudio-notes8-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231515368-robotstudio-notes8-8.png" alt=""></li><li>回到程序设计页面，点击速度值，选择需要替换的速度变量，确定。<br><img src="https://img.mahaofei.com/img/202112231516107-robotstudio-notes8-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231517754-robotstudio-notes8-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231517162-robotstudio-notes8-11.png" alt=""></li></ol><h3 id="三、速度延时设置">三、速度延时设置</h3><p>夹爪的加紧动作需要时间，如果不延时的话，夹爪会在加进的同时运动，可能导致一些问题。设置的方法如下：</p><ol><li>点击夹爪夹紧的指令（Set语句），添加指令WaitTime，这里以1s延时为例。<br><img src="https://img.mahaofei.com/img/202112231518649-robotstudio-notes8-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231518798-robotstudio-notes8-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231520453-robotstudio-notes8-14.png" alt=""></li><li>同理在夹爪松开时，同样需要进行延时设置。<br><img src="https://img.mahaofei.com/img/202112231521870-robotstudio-notes8-15.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（七）工件坐标</title>
      <link href="/post/c31c5b0.html"/>
      <url>/post/c31c5b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、工件坐标简介">一、工件坐标简介</h3><p>在目标工作台的任意位置，任意角度创建一个直角坐标系，把这个坐标系叫做工件坐标。<br>在不同的位置创建工件坐标系，就可以实现，相同的程序在不同的位置实现相同的加工。</p><h3 id="二、3点法设置工件坐标">二、3点法设置工件坐标</h3><ol><li>进入手动操作-工件坐标=新建，创建一个工件坐标<br><img src="https://img.mahaofei.com/img/202112231458020-robotstudio-notes7-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231458085-robotstudio-notes7-2.png" alt=""></li><li>选中新建的工件坐标，编辑-定义，用户方法选择3点<br><img src="https://img.mahaofei.com/img/202112231458270-robotstudio-notes7-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231459866-robotstudio-notes7-4.png" alt=""></li><li>如果想建立一个如下图所示的坐标系<br><img src="https://img.mahaofei.com/img/202112231500037-robotstudio-notes7-5.png" alt=""></li><li>在仿真内选择基本-其它-创建工件坐标，用户坐标框架-取点创建框架，选择三个点即可创建坐标系。<br><img src="https://img.mahaofei.com/img/202112231500874-robotstudio-notes7-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231500815-robotstudio-notes7-7.png" alt=""></li></ol><h3 id="三、实际系统工件坐标的确定">三、实际系统工件坐标的确定</h3><p>在操作实际机器人系统时，可以选择一个具有尖端的工件，手动操作对齐要确定的三个点，记录下来设置工件坐标。</p><ol><li><p>添加一个具有尖端的工具，用于确定目标点坐标。将工具添加到机器人系统中，并隐藏此前的夹爪工具。<br><img src="https://img.mahaofei.com/img/202112231501574-robotstudio-notes7-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231501192-robotstudio-notes7-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231501383-robotstudio-notes7-10.png" alt=""></p></li><li><p>按照上文<strong>三点法设置工件坐标</strong>的前两步。选择仓库的三个点位分别设置为X1、X2、Y1，以此来确定工件坐标系。完成后点击确定。<br><img src="https://img.mahaofei.com/img/202112231503509-robotstudio-notes7-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231504258-robotstudio-notes7-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231504772-robotstudio-notes7-13.png" alt=""></p></li><li><p>同理在操作台也可以创建一个工件坐标<br><img src="https://img.mahaofei.com/img/202112231505134-robotstudio-notes7-14.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231508294-robotstudio-notes7-15.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231508626-robotstudio-notes7-16.png" alt=""></p></li><li><p>删除刚才添加用于确定点位的工具（Pen），令夹爪可见</p></li></ol><h3 id="四、程序中工件坐标的修改方法">四、程序中工件坐标的修改方法</h3><p>修改程序中的工件坐标，使在仓库夹取工件的部分动作使用仓库工件坐标系，在操作台的放置部分动作使用操作台工件坐标系，其余动作使用默认工件坐标系。</p><ol><li>以pPickUP位置处的动作为例。单步运行程序，运行至pPickUP位置时，点击整条指令，<strong>可选变量—[\WObj]—使用</strong><br><img src="https://img.mahaofei.com/img/202112231509087-robotstudio-notes7-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231509106-robotstudio-notes7-18.png" alt=""></li><li>点击wobj0，选择wobj_CK确定<br><img src="https://img.mahaofei.com/img/202112231510351-robotstudio-notes7-19.png" alt=""></li><li>选择回到手动操作面板，点击工件坐标，选择wobj_CK<br><img src="https://img.mahaofei.com/img/202112231511473-robotstudio-notes7-20.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231511778-robotstudio-notes7-21.png" alt=""></li><li>再回到程序编辑器，选择刚才编辑的那一条语句，修改位置即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（六）有效载荷</title>
      <link href="/post/61ec45b2.html"/>
      <url>/post/61ec45b2.html</url>
      
        <content type="html"><![CDATA[<p>从夹爪夹住工件后，系统的载荷就发生了变化，对于仿真程序中效果区别可能不明显，但在实际系统中，必须要考虑载荷的区别。</p><ol><li>打开手动操作-有效载荷<br><img src="https://img.mahaofei.com/img/202112231453205-robotstudio-notes6-1.png" alt=""></li><li>新建一个有效载荷<br><img src="https://img.mahaofei.com/img/202112231454418-robotstudio-notes6-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231455004-robotstudio-notes6-3.png" alt=""></li><li>修改程序，在程序开始处，添加指令-settings-gripload<br><img src="https://img.mahaofei.com/img/202112231456893-robotstudio-notes6-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231456248-robotstudio-notes6-5.png" alt=""></li><li>添加到上方，负载为load0<br><img src="https://img.mahaofei.com/img/202112231456033-robotstudio-notes6-6.png" alt=""></li><li>在夹爪夹取工件后，即set dol0_1语句下，再次添加一条gripload语句，负载为load_Box。同理，在夹爪松开后，再次添加一条gripload语句，负载为load0.<br><img src="https://img.mahaofei.com/img/202112231456481-robotstudio-notes6-7.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（五）工具数据</title>
      <link href="/post/96d699f6.html"/>
      <url>/post/96d699f6.html</url>
      
        <content type="html"><![CDATA[<ol><li>拆除夹爪，测量夹爪末端坐标<br><img src="https://img.mahaofei.com/img/202112231451524-robotstudio-notes5-1.png" alt=""></li><li>点击建模-测量-点到点，选择夹爪底面和末端面，记录得到的z坐标值<br><img src="https://img.mahaofei.com/img/202112231451216-robotstudio-notes5-2.png" alt=""></li><li>将夹爪安装回机器人末端<br><img src="https://img.mahaofei.com/img/202112231451089-robotstudio-notes5-3.png" alt=""></li><li>打开虚拟示教器，进入手动操纵-工具坐标-新建，修改名称，点击左下角初始值<br><img src="https://img.mahaofei.com/img/202112231452933-robotstudio-notes5-4.png" alt=""></li><li>修改第一个z（坐标位置）为刚才测得得值215.30，mass（质量）为1，第二个z（重心位置）初估一个数<br><img src="https://img.mahaofei.com/img/202112231452295-robotstudio-notes5-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231452825-robotstudio-notes5-6.png" alt=""></li><li>验证坐标，选择动作模式为重定位，工具坐标为刚才新建坐标。操纵摇杆可看到机器人绕夹爪两末端中心点转动。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（四）夹取工件程序设计</title>
      <link href="/post/c3082f61.html"/>
      <url>/post/c3082f61.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、指令">一、指令</h3><ol><li>MoveJ：移动到某位置</li><li>Set/Reset：控制外部设备</li></ol><h3 id="二、实现过程">二、实现过程</h3><ol><li>在初始位置添加一句MoveJ指令<br><img src="https://img.mahaofei.com/img/202112231156121-robotstudio-notes4-1.png" alt=""></li><li>将机器人爪调至工件的正上方，再添加一条MoveJ指令（在工件上方添加一个位置点，是为了防止机器人直接夹取，可能会从侧面撞到工件）<br><img src="https://img.mahaofei.com/img/202112231158132-robotstudio-notes4-2.png" alt=""></li><li>将机器人爪子向下移动到夹取工件的位置，添加一条MoveJ指令<br><img src="https://img.mahaofei.com/img/202112231200758-robotstudio-notes4-3.png" alt=""></li><li>使用Set指令，使机器人爪子夹紧工件。<br><img src="https://img.mahaofei.com/img/202112231202140-robotstudio-notes4-4.png" alt=""></li><li>将机器人竖直向上移动，使工件脱离工作台，添加一条MoveJ指令。<br><img src="https://img.mahaofei.com/img/202112231435382-robotstudio-notes4-5.png" alt=""></li><li>将工件移动到夹具台上方，再次添加一条MoveJ指令。<br><img src="https://img.mahaofei.com/img/202112231435336-robotstudio-notes4-6.png" alt=""></li><li>将工具放到工作台上，添加一条MoveJ指令，再使用Reset指令松开夹爪。<br><img src="https://img.mahaofei.com/img/202112231437607-robotstudio-notes4-7.png" alt=""></li><li>使用MoveJ指令将机器人先竖直向上移动，再回到初始位置，即可完成一个动作周期。</li></ol><h3 id="三、增强代码可读性-创建robtarget数据">三、增强代码可读性-创建robtarget数据</h3><p>点击MoveJ指令后的*，点击ToPoint，点击新建，即可创建一个robotarget数据，代替*所在位置，增强程序的可读性。<br>（注意，新建robtarget数据时，是记录机器人<strong>现在位置</strong>，而非原指位置）<br><img src="https://img.mahaofei.com/img/202112231438945-robotstudio-notes4-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231439891-robotstudio-notes4-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231440095-robotstudio-notes4-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231444607-robotstudio-notes4-11.png" alt=""></p><h3 id="四、修改程序中的工具数据">四、修改程序中的工具数据</h3><p>为了输出负载等其它参数的正常与机器人的稳定运行，需要将指令后的工具坐标修改为正确的工具坐标。</p><ol><li>当机器人系统处于此行程序对应位置时，点击tool0修改为tGrip<br><img src="https://img.mahaofei.com/img/202112231448325-robotstudio-notes4-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231450261-robotstudio-notes4-13.png" alt=""></li><li>因工具坐标发生变化，所以对应的位置坐标也需要改变，点击修改位置即可将更改正确位置<br><img src="https://img.mahaofei.com/img/202112231450760-robotstudio-notes4-14.png" alt=""></li><li>将机器人移动到下一个位置，然后再修改工具坐标，再更正位置。<br><img src="https://img.mahaofei.com/img/202112231450222-robotstudio-notes4-15.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（三）程序创建</title>
      <link href="/post/1210b010.html"/>
      <url>/post/1210b010.html</url>
      
        <content type="html"><![CDATA[<p><strong>1. 层级结构</strong><br>打开主菜单-程序 可以看到最上面一行是程序名称，T_ROB1/MainModule/main。<br><img src="https://img.mahaofei.com/img/202112231153517-robotstudio-notes3-1.png" alt=""><br>其中T_ROB1是任务，有几个机械单元就有几个任务可以选择。比如两个机械臂协同工作，就会出现ROB2等。<br><img src="https://img.mahaofei.com/img/202112231153668-robotstudio-notes3-2.png" alt=""><br>第二层是模块，分成系统模块和程序模块。模块就是将机器人需要实现的各个功能分成不同模块。可以理解成文件夹。<br><img src="https://img.mahaofei.com/img/202112231153002-robotstudio-notes3-3.png" alt=""><br>第三层是例行程序，是机器人系统真正执行的一些程序。<br><img src="https://img.mahaofei.com/img/202112231154696-robotstudio-notes3-4.png" alt=""><br><strong>2. 新建程序</strong><br>新建模块：点击文件-新建模块。<br><img src="https://img.mahaofei.com/img/202112231154598-robotstudio-notes3-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231154343-robotstudio-notes3-6.png" alt=""><br>进入新建的模块，可以看到现在的模块只是相当于一个文件夹，并没有创建程序的地方。所以我们需要先创建一个例行程序。点击右上方例行程序，文件-新建例行程序。<br><img src="https://img.mahaofei.com/img/202112231154969-robotstudio-notes3-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231155859-robotstudio-notes3-8.png" alt=""><br>点击显示例行程序，就可以进入到程序编辑页面了。<br>把当前位置记录下来，使用添加指令-MoveJ指令。<br>将机器人移动至另一个位置，再次添加MoveJ指令。点击调试-pp移至Main，点击右边的单步执行，可以看到机器人进行了一步移动。<br><img src="https://img.mahaofei.com/img/202112231155034-robotstudio-notes3-9.png" alt=""><br>同时，程序可以切换单周执行与连续执行。<br><img src="https://img.mahaofei.com/img/202112231156889-robotstudio-notes3-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（二）手动操作</title>
      <link href="/post/8e5621e4.html"/>
      <url>/post/8e5621e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="手动单轴操作">手动单轴操作</h2><ol><li>打开一个机器人系统，打开虚拟示教器</li><li>点击<strong>菜单-手动操纵-动作模式</strong>，可以看到下方有四个动作模型，其中轴1-3和轴4-6为单轴操作，后面是线性操作，和重定位操作，这里<strong>选择轴1-3</strong>，点击确定。<br><img src="https://img.mahaofei.com/img/202112231146716-robotstudio-notes2-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231147272-robotstudio-notes2-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231147945-robotstudio-notes2-3.png" alt=""></li><li>可以看到在手动操作界面右方有机器人的位置信息和操纵杆方向。 操纵杆方向处的箭头对应示教器控制器的箭头，数字代表轴的序号。 如第一个代表上下箭头控制二轴的运动，下箭头为正方向第二个代表左右箭头控制1轴的运动，第三个代表顺时针，逆时针按钮控制3轴的运动。如果想要控制4-6，点击动作模式选择轴4-6即可。<br><img src="https://img.mahaofei.com/img/202112231147709-robotstudio-notes2-4.png" alt=""></li></ol><h2 id="手动线性操作">手动线性操作</h2><ol><li>进入手动操纵的菜单栏，可以看到现在的动作模式是单轴动作，坐标系不可选。<br><img src="https://img.mahaofei.com/img/202112231148535-robotstudio-notes2-5.png" alt=""></li><li>点击动作模式，将<strong>动作模式更改为线性</strong>，确定后，可以看到此时的坐标系可以选择了。<br><img src="https://img.mahaofei.com/img/202112231148461-robotstudio-notes2-6.png" alt=""></li><li>进入坐标系菜单，可以看到有四种坐标系，分别是大地坐标、基坐标、工具、工件坐标。<br><img src="https://img.mahaofei.com/img/202112231148166-robotstudio-notes2-7.png" alt=""></li><li>首先看大地坐标，选择大地坐标确定后，可以看到控制器右侧的位置信息变成了xyz坐标值。操纵杆方向也变成了xyz，大地坐标系就是以机器人视图左下角的坐标系为基准进行运动。<br><img src="https://img.mahaofei.com/img/202112231149507-robotstudio-notes2-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231149493-robotstudio-notes2-9.png" alt=""></li><li>基坐标系，选中机器人底座，可以看到有一个坐标系，此时xyz就是沿着这个坐标系确定的。<br><img src="https://img.mahaofei.com/img/202112231150330-robotstudio-notes2-10.png" alt=""></li><li>工具坐标，可以看到菜单栏有一项为工具坐标tool0，这个坐标系就是以机器人末端第六关节的坐标运动。<br><img src="https://img.mahaofei.com/img/202112231150929-robotstudio-notes2-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231150345-robotstudio-notes2-12.png" alt=""></li><li>工件坐标，可以看到菜单栏有一项为工件坐标tool0，这个坐标系是以工件的坐标系运动。</li></ol><h2 id="重定位操作">重定位操作</h2><ol><li>打开虚拟示教器，<strong>手动操纵-动作模式</strong>，切换动作模式为重定位。<br><img src="https://img.mahaofei.com/img/202112231151019-robotstudio-notes2-13.png" alt=""></li><li>回到手动操纵的菜单栏，可以看到此时的坐标系为工具，工具坐标为tool0<br><img src="https://img.mahaofei.com/img/202112231151642-robotstudio-notes2-14.png" alt=""></li><li>按下示教器的箭头，手动操作进行观察，可以发现位置坐标XYZ始终不发生变化。<br><img src="https://img.mahaofei.com/img/202112231151849-robotstudio-notes2-15.png" alt=""></li><li>将爪子隐藏，可以看出系统运动过程中，第6关节末端中心点位置保持不变。<br><img src="https://img.mahaofei.com/img/202112231152444-robotstudio-notes2-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231152706-robotstudio-notes2-17.png" alt=""></li></ol><h2 id="动作模式的切换">动作模式的切换</h2><ol><li>在摇杆的左侧切换操作模式，第二个按钮是切换重定位和线性，第三个按钮切换轴1-3和轴4-6。面板右下角显示当前操作模式。<br><img src="https://img.mahaofei.com/img/202112231152614-robotstudio-notes2-18.png" alt=""></li><li>点击示教器右下角图标，可以看到机器人系统的详细信息，在这里同样可以对手动操纵菜单栏里所有的选项进行更改。<br><img src="https://img.mahaofei.com/img/202112231152848-robotstudio-notes2-19.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（一）软件的安装与初步测试</title>
      <link href="/post/f1b544b4.html"/>
      <url>/post/f1b544b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="RobotStudio-6-03-02-的安装">RobotStudio 6.03.02 的安装</h2><blockquote><p>链接：<a href="https://pan.baidu.com/s/1NyDTu_OCcPJLbfaQLtCHCw">https://pan.baidu.com/s/1NyDTu_OCcPJLbfaQLtCHCw</a><br>提取码：robo</p></blockquote><h3 id="1-安装注意事项">1. 安装注意事项</h3><p>（1）PC用户名为英文<br>（2）安装路径为英文<br>（3）安装过程全程联网</p><h3 id="2-安装方法">2. 安装方法</h3><p>（1）将安装包解压，运行安装包内的setup.exe程序，按照提示安装即可，比较简单。<br>（2）安装完成后双击<code>RobotStudio_5.61.02注册补丁.reg</code>。<br>（3）打开RobotStudio即可完成安装。</p><h2 id="初次测试">初次测试</h2><ol><li>打开RobotStudio软件，新建一个空工作站解决方案。<br><img src="https://img.mahaofei.com/img/202112231142274-robotstudio-notes1-1.png" alt=""></li><li>点击左上角ABB模型库，导入一个IRB 120确定<br><img src="https://img.mahaofei.com/img/202112231142220-robotstudio-notes1-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231142041-robotstudio-notes1-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231143834-robotstudio-notes1-4.png" alt=""></li><li>然后点击机器人系统-从布局创建系统，选择一个6.03的软件版本<br><img src="https://img.mahaofei.com/img/202112231143475-robotstudio-notes1-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231143090-robotstudio-notes1-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231143933-robotstudio-notes1-7.png" alt=""><br>点击选项，将其中的默认语言改为中文，点击完成即可，稍等一段时间等待系统创建完成。<br><img src="https://img.mahaofei.com/img/202112231144142-robotstudio-notes1-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231144741-robotstudio-notes1-9.png" alt=""></li><li>当下方控制器状态变成绿色的时候说明系统已经创建完成了。<br><img src="https://img.mahaofei.com/img/202112231144001-robotstudio-notes1-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231144900-robotstudio-notes1-11.png" alt=""></li><li>点击上方 控制器-示教器-虚拟示教器<br><img src="https://img.mahaofei.com/img/202112231145793-robotstudio-notes1-12.png" alt=""><br>在弹出的示教器窗口，打开控制面板切换为手动并使能。<br><img src="https://img.mahaofei.com/img/202112231145491-robotstudio-notes1-13.png" alt=""></li><li>在机器人视图内，Ctrl+左键为平移，Ctrl+Shift+左键为旋转，调整视图，使虚拟示教器和机器人能够同时看到。</li><li>点击菜单-程序编辑器，新建一个程序。<br><img src="https://img.mahaofei.com/img/202112231145202-robotstudio-notes1-14.png" alt=""><br>添加一条MoveJ指令<br><img src="https://img.mahaofei.com/img/202112231145407-robotstudio-notes1-15.png" alt=""><br>长按示教器右边的箭头，使机器人转动一个角度，然后在下方再添加一条MoveJ指令。（一定要看示教器上访的状态，保证机器人是手动控制模式、电机开启)<br><img src="https://img.mahaofei.com/img/202112231146603-robotstudio-notes1-16.png" alt=""><br>然后点击调试-PP移至Main，再点击右下方的运行按钮，即可看到机器人在起始位置和刚才转动的位置进行往复运动。<br><img src="https://img.mahaofei.com/img/202112231146967-robotstudio-notes1-17.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WordPress网站设计】小白网站设计流程（使用Elementor可视化编辑网站）</title>
      <link href="/post/ab6dd331.html"/>
      <url>/post/ab6dd331.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备工作-2">一、准备工作</h2><h3 id="1-安装Elementor插件">1. 安装Elementor插件</h3><p>进入wordpress后台，搜索插件Elementor进行安装。</p><blockquote><p>如果安装失败，可以在官网下载安装包，手动上传安装，安装方法参考<a href="https://blog.csdn.net/weixin_44543463/article/details/112839933">此篇文章</a><br>下载地址：<a href="https://cn.wordpress.org/plugins/elementor/">https://cn.wordpress.org/plugins/elementor/</a></p></blockquote><h3 id="2-安装主题">2. 安装主题</h3><p>这里以Astra主题为例，进入wordpress后台，搜索主题Astra进行安装。<br><img src="https://img.mahaofei.com/img/202112231129572-wordpress-elementor-2.png" alt=""></p><h3 id="3-安装辅助插件">3. 安装辅助插件</h3><p>根据不同主题的要求，可能需要安装不同的辅助插件，才能导入网站模板。Astra主题需要的插件是Starter Templates。<br><img src="https://img-blog.csdnimg.cn/20210125142716805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p><h2 id="二、导入模板">二、导入模板</h2><p>点击<strong>外观-Starter Templates</strong>，可以看到Astra的一些网站模板。在这里我们可以选择一个符合自己网站主题的模板（点击详情可以预览网页），导入到我们的网站中。<br><img src="https://img.mahaofei.com/img/202112231134720-wordpress-elementor-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231135722-wordpress-elementor-4.png" alt=""></p><h2 id="三、可视化编辑">三、可视化编辑</h2><h3 id="1-修改网站logo和标识">1. 修改网站logo和标识</h3><p>（1）进入自己的网站界面，点击上方的使用Elementor编辑，进入Elementor的编辑界面。<br><img src="https://img.mahaofei.com/img/202112231135491-wordpress-elementor-5.png" alt=""><br>（2)点击左上角进入<strong>站点设置-网站标识</strong>，可以修改网站的Logo和标识。<br><img src="https://img.mahaofei.com/img/202112231135732-wordpress-elementor-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231136081-wordpress-elementor-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231136994-wordpress-elementor-8.png" alt=""></p><h3 id="2-修改内容">2. 修改内容</h3><p>Elementor是模块化的编辑器，它将网站从上到下按不同段进行拼接，每个段内部分成一个或多个栏，可以填加不同的功能模块。<br>（1）修改文字：将鼠标放在要求改的文字上，单击可以直接修改，或者在左侧编辑菜单中修改。<br><img src="https://img.mahaofei.com/img/202112231136545-wordpress-elementor-9.png" alt=""><br>（2）更换图片：点击要修改的图片，可以看到左侧编辑菜单出现了相应的选项，此处可以更换图像，图像可以选择媒体库中已存在的图像，也可以上传图像。同时下方能够修改图像的尺寸和对齐方式。此外还可以在高级设置中进行更多的设置。<br><img src="https://img.mahaofei.com/img/202112231136332-wordpress-elementor-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231137596-wordpress-elementor-11.png" alt=""><br>（3)更改图标：还是点击要求改的图标，以Read More→的→为例，在左侧可以选择图标库中已经有的图标，也可以自己上传图标。<br><img src="https://img.mahaofei.com/img/202112231137045-wordpress-elementor-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231138675-wordpress-elementor-13.png" alt=""></p><h3 id="3-修改布局">3. 修改布局</h3><p>（1）点击段上方中间的按钮，在左侧可以更改此段的布局（边距、对齐）、结构（分栏数）等。<br><img src="https://img.mahaofei.com/img/202112231138481-wordpress-elementor-14.png" alt=""><br>（2）点击段内部各个栏的左上方的小窗子，可以修改内部各栏的布局。<br><img src="https://img.mahaofei.com/img/202112231138081-wordpress-elementor-15.png" alt=""><br>（3)修改段的位置，点击Elementor编辑菜单下方的导航器。可看到右侧出现了网站的大纲列表，直接拖动对应的段即可直接排序。<br><img src="https://img.mahaofei.com/img/202112231138476-wordpress-elementor-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231139125-wordpress-elementor-17.png" alt=""></p><h3 id="4-添加段">4. 添加段</h3><p>（1）翻到页面最下端或者点击某段上方的+，可以添加段<br><img src="https://img.mahaofei.com/img/202112231139207-wordpress-elementor-18.png" alt=""><br>（2）添加新段：选择分栏的方式数目，然后从左侧Elementor的编辑菜单直接拖动需要的功能模块至各栏即可。<br><img src="https://img.mahaofei.com/img/202112231140673-wordpress-elementor-19.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231140366-wordpress-elementor-20.png" alt=""><br>（3）使用Elementor的模板，这里可以在左上角选择模板的分类，比如我要添加About的相关模块。选好后直接插入即可。<br><img src="https://img.mahaofei.com/img/202112231140428-wordpress-elementor-21.png" alt=""><br>（4)有些主题也有自己内置的模块，添加方法类似。<br><img src="https://img.mahaofei.com/img/202112231140591-wordpress-elementor-22.png" alt=""></p><h2 id="四、修改网页导航">四、修改网页导航</h2><p>网页导航就是网站最上方的一排导航按钮，在wordpress后台的外观-菜单中可以修改。可以选择不同的页面添加到导航菜单中，也可以修改导航菜单的顺序，或者修改页面之间的从属关系，实现下拉菜单的效果。<br><img src="https://img.mahaofei.com/img/202112231141181-wordpress-elementor-23.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231141438-wordpress-elementor-24.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress学习笔记</title>
      <link href="/post/a1cd88a5.html"/>
      <url>/post/a1cd88a5.html</url>
      
        <content type="html"><![CDATA[<h1>一、文章操作</h1><h2 id="1-1-简述">1.1 简述</h2><h3 id="（1）网站的内容">（1）网站的内容</h3><p>对于一个网站来说，内容是最重要的一部分，用户之所以访问你的网站，也是因为你的内容。在WordPress中，内容主要分成两个部分：文章和页面。</p><ul><li>文章：用于发布网站的主要内容（如博客类网站，文章处发布博文）</li><li>页面：用于发布网站的其他内容（如博客类网站，页面处发布博主/网站信息）<br><img src="https://img.mahaofei.com/img/202112231122275-wordpress-notes1-1.png" alt=""></li></ul><h3 id="（2）网站的规划">（2）网站的规划</h3><p>（1）划分出网站的主要内容和其他内容<br>（2）对主要内容进行分门别类，划分出分类目录<br>（3）不需要事先划分标签</p><blockquote><p><strong>分类目录</strong>：对文章按内容进行分类<br><strong>标签</strong>：可以理解为是一种标记，通过给文章添加一个标记，如果需要查看带有某个标记的文章的时候，wordpress就能快速筛选出来。</p></blockquote><p><img src="https://img.mahaofei.com/img/202112231123221-wordpress-notes1-2.png" alt=""></p><h2 id="1-2-文章">1.2 文章</h2><ul><li>右边可以看到文章的发布信息、状态、分类目录、标签、特色图片等信息<br><img src="https://img.mahaofei.com/img/202112231123743-wordpress-notes1-3.png" alt=""></li><li>点击右上角显示选项可以看到更多信息，这里可以先把所有复选框都选上，后面一个一个看他们的作用。（我们的选项可能不一样，这是因为安装的插件不同导致的，这个不用在意）<br><img src="https://img.mahaofei.com/img/202112231123157-wordpress-notes1-4.png" alt=""></li></ul><ol><li><strong>标题</strong>：从上到下，第一个就是文章内容的标题，这里就不多说。</li><li><strong>添加媒体</strong>：可以上传图片等文件，插入进文章中光标所在位置</li><li><strong>文章摘要</strong>：在文章内容下面，可以看到文章摘要的填写框，文章摘要就是文章主要内容的概述，作用为在网站的文章列表中显示摘要，让用户快速的了解文章的主要内容，如果用户感兴趣的话可以进一步查看内容。</li><li><strong>发送Trackback</strong>：如果应用或借鉴了其他人的文章，可以在此处填写ulr通知对方，这个功能目前很少使用。</li><li><strong>自定义栏目</strong>：在正文内无法添加，需要添加更多的内容，可以在自定义栏目中实现。</li><li><strong>讨论</strong>：允许评论勾选则允许评论，不勾选则不允许用户评论</li><li><strong>评论</strong>：可以添加，或者管理评论</li><li><strong>别名</strong>：修改链接网址，使网址更符合搜索引擎的索引要求</li><li><strong>标签</strong>：可以给文章打上标记，将来如果想查看文章，只需要使用标签即可。</li><li><strong>特色图像</strong>：相当于文章的缩略图</li></ol><h1>二、插件安装</h1><p>插件可以实现为wordpress站点增加、修改、删除功能。<br>WordPress有许多安装插件的安装方法，可以在线安装，可以手动上传插件包，也可以直接配置文件视线插件的安装。</p><p><img src="https://img.mahaofei.com/img/202112231123056-wordpress-notes2-1.png" alt=""></p><ol><li>在线安装插件，可以在wordpress的特色、热门、推荐菜单中寻找插件，也可以搜索插件。找到合适的插件后点击安装即可。</li></ol><p><img src="https://img.mahaofei.com/img/202112231124432-wordpress-notes2-2.png" alt=""><br>2. 手动安装插件：当在线安装插件失败或者需要安装wordpress插件库中没有的插件时，从对应网站下载插件包，点击上传插件，选择手动下载下来的插件包即可。</p><p><img src="https://img.mahaofei.com/img/202112231124287-wordpress-notes2-3.png" alt=""></p><ol start="3"><li>解压安装插件：如果手动安装插件仍然出错而且无法解决时，可以将下载的zip压缩包解压，将整个文件夹放到wp-content/plugins/文件夹内</li></ol><h2 id="3-1-媒体库">3.1 媒体库</h2><p>媒体库是主要用来管理，你使用wordpress上传的附件的，比如图片、视频等其他文件。 点击左上角可以切换视图（列表/缩略图）</p><h3 id="（1）媒体文件的管理">（1）媒体文件的管理</h3><ol><li>编辑：可以修改图片的的标题，说明文字，替代文本。替代文本是当图片没有办法正常显示的时候，会用文本代替图片。</li><li>永久删除：在媒体库中删除媒体，已经在文章中添加过的不受影响</li><li>查看：以网页的形式查看图片<br><img src="https://img.mahaofei.com/img/202112231124625-wordpress-notes3-1.png" alt=""></li></ol><h3 id="（2）媒体文件添加">（2）媒体文件添加</h3><ol><li>在此处可以上传到上传文件最大允许尺寸为2M</li><li>常用的图片格式、文档格式、压缩格式都可以上传。可以利用这里上传文件供用户下载。<br><img src="https://img.mahaofei.com/img/202112231124661-wordpress-notes3-2.png" alt=""></li></ol><h2 id="3-2-评论管理">3.2 评论管理</h2><ol><li>列表从左到右依次是：评论的用户，评论内容，用户评论的文章，评论时间。</li><li>在评论内容处可以管理评论，具体操作有<br>（1）驳回/批准：wordpress默认设置用户发表评论，批准后才会在网页显示<br>（2）回复：就是回复用户的评论<br>（3）编辑：可以修改用户的评论<br>（4）垃圾评论和移至回收站操作后，评论都不会在网页中显示。<br><img src="https://img.mahaofei.com/img/202112231125996-wordpress-notes3-3.png" alt=""></li></ol><h2 id="3-3-用户管理">3.3 用户管理</h2><h3 id="（1）添加用户">（1）添加用户</h3><p>可以在此给网站添加用户，一般是不会手动添加用户的，手动添加用户一般只用来添加管理员，普通用户通常是会有注册渠道。<br>填写用户名，电子邮件，名字，姓氏，密码，选择用户角色后即可完成用户的添加。<br><img src="https://img.mahaofei.com/img/202112231125420-wordpress-notes3-4.png" alt=""></p><h3 id="（2）用户资料">（2）用户资料</h3><p>点击个人资料即可看到自己的资料<br><img src="https://img.mahaofei.com/img/202112231125017-wordpress-notes3-5.png" alt=""></p><ol><li>可视化编辑器<br>不使用可视化编辑器：<br><img src="https://img.mahaofei.com/img/202112231125549-wordpress-notes3-6.png" alt=""><br>使用可视化编辑器<br><img src="https://img.mahaofei.com/img/202112231126322-wordpress-notes3-7.png" alt=""></li><li>管理界面的配色：后台左侧和上侧的颜色</li><li>工具栏：在登录之后，打开自己的网站，会看到最上面有一条工具条。<br><img src="https://img.mahaofei.com/img/202112231126870-wordpress-notes3-8.png" alt=""></li><li>资料图片：需要到gravatar网站上注册账户，并设置头像。当在wordpress的网站中使用相同的邮件账户注册会员，那么wordpress就会根据邮件账户信息，从gravatar网站中获取头像</li></ol><h3 id="（3）管理用户">（3）管理用户</h3><p>在所有用户页面内可以管理此网站的所有用户<br>在这里插入图片描述<br><img src="https://img.mahaofei.com/img/202112231126221-wordpress-notes3-9.png" alt=""></p><h2 id="3-4-工具">3.4 工具</h2><h3 id="（1）快速发布">（1）快速发布</h3><p>将按钮拖动到收藏夹栏即可添加这个工具。再打开别人的网站时，点击快速发布按钮，可以将该网页的标题，内容，图片等copy下来形成一个文章。</p><h3 id="（2）直接链接">（2）直接链接</h3><p>类似快速发布，点击直接连接按钮，可以看到最上方有一栏可以输入url，找到想要剪辑的网页，将url复制到此栏即可生成一篇文章。</p><h3 id="（3）导入和导出">（3）导入和导出</h3><p>导入可以从其它博客平台等网站，将自己的文章和评论等导入到此网站。到处则是创建一个xml文件，保存网站的内容。</p><h2 id="3-5外观">3.5外观</h2><h3 id="（1）主题">（1）主题</h3><ol><li>主题的作用<br>更换不同的主题，网站的视觉效果会发生改变。用户看到的网站内容也会发生改变。站点的功能也会发生变化。</li><li>主题的安装方法<br>点击添加主题即可进入安装页面，可以在此页面安装主题<br>（1）在线安装：在wordpress的特色、热门、最新等栏目中选择主题，也可以搜索主题安装。安装后点击实时预览可以看到网站更换主题的效果。点击启用即可更换主题。<br><img src="https://img.mahaofei.com/img/202112231126493-wordpress-notes3-10.png" alt=""><br>（2）手动安装：将主题下载到本地，点击上传主题，选择下载好的主题zip文件，点击现在安装即可。<br><img src="https://img.mahaofei.com/img/202112231127787-wordpress-notes3-11.png" alt=""><br>（3)直接安装：直接将解压后的主题文件夹，放置在wp-content/themes/文件夹内。回到主提页面，刷新一下即可看到刚才安装的主题。</li><li>自定义主题<br>点击自定义按钮后，可以看到左侧是自定义的栏目（不同的主题栏目会不一样），右侧是实时效果预览<br><img src="https://img.mahaofei.com/img/202112231127605-wordpress-notes3-12.png" alt=""></li></ol><h3 id="（2）小工具">（2）小工具</h3><p>有的主题没有提供这个功能，有没有这个功能是由主题决定的。</p><ol><li>小工具右侧可以看到一些容器，修改这些容器可以更改网页的效果。</li><li>小工具左侧可用的选项，可以拖动到右面的容器中使用。<br><img src="https://img.mahaofei.com/img/202112231127711-wordpress-notes3-13.png" alt=""></li></ol><h2 id="3-6-设置">3.6 设置</h2><h3 id="（1）常规设置">（1）常规设置</h3><ol><li>站点标题：网站的名称</li><li>副标题：一般情况下，显示在网站的标题旁边</li><li>wordpress地址和站点地址一般使用默认</li><li>电子邮件地址：用于接收站点相关通知的邮</li><li>成员资格：网站是否允许其他人注册</li><li>新用户默认角色：考虑权限以及安全问题，订阅者权限即可。</li><li>ICP备案号：可以填写网站的备案号，是否会在网站显示取决于主题。<br><img src="https://img.mahaofei.com/img/202112231127549-wordpress-notes3-14.png" alt=""></li></ol><h3 id="（2）撰写设置">（2）撰写设置</h3><ol><li>默认文章分类：发布文章时没有勾选分类目录时，wordpress会自动将这篇文章放到此处设置的分类目录里面</li><li>更新服务：在更新服务里面填写的网址，当发布新的内容的时候，wordpress会自动通知此处的链接地址。（主要用于搜索优化）<br><img src="https://img.mahaofei.com/img/202112231128293-wordpress-notes3-15.png" alt=""></li></ol><h3 id="（3）阅读设置">（3）阅读设置</h3><ol><li>首页显示：默认显示最新文章，选择静态页面时可以设置站点首页为后台发布的某张页面</li><li>Feed中显示最近：用户订阅我们网站内容时，每页显示多少内容<br><img src="https://img.mahaofei.com/img/202112231128640-wordpress-notes3-16.png" alt=""></li></ol><h3 id="（4）讨论设置">（4）讨论设置</h3><p>尝试通知文章链接的博客：在发布文章时，如果文章内容发布链接时，如果勾选此选项，则会通知对方我们的链接指向了他们（一般不使用）。<br><img src="https://img.mahaofei.com/img/202112231128717-wordpress-notes3-17.png" alt=""></p><h3 id="（5）多媒体设置">（5）多媒体设置</h3><p>上传图片后，wordpress会自动在此图片基础上转换出不同像素大小的图片。</p><h3 id="（6）固定链接">（6）固定链接</h3><p>通过切换不同的链接结构，可以改变网页网址。更改的主要原因是为了搜索引擎检索的优化。一般使用文章名较好。<br><img src="https://img.mahaofei.com/img/202112231128743-wordpress-notes3-18.png" alt=""><br>自定义结构</p><table><thead><tr><th>代码</th><th>作用</th></tr></thead><tbody><tr><td>%post_id%</td><td>内容的编号</td></tr><tr><td>%postname%</td><td>内容的名称</td></tr><tr><td>%year%</td><td>发布的年份</td></tr><tr><td>%monthnum%</td><td>发布的月份</td></tr><tr><td>%day%</td><td>具体哪一天</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress后台加载慢的解决方法</title>
      <link href="/post/7755eae.html"/>
      <url>/post/7755eae.html</url>
      
        <content type="html"><![CDATA[<p>进入后台/在后台操作时，会发现页面加载很慢，原因之一是wordpress使用了google字体<br>解决方法：安装disable google fonts插件（2021.1亲测有效）<br>（查资料还有一个原因是用户头像无法正常加载，但是这个在最新版的wordpress中已经解决了）</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress上传文件报错的解决方法（413 Request Entity Too Large、超过upload_max_filesize文件中定义的php.ini值）</title>
      <link href="/post/3357eac0.html"/>
      <url>/post/3357eac0.html</url>
      
        <content type="html"><![CDATA[<h1>报错：413 Request Entity Too Large</h1><p>问题nginx是限制上传大小，解决方法如下:</p><ol><li><p>打开nginx配置文件 nginx.conf, 路径一般是：/etc/nginx/nginx.conf。</p></li><li><p>在http{}段中加入 client_max_body_size 64m; 64m为允许最大上传的大小。</p></li><li><p>保存后重启nginx，service nginx restart</p></li></ol><h1>报错：上传的文件尺寸超过upload_max_filesize文件中定义的php.ini值</h1><p>解决方法：修改/etc/php/7.3/apache2/php.ini文件中的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post_max_size = 64M</span><br><span class="line">upload_max_filesize = 64M</span><br></pre></td></tr></table></figure><p>（这两条都在比较靠后的位置，不太好找）</p><p><img src="https://img.mahaofei.com/img/202112231121053-wp-bugfix-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派搭建个人网站】花生壳内网穿透</title>
      <link href="/post/e8738dca.html"/>
      <url>/post/e8738dca.html</url>
      
        <content type="html"><![CDATA[<p>如果wordpress已经安装设置完成后，浏览器输入<code>localhost</code>或者 <code>树莓派的ip地址</code>，就可以访问到网站了，但是外网（不在一个路由器内）仍然无法访问，而内网穿透的目的就是使外网的计算机能够访问你的网站。为了减少配置的难度和复杂度，我使用了花生壳进行配置。<br>（虽然说是免费内网穿透，但是过程中是花费了6元）</p><h2 id="一、-安装花生壳">一、 安装花生壳</h2><ol><li>进入<a href="https://hsk.oray.com/download/">官网下载页面</a>，下载<strong>树莓派32位系统</strong>。</li><li>通过cd命令进入对应下载目录，输入下面的命令进行安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i phtunnel_5_0_rapi_armhf.deb</span><br></pre></td></tr></table></figure><ol start="3"><li>安装成功后，将显示此树莓派的SN码、默认密码以及远程管理地址。记住这里的SN码。<br><img src="https://img.mahaofei.com/img/202112231121334-raspberry-site3-1.png" alt=""></li></ol><h2 id="二、配置花生壳">二、配置花生壳</h2><ol><li>浏览器输入远程管理地址<a href="b.oray.com">b.oray.com</a>进入花生壳远程管理页面，输入安装花生壳时生成的SN码及默认密码admin进入。</li><li>首次登录，需要通过扫码或者密码进行激活操作，两种方法任选一种。</li><li>激活成功后，即可免费开通内网穿透。</li></ol><h2 id="三、配置内网穿透">三、配置内网穿透</h2><ol><li>点击控制台左侧的花生壳-账号列表，点击自己的账号名，即可进入内网穿透的配置页面</li><li>添加映射，映射类型选择http，这里就需要支付6元了。</li><li>其它配置按下图配置即可，域名只能选择固定的域名，外网端口只能选择动态端口，内网主机为树莓派的ip地址，端口一般是80。<br><img src="https://img.mahaofei.com/img/202112231121558-raspberrypi-site3-2.png" alt=""></li></ol><p>这样就已经实现外网访问自己用wordpress搭建的个人网站了。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派搭建个人网站】WordPress安装</title>
      <link href="/post/ed65ee52.html"/>
      <url>/post/ed65ee52.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、下载wordpress">一、下载wordpress</h2><p>在<a href="https://cn.wordpress.org/download/">wordpress官网</a>下载安装包，解压后把worpress文件夹内容放在html文件夹内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://cn.wordpress.org/latest-zh_CN.tar.gz</span><br><span class="line">tar -xzvf latest-zh_CN.tar.gz</span><br><span class="line"><span class="built_in">mv</span> wordpress/* /var/www/html/</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231118531-raspberrypi-site2-1.png" alt=""></p><h2 id="二、在phpmyadmin内新建一个数据库">二、在phpmyadmin内新建一个数据库</h2><ol><li>浏览器输入localhost/phpmyadmin进入phpmyadmin，输入自己的phpmyadmin用户名和密码</li><li>点击数据库栏，新建数据库，输入一个数据库的名字，点击创建即可，暂时不需要数据表<br><img src="https://img.mahaofei.com/img/202112231119643-raspberrypi-site2-2.png" alt=""></li><li>在地址栏输入localhost，即可进入wordpress，按下图进行wordpress的配置<br>(我是在wordpress官网下载的安装包，没有下载中文官网的，所以显示英文，不过内容一样，按网页提示填写网站的信息即可)。<br><img src="https://img.mahaofei.com/img/202112231119494-raspberrypi-site2-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231119388-raspberrypi-site2-4.png" alt=""></li><li>设置完成后，接下来就可以用刚刚设置的用户名和密码进行wordpress的登陆了<br><img src="https://img.mahaofei.com/img/202112231119135-raspberrypi-site2-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231120445-raspberrypi-site2-6.png" alt=""></li></ol><ul><li>ps.如果要从英文修改成中文，就在如果需要修改中文就在<a href="https://cn.wordpress.org/download/">https://cn.wordpress.org/download/</a>下载中文官网的安装包，解压后将<code>wordpress/wp_content</code>内的language文件夹复制到<code>/var/www/html/wpcontent</code>内即可</li></ul><h2 id="三、wordpress修改网站主题">三、wordpress修改网站主题</h2><p>点击左上角的网站title即可查看当前网站<br><img src="https://img.mahaofei.com/img/202112231120192-raspberrypi-site2-7.png" alt=""><br>如果想更改主题，可以点击左侧W标志，进入外观-主题菜单栏，选择主题安装。<br><strong>主机名填写树莓派的ip地址，用户名为pi，密码为raspberry</strong>，若出现下列要求FTP的对话框<br><img src="https://img.mahaofei.com/img/202112231120759-raspberrypi-site2-8.png" alt=""><br>则在命令栏输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br><span class="line">sudo passwd root<span class="comment">#自己设置一个root账户密码</span></span><br><span class="line">sudo passwd --unlock root</span><br><span class="line">su<span class="comment">#这里会提示输入刚才设置的密码</span></span><br><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"><span class="comment">#去掉write_enable=YES前面的#</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure><p>此时再重新安装主题即可成功安装。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派搭建个人网站】环境配置</title>
      <link href="/post/db9ee778.html"/>
      <url>/post/db9ee778.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建LAMP服务器">搭建LAMP服务器</h2><p><strong>即Linux+Apache+MySQL+PHP</strong></p><p><strong>1. 安装apache</strong><br>打开控制台，输入命令，确保软件安装是最新的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>安装apache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure><p>安装完成后给apache文件赋予权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R pi:www-data /var/www/html/</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 770 /var/www/html/</span><br></pre></td></tr></table></figure><p>在浏览器输入<code>127.0.0.1</code>可以看到apache的页面，说明apache已经顺利安装成功。<br><img src="https://img.mahaofei.com/img/202112231115154-raspberrypi-site1-1.png" alt=""><br><strong>2. 安装Nginx</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p><strong>2. 安装php及部分插件</strong><br>在控制台输入以下命令安装php7.3（2021年1月为7.3版本，安装最新版即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0</span><br></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0-fpm</span><br><span class="line">sudo apt-get install php7.0-mysql</span><br><span class="line">sudo apt-get install php7.0-common</span><br></pre></td></tr></table></figure><p><strong>3. 安装MySQL</strong><br>由于MySQL闭源了，我们安装mariadb.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br><span class="line">sudo apt-get install mariadb-client</span><br></pre></td></tr></table></figure><p><strong>4. 配置Nginx</strong><br>在控制台输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>找到其中的location，将location修改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">index index.html index.htm index.php default.html default.htm default.php</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~\.php<span class="variable">$&#123;</span></span><br><span class="line"><span class="variable">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>5. 重新启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx restart</span><br><span class="line">sudo /etc/init.d/php7.3-fpm restart</span><br><span class="line">sudo service mysql restart</span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><p><strong>6. 测试Nginx与PHP</strong><br>所有关于网站的东西都在var内，对其授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var/www</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var/www/html</span><br></pre></td></tr></table></figure><p>在/var/www/html中新建index.php文件，并输入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>PHP Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;?php echo &#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后删除/var/www/html文件夹内的index.html和index.nginx-debian.html两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /var/www/html/index.html</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /var/www/html/index.nginx-debian.html</span><br></pre></td></tr></table></figure><p>完成后，打开浏览器，输入树莓派的ip地址，或者localhost，即可看到网页Helloworld，说明以上步骤顺利完成了。<br><img src="https://img.mahaofei.com/img/202112231115939-raspberrypi-site1-2.png" alt=""></p><h2 id="创建数据库用户">创建数据库用户</h2><p>这一步需要安装PhpMyAdmin，并使用SQL语句添加mariaDB数据库用户。PHPMYADMIN是一个以PHP为基础，以Web-Base防止架构运行在网站主机上的MySQL的数据库管理工具，让管理者可以直接使用Web接口管理MySQL数据库。<br><strong>1.安装phpmyadmin</strong><br>使用以下命令进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure><p>安装过程中会遇到一些选项，按下图设置即可<br><img src="https://img.mahaofei.com/img/202112231116569-raspberrypi-site1-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231117712-raspberrypi-site1-4.png" alt=""><br>这里的密码要记住，一会登录phpmyadmin时要用到。<br><img src="https://img.mahaofei.com/img/202112231117624-raspberrypi-site1-5.png" alt=""><br><strong>2. 设置PHPMYADMIN软连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/phpmyadmin /var/www/html</span><br></pre></td></tr></table></figure><p><strong>3. 登录phpmyadmin</strong><br>在浏览器输入<code>localhost/phpmyadmin</code>进入登陆界面，初始用户名为<code>phpmyadmin</code>初始密码为之前安装过程中设置的密码。<br><img src="https://img.mahaofei.com/img/202112231117327-raspberrypi-site1-6.png" alt=""><br><strong>4. 使用SQL语句添加mariaDB数据库用户</strong><br>输入以下命令进入mariadb环境，这里没有密码，直接回车或者随便输入即可进入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure><p>在mariadb中添加用户并赋予权限<br>（1）添加用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;名字&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）赋予用户权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to 名字@localhost;</span><br></pre></td></tr></table></figure><p>（3）刷新权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>（4）退出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><p>再次打开浏览器进入phpmyadmin中（<code>localhost/phpmyadmin</code>），使用刚刚创建的用户登录。<br><img src="https://img.mahaofei.com/img/202112231118898-raspberrypi-site1-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231118685-raspberrypi-site1-8.png" alt=""><br>可以看到我们有了很高的权限（甚至可以删库[doge])<br>到此为止就基本完成了网站环境的搭建，之后就是使用wordpress等工具搭建个人网站了。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派系统的安装、初步配置与远程访问</title>
      <link href="/post/ed0c7859.html"/>
      <url>/post/ed0c7859.html</url>
      
        <content type="html"><![CDATA[<h5 id="一、准备TF卡">一、准备TF卡</h5><ol><li>将TF卡通过读卡器连接到电脑上。</li><li>如果原来使用过的话，用Diskgenius将TF卡内所有分区都删除，新建一个分区为FAT32格式，然后格式化当前分区。</li></ol><h5 id="二、镜像的下载和写入">二、镜像的下载和写入</h5><ol><li>进入RaspberryPi官网下载最新的<a href="https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit">系统镜像</a>。这里有三种版本，轻量版、标准版和完全版，大家可以根据需要下载，一般标准版就可以了。</li></ol><p><img src="https://img.mahaofei.com/img/202112231111825-raspberrypi-install-1.png" alt=""></p><p>如果大家觉得下载太慢，也可以使用一些方法从百度网盘下载，链接放在下面了。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1FhSZkqXggTO-spSZxLwLcQ">https://pan.baidu.com/s/1FhSZkqXggTO-spSZxLwLcQ</a><br>提取码：qhcm</p></blockquote><ol><li>使用Win32Diskimager安装镜像。镜像安装完成后可能会弹出格式化的对话框，一定不要格式化，否则相当于前功尽弃。</li></ol><p>（ps：使用过程中可能会报错，因为可能打开了TF卡的某个文件夹，不用理会直接确认即可。）</p><p><img src="https://img.mahaofei.com/img/202112231112696-raspberrypi-install-2.png" alt=""><br>3. 打开SSH服务：在制作好的boot分区内，新建一个文件名为ssh，无任何后缀的文件。（可以在文件资源管理器上方点击查看选项卡，选择显示扩展名）</p><h5 id="三、IP地址的确定和访问">三、IP地址的确定和访问</h5><p>以下操作需要【屏幕+外接键盘】或者【一根网线】，二者选一个即可。使用前者的在需要的时候将屏幕和键盘连接至树莓派即可，使用后者的需要将路由器或者电脑通过网线连接至树莓派。</p><p><strong>使用网线的：</strong></p><ol><li>将之前制作好的TF卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</li><li>开机，等待一段时间后进入系统，如果有显示器可以看到进入系统的界面，没有显示器的直接进行下一步即可。</li><li>使用Advanced scanner搜索此局域网内的树莓派的IP地址。</li></ol><p><img src="https://img.mahaofei.com/img/202112231112675-raspberrypi-install-4.png" alt=""></p><ol start="4"><li>使用PuTTy软件，默认SSH连接方式，输入IP地址，进入系统后如果出现login，则说明连接成功，用户名为pi，密码为raspberry，则可以成功进入系统。如果PuTTy连接超时，则说明IP地址有问题或者树莓派没有连接到网络。</li></ol><p><img src="https://img.mahaofei.com/img/202112231112880-raspberrypi-install-5.png" alt=""></p><ol start="5"><li>设置wifi</li></ol><p>(1)命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>(2)内容改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">ssid=<span class="string">&quot;这里写wifi名称&quot;</span></span><br><span class="line">psk=<span class="string">&quot;这里写密码&quot;</span></span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210103164816336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><p>其中priority是连接优先级，数字越大，优先级越高。</p><p>(3)保存后reboot重启，没有问题的话就可以连接上WiFi了，如果出现no wireless interfaces found，那么一定要检查上面这个文件/etc/wpa_supplicant/wpa_supplicant.conf的内容，key_mgmt和priority两行是可以不写的，所有拼写都不能错。（本人就曾因为把ssid打成ssod导致连接不上wifi排查了好久）</p><ol><li>查看IP地址，使用Advanced scanner搜索，或者用更简单的方法，在命令行里输入<code>raspberrypi.local</code>即可查看树莓派的地址，再使用PuTTy访问即可。<br><strong>使用外接屏幕键盘数表的</strong>（这些设备只使用一次就够了）</li><li>将之前制作好的TF卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</li><li>开机，等待一段时间后进入系统，如果有显示器可以看到进入系统的界面，按照提示进行初始化设置，提示需要大量更新的时候跳过即可，后续换源后再手动更新。</li></ol><h5 id="四、数据源的更新和配置">四、数据源的更新和配置</h5><p>如果使用默认的源，下载速度可能会很慢，因此推荐换成国内的源，这里以清华源为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">打开sources.list文件</span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">注释里面的所有内容，输入以下地址</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">（ctrl+o回车保存，ctrl+x退出编辑器）</span><br><span class="line"></span><br><span class="line">打开raspi.list文件</span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">注释里面的所有内容，输入以下地址</span><br><span class="line">deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line">deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line"></span><br><span class="line">更新源</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h5 id="五、windowns远程访问的实现">五、windowns远程访问的实现</h5><ol><li>在PuTTy命令行窗口输入<code>sudo raspi-config</code>，选中进入Interfacing Options，选中VNC选项，回车，选择Enable，即可打开VNC。</li><li>下载安装<a href="https://www.realvnc.com/en/connect/download/viewer/windows/">VNC软件</a></li></ol><p><img src="https://img.mahaofei.com/img/202112231113661-raspberrypi-install-6.png" alt=""></p><p>注意：如果出现cannot currently show the desktop，则需要在刚才的位置修改分辨率，在PuTTy中输入<code>sudo raspi-config</code>，选中进入Advanced Options-Resolutions，选择除了第一个default的任意一个，保存重启后，再打开VNC即可。</p><ol start="3"><li>即可进入图形界面。至此，初步完成了系统的安装。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（十）：条件结构</title>
      <link href="/post/71a94f2b.html"/>
      <url>/post/71a94f2b.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="条件结构">条件结构</h2><ol><li>条件结构类似C语言中的if…else…和switch结构，主要用于分支选择程序逻辑。</li><li>条件结构包括两个及以上子程序框图或分支。每次仅执行一个条件分支</li><li>右键单击条件结构边框添加、复制、删除、重排及选择默认分支。</li></ol><h2 id="输入和输出隧道">输入和输出隧道</h2><ol><li>可创建多个输入/输出隧道</li><li>输入数据可供全部条件分支使用</li><li>必须为每个条件分支定义各自的输出隧道</li><li>默认分支选择器是布尔型的，当为真的时候，执行真框图内的内容，当为假的时候执行假框图内的内容。同时分支选择器也可以是数组、枚举等控件输入。</li></ol><h2 id="实验">实验</h2><p><strong>任务要求</strong></p><ol><li>产生频率、波形类型均可设置的信号</li><li>已足够的采样率产生和显示波形，并生成采样率可调的波形，并进行比较</li><li>显示波形和信号频谱</li></ol><p><strong>实现过程</strong></p><ol><li>信号的产生和显示是一个连续的过程，所以考虑使用循环。</li><li>由于信号的波形类型是可以设置的，所以在前面板中插入一个枚举型变量用于进行设置，对于枚举型变量采用不同的值，要产生不同的波形，因此使用条件结构进行判断。<br><img src="https://img.mahaofei.com/img/202112231107751-labview-notes10-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231108679-labview-notes10-2.png" alt=""></li><li>首先对第一种波形（正弦波）进行设置，程序框图中添加一个正弦波形生成控件。<br>（1）设置波形：在前面板插入一个旋钮用于调节频率，回到程序框图将其连到正弦波形生成控件的频率接口上。<br><img src="https://img.mahaofei.com/img/202112231108399-labview-notes10-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231108041-labview-notes10-4.png" alt=""><br>（2)设置采样信息：在对应接口处添加常量，增大采样率，产生采样率足够大的正弦信号。<br><img src="https://img.mahaofei.com/img/202112231108259-labview-notes10-5.png" alt=""></li><li>产生采样信号 添加一个正弦波形生成控件用于产生采样信号，在前面板添加一个文本下拉列表控件用于设置采样率（数据类型为DBL，采样率如下图），利用捆绑，将采样率和采样点数捆绑后传递给正弦波形生成控件的采样信息接口。其它接口与上面正弦波形的部分一致。<br><img src="https://img.mahaofei.com/img/202112231109348-labview-notes10-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231109263-labview-notes10-7.png" alt=""></li><li>显示信号：因涉及到两个信号的显示，因此使用创建数组，将两个信号合成为数组传递到波形图中。<br><img src="https://img.mahaofei.com/img/202112231109353-labview-notes10-8.png" alt=""></li><li>信号测量：添加一个FFT功率谱和PSD（在信号处理-波形测量中）。将采样信号连接至时间信号接口，平均参数接口创建一个常量并选择RMS平均方式。然后在前面板添加一个波形图控件用于显示频谱图。<br><img src="https://img.mahaofei.com/img/202112231109525-labview-notes10-9.png" alt=""></li><li>配置其他波形：先在条件结构中删除方波分支，然后选择复制正弦波分支，并将条件结构内的正弦波形生成控件替换为方波生成控件。（其他波形也是类似的操作流程）<br><img src="https://img.mahaofei.com/img/202112231110894-labview-notes10-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231110577-labview-notes10-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231110944-labview-notes10-12.png" alt=""></li><li>添加停止按钮，修改波形图的横坐标显示范围，最后修饰一下界面，程序就成功完成了<br><img src="https://img.mahaofei.com/img/202112231110027-labview-notes10-13.png" alt=""><br>采样率足够高时，波形信号与采样率几乎重合。<br><img src="https://img.mahaofei.com/img/202112231110120-labview-notes10-14.png" alt=""><br>采样率较低时，会出现明显的失真<br><img src="https://img.mahaofei.com/img/202112231111768-labview-notes10-15.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（九）：数组与簇</title>
      <link href="/post/2d7ac11f.html"/>
      <url>/post/2d7ac11f.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h3 id="数组">数组</h3><ol><li>数组：处理一系列相似的数据和执行重复计算操作时，可考虑使用数组。数据将相同类型的数据元素归为一组。</li><li>创建方法：在前面板放置一个数组的外框，拖放一个数据对象或元素至外框内即可创建数组。</li><li>数组组成：<br>（1） 元素：组成数组的数据<br>（2）b. 维度：数组的长度、高度、深度 （数组可以是一维或多维的，内存允许的情况下，每一维度可有多达(2^31)-1个元素）</li><li>数组初始化<br>（1）直接在前面板输入元素进行初始化。<br>（2）利用循环，如for循环索引输出的是一个数组<br>（3）c. 数组的初始化函数<br>（注：未初始化的元素只具有维数，不包含任何元素）</li><li>数组函数：包括数组大小、索引数组、创建数组、数组最大值最小值、排序、拆分数组等操作均可以通过数组函数实现。<br><img src="https://img.mahaofei.com/img/202112231106676-labview-notes9-1.png" alt=""></li></ol><h3 id="簇">簇</h3><ol><li>簇与数组：簇将不同类型数据元素归为一组，簇不同于数组的地方在于簇的大小是固定的，簇可以包含不同的数据类型，数组仅可包含一种数据类型。</li><li>簇的创建方法<br>（1）在前面板上放置一个簇的外框<br>（2）推拽数据对象或元素至簇的外框内，拖拽对象可分为数值、布尔值、字符串、路径、引用句柄、数组、簇输入控件和簇显示控件</li><li>簇的顺序：簇元素的逻辑顺序与其在簇内的位置无关，右键单击簇外框，从快捷菜单中选择重新排序簇中控件<br><img src="https://img.mahaofei.com/img/202112231107285-labview-notes9-2.png" alt=""></li><li>簇函数：簇函数中最重要的就是构造打包生成簇的捆绑函数和从簇中解包提取簇中元素的接触捆绑函数<br><img src="https://img.mahaofei.com/img/202112231107463-labview-notes9-3.png" alt=""></li><li>错误簇：<br>（1）可以控制控件执行的先后顺序<br>（2）也可以通过错误簇控制循环的终止</li><li>波形簇的簇元素<br>（1）t0：时间戳<br>（2）dt：Y数据的时间间隔<br>（3）Y：随时间变化的一组数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（八）：属性节点</title>
      <link href="/post/d8947a19.html"/>
      <url>/post/d8947a19.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="一、属性节点的介绍">一、属性节点的介绍</h2><ol><li>属性节点：可用于访问对象的属性。当某些应用中可能需要通过编程改变前面板对象外观，以响应特定输入时，通过编辑属性节点进行设置。</li><li>创建方法：在程序框图的控件上右键，创建属性节点。需要设置多个属性时可以在边框上下拖动添加属性，属性节点按照由上而下的顺序执行。</li><li>严格属性节点：右键控件创建属性节点的方法为隐含属性节点；通过控件引用创建严格属性节点（右键创建属性节点，控件右键创建引用，二者相连即可创建严格属性节点）。在多个VI涉及同一个控件的属性时，会使用严格属性节点传递。</li></ol><h2 id="二、实验">二、实验</h2><ol><li>任务要求：通过滑动杆对波形图任意一段进行显示。<br><img src="https://img.mahaofei.com/img/202112231105333-labview-notes8-1.png" alt=""></li><li>实现过程：<br>（1）用for循环产生1000个随机数，通过波形图将1000个点显示出来<br><img src="https://img.mahaofei.com/img/202112231105730-labview-notes8-2.png" alt=""><br>（2）在前面板添加一个水平滑动杆作为拖动的滚动条。<br><img src="https://img.mahaofei.com/img/202112231105264-labview-notes8-3.png" alt=""><br>（3）因需要实时调整波形图，所以用一个while循环，在while循环中创建属性节点（波形图的最大值和最小值），并将其转换为写入。将滑动杆的输出连接至波形图最小值，滑动杆的输出+100连接至波形图最大值。<br><img src="https://img.mahaofei.com/img/202112231105825-labview-notes8-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231105330-labview-notes8-5.png" alt=""><br>（4）设置滑动杆的属性（最大值和最小值）为0和900，初始值为0。<br><img src="https://img.mahaofei.com/img/202112231106970-labview-notes8-6.png" alt=""><br>（5）连接错误簇确定程序执行顺序。<br><img src="https://img.mahaofei.com/img/202112231106405-labview-notes8-7.png" alt=""><br>（6)程序设计完成</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（七）：变量与移位寄存器</title>
      <link href="/post/20f87532.html"/>
      <url>/post/20f87532.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="变量">变量</h2><ol><li>变量的作用：在并行循环间传递数据</li><li>变量类型</li></ol><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>局部变量</td><td>将数据存储在前面板输入控件和显示控件中</td></tr><tr><td>全局变量</td><td>将数据存储在多个VI可访问的特殊数据库中</td></tr><tr><td>功能全局变量</td><td>将数据存储在While循环移位寄存器中</td></tr><tr><td>共享变量</td><td>在通过网络连接的分布式任务间传递数据</td></tr></tbody></table><ol start="3"><li>布尔控件的局部变量</li></ol><ul><li>具有关联局部变量的布尔控件必须使用开关机械动作</li><li>布尔触发动作与局部变量不兼容</li></ul><h2 id="移位寄存器">移位寄存器</h2><ol><li>应用：移位寄存器可以将前一循环产生的数据传递至下一循环</li><li>添加方法：右键单击循环边框，添加移位寄存器</li><li>右侧的移位寄存器存储每次循环结束后的数据，左侧的移位寄存器为下一循环提供所存储的数据</li><li>移位寄存器的初始化</li></ol><table><thead><tr><th>初始化</th><th>程序执行结果</th></tr></thead><tbody><tr><td>初始化的移位寄存器</td><td>无论程序运行多少次结果都一样</td></tr><tr><td>未初始化的移位寄存器</td><td>输入为上一次程序运行的结果，因此输出结果会随着程序运行次数而改变</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（六）：while循环与for循环</title>
      <link href="/post/f5eddc6a.html"/>
      <url>/post/f5eddc6a.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="while循环（图片循环播放程序）">while循环（图片循环播放程序）</h2><p>实验：完成三张图片的循环放映</p><ol><li>插入一个图片下拉列表，并导入n张图片<br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223110219783.png" alt="image-20211223110219783"><br><img src="https://img.mahaofei.com/img/202112231102463-labview-notes6-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231102640-labview-notes6-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231103974-labview-notes6-4.png" alt=""></li><li>打开程序框图，利用While循环实现图片的循环播放，首先将图片下拉列表转换为显示控件<br><img src="https://img.mahaofei.com/img/202112231103789-labview-notes6-5.png" alt=""></li><li>创建一个While循环<br><img src="https://img.mahaofei.com/img/202112231103002-labview-notes6-6.png" alt=""></li><li>因下拉图片列表中各个图片的值为0，1，2……n，利用循环次数与n的余数作为图片的选择依据（n为图片个数），插入数值中的商与余树控件并连线<br><img src="https://img.mahaofei.com/img/202112231103372-labview-notes6-7.png" alt=""><br>在我的程序中图片数是3所以除数为3</li><li>创建停止条件<br><img src="https://img.mahaofei.com/img/202112231103976-labview-notes6-8.png" alt=""></li><li>回到前面板中添加一个旋钮，用于调整图片切换速度<br><img src="https://img.mahaofei.com/img/202112231104493-labview-notes6-9.png" alt=""></li><li>在while循环中插入一个等待时间，等待时间的输入端以毫秒作为单位，同时考虑旋钮越大图片切换速度应该越快，因此将旋钮的数值取倒数再乘1000作为while循环的等待时间<br><img src="https://img.mahaofei.com/img/202112231104454-labview-notes6-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231104777-labview-notes6-11.png" alt=""></li><li>运行程序，即可观察到图片循环播放，拖动旋钮可以看到图片切换速度也会随之变化。</li></ol><h2 id="for循环">for循环</h2><ol><li>for循环的创建</li></ol><ul><li>创建for循环的方法和while循环类似</li><li>可以右键单击while循环的边框，在右键菜单中将while循环转换为for循环</li></ul><ol start="2"><li>for循环的接线端</li></ol><ul><li>N为循环次数，循环次数必须指定为非负整数（如果将双精度浮点数值连接至总线接线端，LabView将把较长的数值转换为32位有符号整数）</li><li>为了避免强制转换，以增强程序性能，选择匹配的数据类型，或者通过编程进行数据类型的转换</li></ul><ol start="3"><li>与while循环的区别</li></ol><ul><li>while循环至少执行一次，for循环可以执行0次</li><li>while循环自动输出最后一次执行的值，for循环自动输出一个数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（五）：数据类型综合实验</title>
      <link href="/post/3bed1cad.html"/>
      <url>/post/3bed1cad.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="任务要求">任务要求</h2><ol><li>输出正弦波信号，频率0-50M</li><li>采样率10M、50M、100M可选</li><li>检测信号频率</li><li>输出采样信号的功率谱，如果频率或采样率发生变化，重新开始平均过程</li></ol><h2 id="实现过程">实现过程</h2><ol><li>在程序框图中创建基本函数发生器，按下Ctrl+H查看即时帮助中的接口说明<br><img src="https://img.mahaofei.com/img/202112231056843-labview-notes5-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231056869-labview-notes5-2.png" alt=""></li><li>按照任务要求配置各个接口，首先在信号类型处右键，创建常量（正弦波）<br><img src="https://img.mahaofei.com/img/202112231057916-labview-notes5-3.png" alt=""></li><li>在频率、采样信息处右键创建输入控件<br><img src="https://img.mahaofei.com/img/202112231057344-labview-notes5-4.png" alt=""></li><li>添加两个波形测量的Express VI，分别是提取单频信息、FFT功率谱和PSD<br><img src="https://img.mahaofei.com/img/202112231057877-labview-notes5-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231057962-labview-notes5-6.png" alt=""></li><li>在 提取单频信息 的Express VI的<strong>检测到的功率</strong>的接口，FFT功率谱和PSD 的Express VI<strong>功率谱/PSD</strong>接口创建显示控件<br><img src="https://img.mahaofei.com/img/202112231058600-labview-notes5-7.png" alt=""></li><li>在FFT功率谱和PSD的Express VI的<strong>显示为DB</strong>接口创建常量并设置为<strong>True</strong><br><img src="https://img.mahaofei.com/img/202112231058453-labview-notes5-8.png" alt=""></li><li>在FFT功率谱和PSD的Express VI的<strong>平均参数</strong>接口创建常量并设置为<strong>RMS均方根平均方式</strong><br><img src="https://img.mahaofei.com/img/202112231058660-labview-notes5-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231058145-labview-notes5-10.png" alt=""></li><li>因需要重新开始平均所以在<strong>重新开始平均</strong>接口处创建常量并选择为<strong>真</strong><br><img src="https://img.mahaofei.com/img/202112231059510-labview-notes5-11.png" alt=""></li><li>切换回前面板，将功率谱的显示方式替换为波形图，并将频率的显示方式替换为旋钮<br><img src="https://img.mahaofei.com/img/202112231059800-labview-notes5-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231059373-labview-notes5-13.png" alt=""></li><li>修改旋钮周围的刻度<br><img src="https://img.mahaofei.com/img/202112231059667-labview-notes5-14.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231100465-labview-notes5-15.png" alt=""></li><li>将采样信息替换为文本下拉列表，然后右键-编辑项，修改下拉列表的菜单，并设置默认值为50M<br><img src="https://img.mahaofei.com/img/202112231100878-labview-notes5-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231100461-labview-notes5-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231101223-labview-notes5-18.png" alt=""></li><li>修改检测到的频率的显示格式<br><img src="https://img.mahaofei.com/img/202112231101135-labview-notes5-19.png" alt=""></li><li>进行简单外观修饰后运行程序<br><img src="https://img.mahaofei.com/img/202112231101949-labview-notes5-20.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（四）：动态数据类型</title>
      <link href="/post/8038e45b.html"/>
      <url>/post/8038e45b.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="动态数据类型介绍">动态数据类型介绍</h2><ol><li>在LabView中，动态数据类型表示为深蓝色</li><li>只有Express VI才能产生和接收ExpressVI （如要使用内置VI或函数处理动态数据类型，必须先进行数据类型转换，连线时一般会自动转换动态数据）</li><li>动态数据类型转换</li></ol><ul><li>从动态数据类型转换：在程序框图上放置“从动态数据转换”Express VI，配置转换的数据类型</li><li>转换至动态数据：在程序框图上放置“转换至动态数据”ExpressVI</li></ul><ol start="4"><li>获取和设置动态数据</li></ol><ul><li>使用获取动态数据ExpressVI获取动态数据的属性</li><li>使用设置动态数据属性ExpressVI设置动态数据的属性，如信号名、时间标识、时间模式等</li></ul><h2 id="实验：波形显示和数据获取">实验：波形显示和数据获取</h2><ol><li>主要目的：模拟信号输入，在波形图上显示波形，获取采样数据，采样时间和信号名称</li><li>实验过程<br>（1）添加并配置仿真信号<br><img src="https://img.mahaofei.com/img/202112231053478-labview-notes4-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231053836-labview-notes4-2.png" alt=""><br>（2）创建图形显示控件（示波器），用来显示输出波形<br><img src="https://img.mahaofei.com/img/202112231053597-labview-notes4-3.png" alt=""><br>（3）获得信号数据，并进行显示<br><img src="https://img.mahaofei.com/img/202112231054721-labview-notes4-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231054013-labview-notes4-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231054727-labview-notes4-6.png" alt=""><br>（4）获得信号属性并显示<br><img src="https://img.mahaofei.com/img/202112231055401-labview-notes4-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231055694-labview-notes4-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231055409-labview-notes4-9.png" alt=""><br>（5)运行程序查看结果<br><img src="https://img.mahaofei.com/img/202112231056441-labview-notes4-10.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（三）：基本控件</title>
      <link href="/post/2641b5ca.html"/>
      <url>/post/2641b5ca.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="1-数值型控件">1. 数值型控件</h2><ul><li>数值型控件可表示不同类型的数值</li><li>程序框图或前面板中，右键单击输入控件、显示控件或常量，从快捷菜单中选择表示法，可以改变数值型数据的表示法<br><img src="https://img.mahaofei.com/img/202112231050733-labview-notes3-1.png" alt=""></li></ul><h2 id="2-布尔型控件">2. 布尔型控件</h2><ul><li>布尔型控件最关键的就是机械动作的选择。</li></ul><table><thead><tr><th>机械动作</th><th>作用</th></tr></thead><tbody><tr><td>单击时转换</td><td>按下按钮时改变状态。保持改状态直至其他按钮按下</td></tr><tr><td>释放时转换</td><td>释放按钮时改变状态。释放其他按钮之前保持当前状态</td></tr><tr><td>保持转换直到释放</td><td>按下按钮时改变状态。松开按钮后恢复原来的状态</td></tr><tr><td>单击时触发</td><td>按下按钮时改变状态。LabView读取控件值后恢复原来的状态</td></tr><tr><td>释放时触发</td><td>释放按钮时改变状态。LabView读取控件值后返回原状态</td></tr><tr><td>保持触发直到释放</td><td>按下按钮时改变状态。松开按钮且LabView读取控件值后恢复原来的状态</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/202112231050980-labview-notes3-2.png" alt=""></p><h2 id="3-字符型控件">3. 字符型控件</h2><ul><li>可以通过快捷菜单更改显示类型：正常显示、''显示、密码显示、十六进制显示</li><li>在LabView中字符串颜色为粉红色</li><li>字符串的数据/控件可以通过数值/字符串转换函数实现字符串与各种类型数值数据之间的转换，字符串数据也可以与路径、数组之间进行转换</li><li>字符串型控件可以通过函数面板的连接字符串以及制表符、回车/换行符将多个字符串数据转换成指定格式的字符串，用于报表的制作<br><img src="https://img.mahaofei.com/img/202112231051354-labview-notes3-3.png" alt=""></li></ul><h2 id="4-枚举和下拉控件">4. 枚举和下拉控件</h2><ul><li>下拉列表：右键单击下拉列表控件，并从快捷菜单中选择编辑项，或者在属性对话框中点击编辑项的选项卡，即可向控件的下拉列表中添加内容，并更改项的顺序<br><img src="https://img.mahaofei.com/img/202112231051221-labview-notes3-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231052453-labview-notes3-5.png" alt=""></li><li>枚举型控件：将枚举型控件连接至条件结构的选择器接线端时，LabView将控件中的字符串与分支条件相比较，而不是控件的数值<br><img src="https://img.mahaofei.com/img/202112231052099-labview-notes3-6.png" alt=""></li><li>如果数据过大时，枚举类型可以较好的显示，而下拉列表有时需要更改数据类型以实现存储较大数据。<br><img src="https://img.mahaofei.com/img/202112231052110-labview-notes3-7.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（二）：滤波器实验</title>
      <link href="/post/7442f1dd.html"/>
      <url>/post/7442f1dd.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h3 id="滤波器实验">滤波器实验</h3><p><strong>1. 主要目的</strong>：学习VI的创建方法<br><strong>2. 操作步骤</strong>：<br>（1）放置Express VI至程序框图<br>（2）配置弹出的对话框<br>（3）连线Express VI<br>（4）保存并运行VI<br><strong>3. 实验过程</strong><br>（1）添加正弦仿真信号，并对正弦信号进行配置，设置频率为100Hz<br><img src="https://img.mahaofei.com/img/202112231047458-labview-notes2-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231048500-labview-notes2-2.png" alt=""><br>（2）添加滤波器，设置截止频率为100Hz，频率低于100Hz就可以进行波形显示<br><img src="https://img.mahaofei.com/img/202112231048435-labview-notes2-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231048260-labview-notes2-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231048631-labview-notes2-5.png" alt=""><br>（3）将正弦信号和滤波后的信号进行合并<br><img src="https://img.mahaofei.com/img/202112231049922-labview-notes2-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231049124-labview-notes2-7.png" alt=""><br>（4）添加图形显示控件<br><img src="https://img.mahaofei.com/img/202112231049374-labview-notes2-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231049966-labview-notes2-9.png" alt=""><br>（5）双击生成的图形显示控件，进入前面板，运行程序<br><img src="https://img.mahaofei.com/img/202112231050285-labview-notes2-10.png" alt=""><br>（6)可以尝试修改正弦信号源和滤波器的配置，观察曲线变化</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（一）：基础介绍</title>
      <link href="/post/840cf816.html"/>
      <url>/post/840cf816.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h1>一、前面板</h1><h2 id="1-控件选板">1. 控件选板</h2><p>（1） 控件来源于控件选板，右键可以打开控件选板，控件可以点击后添加到前面板，也可以通过拖拽添加控件。<br><img src="https://img.mahaofei.com/img/202112231047048-labview-notes1-1.png" alt=""><br>（2) 分类</p><ul><li>数值控件：输入和显示数值数据</li><li>布尔控件：创建按钮、开关和指示灯</li><li>路径控件：输入或返回文件或目录的地址</li><li>数组、矩阵、簇控件：创建数组、矩阵、簇</li><li>列表框、树形和表格等控件：提供选项列表</li><li>图形控件：图形和图表的形式绘制数值数据</li><li>枚举控件：提供一个可供选择的项列表</li><li>容器控件：用于组合各种控件</li></ul><h2 id="2-工具选板">2. 工具选板</h2><p><img src="https://img.mahaofei.com/img/202112231047795-labview-notes1-2.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220410101018.png" alt=""></p><h1>二、程序框图</h1><h2 id="1-组成">1. 组成</h2><p>接线端（前面板）、子VI、函数、常量、结构、连线</p><h2 id="2-函数选板">2. 函数选板</h2><p>依然是右键打开</p><h2 id="3-程序框图">3. 程序框图</h2><p>（1） 接线端：包括前面板对象程序框图外观，可以右键不选显示为图标，使程序框图界面更简洁。<br>（2） 节点：带有输入和输出端，是用来进行运算的，比如函数节点、子VI节点（双击即可查看子VI的前面板和程序框图，ExpressVI是特殊的子VI所需连线数量最少，通过对话框配置）。<br>（3） 连线</p><ul><li>程序框图对象之间通过连线传输数据</li><li>不同数据类型的连线颜色、粗细和样式均有差异</li><li>断开的连线显示为中间带有红叉的黑色虚线</li><li>按下Ctrl+B删除所有断线</li><li>右键连线可以整理连线</li><li>框选程序框图的一部分，使用整理程序框图可以使程序框图更易读</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView2018的安装</title>
      <link href="/post/9b2c6c92.html"/>
      <url>/post/9b2c6c92.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>百度网盘链接：<a href="https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA">https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA</a><br>提取码：labv</p></blockquote><p>安装前请新建一个文件夹作为labview的安装路径，最好不要安装在盘符根目录下。</p><ol><li>下载LabView2018安装包解压，运行安装程序。</li></ol><p><img src="https://img.mahaofei.com/img/202112231042371-labview2018-1.png" alt=""></p><ol start="2"><li>选择安装程序的解压路径，点击Unzip</li></ol><p><img src="https://img.mahaofei.com/img/202112231043655-labview2018-2.png" alt=""></p><ol start="3"><li>开始安装，点击下一步</li></ol><p><img src="https://img.mahaofei.com/img/202112231043950-labview2018-3.png" alt=""></p><ol start="4"><li>输入用户信息，可以随意输入</li></ol><p><img src="https://img.mahaofei.com/img/202112231043887-labview2018-4.png" alt=""></p><ol start="5"><li>不用输入序列号，直接跳过，点击下一步</li></ol><p><img src="https://img.mahaofei.com/img/202112231043425-labview2018-5.png" alt=""></p><ol start="6"><li>选择安装目录，点击下一步</li></ol><p><img src="https://img.mahaofei.com/img/202112231044650-labview2018-6.png" alt=""></p><ol start="7"><li>选择需要安装的组件，一般情况默认下一步即可</li></ol><p><img src="https://img.mahaofei.com/img/202112231044511-labview2018-7.png" alt=""></p><ol start="8"><li>接受许可，一直下一步即可</li></ol><p><img src="https://img.mahaofei.com/img/202112231044061-labview2018-8.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231045566-labview2018-9.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231045211-labview2018-10.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231045881-labview2018-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231045928-labview2018-12.png" alt=""></p><p>如果出现需要安装支持，如果不用NI的采集卡，是不需要安装这个驱动的，直接点击不需要支持就可以，如果后续需要驱动的话可以另行安装。</p><p><img src="https://img.mahaofei.com/img/202112231046513-labview2018-13.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231046586-labview2018-14.png" alt=""></p><ol start="9"><li>进行软件的注册破解</li></ol><p>打开破解工具</p><p><img src="https://img.mahaofei.com/img/202112231046976-labview2018-15.png" alt=""></p><p>鼠标右键激活，将所有都变成绿色</p><p><img src="https://img.mahaofei.com/img/202112231046569-labview2018-16.png" alt=""></p><p>至此完成了LabView的安装和破解，接下来就可以正常使用了。</p><p>在开始菜单中所有应用中可以找到新安装的LabView2019</p><p><img src="https://img.mahaofei.com/img/202112231046828-labview2018-17.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView2019的安装与卸载</title>
      <link href="/post/3e37433.html"/>
      <url>/post/3e37433.html</url>
      
        <content type="html"><![CDATA[<h1>LabView2019的安装</h1><p><strong>注：此版本为==英文版==，如需要要中文版的请参考<a href="https://blog.csdn.net/weixin_44543463/article/details/112323169">LabView2018的安装<br></a></strong><br><strong>1. 下载网盘里面的LabView2019.zip压缩包</strong></p><blockquote><p>百度网盘链接：<a href="https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA">https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA </a><br>提取码：labv</p></blockquote><p><strong>2. 解压进入对应64位或32位文件夹，再解压文件夹内的的ISO文件，进入打开的文件夹，双击install.exe</strong></p><p><strong>3. 按照下列步骤进行安装</strong></p><p><img src="https://img.mahaofei.com/img/202112231039411-labview2019-2.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231039570-labview2019-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231039014-labview2019-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231040434-labview2019-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231040848-labview2019-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231040160-labview2019-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231040293-labview2019-8.png" alt=""></p><p>等待一段时间的安装</p><p><img src="https://img.mahaofei.com/img/202112231040948-labview2019-9.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231041218-labview2019-10.png" alt=""></p><p>这里不要登陆账号，直接关闭所有窗口，然后点击立即重启。</p><p><img src="https://img.mahaofei.com/img/202112231041957-labview2019-11.png" alt=""></p><p><strong>3. 进行软件的破解</strong></p><p>打开Crack文件夹下面的破解工具</p><p><img src="https://img.mahaofei.com/img/202112231041200-labview2019-12.png" alt=""></p><p>鼠标右键激活，将所有都变成绿色</p><p><img src="https://img.mahaofei.com/img/202112231041456-labview2019-13.png" alt=""></p><p>至此完成了LabView的安装和破解，接下来就可以正常使用了。</p><p>在开始菜单中所有应用中可以找到新安装的LabView2019</p><p><img src="https://img.mahaofei.com/img/202112231042809-labview2019-14.png" alt=""></p><h1>LabView2019的卸载</h1><p>打开控制面板，按照安装时间排序，找到图示的程序，双击卸载</p><p><img src="https://img.mahaofei.com/img/202112231042194-labview2019-15.png" alt=""></p><p>选择删除全部</p><p><img src="https://img.mahaofei.com/img/202112231042213-labview2019-16.png" alt=""></p><p>再在控制面板中删除其它有关LabView的程序</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用38译码器扩展单片机接口</title>
      <link href="/post/d455f071.html"/>
      <url>/post/d455f071.html</url>
      
        <content type="html"><![CDATA[<h2 id="74HC138译码器">74HC138译码器</h2><p><strong>1. 介绍</strong><br>在设计单片机电路的时候，单片机的IO口数量是有限的，有时并满足不了我们的设计需求，因此为了控制更多的器件，就需要使用一些外围的数字芯片进行引脚扩展。常用的是74HC138，也叫38译码器。<br><img src="https://img.mahaofei.com/img/202112231037711-74hc138-1.png" alt=""><br><strong>2. 工作原理</strong><br>38译码器，从名字来分析就是把3种输入状态翻译成8种输出状态。对于数字器件的引脚，如果一个引脚输入的时候，有 0 和 1 两种状态；对于两个引脚输入的时候，就会有 00、01、10、11 这四种状态了，那么对于 3 个输入的时候，就会出现 8 种状态了，真值表如下图所示。<br><img src="https://img.mahaofei.com/img/202112231037943-74hc138-2.png" alt=""><br>可以看出，左面三位相当于从0~8，右面则是8种输出状态。在任意输入状态时，只有一个输出引脚是低电平，这一点需要注意，也可以通过连接反相器实现高电平输出。<br>使用时，E2、E3接地，E1用来控制译码器的选通1为开启，0为关闭。A、B、C分别对应A0、A1、A2。E1、A、B、C连接单片机的4个引脚，就可以实现共输出状态的控制。</p><h2 id="Protues仿真实验">Protues仿真实验</h2><p><strong>1. 实验目的</strong><br>使用51单片机控制12个电机的选择启动<br><strong>2. 实验过程</strong><br><img src="https://img.mahaofei.com/img/202112231037894-74hc138-3.png" alt=""></p><ul><li>L298N作为步进电机的驱动</li><li>CD4066作为步进电机的选通开关，控制端收到高电平则导通</li><li>74HC138译码器+74HC240反相器用于扩展引脚，将单片机的信号经翻译后发送给给CD4066选择电机<br><strong>3. 实验结果</strong><br>电机按照预期要求以此选通启动。<br><img src="https://img.mahaofei.com/img/202112231038889-74hc138-4.png" alt=""><br><strong>4. 代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">enable</span> <span class="operator">=</span> P3^<span class="number">0</span>;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">key</span> <span class="operator">=</span> P3^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="type">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;<span class="comment">//顺时针转动</span></span><br><span class="line"><span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line">unsigned <span class="type">char</span> table[] = &#123;<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xa0</span>,<span class="number">0xb0</span>,<span class="number">0xc0</span>,<span class="number">0xd0</span>,<span class="number">0xe0</span>,<span class="number">0xf0</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,<span class="number">0x0a</span>,<span class="number">0x0b</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line">P1=<span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>);</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num&gt;=<span class="number">12</span>)</span><br><span class="line">num=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(num==-1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">P1=0x00;</span></span><br><span class="line"><span class="comment">P0=0x00;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else if(num&lt;8)</span></span><br><span class="line"><span class="comment">P1=table1[num];</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">P0=table2[num-8];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(num==-<span class="number">1</span>)</span><br><span class="line">P1=<span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P1 = table[num];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P2 = step[i];</span><br><span class="line">delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动多个二相四线制步进电机的Proteus仿真</title>
      <link href="/post/6f10ef99.html"/>
      <url>/post/6f10ef99.html</url>
      
        <content type="html"><![CDATA[<h2 id="CD4066介绍">CD4066介绍</h2><p><strong>1. 功能简介</strong><br>CD4066是四双向模拟开关，主要用作模拟或数字信号的多路传输。CD4066 的每个封装内部有4 个独立的模拟开关，每个模拟开关有输入、输出、控制三个端子，其中输入端和输出端可互换。<br><img src="https://img.mahaofei.com/img/202112231034164-mulity-step-motor-1.png" alt=""><br><strong>2. 引脚说明</strong></p><ul><li>CONTROL：开关控制端 [1]</li><li>IN/OUT：输入/输出端</li><li>OUT/IN：输出/输入端</li><li>VDD：电源正</li><li>VSS：电源负</li></ul><p><strong>3. 控制方法</strong><br>将CD4066的四个输入端接在L298N的输出口，CD4066的输出端接在步进电机的A+、A-、B+、B-端口，四个控制口同时接在单片机的某一引脚上，实现单片机的一个引脚控制一个CD4066上四个开关的同时开断，进而实现步进电机的选择。</p><h2 id="Proteus仿真">Proteus仿真</h2><p>Proteus接线图如下图所示。<br><img src="https://img.mahaofei.com/img/202112231035730-mulity-step-motor-2.png" alt=""><br>由于Proteus内没有CD4066，只有4066，因此考虑将4个4066组合视为一个整体。<br><img src="https://img.mahaofei.com/img/202112231036221-mulity-step-motor-3.png" alt=""><br>仿真结果：<br><img src="https://img.mahaofei.com/img/202112231036870-mulity-step-motor-4.png" alt=""><br>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">enable</span> <span class="operator">=</span> P3^<span class="number">0</span>;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">key</span> <span class="operator">=</span> P3^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="type">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;<span class="comment">//顺时针转动</span></span><br><span class="line"><span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line">unsigned <span class="type">char</span> table1[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line">unsigned <span class="type">char</span> table2[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>);</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num&gt;=<span class="number">12</span>)</span><br><span class="line">num=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P1=<span class="number">0x00</span>;</span><br><span class="line">P0=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num&lt;<span class="number">8</span>)</span><br><span class="line">P1=table1[num];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P0=table2[num-<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P2 = step[i];</span><br><span class="line">delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proteus仿真错误解决方法：No power supply specified for net 5V in Power Rail Configuration.</title>
      <link href="/post/1204e2b0.html"/>
      <url>/post/1204e2b0.html</url>
      
        <content type="html"><![CDATA[<p><strong>错误原因</strong><br>设置的5V电源没有添加到电网，如下图红圈中的电源。<br><img src="https://img.mahaofei.com/img/202112231033794-no-power-1.png" alt=""><br><strong>解决方法</strong><br>设计—配置供电网—在电源供应中，并将未连接电网的电源增加到网络连接即可。<br><img src="https://img.mahaofei.com/img/202112231033971-no-power-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231034901-no-power-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二相四线制步进电机驱动原理与Proteus仿真</title>
      <link href="/post/cacaac0f.html"/>
      <url>/post/cacaac0f.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、L298N">一、L298N</h2><p><img src="https://img.mahaofei.com/img/202112231031103-step-motor-1.png" alt=""><br>单片机无法直接驱动步进电机，需要L298N进行驱动。L298N的最大功耗为20W，驱动部分端子供电范围+5~+30V，控制信号输入电压范围5V/0V，驱动部分峰值电流2A。</p><h2 id="二、两相四线制步进电机">二、两相四线制步进电机</h2><p><strong>1. 技术指标</strong><br>（1）相数：电机内部的线圈组数。<br>（2）拍数：完成一个磁场周期性变化所需要脉冲数或导电状态。两相四线电机可以使用单四拍、双四拍和八拍的方式驱动。<br>（3）步距角：磁场变化一次电机转过的角度，两相四线电机步距角为0.9°/1.8°。<br><strong>2. 工作原理</strong><br><img src="https://img.mahaofei.com/img/202112231032895-step-motor-2.png" alt=""><br>如图所示，电机有四条控制信号A+、A-、B+、B-，通过控制这四条引线上的励磁脉冲，就可以控制步进电机的转动。以四拍驱动方式为例，顺时针转动时</p><table><thead><tr><th>STEP</th><th>A+</th><th>A-</th><th>B+</th><th>B-</th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td></td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td><td>0</td><td></td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td>0</td><td></td></tr><tr><td>4</td><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr><tr><td>**ps：**电动机的旋转方向由脉冲顺序决定，转动速度和脉冲频率有关。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="三、接线方法">三、接线方法</h2><ul><li>控制端：IN1、IN2、IN3、IN4接单片机的四个管脚，用于给出脉冲</li><li>输入端：5V输入接板载5V，12V输入外接电源</li><li>使能端：ENA、ENB接板载5V，默认使能</li><li>输出端：OUT1、OUT2、OUT3、OUT4分别接步进电机的四条线红绿黄蓝。</li></ul><h2 id="三、Proteus仿真">三、Proteus仿真</h2><p>在Proteus中的接线情况如下图所示：<br><img src="https://img.mahaofei.com/img/202112231032155-step-motor-3.png" alt=""><br>参考程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">enable</span> <span class="operator">=</span> P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="type">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;<span class="comment">//顺时针转动</span></span><br><span class="line"><span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P2 = step[i];</span><br><span class="line">delay(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿真结果：<br><img src="https://img.mahaofei.com/img/202112231033161-step-motor-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266_APP连接试验</title>
      <link href="/post/4d218ae.html"/>
      <url>/post/4d218ae.html</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p>本次试验使用的是ESP8266 NodeMCU</p><h1>硬件部分</h1><h2 id="8266固件烧录">8266固件烧录</h2><p>固件烧录的是nodemcu官方固件，打开官方提供的ESP8266Flasher，在配置一栏选择nodemcu固件，烧录地址为0x00000。<br><img src="https://img.mahaofei.com/img/202112231028978-esp8266-app-1.png" alt=""></p><h2 id="Arduino-IDE-8266版型下载">Arduino IDE 8266版型下载</h2><p>打开Arduino IDE，在文件-首选项-附加开发板管理器网址中输入：<br><code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code><br><img src="https://img.mahaofei.com/img/202112231029730-esp8266-app-2.png" alt=""><br>然后打开工具-开发板-开发板管理器，在搜索框输入esp8266，在下方弹出的搜索结果中选中要下载的版型，点击安装即可。（下载速度较慢，可挂梯子）<br><img src="https://img.mahaofei.com/img/202112231029664-esp8266-app-3.png" alt=""><br>到此为止，硬件部分的准备工作就完成了，接下来就可以使用Arduino IDE进行ESP8266的编程。</p><h2 id="安装MQTT库">安装MQTT库</h2><p>因本程序设计MQTT部分，因此还需要安装MQTT库才能正常编译程序，打开项目-加载库-管理库，有许多mqtt库可以选择，我使用的是PubSubClient。<br><img src="https://img.mahaofei.com/img/202112231029797-esp8266-app-4.png" alt=""></p><h2 id="ESP8266程序设计">ESP8266程序设计</h2><p>代码不长，贴在下方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;<span class="title class_">ESP8266WiFi</span>.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;<span class="title class_">PubSubClient</span>.<span class="property">h</span>&gt;</span><br><span class="line"><span class="title class_">WiFiClient</span> espClient;</span><br><span class="line"><span class="title class_">PubSubClient</span> <span class="title function_">client</span>(espClient);</span><br><span class="line"><span class="keyword">const</span> char* wifissid = <span class="string">&quot;Wifi_SSID&quot;</span>; <span class="comment">//自己家WIFI</span></span><br><span class="line"><span class="keyword">const</span> char* password = <span class="string">&quot;Wifi_Password&quot;</span>; <span class="comment">//自己家WIFI密码</span></span><br><span class="line"><span class="keyword">const</span> char* mqtt_server = <span class="string">&quot;***,***,***,***&quot;</span>;<span class="comment">//MQTT服务器地址</span></span><br><span class="line"><span class="keyword">const</span> char* mqtt_id = <span class="string">&quot;827855942_ESP&quot;</span>;<span class="comment">//MQTT ID需要唯一，这里我设置成自己的QQ号+_ESP</span></span><br><span class="line"><span class="keyword">const</span> char* <span class="title class_">Mqtt</span>_sub_topic = <span class="string">&quot;827855942_ESP&quot;</span>;   <span class="comment">//ESP8266订阅的topic，其他客户端向此topic发送信息时ESP8266会收到，设成自己的QQ号+_ESP</span></span><br><span class="line"><span class="keyword">const</span> char* <span class="title class_">Mqtt</span>_pub_topic = <span class="string">&quot;827855942&quot;</span>;  <span class="comment">//ESP8266发布消息的topic，上报消息给手机APP的TOPIC，设成自己的QQ号</span></span><br><span class="line">long lastMsg = <span class="number">0</span>; <span class="comment">//定时用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">pinMode</span>(<span class="number">2</span>, <span class="variable constant_">OUTPUT</span>);     </span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">begin</span>(<span class="number">115200</span>);<span class="comment">//设置波特率</span></span><br><span class="line">  <span class="title function_">setup_wifi</span>();<span class="comment">//初始化wifi</span></span><br><span class="line">  client.<span class="title function_">setServer</span>(mqtt_server, <span class="number">1883</span>);<span class="comment">//设定MQTT服务器与使用的端口，1883是默认的MQTT端口</span></span><br><span class="line">  client.<span class="title function_">setCallback</span>(callback); <span class="comment">//设定回调方式，当ESP8266收到订阅消息时会调用此方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Wifi</span></span><br><span class="line"><span class="comment">//连接成功后可在串口监视器看到ESP8266的IP地址</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setup_wifi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>();</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(wifissid);</span><br><span class="line">  <span class="title class_">WiFi</span>.<span class="title function_">begin</span>(wifissid, password);</span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">WiFi</span>.<span class="title function_">status</span>() != <span class="variable constant_">WL_CONNECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">delay</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;WiFi connected&quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="title class_">WiFi</span>.<span class="title function_">localIP</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，参数固定不能改</span></span><br><span class="line"><span class="comment">//payload内容可以是任意的，此程序中传递的是JSON数据</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">callback</span>(<span class="params">char* topic, byte* payload, unsigned int length</span>) &#123;</span><br><span class="line">  <span class="title class_">String</span> msg=<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title class_">String</span> LED_set = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;Message arrived [&quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(topic);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;] &quot;</span>);</span><br><span class="line">  <span class="comment">//msg中存放的就是传递过来的json数据，此处为&#123;&quot;set_led&quot;:1&#125;格式</span></span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    msg+= (char)payload[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(msg);</span><br><span class="line">  <span class="keyword">if</span>(msg.<span class="title function_">indexOf</span>(<span class="string">&quot;led&quot;</span>))  <span class="comment">//判断是否是要设置LED灯</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//取出LED_set数据 并执行</span></span><br><span class="line">    LED_set = msg.<span class="title function_">substring</span>(msg.<span class="title function_">indexOf</span>(<span class="string">&quot;led\&quot;:&quot;</span>)+<span class="number">5</span>,msg.<span class="title function_">indexOf</span>(<span class="string">&quot;&#125;&quot;</span>)); </span><br><span class="line">    <span class="title function_">digitalWrite</span>(<span class="number">2</span>,!LED_set.<span class="title function_">toInt</span>()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断线重连</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!client.<span class="title function_">connected</span>()) &#123;</span><br><span class="line">    <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;Attempting MQTT connection...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.<span class="title function_">connect</span>(mqtt_id)) &#123;</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">      <span class="comment">//连接成功以后就开始订阅</span></span><br><span class="line">      client.<span class="title function_">subscribe</span>(<span class="title class_">Mqtt</span>_sub_topic,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;failed, rc=&quot;</span>);</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">print</span>(client.<span class="title function_">state</span>());</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot; try again in 5 seconds&quot;</span>);</span><br><span class="line">      <span class="title function_">delay</span>(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//MQTT是否连接，若未连接则重连</span></span><br><span class="line">  <span class="keyword">if</span> (!client.<span class="title function_">connected</span>()) &#123;</span><br><span class="line">    <span class="title function_">reconnect</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  client.<span class="title function_">loop</span>();</span><br><span class="line">  long now = <span class="title function_">millis</span>();<span class="comment">//运行时间</span></span><br><span class="line">  <span class="keyword">if</span> (now - lastMsg &gt; <span class="number">2000</span>) &#123;</span><br><span class="line">    lastMsg = now;</span><br><span class="line">    <span class="comment">//打包发送数据给pubtopic    </span></span><br><span class="line">    <span class="title class_">String</span> json = <span class="string">&quot;&#123;\&quot;temperature\&quot;:&quot;</span>+<span class="title class_">String</span>(<span class="title function_">analogRead</span>(<span class="variable constant_">A0</span>))+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    client.<span class="title function_">publish</span>(<span class="title class_">Mqtt</span>_pub_topic,json.<span class="title function_">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>APP部分</h1><h2 id="创建项目">创建项目</h2><p>Start a new Android project，我选择Empty Activity，name随意，language java，Android版本要小于等于手机安卓版本。（尽量用真机调试，虚拟机bug太多）<br><img src="https://img.mahaofei.com/img/202112231030854-esp8266-app-5.png" alt=""></p><h2 id="UI设计">UI设计</h2><p>打开app-res-layout下的activity_main.xml文件，设计UI<br>常用的代码列下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android:orientation=<span class="string">&quot;vertical&quot;</span><span class="comment">//设置线性布局方向</span></span><br><span class="line">android:background=<span class="string">&quot;#FFFFFF&quot;</span><span class="comment">//设置背景色</span></span><br><span class="line">android:src=<span class="string">&quot;@drawable/pic&quot;</span><span class="comment">//ImageView下添加图片</span></span><br><span class="line">android:layout_margin=<span class="string">&quot;10dp&quot;</span><span class="comment">//设置距离父空间边缘距离</span></span><br><span class="line">android:id=<span class="string">&quot;@+id/image_1//设置id</span></span><br><span class="line"><span class="string">android:layout_weight=&quot;</span><span class="number">1</span><span class="string">&quot;//布局内设置权重</span></span><br><span class="line"><span class="string">android:gravity=&quot;</span>center_vertical<span class="string">&quot;//布局内设置垂直居中</span></span><br></pre></td></tr></table></figure></p><h2 id="主程序设计">主程序设计</h2><p>打开MainActivity.java编写程序<br>1. OnCreate函数是程序打开后最先运行的地方</p><pre><code>![](https://img.mahaofei.com/img/202112231030143-esp8266-app-6.png)4. 移植Mqtt_init()函数5. 移植startReconnect()函数6. 移植publishmessageplus()函数7. 在OnCreate中加入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mqtt_init();</span><br><span class="line">startReconnect();</span><br><span class="line">handler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br></pre></td></tr></table></figure>注：每完成一小步都要刷入真机调试，以免调bug之痛2. 按钮单击事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button_1 = findViewById(R.id.button_1); <span class="comment">//寻找XML里面真正的ID，与自己初始化的变量绑定</span></span><br><span class="line">button_1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"><span class="comment">//这里是单击之后执行的地方</span></span><br><span class="line"><span class="comment">//在当前ativity 显示内容为hello的短时间弹窗</span></span><br><span class="line">Toast.makeText(MainActivity.<span class="built_in">this</span>,<span class="string">&quot;hello&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>3. 导入JAR包将mqtt的JAR包复制到app下的libs文件夹中右键JAR包Add as Lib确定</code></pre><p>以上就完成了基本的app与ESP8266的通信。<br><img src="https://img.mahaofei.com/img/202112231031740-esp8266-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231031908-esp8266-app-8.png" alt=""><br>感谢正哥，B站up<a href="https://space.bilibili.com/265908761/">阿正啷个哩个啷</a>，大佬的教程</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础_常用函数</title>
      <link href="/post/ee422c9c.html"/>
      <url>/post/ee422c9c.html</url>
      
        <content type="html"><![CDATA[<hr><p>title: 数字化方法基础_常用函数<br>date: 2019-10-29 21:12:14<br>description: 数字化方法基础_常用函数1.叉乘2.单位化矢量3.矩阵乘法4.矩阵乘法。<br>categories:</p><ul><li>程序设计</li><li>OpenGL<br>tags:</li><li>笔记</li><li>数字化方法</li></ul><hr><h2 id="1-叉乘">1. 叉乘</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">crossproject</span><span class="params">(<span class="type">float</span> vec1[<span class="number">3</span>],<span class="type">float</span> vec2[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-单位化矢量">2. 单位化矢量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Normalize</span><span class="params">(<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> length;</span><br><span class="line">length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">n[i] /= length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-矩阵乘法4×4-×-4×1">3. 矩阵乘法4×4  ×  4×1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ApplyMatrix</span><span class="params">(<span class="type">float</span> *P0,<span class="type">float</span> *translation,<span class="type">float</span> *P1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-矩阵乘法-4×4-×-4×4">4. 矩阵乘法 4×4  ×  4×4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">float</span> *rotation,<span class="type">float</span> *translation,<span class="type">float</span> *tran)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础教程</title>
      <link href="/post/1e786620.html"/>
      <url>/post/1e786620.html</url>
      
        <content type="html"><![CDATA[<p><strong>如果觉得这篇太长，可到以下各单独blog<br>（1）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727427">数字化方法基础（一）_基础操作与生成四面体（Chapter 1-3）</a><br>（2）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727368">数字化方法基础（二）_点的投影（Chapter 4-5）</a><br>（3）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727404">数字化方法基础（三）_导入本地模型（Chapter 6）</a><br>（4）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727509">数字化方法基础（四）_矩阵操作（Chapter 7）</a></strong></p><p>ps.<a href="https://blog.csdn.net/weixin_44543463/article/details/102808548"><strong>常用函数请看这里</strong></a></p><p><strong>最近一次的代码（全）百度网盘：</strong><br><a href="https://pan.baidu.com/s/1cmQwrqrWzPwYdklb7snTkg">https://pan.baidu.com/s/1cmQwrqrWzPwYdklb7snTkg</a></p><h1>Chapter1  VisualStudio2010 Express如何创建新工程</h1><p>1、新建一个win32 Console Application工程，选择建立一个空项目（带预编译头的也可以，只不过大多数人不太习惯）</p><p><img src="https://img.mahaofei.com/img/202112230957699-numerical-recipe-2.png" alt=""><br>2、在左侧解决方案资源管理器中右击Source-add-New item，创建一个C++文件</p><p><img src="https://img.mahaofei.com/img/202112230958908-numerical-recipe-3.png" alt=""><br>3、这样就用VS2010创建好了一个简单的工程！</p><h1>Chapter2 SB-WinSRC的使用方法</h1><p>1、解压压缩包，得到一个SB-WinSRC文件夹<br>2、打开SB-WinSrc\examples\projects\microsoft\chapt05\shinyjet文件夹中的shinyjet.vcproj文件，如出现以下对话框则一直Next到最后<br><img src="https://img.mahaofei.com/img/202112230958911-numerical-recipe-4.png" alt=""><br>3、打开shinyjet.cpp并进行编译（Build solution生成解决方案）<br><img src="https://img.mahaofei.com/img/202112230958652-numerical-recipe-5.png" alt=""><br>4、出现图示错误<br><img src="https://img.mahaofei.com/img/202112230959276-numerical-recipe-6.png" alt=""><br>5、打开目录\SB-WinSrc\examples\src\shared，找到freeglut_static.lib文件，将它复制到之前打开的shinyjet文件夹内<br><img src="https://img.mahaofei.com/img/202112230959001-numerical-recipe-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231000243-numerical-recipe-8.png" alt=""><br>6、再次进行编译（Build solution生成解决方案），出现下图错误<br><img src="https://img.mahaofei.com/img/202112231000076-numerical-recipe-9.png" alt=""><br>7、在左侧Solution Explorer（解决方案资源管理器）中右击shinyjet打开属性，将Linker-Input-忽略特定默认库一栏中输入LIBC.lib<br><img src="https://img.mahaofei.com/img/202112231000584-numerical-recipe-10.png" alt=""><br>8、再次编译，成功！</p><h1>Chapter3  用OpenGL生成四面体</h1><h2 id="已知3点求法向量">已知3点求法向量</h2><p>1、具体思路为先根据已知3点做差求出两个向量，利用两个向量叉乘运算求出法向量，实现过程中尽量避免将所有代码集中到一个函数中，因为后续的操作（如投影点的计算）还需用到求法向量的函数，到时可直接调用。<br>2、已知2点求向量的函数十分简单，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getvector</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> vec[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">vec[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、调用两次上述函数即可获得两个向量，接下来要做的就是拿这两个向量进行叉乘，以得到法向量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crossproject</span><span class="params">(<span class="type">float</span> vec1[<span class="number">3</span>],<span class="type">float</span> vec2[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、将上面两个函数简单封装一下如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">project</span><span class="params">(<span class="type">float</span> point1[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> vec1[<span class="number">3</span>],vec2[<span class="number">3</span>];</span><br><span class="line">getvector(a,b,vec1);</span><br><span class="line">getvector(b,c,vec2);</span><br><span class="line">crossproject(vec1,vec2,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、这样一个求法向量的函数就写好了，使用方法如下例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[<span class="number">3</span>] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> b[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> c[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//调用过project()函数之后，n[3]数组内的值即为法向量</span></span><br></pre></td></tr></table></figure><h2 id="生成四面体">生成四面体</h2><p>1、使用OpenGL生成四面体的基本方法为，<strong>给定三个点和一个法向量</strong>，调用OpenDL的库函数，即可<strong>生成一个由这三点围成的三角形平面</strong>，<strong>四个三角形平面即可组成一个四面体</strong>。<br>2、将课上的shinyjet.cpp模板复制到src相应的文件夹中（\SB-WinSrc\examples\src\chapt05\shinyjet），然后回到project对应文件夹中，打开shinyjet.vcxproj工程，点击调试，成功后出来的应该为一个蓝绿色底的对话框。<br><img src="https://img.mahaofei.com/img/202112231001853-numerical-recipe-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231001700-numerical-recipe-12.png" alt=""></p><p>3、在RenderSenen()函数中的下图位置 <strong>写入glBegin()与glEnd()函数，并在二者之间插入画三角形的代码</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231002123-numerical-recipe-13.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> rgfPoints4[<span class="number">12</span>] = &#123;<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,</span><br><span class="line"><span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line"><span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line"><span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">//这是定义了一个长为12的数组，每3个元素代表一个点坐标，共4个点</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置要生成图形的颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"><span class="comment">//开始生成三角形</span></span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>);</span><br><span class="line">DrawTriangle(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//↑函数功能：给定3个点生成一个三角形，调用4次生成4个三角形组成四面体</span></span><br><span class="line">   glEnd();</span><br><span class="line">   <span class="comment">//结束</span></span><br></pre></td></tr></table></figure><p>4、在这里，glColor3ub、glBegin，glEnd均是OpenGL的库函数，不需要我们定义，直接调用即可，<strong>需要我们写的是DrawTriangle函数</strong>，接下来我们就开始定义DrawTriangle()，前面已经提到，需要用<strong>3个点和一个法向量</strong>来确定一个平面，因此我们把第一节中生成法向量的函数复制到此文件的开头处，以便调用。<br><img src="https://img.mahaofei.com/img/202112231002324-numerical-recipe-14.png" alt=""><br>5、画三角形的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawTriangle</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];<span class="comment">//定义一个数组用来存放法向量</span></span><br><span class="line">project(a,b,c,n);<span class="comment">//调用生成法向量的函数由a,b,c三点生成法向量n</span></span><br><span class="line">glNormal3fv(n);</span><br><span class="line">glVertex3fv(a);</span><br><span class="line">glVertex3fv(b);</span><br><span class="line">glVertex3fv(c);<span class="comment">//此四行为利用用库函数，由法向量n和三个点abc生成一个平面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、完成上述步骤后，进行调试，即可得到一个四面体<br><img src="https://img.mahaofei.com/img/202112231003764-numerical-recipe-15.png" alt=""></p><h1>Chapter4  用OpenGL生成点的投影</h1><h2 id="计算点的投影的基本原理">计算点的投影的基本原理</h2><p><img src="https://img.mahaofei.com/img/202112231003891-numerical-recipe-16.png" alt=""></p><h2 id="如何编写程序实现点的投影">如何编写程序实现点的投影</h2><p>1、我们要实现点的投影就要知道投影点的坐标，由上一节可知，需要计算<strong>P0P1矢量</strong>（这个直接调用上一讲求向量的函数），<strong>en向量</strong>（需要写一个单位化函数），<strong>向量点乘</strong>的函数<br>2、单位化，即将向量各个坐标除以它的模，函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Normalize</span><span class="params">(<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> length;</span><br><span class="line">length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//求向量的模</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">n[i] /= length;</span><br><span class="line"><span class="comment">//函数执行过后n[3]即变成单位法向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、进行向量点乘计算，并求N点坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProjectPointtoPoint</span><span class="params">(<span class="type">float</span> point[<span class="number">3</span>],<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>], <span class="type">float</span> ProjectPoint[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> vector_a_p[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> distance;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">vector_a_p[i] = point[i] - a[i];</span><br><span class="line"><span class="comment">//求面内一点与面外一点的向量,即P0P1</span></span><br><span class="line">distance = vector_a_p[<span class="number">0</span>]*n[<span class="number">0</span>]+vector_a_p[<span class="number">1</span>]*n[<span class="number">1</span>]+vector_a_p[<span class="number">2</span>]*n[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//做点乘运算求点到平面距离，即图中|P0N|</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">ProjectPoint[j] = point[j] - n[j]*distance;</span><br><span class="line"><span class="comment">//N点坐标=P0坐标 - en * |P0N|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、经过上述步骤之后就获得投影点坐标，然后就可调用库函数显示投影点，以下为显示一个点的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawPoint</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> point[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//求abc平面法向量</span></span><br><span class="line">Normalize(n);</span><br><span class="line"><span class="comment">//单位化法向量</span></span><br><span class="line"><span class="type">float</span> ProjectPoint[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//定义一个数组用来存放投影点坐标</span></span><br><span class="line">ProjectPointtoPoint(point,a,n,ProjectPoint);</span><br><span class="line"><span class="comment">//获得投影点坐标</span></span><br><span class="line">glVertex3fv(ProjectPoint);</span><br><span class="line"><span class="comment">//显示投影点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、同三角形，在RenderSenen()函数中的画三角形的glEnd()后面 <strong>再次写入glBegin()与glEnd()函数，并在二者之间插入显示点的代码</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> point[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;;</span><br><span class="line"><span class="comment">//定义要投影的点</span></span><br><span class="line">glColor3ub(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//显示的点的颜色</span></span><br><span class="line">glPointSize(<span class="number">6.0f</span>);</span><br><span class="line"><span class="comment">//显示的点的大小</span></span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line"><span class="comment">//开始生成点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line"><span class="comment">//根据第一个面3个点，画第一个投影点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>,point);</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure><p>6、调试成功，显示如图<br><img src="https://img.mahaofei.com/img/202112231003356-numerical-recipe-17.png" alt=""></p><h1>Chapter5  如何使用VS2010的调试功能</h1><p>假如我写完程序调试后发现点没有显示，那么可以一步步调试，找出错误的地方。<br>1、设置断点，在觉得可能出问题的代码处设置断点<br><img src="https://img.mahaofei.com/img/202112231004361-numerical-recipe-18.png" alt=""><br>2、点击调试，下图红框内左面按键为单步执行，点一下执行一句话，如果遇到函数就进入函数内部执行函数体的第一句；右面的按键，点一下执行一句，在遇到函数是直接将整个函数执行完，即将函数也当成一句话。<br><img src="https://img.mahaofei.com/img/202112231004424-numerical-recipe-19.png" alt=""><br>3、这里选择左面按键进入函数内部查看,黄色箭头表示当前执行到哪一句<br><img src="https://img.mahaofei.com/img/202112231004146-numerical-recipe-20.png" alt=""><br>4、按第二个按键将这个函数执行完（但不要退出这个函数，否则函数内部的变量内存会被释放，无法查看变量的值）<br><img src="https://img.mahaofei.com/img/202112231005406-numerical-recipe-21.png" alt=""><br>5、此时可以看到下面的监视窗口可以看到变量，单击+即可看到变量的值，图中展开的为第一个面的法向量和投影点坐标<br><img src="https://img.mahaofei.com/img/202112231005488-numerical-recipe-22.png" alt=""><br>第二个面的法向量和投影点坐标<br><img src="https://img.mahaofei.com/img/202112231005139-numerical-recipe-23.png" alt=""><br>第三个面<br><img src="https://img.mahaofei.com/img/202112231006139-numerical-recipe-24.png" alt=""><br>第四个<br><img src="https://img.mahaofei.com/img/202112231006058-numerical-recipe-25.png" alt=""></p><h1>Chapter 6  导入本地模型</h1><p>图形的生成需要消耗一定的时间，简单的模型可能没有什么感觉，但是在模型十分复杂时，模型的生成就需要相当长的时间，这是我们不能忍受的。因此，将模型保存为本地文件，使用时直接加载进来，这就变得十分必要了，本节主要讲如何将创建一个列表以及如何加载一个列表。</p><h2 id="如何创建一个列表">如何创建一个列表</h2><p>列表的基本原理就是将之前写的<strong>从glPolygonMode、glBegin开始，到glEnd</strong>将这些代码<strong>用一行glCallList(DrawList)代替</strong>，其中DrawList内存放的就是之前生成四面体的代码了。glCallList就相当于把原来的四面体代码加载进来。<br>那如何将原来的四面体代码创建为一个列表供glCallList读取呢，过程十分简单，只需要按以下步骤即可：<br>1、在整个文件开头部分<strong>定义一个GLuint类型的全局变量</strong>（因为这个变量要在不同的函数使用，故须定义为全局变量）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLuint DrawList;</span><br></pre></td></tr></table></figure><p>2、将RenderScene函数（就是之前写glbegin和glEnd的地方）中的<strong>有关三角形的代码全部用glCallList函数代替</strong></p><p><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223100655803.png" alt="image-20211223100655803"><br>3、在SetupRC函数中的最后<strong>新建列表</strong>，<strong>框架</strong>如下<br><img src="https://img.mahaofei.com/img/202112231007333-numerical-recipe-27.png" alt=""><br>4、框架写好之后在图中注释位置<strong>插入画四面体的代码</strong>，插入后结果如下图<br><img src="https://img.mahaofei.com/img/202112231007814-numerical-28.png" alt=""><br>5、至此一个存有四面体列表就新建好了，点击调试运行即可看到和以前一样的四面体。<br><img src="https://img.mahaofei.com/img/202112231007227-numerical-recipe-29.png" alt=""></p><h2 id="如何读取本地模型">如何读取本地模型</h2><p>当我们需要读取本地文件中的模型时，如何操作呢<br>1、既然要读取文件中的模型，首先肯定要打开文件，在创建列表的代码之前插入如下三行代码<br><img src="https://img.mahaofei.com/img/202112231008514-numerical-recipe-30.png" alt=""><br>（注意，if stream的括号内为文件的路径，其中的\都要写成\，因为在C语言字符串中，\表示转义，\\才表示一个\）<br>（注意，ifstream若要使用需要先在开头插入以下两行引入头文件同时设置环境)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>2、在定义几个数组用来存放一会要读取的数据<br><img src="https://img.mahaofei.com/img/202112231008162-numerical-recipe-31.png" alt=""><br>3、然后，将之前画四面体的代码，更改为读取文件的代码，更换后的框架如下，其中in每次读取一串字符（到空格或换行停止)，<strong>in &gt;&gt; String0指的是将读取到的字符存入String0中</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DrawList = <span class="built_in">glGenLists</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glNewList</span>(DrawList,GL_COMPILE);</span><br><span class="line"><span class="built_in">glPolygonMode</span>(GL_BACK,GL_LINE);</span><br><span class="line"><span class="comment">//在↓插入代码</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0;<span class="comment">//这就表示将两个字符串先后存入到String0中</span></span><br><span class="line"><span class="comment">//因为如下图在读取到有用数据之前有两个没用的单词，需要读取两次</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;end&quot;</span>))<span class="comment">//读到的字符串为end则退出循环</span></span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//因为刚才已经读掉了前两个没用的字符串，因此直接读取三个坐标到Points里</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//如下图读完第一组坐标后会遇到 vertex这个单词，需要读到垃圾桶（String0）里再读坐标</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="built_in">glColor3ub</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">DrawTriangle</span>(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//这三行时画一个三角形，根据刚才读到的三个点</span></span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在↑插入代码</span></span><br><span class="line"><span class="built_in">glEndList</span>();</span><br></pre></td></tr></table></figure><p>（因为用到了strcmp函数，需要引入头文件#include&lt;string.h&gt;）<br><img src="https://img.mahaofei.com/img/202112231009244-numerical-recipe-32.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231009411-numerical-recipe-33.png" alt=""><br>注意一下，计算机里的图像<strong>无论是平面还是曲面，都是由无数个三角形组成的</strong>，只不过三角形数量无比多时，我们看起来它就是一个曲面，Part1.TXT文件中也是，每读取到三个点就画一个三角形，许许多多个三角形就会组成一个立体图形。<br>4、至此，如何从文件中导入立体模型就完成了，点击调试，即可看到一个正方体<br>6、那么对于给定的STL文件如何读取？首先右击Part2.STL，用记事本打开，看到文件内容如下<br><img src="https://img.mahaofei.com/img/202112231010481-numerical-recipe-34.png" alt=""><br>这看起来和之前差不多，只是他多给了一个法向量，没用的字符串多了一些而已，你可以不用他给的法向量，只读取三个坐标然后自己计算法向量，也可以读取法向量，这个时候 DrawTriangle函数就不需要计算法向量了，直接四行代码就ok，和之前一样，每一次in &gt;&gt; String0操作就读掉一个没用的字符串，自己编写代码就可实现将STL文件中的所有点全部读取出来<br>需要注意的是，<strong>每次循环结束</strong>的时候都要保证<strong>String内存放</strong>的是<strong>facet或者最后的endsolid</strong>这个单词，以保证循环可以正常退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//float n[3];</span></span><br><span class="line"><span class="comment">//project(a,b,c,n);</span></span><br><span class="line"><span class="built_in">glNormal3fv</span>(n);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(a);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(b);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS.如果程序出现错误，如何进行调试呢，首先在while循环里第一句前面设置断点，如下图<br><img src="https://img.mahaofei.com/img/202112231010555-numerical-recipe-35.png" alt=""><br>然后点击单步执行第二个按钮<br><img src="https://img.mahaofei.com/img/202112231010062-numerical-recipe-36.png" alt=""><br>每次循环读9个点,查看你读取到的点的值是否与文件中的坐标值一一对应，其中012对应第一行3个点，345对应第二行三个点，678对应第三行。<br><img src="https://img.mahaofei.com/img/202112231011562-numerical-recipe-37.png" alt=""></p><h1>Chapter 7 矩阵操作</h1><h2 id="利用矩阵实现向量平移">利用矩阵实现向量平移</h2><p>1、基本原理:如图，任意给定一个点的坐标（列向量）x,y,z。设置一个矩阵，利用矩阵的乘法运算即可将三个坐标进行平移<br>注意：过程中所设置的矩阵为单位阵的最后一列加上偏移量Tx，Ty，Tz。如下图，大家自己试一下矩阵乘法即可验证。<br><img src="https://img.mahaofei.com/img/202112231011567-numerical-recipe-38.png" alt=""></p><p>2、在了解了如何将一个列向量进行平移之后，我们就可以编写程序进行向量的平移操作了，我们打开生成螺旋线的程序，注意到螺旋线是由许许多多点组成的，下面这个for循环就是每次生成一个点，我们只需要吧每个点的坐标向量进行平移即可使整个螺旋线平移。<br><img src="https://img.mahaofei.com/img/202112231012895-numerical-recipe-39.png" alt=""><br>3、现在就开始写程序了，首先明确一下程序执行过程</p><p><strong>1. 获得一个点的坐标存入P0数组内<br>2. 设置一个矩阵Translation用来将坐标平移<br>3. 将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标</strong></p><p>4、第一步，获得一个点的坐标存入P0数组内，这一步十分简单（注：除函数定义外，其余代码均在for循环内）<code>float P0[3] = &#123;x,y,z&#125;;</code><br>5、第二步，设置一个矩阵Translation用来将坐标平移，我们需要一个下面这样的矩阵<br><img src="https://img.mahaofei.com/img/202112231012723-numerical-recipe-40.png" alt=""><br>如何操作呢，首先先初始化一个单位矩阵，然后将单位矩阵的最后一列赋值为需要偏移的量（我的代码十分简单粗暴，当然也可单独另写一个函数用于初始化一个单位矩阵)<br>注意：在OpenGL中，矩阵是按列数的，就是说我定义的I[16]中的前四个元素I[1]、I[2]、I[3]、I[4]实际上是矩阵的第一列，最后的I[12]、I[13]、I[14]、I[15]是矩阵的最后一列，而非上学期C语言中理解的最后一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Translate</span><span class="params">(<span class="type">float</span> fx,<span class="type">float</span> fy,<span class="type">float</span> fz,<span class="type">float</span> Translation[<span class="number">16</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> I[<span class="number">16</span>] = &#123;<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;<span class="comment">//定义一个四阶单位阵</span></span><br><span class="line">I[<span class="number">12</span>] = fx;<span class="comment">//将第四列第一行的元素赋fx</span></span><br><span class="line">I[<span class="number">13</span>] = fy;<span class="comment">//第四列第二行赋fy</span></span><br><span class="line">I[<span class="number">14</span>] = fz;<span class="comment">//第四列第三行赋fz</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)</span><br><span class="line">Translation[i] = I[i];<span class="comment">//将I数组的值循环赋给Translation数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作之后就获得了如上面图片中的数组了。<br>6、第三步，将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标，So我们要做的就是定义一个P1数组<code>float P1[3];</code>这十分简单，然后就是写一个矩阵乘法的运算，用Translation*P0，结果存入P1中。<br>实现代码如下，注意translation为4*4矩阵，P0为3*1矩阵，P1为4*1矩阵，<br>（为什么要四阶矩阵是因为我们需要矩阵运算平移，只有多加一行一列才能实现，而P0和P1我们实际只用前3个元素，）<br>故我们让P0的“第四个”元素默认为1，即下面代码中最后一项为1*translation[i+12]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ApplyMatrix</span><span class="params">(<span class="type">float</span> *P0,<span class="type">float</span> *translation,<span class="type">float</span> *P1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)</span><br><span class="line">P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、有了设置操作矩阵的函数Translate，和矩阵相乘的函数ApplyMatrix，我们就可以平移点了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;<span class="comment">//定义P0存放平移之前的点</span></span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];<span class="comment">//定义P1存放平移之后的点</span></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];<span class="comment">//存放一个4*4的操作矩阵</span></span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">30.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//设置操作矩阵为我们想要的格式（单位阵-&gt;最后一列赋值）</span></span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//操作矩阵和P0点相乘，结果放在P1内</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示平移之后的点</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为螺旋线平移步骤</p><h2 id="使用矩阵实现向量旋转">使用矩阵实现向量旋转</h2><p>1、如何进行向量旋转<br>首先了解一下二维坐标的旋转，设一个向量a的坐标是（x,y），长度为r，与x轴正向夹角为α，则：<br>xa = r cos α,<br>ya = r sin α.<br>如果把向量旋转一个角度φ，则新的向量b的坐标是<br>xb = r cos(α + φ) = r cos α cos φ - r sin α sin φ,<br>yb = r sin(α + φ) = r sin α cos φ + r cos α sin φ.<br><img src="https://img.mahaofei.com/img/202112231012454-numerical-recipe-41.png" alt=""><br>又因为xa = r cos α，ya = r sin α.所以容易看出来<br>xb = xa cos φ - ya sin φ,<br>yb = ya cos φ + xa sin φ.<br>而等式右边，又可写成两个矩阵的乘积<br><img src="https://img.mahaofei.com/img/202112231013633-numerical-recipe-42.png" alt=""><br>由此可知，等式中<strong>由sin和cos组成的二阶方阵</strong>，就<strong>可以实现将向量(xa ya,)旋转为(xb,yb,)</strong>，暂且叫做二阶的旋转操作矩阵<br>由此推导至三阶，<strong>三阶的旋转操作矩阵为以下三种</strong>（分别为绕x，y，z轴旋转），大家带入检验一下即可知道，<br><img src="https://img.mahaofei.com/img/202112231013952-numerical-recipe-43.png" alt=""><br>而为了与之前的平移操作统一，因此我们也把这个三阶旋转操作矩阵扩展为四阶的，如下<br><img src="https://img.mahaofei.com/img/202112231013016-numerical-recipe-44.png" alt=""><br>2、如何编写函数实现向量旋转呢<br>由刚才的推导我们知道，用旋转操作矩阵左乘一个列向量即可实现向量的旋转操作<br>现在我们来编写函数，以绕x轴为例，我们先来看一下“主函数”，这是生成螺旋线的那个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个数组（用于存放旋转操作矩阵）</span></span><br><span class="line"><span class="comment">//这里也可生成一个单位阵，那样就不用初始化为0了</span></span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//给定一个角度（-90°），生成旋转操作矩阵</span></span><br><span class="line">ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用旋转操作矩阵左乘P0，得到的结果P1即为旋转完成的向量坐标</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示旋转后的坐标对应的点</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们需要做的就是<strong>写一个函数</strong>，<strong>由参数（角度）生成一个旋转操作矩阵</strong>，这里需要注意的是，math.h头文件中有sin和cos的函数，直接sin（angle）即可调用，其中angle为弧度值，代码如下<br>（注意，函数里用到的PI是在开头宏定义的<code>#define PI 3.14159</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Rotate_x</span><span class="params">(<span class="type">float</span> angle,<span class="type">float</span> *rotation)</span></span><br><span class="line">&#123;</span><br><span class="line">angle = angle/<span class="number">180.0</span>*PI;</span><br><span class="line"><span class="comment">//将角度值转换为弧度值</span></span><br><span class="line">rotation[<span class="number">5</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">rotation[<span class="number">6</span>] = <span class="built_in">sin</span>(angle);</span><br><span class="line">rotation[<span class="number">9</span>] = -<span class="built_in">sin</span>(angle);</span><br><span class="line">rotation[<span class="number">10</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">rotation[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//配置各个位置的数值，注意矩阵下标是竖着数的，第一行位置为0、4、8、12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们得到了旋转操作矩阵，经“主函数”调用即可实现向量的旋转</p><h2 id="如何让图形既平移又旋转">如何让图形既平移又旋转</h2><p>一个很简单的思路就是<strong>先后调用平移和旋转操作的函数</strong>，像下面这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> P2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//进行平移操作，P0平移后为P1</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line">ApplyMatrix(P1,Rotation,P2);</span><br><span class="line"><span class="comment">//进行旋转操作，P1旋转后为P2</span></span><br><span class="line"></span><br><span class="line">glVertex3f(P2[<span class="number">0</span>], P2[<span class="number">1</span>], P2[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//最后输出P2的点即可</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这显然不是我们想要的，我们想一步就完成平移操作，不需要中间P1的出现，那么就需要<strong>将平移操作矩阵和旋转操作矩阵相乘，得到的仍为一个四阶矩阵，再拿这个新的四阶矩阵左乘列向量xy，即可将列向量既平移又旋转</strong>。<br><strong>如何理解？</strong><br>我们知道平移操作矩阵和旋转操作矩阵都是可逆矩阵（det Rx ≠ 0，det T ≠ 0）<br><img src="https://img.mahaofei.com/img/202112231014359-numerical-recipe-45.png" alt=""><br>那么这两个矩阵都可以写成许多个初等矩阵的乘积，即<br>Rx = R1*R2*R3*……Rn * I<br>T = R1’*R2’*R3’……Rn’ * I<br>（其中R1，R1’……Rn，Rn’都为初等矩阵，初等矩阵还记得吧，刚学过的线代，只进行一次初等变换的矩阵；初等矩阵左乘一个矩阵即对他行变换）<br>那么我们知道平移操作为<br><img src="https://img.mahaofei.com/img/202112231014908-numerical-recipe-46.png" alt=""><br>同理旋转操作也可以写成<br><img src="https://img.mahaofei.com/img/202112231015626-numerical-recipe-47.png" alt=""><br>那么先平移，然后把平移得到的矩阵旋转就可以写成如下的形式<br><img src="https://img.mahaofei.com/img/202112231015778-numerical-recipe-48.png" alt=""><br>又因为Rx = R1<em>R2</em>R3*……Rn，T = R1’<em>R2’<em>R3’……Rn’<br>所以 Rx</em>T</em>列向量 就代表把列向量平移又旋转<br>那么我们现在要做的就是写一个四阶矩阵的乘法函数，以获取Rx*T的结果，拿这结果左乘列向量即一步实现平移旋转。<br>四阶矩阵的乘法代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">float</span> *rotation,<span class="type">float</span> *translation,<span class="type">float</span> *tran)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个是用16个元素的变量代表一个矩阵，下标表示比较麻烦，大家可以在纸上写一下<br>代码写法不唯一，也可以把它拆成四个循环单独写，当然也可以直接把每个元素赋值，赋值16次就完了<br>然后按照刚才的逻辑在“主函数”里调用一下就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//获得平移操作矩阵</span></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//获得旋转操作矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> multi[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">mul(Rotation,Translation,multi);</span><br><span class="line"><span class="comment">//两矩阵相乘获得平移+旋转操作矩阵</span></span><br><span class="line">ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用平移+旋转操作矩阵左乘P0即可得到被平移且旋转之后的矩阵P1</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即利用矩阵实现向量的平移与旋转操作</p><h2 id="坐标系的旋转">坐标系的旋转</h2><p><strong>1、目标</strong>：<br>给定一个向量（如(1,1,1)），将原坐标系旋转为以此向量为Z轴的坐标系。<br><strong>2、基本概念</strong>：<br>如图，左面的三阶方阵内每一列为新坐标轴的三个单位向量，用这个<strong>三阶方阵左乘一个原坐标系的点</strong>，即可<strong>将这个点坐标旋转为新坐标系的对应坐标</strong><br>由此，我们只需要生成一个左面的旋转坐标系的矩阵即可。<br><img src="https://img.mahaofei.com/img/202112231015231-numerical-recipe-49.png" alt=""><br><strong>3、如何生成Ruvw矩阵</strong><br>法一：<br>（1）先单位化已知矢量z<br>（2）然后把已知矢量z中的其中一个坐标变为1，这样就获得了两个在同一平面的向量<br>（3）然后用这两个向量叉乘，得到的结果就是和已知矢量z垂直的矢量y<br>（4）然后再用已知矢量z叉乘刚获得的向量y，得到与这两个向量都垂直的向量x。<br>（5）如此，将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br><img src="https://img.mahaofei.com/img/202112231016083-numerical-recipe-50.png" alt=""><br>法二：知道给定矢量的三个坐标(Zx,Zy,Zz),则和这个矢量垂直的向量之一的坐标是(Zy,-Zx,0)，这样同样可以获得两个相互垂直的矢量，然后这俩矢量叉乘得到第三个矢量，即为三坐标轴。将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br>（注：代表新坐标轴的三个矢量均需要单位化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此为法二的代码，其中Rotation+4等地方用到了指针的技巧</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RotateCoor</span><span class="params">(<span class="type">float</span> *z,<span class="type">float</span> *Rotation)</span></span><br><span class="line">&#123;</span><br><span class="line">Rotation[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">Rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">Normalize(z);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">Rotation[<span class="number">8</span>+i] = z[i];</span><br><span class="line">Rotation[<span class="number">4</span>] = -z[<span class="number">1</span>];</span><br><span class="line">Rotation[<span class="number">5</span>] = z[<span class="number">0</span>];</span><br><span class="line">Normalize(Rotation+<span class="number">4</span>);</span><br><span class="line">crossproject(z,Rotation+<span class="number">4</span>,Rotation);</span><br><span class="line">Normalize(Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231016916-numerical-recipe-51.png" alt=""><br>上图矩阵即为坐标系旋转操作矩阵，<strong>和之前平移与旋转一样</strong>，用<strong>这个矩阵×P0点</strong>，即可得到<strong>坐标轴旋转后的点P1</strong></p><h2 id="让图形显示在屏幕中心且绕中心转动">让图形显示在屏幕中心且绕中心转动</h2><p>1.首先我们要知道，OpenGL生成的对话框的长和宽是可以设置的，我们需要让对话框的宽高比与我们要生成的图像的宽高比相同，并且对话框要比图像稍大一些。<br>2、具体如下思路：<br>设模型的高为ModelHeight，宽为ModelWidth，生成的空间高为h，宽为w<br><strong>如果ModelHeight/h &gt; ModelWidth/w，说明对话框比较高（模型比较宽），因此要尽可能满足模型的宽</strong>，比如让<strong>对话框的宽为模型宽的2.5倍</strong>（让对话框稍大一些），则<strong>对话框的高就为 对话框的高/模型的高 * 模型的宽</strong>。<br>同理对话框比较扁也可以得到对称的结论，因此，用计算得到的对话框的宽和高就可生成一个合适的对话框。<br>3、如何编程更改对话框大小：<br>打开之前加载泵体的那个文件(chapt05\shinyjet)更改ChangeSize函数为以下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ChangeSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span><br><span class="line">    &#123;</span><br><span class="line">    GLfloat fAspect;</span><br><span class="line">    GLfloat lightPos[] = &#123; <span class="number">-50.f</span>, <span class="number">50.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a divide by zero</span></span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span>)</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Viewport to window dimensions</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset coordinate system</span></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fAspect = (GLfloat) w / (GLfloat) h;</span><br><span class="line"><span class="comment">// Establish clipping volume (left, right, bottom, top, near, far)</span></span><br><span class="line"><span class="comment">//aspectRatio = (GLfloat)w / (GLfloat)h;</span></span><br><span class="line"><span class="comment">//这之上都不用动</span></span><br><span class="line"><span class="type">float</span> scale = <span class="number">2.5</span>;</span><br><span class="line"><span class="comment">//对话框与模型大小比例为2.5倍</span></span><br><span class="line"><span class="type">float</span> ScaleHeight,ScaleWidth,ModelWidth,ModelHeight;</span><br><span class="line"><span class="comment">//定义对话框的宽高，模型的宽高</span></span><br><span class="line">ModelWidth = PointMax[<span class="number">0</span>]-PointMin[<span class="number">0</span>];</span><br><span class="line">ModelHeight = PointMax[<span class="number">1</span>]-PointMin[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//模型宽的计算可由模型上最右的点坐标减最左点的坐标</span></span><br><span class="line"><span class="keyword">if</span>(w*ModelHeight &gt; h*ModelWidth)</span><br><span class="line">&#123;<span class="comment">//当ModelHeight/h &gt; ModelWidth/w时，模型比较宽，对话框比较高</span></span><br><span class="line">ScaleHeight = scale * ModelHeight;</span><br><span class="line"><span class="comment">//设置对话框的宽为模型宽的2.5倍</span></span><br><span class="line">ScaleWidth =  scale * ModelHeight * w / h;</span><br><span class="line"><span class="comment">//对话框的高为 对话框的高/模型的高 * 模型的宽</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ScaleWidth =  scale * ModelWidth;</span><br><span class="line">ScaleHeight = scale * ModelWidth * h / w;</span><br><span class="line">&#125;</span><br><span class="line">glOrtho(<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">-2.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//定出模型的中心坐标，下面代码就根据中心坐标生成一个与模型中心位置相同的对话框</span></span><br><span class="line"><span class="comment">//这之下都不用动</span></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    </span><br><span class="line">    glLightfv(GL_LIGHT0,GL_POSITION,lightPos);</span><br><span class="line">    <span class="comment">//glTranslatef(0.0f, 0.0f, -150.0f);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、如何编程找出模型上对角线的两个点<br>将之前写过的读取文件里点的坐标的那个while循环中添加一部分内容，改成如下形式，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//以下为新加内容，作用为找到对角线上的两个点，存到PointMin和PointMax里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMin[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMax[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上为新加内容</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>,n);</span><br><span class="line">glEnd();</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line">（注意，因为PointMin和PointMax既在SetupRC函数里使用又在Changesize函数里使用，故需要定义为全局变量，如下<span class="type">float</span> PointMin[<span class="number">3</span>] = &#123;<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f&#125;;<span class="type">float</span> PointMax[<span class="number">3</span>] = &#123;<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f&#125;;）</span><br></pre></td></tr></table></figure><p>5、现在看起来可以了，我们把对话框设置成了和模型等比例，对称中心重合，但还需要更改一个地方就是，我们生成的<strong>模型中心和我们旋转轴的中心不是重合的</strong>，我们如何实现按下键盘时，让模型绕原点转动，而不是绕其他轴运动。<br>具体思路就是，我们<strong>要让模型绕自己中心旋转，可以先把模型平移到坐标轴原点处（原点与模型中心重合），进行旋转，然后在平移回原来位置，这样看上去就是模型绕自己中心旋转了</strong>，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">glPushMatrix();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glCallList(DrawList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the matrix state</span></span><br><span class="line">glPopMatrix();</span><br><span class="line"><span class="comment">// Display the results</span></span><br><span class="line">glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改这三个地方就实现了让模型能够正常的显示在屏幕中心且绕模型自己的中心转动</p><h1>Chapter 8 造小车</h1><h2 id="装配一个小车">装配一个小车</h2><p>组装小车开始了<br>在学习本节内容之前，<strong>请先掌握装载泵体模型的相关操作</strong><br>1.原理部分：我们知道了如何将一个模型文件装载进来同时显示出来，主要步骤是<strong>先新建一个列表DrawList</strong>，然后<strong>将模型存入此列表中</strong>，最后在<strong>通过glCallList()函数召唤列表即可生成一个模型</strong>。现在我们要做的就是同时生成许多个模型，那么<strong>如何同时生成许多模型呢，只要新建许多列表，然后把它们一个一个召唤出来（glCallList）就可以了</strong>。<br>2.既然我们需要新建好多个列表，那么我们最好定义一个函数用于生成列表，不然一大段代码赋值五六遍可不是一般的长。把之前在SetupRC函数里的新建列表的代码移出来，稍加修改封装成一个函数。新建列表的代码如下说明一下，函数第一个参数是文件名，也就是”&quot;F:\Works\Practice\数字化方法\Shove\Shovel.STL&quot;像这样的字符串，后面三个参数是RGB颜色，用于设置生成的模型的颜色，毕竟你也不想让整个小车变成一个颜色吧。最后一个参数是定义的列表变量的地址，或者说列表变量的指针<br>（注：为什么要用指针呢，我jo得这个可以参考上学期C++课上的内容，函数的形参只在函数体内有效，比如在主函数里定义了一个变量，把它传给一个函数并在函数内部改变它的值，主函数内的变量的值不会发生改变，因此只有把地址传过去才可以正常新建列表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatGLList</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> R,<span class="type">int</span> G,<span class="type">int</span> B,GLuint *listname)</span></span><br><span class="line">&#123;</span><br><span class="line">ifstream <span class="title function_">in</span><span class="params">(filename)</span>;</span><br><span class="line"><span class="comment">//要读取的文件是filename，例如如果参数是</span></span><br><span class="line"><span class="comment">//&quot;F:\\Works\\Practice\\数字化方法\\Shove\\Shovel.STL&quot;，</span></span><br><span class="line"><span class="comment">//那么会读取F:\\Works\\Practice\\数字化方法\\Shove这个目录下的Shove1.STL文件。</span></span><br><span class="line"><span class="keyword">if</span> (!in)</span><br><span class="line">_ASSERT(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> String0[<span class="number">30</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line"></span><br><span class="line">*listname = glGenLists(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//参数listname是一个指针，*listname才是列表变量</span></span><br><span class="line"><span class="type">float</span> Points[<span class="number">12</span>];</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">glNewList(*listname,GL_COMPILE);</span><br><span class="line">glPolygonMode(GL_BACK,GL_LINE);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMin[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMax[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glColor3ub(R,G,B);</span><br><span class="line"><span class="comment">//根据函数的参数设置模型颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line">glEnd();</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glEndList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们有了新建列表的函数之后，然后就可以加载文件了……吗？注意，<strong>在使用函数之前先在文件开头定义几个列表变量（GLuint类型变量）</strong>，这个几个变量是用来存放各个模型的，没有这些变量就调用函数，软件会在参数上划红线，也就是它不知道把模型读取进来之后存到哪里去。<br><img src="https://img.mahaofei.com/img/202112231016256-numerical-recipe-52.png" alt=""><br>做好了这两个准备工作之后就可以开始新建模型列表and召唤模型列表了。在SetupRC函数原来加载文件的那个地方就可以用一句简单的CreatGLList(“F:\Works\Practice\数字化方法\Shove\Shovel.STL”,255,255,0,&amp;Shove);代替了。<strong>新建六个模型列表就用六次这个函数就可以了</strong>，比直接复制一大段读取模型的文件简化了不少。就像下面这样<br><img src="https://img.mahaofei.com/img/202112231017247-numerical-recipe-53.png" alt=""><br>建好了这六个模型列表，那我们就可以直接召唤它们了，在RenderScene函数里直接调用六个glCallList就可以把这六个模型召唤出来了<br><img src="https://img.mahaofei.com/img/202112231017471-numerical-recipe-54.png" alt=""><br>这么召唤神龙，sorry召唤模型，出来就直接是装配好的小车的样子，（虽然我也不知是为什么<br>这一节到此为止。</p><h2 id="让小车动起来">让小车动起来</h2><p>本节的目的是让小车动起来！难度稍大，各位仔细听我娓娓道来<br>1、理论部分，我们想让这个模型通过按键盘上不同的按键让他动起来，肯定要有<strong>函数用来读取按键</strong>，<strong>读取之后利用平移旋转之类的矩阵各个部分运动起来</strong>。<br>2、键盘部分：在写函数之前先在文件开头定义一些全局变量（各部分的转动角度），用于以后的旋转矩阵。<br><img src="https://img.mahaofei.com/img/202112231018223-numerical-recipe-55.png" alt=""><br>然后我们先写一下读取按键的函数。请大家先在最下方main函数里添加如下的一行代码，这个是库函数，用于读取按键的。<br><img src="https://img.mahaofei.com/img/202112231018145-numerical-recipe-56.png" alt=""><br>然后在前面我们定义一个函数名叫keyboard，函数内容如下，函数体是有重复的代码组成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">keyboard</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key,<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> ShoveStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//定义一个静态变量（下一次进入函数，变量内容保持不变）</span></span><br><span class="line"><span class="comment">//步长为3.0f，即设定按一下按键角度变化3度</span></span><br><span class="line"><span class="keyword">if</span>(ShoveRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">ShoveRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ShoveRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">ShoveRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//这里作用是防止模型出现失真（比如铲子转着转着转到驾驶舱里去了）</span></span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:ShoveRot+=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:ShoveRot-=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是“某一按键”，是的话相应部分的转动角度增加（减少）一个步长。</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MainLinkStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(MainLinkRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">MainLinkRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MainLinkRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">MainLinkRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:MainLinkRot+=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:MainLinkRot-=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MainBodyStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(MainBodyRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">MainBodyRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MainBodyRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">MainBodyRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:MainBodyRot+=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:MainBodyRot-=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> GroundStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(GroundRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">GroundRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(GroundRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">GroundRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:GroundRot+=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:GroundRot-=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> FrontWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(FrontWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">FrontWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(FrontWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">FrontWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:FrontWheelsRot+=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:FrontWheelsRot-=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> BackWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(BackWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">BackWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(BackWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">BackWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:BackWheelsRot+=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:BackWheelsRot-=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就成功的读取到了按键并能够根据按键的不同，相应的角度变量发生改变（函数中的按键可以自己设置，根据个人喜好）<br>3、矩阵操作部分<br>首先来了解一下几个函数的用法<br><strong>glLoadIdentity();生成一个单位阵并设置为当前阵<br>glPushMatrix();保存当前的矩阵到一个不知名的地方<br>glPopMatrix();设置之前保存的矩阵为当前阵<br>glMultMatrixf(A);用A矩阵乘当前阵，结果设置为当前阵<br>glRotatef(角度值,0.0f,1.0f,0.0f);后面三个参数若第一个为1，则绕x轴旋转，第二个为1则绕y轴旋转，第三个为1则绕z轴旋转。</strong><br>还有一个平移的库函数我没记住；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">glPushMatrix();</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glPushMatrix();</span><br><span class="line">glCallList(MainBody);</span><br><span class="line"></span><br><span class="line">glPopMatrix();</span><br><span class="line">glPushMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-4.89</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">4.89</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(BackWheels);</span><br><span class="line"></span><br><span class="line">glLoadIdentity();</span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glPushMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-6.63</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">6.63</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(FrontWheels);</span><br><span class="line"></span><br><span class="line">    glPopMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="type">float</span>(<span class="number">-10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glRotatef(GroundRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="type">float</span>(<span class="number">10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(Ground);</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">21.74</span>/<span class="number">1000</span>),<span class="type">float</span>(<span class="number">4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(MainLinkRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-21.74</span>/<span class="number">1000</span>),<span class="type">float</span>(<span class="number">-4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(MainLink);</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">31.74</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-31.74</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(Shove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the matrix state</span></span><br><span class="line">glPopMatrix();</span><br><span class="line"><span class="comment">// Display the results</span></span><br><span class="line">glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码都可在博客开头的网盘里自行提取<br><img src="https://img.mahaofei.com/img/202112231018833-numerical-recipe-57.png" alt=""><br>（2）主体和两个轮子要和（1）分开，因为他们的位移没有叠加关系，具体可用glPushMatrix();和glPopMatrix();实现<br>这部分程序我自己理解的并不是很透彻，如有问题or不懂的请单独找我。</p><p><em><strong>Continue……</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 编程基础 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【论文笔记】面向非结构化环境的机器人6D抓取技术研究</title>
      <link href="/post/ff098567.html"/>
      <url>/post/ff098567.html</url>
      
        <content type="html"><![CDATA[<p>针对非结构化环境中抓取物体的问题，从以下四个方面展开研究，并在相关开源算法的基础上进行改进。</p><ol><li>实例分割（SOLOv2）</li><li>位姿估计（Contact-GraspNet）</li><li>地图构建（Otomap）</li><li>运动规划（GRRT-Connect）</li></ol><h1>一、研究现状</h1><h2 id="2-1-物体识别与位姿估计">2.1 物体识别与位姿估计</h2><p>物体识别：</p><ul><li>两阶段方法：RCNN</li><li>单阶段方法：YOLO，SSD</li></ul><p>位姿估计：</p><ul><li>基于点对应</li><li>基于投票</li><li>基于回归</li></ul><p>代表性工作：</p><ul><li>PoseCNN：三个分支完成语义分割，位置预测（霍夫投票）、姿态预测（池化+回归）</li><li>6-PACK：使用立方体包络框表示物体，引入anchor机制，无需三维模型</li><li>DenseFusion：RGB和点云融合，实现端到端的训练</li></ul><blockquote><ol><li><p>什么是霍夫投票？</p></li><li><p>为什么anchor机制可以无需三维模型估计位姿？</p></li></ol></blockquote><h2 id="2-2-端到端的抓取估计">2.2 端到端的抓取估计</h2><p>代表性工作：</p><ul><li>GQ-CNN：抓取采样（获得多个候选抓取配置），质量评估</li><li>GPD：不需要分割对象</li><li>PointNetGPD：对局部结构进行特征提取和表征</li><li>RegNet：抓取点置信度预测网络+抓取区域生成网络+抓取校正网络</li></ul><h1>二、基于SOLOv2的目标识别及分割</h1><h2 id="2-1-实例分割算法简介">2.1 实例分割算法简介</h2><p>实力分割可以按以下方式分类：</p><ul><li>两阶段方法<ul><li>自顶向下：先确定物体所在区域，再在区域内进行语义分割</li><li>自底向上：先进性像素级别的语义分割，再学习区分不同实例</li></ul></li><li>单阶段方法</li></ul><p>相关算法</p><ul><li>Mask RCNN：分成目标检测分支和mask预测分支实现</li><li>Yolact：分为生成原型掩膜和生成掩膜系数两个字任务并行运行</li><li>PolarMask：将实力分割和目标检测任务采用相同的建模方式</li><li>BlendMask：融合实例级注意力信息和低级别语义信息改进掩码预测</li></ul><h2 id="2-2-SOLOv2">2.2 SOLOv2</h2><p>SOLOv2是，无候选框，单阶段的实例分割算法。</p><h3 id="2-2-1-网络结构">2.2.1 网络结构</h3><p><strong>SOLOv1的网络结构</strong></p><ul><li>backbone：通过卷积、池化、残差网络、激活函数等单元对图像特征进行提取，采用ResNet50或ResNet101</li><li>FPN网络：建立特征金字塔，将低层特征和高层特征进行融合</li><li>SOLO head：分为两个分支，类别预测分支和掩膜预测分支。类别预测分支输出的维度是SxSxC，特征图被分为SxS网格，每个通道表示物体属于某一类别的置信度。掩膜预测分支输出HxWxS^2的特征图，H和W为特征图的高和宽，通道数S^2为可以预测的最大掩膜数量。</li></ul><p><img src="https://img.mahaofei.com/img/20220704211545.png" alt=""></p><p><strong>SOLOv2网络结构改进</strong></p><ul><li>掩膜预测分支使用Decoupled SOLO结构进行改进，将通道数由S^2将为2S。</li><li>提出了动态预测掩膜的方法，将掩膜预测分支划分为卷积核预测分支和掩膜特征预测分支，掩膜通过卷积核和掩膜特征图卷积得到。</li></ul><p><img src="https://img.mahaofei.com/img/20220704212325.png" alt=""></p><h3 id="2-2-2-非极大值抑制算法">2.2.2 非极大值抑制算法</h3><p>非极大值抑制算法NMS，主要作用是筛选出局部极大值，抑制非极大值，通过NMS算法可以筛选出得分最高的检测框。</p><p>Soft NMS算法通过引入置信度防止两个目标接近情况下其中一个检测框被抑制的情况。</p><p>Matrix NMS算法，使用矩阵并行运算极大提高了算法运行速度，可以在1ms内处理500个mask。</p><p>一个预测的掩膜$m_j$被抑制的因素归为两方面：</p><ul><li>每个预测的掩膜$m_i$对$m_j$的惩罚</li><li>$m_i$本身被抑制的概率</li></ul><p>如果$m_i$被抑制，那么它对$m_j$的惩罚将不存在。而$m_i$被抑制的概率与掩膜之间的交并比IOU最大值正相关。</p><h3 id="2-2-3-正负样本分配策略和损失函数设计">2.2.3 正负样本分配策略和损失函数设计</h3><p>目标检测算法采用的正负样本分配策略通常是当网格落入任何物体的真实中心区域，那么就将其视为正样本，反之则为负样本，通过实验验证这种设计通常是最有效的。SOLOv2算法采用类似的策略。</p><p>物体的真实区域设置为S，S为以掩膜中心位置$(c_x, c_y)$为中心，宽高为$(\epsilon w, \epsilon h)$的矩形区域，其中$\epsilon=0.2$，$w, h$为真是淹没的宽高</p><p>$S=(c_x, c_y, \epsilon w, \epsilon h)$</p><p>若网格$(i, j)$落在任何物体的真是区域中，就可以将类别预测分支的该位置和掩膜预测分支的对应通道设置为正样本，反之为负样本。</p><h3 id="2-2-4-图像增广">2.2.4 图像增广</h3><p>图像增广技术可以分为在线增广和离线增广。在线增广即在模型训练过程中同时使用图像增广技术，在图像输入模型前对其进行增广。离线增广技术是在模型训练之前就对数据进行增广。</p><p><strong>（1）图像增广技术</strong></p><ol><li>旋转和裁剪，通过翻转和裁剪可以有效降低模型对物体位置的依赖性；</li><li>亮度和色彩变换，可以有效降低模型对色彩、光照的敏感程度；</li><li>噪点引入，可以增强模型对图像噪声的抗干扰性；其他常见的技术还有锐化、对比度增强、仿射变换等等。</li></ol><p><img src="https://img.mahaofei.com/img/20220704215124.png" alt=""></p><p><strong>（2）应对遮挡</strong></p><p>本项目引入了两项应对遮挡的图像增广技术，分别是Cutout和GridMask。</p><p>Cutout就是模拟遮挡情况，实现方法是在图像中随机选取一块方形区域，采用全0或其他纯色值填充，通过实验验证Cutout可以较好地提升模型的泛化能力。</p><p>GridMask是在Cutout的基础上进行改进，因为Cutout的方形区域时随机的，因此可能会出现对重要特征全部遮盖的情况，GridMask采用排列的正方形区域进行掩码，实现对特定区域信息的dropout。</p><p><img src="https://img.mahaofei.com/img/20220704215141.png" alt=""></p><p><strong>（3）迁移学习</strong></p><p>本项目中通过使用在coco数据集中预训练的网络参数进行迁移，迁移至实验数据集中进行训练，模型可以基于COCO数据集学习到大量特征，具备极强的泛化能力，经过较短时间的训练即在本文数据集上达到预期的精度。</p><h1>三、抓取估计</h1><h2 id="3-1-任务分析">3.1 任务分析</h2><p>输入：<br>RGB-D 图像</p><p>已有：<br>SOLOv2得到的物体语义信息和位置</p><p>问题：<br>获取目标物体的6D数据，并计算抓取位姿</p><p>6D抓取估计方法：</p><ul><li>基于已知模型的方法<ul><li>过程：先进性物体位姿估计，再进行抓取匹配</li><li>优点：直接从数据库中搜索对应的模型和抓取，速度快，精度高</li><li>缺点：无法对未知物体进行抓取，准确性依赖于物体位姿估计的结果</li></ul></li><li>基于无模型的方法<ul><li>过程：端到端，从点云数据直接生成抓取预测，并进行抓取评估</li><li>缺点：需要大量数据训练来提高鲁棒性和精度</li></ul></li></ul><h2 id="3-2-抓取生成网络">3.2 抓取生成网络</h2><p>使用基于PointNet改进的分层级点云处理网络，进行点云特征提取和分割。由前半部分的分层级特征提取网络和后半部分的全连接分类网络或上采样分割网络组成。</p><p><strong>（1）网络基础</strong></p><p>分层级特征提取网络：</p><ol><li>采样层：对点云使用FPS算法进行降采样，减少计算负荷</li><li>组合层：以采样的C1为中心，在初始点云C中寻找K个邻域点，以覆盖点云的局部特征</li><li>特征提取层：通过小型PointClond层提取点云组的特征</li></ol><blockquote><p>FPS算法：先在初始点云C中随机选取一点p0，将其加入到集合C1中，然后计算C中所有点与P0的距离，选择距离最远的作为p1，将其添加到集合中，以此往复。</p></blockquote><p>将采样得到的点作为抓取接触点，抓取位姿$[R_g,t_g]$定义如下</p><p>$t_g=c+\frac{w}{2}-dz$</p><p>$R_g=[x, x\times z, z]$</p><p>c——即夹爪闭合时和物体的接触点；<br>x——二指夹爪的平行钳口方向( 轴)， ；<br>z——夹爪接近物体的方向( 轴)， ；<br>w——夹爪抓取的宽度；<br>d——夹爪的长度；<br><img src="https://img.mahaofei.com/img/20220820141021.png" alt=""></p><p><strong>（2）网络结构</strong></p><p>Contact-GraspNet网络结构由PointNet++主干网络和四个分支预测网络组成。</p><p>网络的输入为单视角点云、彩色图、深度图。</p><p>四个分支网络分别用于预测抓取方向Grasp_x、抓取方向Grasp_z，抓取预测分数Score、抓取宽度Width。</p><p>总体流程如下：</p><ol><li>输入：从场景点云中选取20000个点作为网络输入</li><li>PointNet++：降采样得到2048个抓取接触点，提取得到特征</li><li>预测分支：将特征输入，获得x、z方向预测、抓取分数和抓取宽度</li><li>汇总：将所有分支输出与接触点联合计算得到抓取集合</li></ol><h1>四、运动规划</h1><h2 id="4-1-基于Octomap的规划地图构建">4.1 基于Octomap的规划地图构建</h2><p>Octomap八叉树地图是机械臂运动规划、SLAM领域复杂地图构建的最佳方式之一。</p><p>Octomap的底层数据结构是Octree八叉树，以Octree表示层级结构。三维空间可以分为8个象限，每个子象限又可以分为8个象限，只要未达到最大递归深度就可以一直划分。</p><p><img src="https://img.mahaofei.com/img/20220821154602.png" alt=""></p><p>Octomap将空间划分为三维体素网格，每一个体素有两种状态，free自由用0表示，occupied被占据用1表示。根据点云观测数据确定体素是否被占据，通过使用Ray-Casting算法，以相机光心为起点，点云中每个点为终点，形成一组射线，射线经过的体素就是非占据free状态。</p><p><img src="https://img.mahaofei.com/img/20220821154609.png" alt=""></p><p><strong>深度图修复</strong></p><p>使用RGB-D相机采集的深度图在物体的边界存在空洞缺陷，通过双滤波核修复算法可以有效填充物体边界的空洞区域。</p><p><strong>原理</strong>：遍历深度图所有像素，当出现像素值为0（空洞）时，统计以其为中心，滤波核大小范围内不为0的像素值及出现频率，选择出现最多的替代当前像素。</p><p><strong>双滤波核</strong>：先对小空洞区域使用小滤波核3x3修复，例如边缘部分；对于大空洞区域使用大滤波核5x5修复，减少误差。</p><h2 id="4-2-基于GRRT-Connect的机器人运动规划算法">4.2 基于GRRT-Connect的机器人运动规划算法</h2><p><strong>（1）概述</strong></p><p>运动规划算法主要分为两类：</p><ul><li>基于图搜索<ul><li>原理：将空间用离散状态进行表示</li><li>优点：可以寻找出最优解</li><li>缺点：计算代价较大</li><li>算法：Dijkstra算法、A*算法</li></ul></li><li>基于随机采样<ul><li>原理：对状态空间进行随机采样</li><li>优点：可以直接在构形空间进行规划，将动力学约束考虑在内</li><li>缺点：存在概率非完备或规划非最优问题</li><li>算法：快速扩展随机树RRT系列算法、概率路径图PRM系列算法、ABIT*算法、BIT*算法</li></ul></li></ul><p><strong>（2）RRT算法原理</strong></p><p><strong>RRT</strong></p><p>快速扩展随机数算法的核心思想就是通过随机采样探索未知空间，利用树形结构维护已知状态节点。</p><p><img src="https://img.mahaofei.com/img/20220821165116.png" alt=""></p><p>RRT算法随机生成采样点 $q_{rand}$，然后遍历树中的节点找到离$q_{rand}$最近的节点${q_{near}}$ ，以$q_{near}$为起点向$q_{ramd}$方向生长stride的距离得到一个新的节点$q_{new}$ ，如果$q_{near}$和$q_{new}$的连线不会与状态空间中的障碍物发生碰撞，就将连线和节点$q_{new}$加入扩展树，重复这个过程。</p><p><strong>RRT-Connect</strong></p><p>通过双树同时对空间进行探索，一棵以起始点为根节点进行生长，另一棵以目标点为根节点进行生长。当两棵树连接到一起时，路径搜索完成。</p><p><strong>GRRT-Connect</strong></p><p>贪婪式快速扩展随机树算法主要通过两个方法进行优化：</p><ul><li>贪婪式步长递增：如果不发生碰撞，随机树一直往目标节点生长。并引入补偿增长因子$g_{rate}$，每生长一个节点就将步长stride乘以$g_{rate}$，如果与障碍物发生碰撞，则将步长stride回归到初始值，通过这种步长倍增的方式可以加快节点的连接速度并减少节点的产生。</li><li>贪婪式二分剪枝策略：每次迭代尝试将当前节点与目标节点相连，如果不予障碍物发生碰撞则删除两者之间的节点，进行剪枝。否则采用二分法将目标点设置成两者中间路径上的节点，重复过程知道目标点与当前点相邻。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 机器人抓取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【6D位姿估计算法】DenseFusion代码结构</title>
      <link href="/post/2f1e8a35.html"/>
      <url>/post/2f1e8a35.html</url>
      
        <content type="html"><![CDATA[<h1>一、数据读取</h1><h2 id="1-1-train-py中的数据加载">1.1 train.py中的数据加载</h2><p><strong>数据集定义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载训练数据集和测试数据集</span></span><br><span class="line"><span class="keyword">if</span> opt.dataset == <span class="string">&#x27;ycb&#x27;</span>:</span><br><span class="line">    dataset = PoseDataset_ycb(<span class="string">&#x27;train&#x27;</span>, opt.num_points, <span class="literal">True</span>, opt.dataset_root, opt.noise_trans, opt.refine_start)</span><br><span class="line"><span class="keyword">elif</span> opt.dataset == <span class="string">&#x27;linemod&#x27;</span>:</span><br><span class="line">    dataset = PoseDataset_linemod(<span class="string">&#x27;train&#x27;</span>, opt.num_points, <span class="literal">True</span>, opt.dataset_root, opt.noise_trans, opt.refine_start)</span><br><span class="line"><span class="comment"># dataloader使用opt.workers个进程加速读取数据</span></span><br><span class="line">dataloader = torch.utils.data.DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">True</span>, num_workers=opt.workers)</span><br><span class="line"><span class="keyword">if</span> opt.dataset == <span class="string">&#x27;ycb&#x27;</span>:</span><br><span class="line">    test_dataset = PoseDataset_ycb(<span class="string">&#x27;test&#x27;</span>, opt.num_points, <span class="literal">False</span>, opt.dataset_root, <span class="number">0.0</span>, opt.refine_start)</span><br><span class="line"><span class="keyword">elif</span> opt.dataset == <span class="string">&#x27;linemod&#x27;</span>:</span><br><span class="line">    test_dataset = PoseDataset_linemod(<span class="string">&#x27;test&#x27;</span>, opt.num_points, <span class="literal">False</span>, opt.dataset_root, <span class="number">0.0</span>, opt.refine_start)</span><br><span class="line">testdataloader = torch.utils.data.DataLoader(test_dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, num_workers=opt.workers)</span><br></pre></td></tr></table></figure><p><strong>数据读取</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader, <span class="number">0</span>):</span><br><span class="line">points, choose, img, target, model_points, idx = data</span><br></pre></td></tr></table></figure><h2 id="1-2-dataset-py数据读取">1.2 dataset.py数据读取</h2><h3 id="1-2-1-初始化">1.2.1 初始化</h3><p><strong>（1）参数输入</strong></p><ul><li>mode：模式，共有三种，train、test、eval</li><li>num：输入的点云个数（这里linemod默认500个）</li><li>add_noise：是否加入噪声（实验中将train加入噪声，test和eval不加入）</li><li>root：数据集的根目录</li><li>noise_trans：噪声超参数</li><li>refine：是否启用refine过程</li></ul><p><strong>（2）加载数据集文件</strong></p><p>针对数据集中每一个文件夹（物体类别序号），开始读取。</p><p>首先根据mode模式参数不同，获取train.txt或者test.txt，即得到哪些图片模型文件是要被读取来进行训练或测试的。这里train读取train.txt，test和eval模式都读取test.txt。每读取一行train.txt或test.txt：</p><ul><li>添加RGB图、深度图、mask标签图的路径到三个列表（list_rgb、list_depth、list_label）中，其中mask标签图如果是eval模式，则添加语义分割后的mask标签，如果是train或test模式，就添加标准的mask。</li><li>添加类别号list_obj</li><li>添加图片编号list_rank<br>（这里的几个列表按顺序保存了所有物体的txt对应的图片）</li></ul><p>然后加载该物体类别的元数据信息meta，包括每一个图像的旋转矩阵、平移矩阵、包围矩形框的坐标、物体类别号。（每个meta[item]保存了一个物体item的元数据）</p><p>最后加载该物体的三维点云文件。（每个pt[item]保存了一个物体item的点云）</p><p><strong>（3）初始化参数</strong></p><p>初始化设置一些参数：</p><ul><li>相机内参</li><li>xmap，ymap：xmap 数组的第 i 行和第 j 列的值为j，ymap 数组的第 i 行和第 j 列的值为i</li><li>图像调整参数trancolor，通过颜色变换可以使图像变得更随机，从而防止模型对数据集过度拟合，作为噪声项根据需要添加。</li><li>图像归一化参数，通过归一化可以是模型在训练的时候更快的收敛，并降低对输入数据的敏感度</li><li>图像分割列表，将图像分成多块</li><li>点云最大数量、最小数量</li><li>对陈物体的序号</li></ul><h3 id="1-2-2-数据集读取函数">1.2.2 数据集读取函数</h3><p>当train.py使用dataloader读取数据时，每迭代一次，调用数据集类的def getitem(self, index)返回一组数据信息。</p><ul><li>cloud：深度图+内参计算的点云</li><li>choose：用于选取的choose列表</li><li>img_masked：物体所在标准包围框的RGB图</li><li>target：模型点云齐次变换后的点云</li><li>model_points：模型点云</li><li>self.objlist.index(obj)：该物体在objlist的索引</li></ul><p><strong>（1）加载图片</strong></p><p>使用PIL的Image模块加载当前索引批次的RGB图片、深度图、mask标签图、类别号、图片序号信息。并且要保证mask标签图也是BRG三通道图。</p><p>根据物体类别号和图片序号，在meta中找到当前数据批次对应的元数据</p><p><strong>（2）获取掩码（得到物体所在的标准大小矩形区域）</strong></p><p>获取深度图的掩码，根据深度图上每个像素的值是否为0，来构造一个掩码，以确定深度图上的哪些像素值有效，哪些像素值无效。掩码是一个布尔数组，其中的值为True的元素表示相应位置的值有效，值为False的元素表示相应位置的值无效。</p><p>获取mask掩码，将实例分割后的结果(eval)，或者标准mask(train/test)中值为255的像素作为掩码保存在mask_label数组中，并转换为1通道。</p><p>取两个掩码图的交集作为mask，其中depth为true代表深度值有效，label为true代表此处有物体</p><p>根据超参数确定是否为RGB添加噪声（改变亮度、对比度、饱和度、色调），然后提取RGB图的前三个通道，并将图像的维度从(height, width, channel)转换为(channel, height, width)。很多图像处理的库都把通道数放在第1维，这样可以方便地对每一个通道进行操作。</p><p>根据元数据中的包围框坐标，或eval时使用mask_to_bbox获取mask图像中物体的包围框，利用get_bbox将包围框转换为标准大小的包围框（标准大小在border_list中定义）。</p><p>利用标准大小的包围框获取RGB图像中物体所在的矩形区域。</p><p><strong>（3）获得物体上500个随机点的x、y、深度值点云</strong></p><p>将物体所在标准包围框区域的mask展开到1维，选取为true的部分的下标，赋值给choose，此时choose就是所有非零元素的下标的数组。</p><ul><li>如果choose长为0，则返回6个0张量</li><li>如果choose超过500，则随机选取500个作为choose</li><li>如果choose介于0-500个，则使用warp模式填充[1,2,3] -&gt; [1,2,3,1,2,3,…]</li></ul><p>根据物体所在标准包围框，获得对应区域的深度图，并展开至1维，然后使用choose进行索引，得到choose的深度值，然后转换为列向量。对xmap和ymap进行同样的操作。</p><p>利用相机参数，以及choose点的x、y、深度，计算choose的500个点的相机坐标系下的三维坐标，并将x、y、深度三个列向量(500,1)拼接为(500,3)的点云cloud。</p><p>根据超参数判断是否为x、y、depth点云添加噪声</p><p><strong>（4）读取模型点云和齐次变换后的模型点云</strong></p><p>读取该物体的模型点云（从ply文件中读取），在点云中随机删除，最后只留下500个点云。</p><p>从元数据中读取真实的旋转矩阵、平移矩阵。利用齐次变换得到当前姿态的点云target。</p><p>根据超参数判断是否为模型变换得到的点云target添加噪声</p><h1>二、网络模型</h1><h2 id="2-1-模型定义">2.1 模型定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># estimator为PoseNet网络，即用于预测姿态的主干网络</span></span><br><span class="line">estimator = PoseNet(num_points = opt.num_points, num_obj = opt.num_objects)</span><br><span class="line">estimator.cuda()</span><br><span class="line"><span class="comment"># refiner为PoseRefineNet网络，用于后续迭代自优化</span></span><br><span class="line">refiner = PoseRefineNet(num_points = opt.num_points, num_obj = opt.num_objects)</span><br><span class="line">refiner.cuda()</span><br></pre></td></tr></table></figure><h2 id="2-2-修改ResNet-18网络">2.2 修改ResNet-18网络</h2><p>定义一个ModifiedResnet网络，将ResNet-18网络模型转换为nn.DataParallel模型，便于在多GPU下训练。</p><p>网络输入一个特征向量，返回一个经修改的ResNet-18网络的特征向量。</p><h2 id="2-3-PoseNetFeat特征融合网络">2.3 PoseNetFeat特征融合网络</h2><p>输入</p><ul><li>x (batchsize,3,500)，由xydepth生成的三维点云</li><li>emb (batchsize,di(32),500)，标准包围框区域的RGB图像，经过ModifiedResnet得到的特征图，经过choose选择后的特征<br>输出</li><li>前向计算得到(batchsize, 128+256+1024,500)的向量，64x2通道特征+128x2通道特征+1024通道全局特征</li></ul><h2 id="2-4-PoseNet姿态提取网络">2.4 PoseNet姿态提取网络</h2><p>输入</p><ul><li>img (batchsize, w, h)，标准包围框区域的RGB图像</li><li>x (batchsize,500,3)，由xydepth生成的三维点云</li><li>choose (batchsize,1,500)，选择数组</li><li>obj (batchsize, 1)，物体索引序号<br>输出</li><li>out_rx (1,500,4)，回归得到的四元数</li><li>out_tx (1,500,3)，回归得到的平移变量</li><li>out_cx (1,500,1)，回归得到的置信度</li><li>emb (batchsize,di(32),500)，标准包围框区域的RGB图像，经过ModifiedResnet得到的特征图，经过choose选择后的特征</li></ul><h2 id="2-5-PoseRefineNetFeat优化特征融合网络">2.5 PoseRefineNetFeat优化特征融合网络</h2><p>与PoseNetFeat结构基本一致。</p><p>但是PoseNetFeat先将pointfeat_2进行池化，再转换到1024通道得到全局特征，再和pointfeat_1和pointfeat_2拼接。</p><p>而PoseRefineNetFeat则是先将pointfeat_1和pointfeat_2拼接作为pointfeat_3，然后进行池化得到融合特征。</p><p>输入：</p><ul><li>x (batchsize,3,500)，由xydepth生成的三维点云</li><li>emb (batchsize,di(32),500)，标准包围框区域的RGB图像，经过ModifiedResnet得到的特征图，经过choose选择后的特征<br>输出</li><li>前向计算得到(batchsize, 1024)的特征向量</li></ul><h2 id="2-6-PoseRefineNet姿态优化网络">2.6 PoseRefineNet姿态优化网络</h2><p>输入：</p><ul><li>x，预测的三维坐标(batchsize,3,500)</li><li>emb，标准包围框区域的RGB图像，经过ModifiedResnet得到的特征图，经过choose选择后的特征(batchsize,di(32),500)</li><li>obj，物体索引序号(batchsize, 1)<br>输出：</li><li>out_rx(1,4)，回归得到的四元数，预测的三维坐标相对于真实三维坐标的变换</li><li>out_tx(1,4)，回归得到的平移变量，预测的三维坐标相对于真实三维坐标的变换</li></ul><h1>三、损失函数</h1><h2 id="3-1-Loss初始化">3.1 Loss初始化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对loss进行初始化</span></span><br><span class="line"><span class="comment"># num_points_mesh=500，sym_list对陈物体列表</span></span><br><span class="line">criterion = Loss(opt.num_points_mesh, opt.sym_list)</span><br><span class="line">criterion_refine = Loss_refine(opt.num_points_mesh, opt.sym_list)</span><br></pre></td></tr></table></figure><h2 id="3-2-Loss计算">3.2 Loss计算</h2><p>输入：</p><ul><li>pred_r，(1, 500, 4)，预测得到的四元数</li><li>pred_t，(1, 500, 3)，预测得到的平移变量</li><li>pred_c，(1, 500, 1)，预测得到的置信度</li><li>target，(bs, 500, 3)，根据model_points点云信息，以及标准旋转偏移矩阵转换过的目标点云</li><li>model_points，(bs, 500, 3)，模型点云信息</li><li>idx，(1)，物体类别序号</li><li>points，(bs, 500, 3)，深度三维坐标</li><li>opt.w，权重参数</li><li>opt.refine_start，是否开始refine过程<br>输出：</li><li>loss，损失值</li><li>dis，置信度最大的点的距离</li><li>new_points，由points转换到世界坐标系下的点云坐标</li><li>new_target，由target转换到世界坐标系下的点云坐标</li></ul><p>首先将预测得到的四元数转换为旋转矩阵。</p><p>然后将model_points和target都复制500次，用于对每个点进行计算。</p><p>利用<code>pred = torch.add(torch.bmm(model_points, base), points + pred_t)</code>公式求出预测值。</p><ul><li>model_points是从点云文件中读取的，其坐标是在世界坐标系下定义的，坐标原点为点云文件中固定的零点。</li><li>target是model_points在相机坐标系下的坐标，也就是物体在相机坐标系下的点云坐标，也就是物体的实际坐标。</li><li>pred_r是世界坐标系和相机坐标系的变换矩阵。</li><li>pred_t我也不知道是什么</li><li>pred是预测得到的model_points在相机坐标系下的坐标，也就是预测的物体实际坐标。<br>其中<code>torch.bmm(model_points, base)</code>利用旋转矩阵将model_points姿态转换到相机坐标系下，然后本来加上target_t就是实际坐标，但是这里加上<code>points+pred_t</code>得到预测的坐标。</li></ul><p>再对对称物体进行单独的处理。</p><p>计算预测的点云pred和真实的点云target之间的距离，求平均值来计算loss，并保存置信度最大的距离loss。</p><p>找到置信度最大的点对应的平移向量和旋转矩阵，利用points(相机坐标系点云)逆变换回世界坐标系得到new_points，将target同样逆变换回世界坐标系得到new_target。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
          <category> 位姿估计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实验 </tag>
            
            <tag> 视觉 </tag>
            
            <tag> 位姿估计 </tag>
            
            <tag> DenseFusion </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
