<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>各大视频音频网站资源下载</title>
      <link href="/post/2c340937.html"/>
      <url>/post/2c340937.html</url>
      
        <content type="html"><![CDATA[<h1>介绍</h1><p>使用<a href="https://github.com/soimort/you-get">You-get工具</a>，这是Github上的一个项目，可以下载大多数主流网站的视频，图片、音频。</p><p>支持的网站包括YouTube、Twitter、Facebook、bilibili、AcFun、niconico、网易云音乐、酷狗音乐、qq音乐、爱奇艺、腾讯视频、抖音、快手、知乎等等。</p><blockquote><p>详细文档参见：<a href="https://github.com/soimort/you-get">https://github.com/soimort/you-get</a></p></blockquote><h1>工具准备</h1><h2 id="1-下载安装python3">1. 下载安装python3</h2><p>网上有很多教程，按照教程安装最新版的python即可。</p><h2 id="2-安装you-get">2. 安装you-get</h2><p>按下<code>win+R</code>输入<code>cmd</code>，打开命令行窗口，使用如下指令安装you-get工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get</span><br></pre></td></tr></table></figure><p>然后输入下方代码，升级you-get工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip3 install --upgrade you-get</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407190404.png" alt=""></p><h1>使用方法</h1><h2 id="1-查看可以下载的质量和格式">1. 查看可以下载的质量和格式</h2><p>复制想要下载的视频或音频的网页链接。</p><p>使用<code>--info</code>/<code>-i</code>指令即可查看所有可以下载的文件质量和格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407191446.png" alt=""></p><h2 id="2-下载视频-音频-图片">2. 下载视频/音频/图片</h2><p>直接使用<code>you-get</code>指令会下载defalut下面的第一种格式，并下载到命令行当前所在目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get -i https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p>如果想要下载特定的格式，找到对应格式下面提示的下载指令，使用下载指令下载就行，例如我要下载此视频的mp4版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407193145.png" alt=""></p><p>可以看到速度还是蛮快的。</p><h2 id="3-设置输出文件夹与文件名">3. 设置输出文件夹与文件名</h2><p>使用<code>--output-dir</code>/<code>-o</code>选项设置路径，使用<code>--output-filename</code>/<code>-O</code>设置下载文件的名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --format=dash-flv -o E:/Windows/VIDEOS -O 夏天 https://www.bilibili.com/video/BV1Ni4y1k7rv</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220407193428.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为手机安装谷歌服务</title>
      <link href="/post/367f6bb8.html"/>
      <url>/post/367f6bb8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接: <a href="https://pan.baidu.com/s/1_PPC3xveD2xPwsg6JGgZmQ?pwd=wcrp">https://pan.baidu.com/s/1_PPC3xveD2xPwsg6JGgZmQ?pwd=wcrp</a><br>提取码: wcrp</p></blockquote><p>1、荣耀60或60pro教程【本人实测教程】，把这里的文件复制到手机</p><p>2、清除所有之前安装过的谷歌相关软件和系统进程。没装过的跳过这一步</p><p>3、打开 文件管理APP 将下载文件中的【Backup】 文件夹，复制到U盘根目录</p><p>4、很关键的一步，打开系统和更新，设置时间，将时间设置到2020年的任何一天</p><p>5、打开设置–系统和更新–备份和恢复-内部存储恢复-选择20191207的选项进行恢复。恢复完成后桌面会有一个谷歌服务助手，点开点激活，之后不用管它。回到设置–将时间设置为自动设置，恢复到2021年。</p><p>6、打开梯子。</p><p>7、安装0文件(microG)，装完之后打开，点账户account，点sign in，没有反应，就再点account，点sign in，登录谷歌账号（有几个登几个，后边不能再加）。</p><p>8、安装1，3，4，apk文件，然后卸载掉第7步安装的0文件(microG)</p><p>9、回到文件管理，安装2文件Google play服务.apk，拉下通知栏，等待弹出谷歌认证，之后点击验证（等10秒-50秒就会自动弹出来了）。</p><p>10、回到手机桌面，打开Google play商店，Google play商店可以正常打开，将Google play商店从后台关掉</p><p>11、打开手机设置-应用和服务-应用管理-点右上角，显示系统程序，搜索【Google】，</p><p>点开Google play商店，强行停止，后退，</p><p>点开-Google账号管理程序，存储，删除数据，后退，再后退</p><p>点开Google服务框架，存储，删除数据，后退</p><p>然后重启手机。</p><p>12、设置-里面有Google服务</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云图床搭建方法</title>
      <link href="/post/d05a7f72.html"/>
      <url>/post/d05a7f72.html</url>
      
        <content type="html"><![CDATA[<p>由于现在一直在CSDN和自己的网站同步写博客记录，可是以前我都是在CSDN编辑器内直接码字上传，但这样的编辑方式很难受，我还是更喜欢像Typora的本地markdown编辑器，这样就需要有一个自己的图床，本地截图粘贴到markdown编辑器内，就会自动上传到自己的图床中。</p><h1>开通阿里云OSS服务</h1><p>首先需要开通<a href="https://www.aliyun.com/product/oss">阿里云OSS服务</a>，登录账号后直接点击立即开通就可以。</p><p>阿里云提供了两种计费方式：</p><ul><li>按量收费：这是默认的计费方式，开通OSS后就是这种方式，不需要提前付款，使用后会直接从账户内扣钱。</li><li>包月包年套餐：点击折扣套餐可以看到各种不同容量和时间的套餐</li></ul><p>由于我在这里只存储写博客用到的图片，每张图片只有几十K，就算是最小的40G套餐我也是远远用不到的，因此我选择按量收费，也就是这里不操作，直接下一步。</p><h1>新建Bucket</h1><p>Bucket相当于存储图片的容器，这里新建Bucket。</p><ul><li>输入Bucket的名称：生成链接后，链接名称的组成部分（*****.oss-cn-beijing.aliyuncs.com）</li><li>区域：选择一个离你最近的就可以</li><li>存储类型：一般选择标准存储</li><li>读写权限：必须选择公共读，否则其他人无法访问图片</li><li>剩余的服务都不需要开启</li></ul><p>打开Bucket列表，在刚创建的bucket下新建一个目录img，用于存放博客图片。</p><p><img src="https://img.mahaofei.com/img/202203260958360.png" alt=""></p><h1>获取阿里云AccessKey</h1><p>鼠标移动到阿里云首页右上角个人头像，点击AccessKey管理。</p><p>进入页面后可能会出现安全提示，点击继续使用AccessKey。</p><p>点击创建AccessKey，通过验证后就可以看到AccessKey了。</p><p>这里的AccessKey ID和AccessKey Secret一定要记录好，而且一定不能公开。</p><h1>下载安装Picgo</h1><p>下面是Picgo项目的Github链接，直接在这里下载就可以。<br><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h1>配置Picgo</h1><p>在Picgo设置里勾选显示阿里云OSS图床（默认已经打开了很多常用图床）</p><p>在图床设置-阿里云OSS设置内，填写自己的信息</p><p><img src="https://img.mahaofei.com/img/202203260959238.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博途TIA Portal V15 下载与安装教程</title>
      <link href="/post/bb559113.html"/>
      <url>/post/bb559113.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>下载链接：</p><p>阿里云盘：<a href="https://www.aliyundrive.com/s/G5V98sQFqVq">https://www.aliyundrive.com/s/G5V98sQFqVq</a></p><p>百度网盘： <a href="https://pan.baidu.com/s/1X3hMP5n2DlMXB_wiGztarg?pwd=dpzk">https://pan.baidu.com/s/1X3hMP5n2DlMXB_wiGztarg?pwd=dpzk</a></p><p>提取码: dpzk</p></blockquote><h2 id="准备工作">准备工作</h2><p>在安装西门子软件的时候，经常提示要重启，而且重启之后依然提示重启，让人莫名烦恼， 按照以下步骤删除注册表则不会再提示重启。<br><font color="red">注意：删除注册表后不要重启，直接继续安装，（删除此文件对电脑没有任何影响）</font></p><ol><li>在windows系统下，按下组合键：WIN+R，输入“regedit”，打开注册表编辑器<br><img src="https://img.mahaofei.com/img/202203261044325.png" alt="">找到 HEEY_LOCAL_MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\SESSION MANAGE\ 下的 PendingFileRemameOpeaations 键，直接删除该键值。不需要重新启动，继续你的软件安装即可。<br><img src="https://img.mahaofei.com/img/202203261044343.png" alt=""></li></ol><blockquote><p>安装前注意：</p><ul><li>V15 支持WIN11 WIN10  WIN8  WIN7, 但必须都是64位系统</li><li>文件下载完成，安装出现安装过程中出错，则重新安装或修复，如果再次安装仍出现此问题则只能重新安装系统后再装软件，之所以出现这种问题，因为博途软件较庞大，所用到的数据库文件非常复查，系统内含有其他第三方软件可能导致博途安装无法正常成功，所以尽量保持系统的纯净再安装，切记，万不能开始各种杀毒软件，尤其360，否在无法保证是否能成功，或者安装完成能否正常使用。</li></ul></blockquote><h2 id="font-color-red-安装前一定要关闭杀毒软件-font"><font color="red">安装前一定要关闭杀毒软件</font></h2><h2 id="开始安装软件">开始安装软件</h2><h3 id="①-安装STEP7-Professional">① 安装STEP7 Professional</h3><ol><li>将安装包解压，进入<strong>01-STEP7+Wincc Profesional V15</strong>文件夹，运行<strong>TIA_Portal_STEP_7_Pro_WINCC_Pro_V15.exe</strong>，首先安装SETP7 Professional（PLC编程软件+WINCC触摸屏和上位机组态软件）<br><img src="https://img.mahaofei.com/img/202203261045172.png" alt=""></li><li>选择要安装的位置（尽量避免解压在C盘），然后点击下一步等待解压，解压过程5分钟左右<br><img src="https://img.mahaofei.com/img/202203261045963.png" alt=""></li><li>开始正式安装，<strong>直接点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045632.png" alt=""></li><li>语言选择默认勾选中文，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045370.png" alt=""></li><li>默认典型安装即可，<strong>浏览选择安装路径</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045522.png" alt=""></li><li><strong>勾选接受两个条款协议</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045996.png" alt=""></li><li><strong>勾选接受</strong>安全和权限设置，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261045675.png" alt=""></li><li>确认安装路径没问题后，<strong>点击安装按钮</strong>，开始进行安装，安装过程约40分钟<br><img src="https://img.mahaofei.com/img/202203261045605.png" alt=""></li><li><strong>选择立即重启</strong>，完成安装（这里需要重启电脑，否则无法进行后续安装）</li></ol><h3 id="②-安装STEP7-Simulation">② 安装STEP7_Simulation</h3><ol><li>进入<strong>02-PLCSIM_V15</strong>文件夹，双击运行<strong>SIMATIC_S7PLCSIM_V15.exe</strong>，开始安装STEP7_simulation（PLC的仿真软件）<br><img src="https://img.mahaofei.com/img/202203261046807.png" alt=""></li><li>开始安装，直接<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046519.png" alt=""></li><li>安装语言默认选择中文，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046465.png" alt=""></li><li><strong>选择安装文件解压路径（不要和上一个程序选择同一路径，否则会出现文件覆盖问题）</strong>，然后<strong>点击下一步</strong>，等待解压，此过程约3分钟<br><img src="https://img.mahaofei.com/img/202203261046214.png" alt=""></li><li>进入安装程序，点击下一步开始安装<br><img src="https://img.mahaofei.com/img/202203261046805.png" alt=""></li><li>默认选择中文，<strong>点击下一步</strong>继续<br><img src="https://img.mahaofei.com/img/202203261046058.png" alt=""></li><li>浏览<strong>选择安装路径</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261046718.png" alt=""></li><li><strong>接受条款协议</strong>，然后<strong>点击下一步</strong><br><img src="https://img.mahaofei.com/img/202203261047339.png" alt=""></li><li>接受计算机安全和权限设置，点击下一步<br><img src="https://img.mahaofei.com/img/202203261047195.png" alt=""></li><li><strong>检查安装路径</strong>没问题，<strong>点击安装按钮</strong>开始安装软件12<br><img src="https://img.mahaofei.com/img/202203261047722.png" alt=""></li><li>选择稍后重启，完成安装<br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220326104732524.png" alt="image-20220326104732524"></li></ol><h3 id="③-安装驱动（如果只仿真，不需要连接PLC可跳过安装）">③ 安装驱动（如果只仿真，不需要连接PLC可跳过安装）</h3><ol><li>进入<strong>Startdrive</strong>文件夹中，双击运行<strong>Startdrive_V15.exe</strong>，按步骤进行安装<br><img src="https://img.mahaofei.com/img/202203261047076.png" alt=""></li></ol><h3 id="④-授权">④ 授权</h3><ol><li>在授权文件夹下找到<strong>Sim_EKB_Install_2018_11_14.exe</strong>文件，右键<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202203261047455.png" alt=""></li><li>授权Step7 Professional<br><img src="https://img.mahaofei.com/img/202203261047872.png" alt=""></li><li>授权WinCC，找到TIA Portal  --TIA Portal V15 –WINCC Prof v15，按图找到几个选项后点击安装长密钥<br><img src="https://img.mahaofei.com/img/202203261047560.png" alt=""></li><li>然后关闭程序，重启计算机</li></ol><blockquote><p>如果重启后打开软件授权不成功，则在C盘找到AX NF  ZZ文件夹删除（如果找不到，请打开显示隐藏文件夹）<br><img src="https://img.mahaofei.com/img/202203261048361.png" alt=""><br>如果以上步骤操作完毕仍然无法授权，则需要重装Windows纯净系统，不要再安装任何其他软件和杀毒管家等，直接安装博途</p></blockquote><p>在桌面找到TIA Portal V15软件，双击运行，可正常启动<br><img src="https://img.mahaofei.com/img/202203261048756.png" alt=""><br><img src="https://img.mahaofei.com/img/202203261048505.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> PLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河北工业大学机械电子工程专业课程资料（个人整理，请勿外传）</title>
      <link href="/post/21df2adf.html"/>
      <url>/post/21df2adf.html</url>
      
        <content type="html"><![CDATA[<h2 id="公共课">公共课</h2><h3 id="大二上"><em>大二上</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/vNZ6TSj6WJd">线性代数</a></th><th><a href="https://www.aliyundrive.com/s/6QjzPDqcgF1">大学物理</a></th><th><a href="https://www.aliyundrive.com/s/LWNGU81AUWZ">马克思主义基本原理概论</a></th></tr></thead></table><h3 id="大二下"><em>大二下</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/3aFWBAdyhgR">概率论与数理统计</a></th><th><a href="https://www.aliyundrive.com/s/248XLLcHYHp">毛泽东思想和中国特色社会主义理论体系概论</a></th><th>       </th></tr></thead></table><h2 id="专业课">专业课</h2><h3 id="大二下-2"><em>大二下</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/ikNAzyqmWAf">电工电子技术</a></th><th><a href="https://www.aliyundrive.com/s/BBwwM9t2dNc">机械原理</a></th><th><a href="https://www.aliyundrive.com/s/cWbKWUMy2yc">材料力学</a></th></tr></thead><tbody><tr><td><strong><a href="https://www.aliyundrive.com/s/Fs51pUPd4dm">互换性与测量技术</a></strong></td><td></td><td></td></tr></tbody></table><h3 id="大三上"><em>大三上</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/pFNWexCiLqY">机械设计</a></th><th><a href="https://www.aliyundrive.com/s/2CJKUJzjouK">机电传动与控制</a></th><th><a href="https://www.aliyundrive.com/s/YLHZLGZeWSC">液压传动与控制</a></th></tr></thead><tbody><tr><td><strong><a href="https://www.aliyundrive.com/s/BvQ7FgyCAMy">自动控制原理</a></strong></td><td></td><td></td></tr></tbody></table><h3 id="大三下"><em>大三下</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/Z7ZEtnbsPov">传感与检测技术</a></th><th><a href="https://www.aliyundrive.com/s/dL2cZ1g2n5Q">微机原理及应用</a></th><th><a href="https://www.aliyundrive.com/s/3Fj4pxuYNRz">机械制造技术基础</a></th></tr></thead><tbody><tr><td><strong><a href="https://www.aliyundrive.com/s/FEPhcgfyKTq">机械动力学</a></strong></td><td></td><td></td></tr></tbody></table><h3 id="大四上"><em>大四上</em></h3><table><thead><tr><th><a href="https://www.aliyundrive.com/s/h2Ayhm17cC6">数控技术</a></th><th><a href="https://www.aliyundrive.com/s/5SzkVMMrZK6">机器人技术及应用</a></th><th><a href="https://www.aliyundrive.com/s/k4BYhySnW6a">机电系统建模仿真</a></th></tr></thead><tbody><tr><td><a href="https://www.aliyundrive.com/s/iExSacLgtt4"><strong>机电系统设计</strong></a></td><td><a href="https://www.aliyundrive.com/s/PWFoXhRDv5Z"><strong>电气控制与PLC</strong></a></td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PS2020 下载与安装教程（可更改安装位置）</title>
      <link href="/post/f43c25b0.html"/>
      <url>/post/f43c25b0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>阿里云盘链接：<a href="https://www.aliyundrive.com/s/UFEbPAqUVvD">https://www.aliyundrive.com/s/UFEbPAqUVvD</a></p><p>下载后将文件的后缀名改回【.zip】即可正常解压。</p><p>百度网盘链接：<a href="https://pan.baidu.com/s/1-GCMRxMQLGaOBn_dtcgJmw">https://pan.baidu.com/s/1-GCMRxMQLGaOBn_dtcgJmw</a></p><p>提取码：mhf6</p></blockquote><ol><li>打开解压的文件夹，右键【Set-up.exe】，<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230952400-ps2020-1.png" alt=""></li><li>点击右侧按钮<strong>更改安装位置</strong>，安装到除C盘外的区域<br><img src="https://img.mahaofei.com/img/202112230953657-ps2020-2.png" alt=""></li><li><strong>点击继续</strong>，开始安装<br><img src="https://img.mahaofei.com/img/202112230953836-ps2020-3.png" alt=""></li><li>安装过程大约需要3分钟，安装过程自动破解，安装完成就可以直接使用。<br><img src="https://img.mahaofei.com/img/202112230953164-ps2020-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230953914-ps2020-5.png" alt=""></li><li>打开软件，可以正常使用<br><img src="https://img.mahaofei.com/img/202112230953060-ps2020-6.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PR2020 下载与安装教程（可更改安装位置）</title>
      <link href="/post/f5998c06.html"/>
      <url>/post/f5998c06.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>阿里云盘链接：<a href="https://www.aliyundrive.com/s/QYQ5oszJVSq">https://www.aliyundrive.com/s/QYQ5oszJVSq</a></p><p>下载后将文件的后缀名改回【.zip】即可正常解压。</p><p>百度网盘链接：<a href="https://pan.baidu.com/s/1vQgVLG2Im4VKELuOwQ2zyg">https://pan.baidu.com/s/1vQgVLG2Im4VKELuOwQ2zyg</a></p><p>提取码：mhf6</p></blockquote><ol><li><p>打开解压的文件夹，右键【Set-up.exe】，<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230954169-pr2020-1.png" alt=""></p></li><li><p>点击右侧按钮<strong>更改安装位置</strong>，安装到除C盘外的区域<br><img src="https://img.mahaofei.com/img/202112230955092-pr2020-2.png" alt=""></p></li><li><p>安装过程大约需要3分钟，安装过程自动破解，安装完成就可以直接使用。<br><img src="https://img.mahaofei.com/img/202112230955695-pr2020-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230955657-pr2020-4.png" alt=""></p></li><li><p>打开软件，可以正常使用<br><img src="https://img.mahaofei.com/img/202112230955835-pr2020-5.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Office2019专业版安装教程</title>
      <link href="/post/197d036c.html"/>
      <url>/post/197d036c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>阿里云盘链接：<a href="https://www.aliyundrive.com/s/PNmJsdoM9AD">https://www.aliyundrive.com/s/PNmJsdoM9AD</a><br>下载完成后将后缀名改回【.zip】即可正常解压</p><p>百度网盘链接：<a href="https://pan.baidu.com/s/15yVE9_3PUWwb9tHZKwzB_w">https://pan.baidu.com/s/15yVE9_3PUWwb9tHZKwzB_w </a><br>提取码：mhf6</p></blockquote><p>安装之前，先到【控制面板-卸载程序】，卸载掉所有Office产品。</p><ol><li><p>解压压缩包，运行【<strong>Setup64.exe</strong>】<br><img src="https://img.mahaofei.com/img/202112230940086-office2019-1.png" alt=""></p></li><li><p>等待20分钟左右安装，只能安装在C盘。</p></li><li><p>安装完成后在开始菜单打开，可以正常使用</p></li><li><p>如果需要激活，可以使用<a href="https://huffie.lanzouw.com/idn0Cuhmwzg">【此工具】</a>进行激活。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【目标识别】SIFT算法理论部分</title>
      <link href="/post/f8e83802.html"/>
      <url>/post/f8e83802.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍">一、介绍</h2><h3 id="1-1-SIFT算法">1.1 SIFT算法</h3><p>SIFT(Scale invariant feature transform)是尺度不变特征变换，是一种用来检测和描述图像局部特征的算法。算法实际上是要在不同尺度空间中寻找极值点，并提取其位置、尺度和旋转不变量，这些关键点不会因光照、仿射变换和噪音而变化。</p><h3 id="1-2-SIFT特征的获取方法">1.2 SIFT特征的获取方法</h3><ol><li><p><strong>尺度空间极值检测</strong></p><p>利用高斯差分函数搜索所有尺度和图像位置，找到对尺度和方向不变的候选关键点。</p></li><li><p><strong>关键点定位</strong></p><p>对每一个候选关键点都需要确定其位置和尺度，并要保证其稳定性。</p></li><li><p><strong>方向分配</strong></p><p>根据局部图像的梯度方向，为每个关键点分配一个或多个方向。</p></li><li><p><strong>关键点描述</strong></p><p>在每个关键点周围区域的选定尺度上测量局部图像的梯度，这些信息表示了允许的局部形状失真和光照变化。</p></li></ol><h3 id="1-3-图像匹配和识别的方法">1.3 图像匹配和识别的方法</h3><ol><li>先从一组目标物体的参考图像中提取SIFT特征并存储在数据库。</li><li>将新图像的每个特征与之前的数据库逐一比较，根据特征向量的欧几里得距离找到匹配特征。</li></ol><h3 id="1-4-如何提高匹配准确率">1.4 如何提高匹配准确率</h3><ol><li><p>利用识别与新图像中对象的位置、比例和方向一致的关键点子集，可以在匹配集中过滤出正确的匹配。几个特征共同作为判断依据匹配出错率远小于单一特征匹配。</p></li><li><p>匹配方法</p><p>①先对物体姿态的放射近似作最小二乘估计，与此姿态一致的其它图像特征被识别出来，异常值被丢弃。</p><p>②给出你和的准确性和可能的错误匹配的数量，对一组特征表明对象存在的概率进行详细计算。</p><p>③通过所有测试的对象匹配可被标为正确且具有高可信度。</p></li></ol><h2 id="二、尺度空间极值检测">二、尺度空间极值检测</h2><p>SIFT算法是在不同的尺度空间上查找关键点，尺度空间的获取需要使用高斯模糊。</p><h3 id="2-1-高斯模糊">2.1 高斯模糊</h3><h4 id="（1）高斯函数">（1）高斯函数</h4><p>高斯模糊使用高斯函数（正态分布）计算模糊模板，并使用该模板与原图像做卷积运算，以此模糊图像。</p><p>N维空间的高斯计算公示：</p><p><img src="https://img.mahaofei.com/img/202112232022082-sift-theory-1.png" alt=""></p><blockquote><ul><li>$\sigma$为正态分布的标准差，$\sigma$越大图像越模糊、越平滑</li><li>$r$为模糊半径，指模板元素到模板中心的距离</li></ul></blockquote><p>二维空间的高斯计算公式：</p><p><img src="https://img.mahaofei.com/img/202112232022463-sift-theory-2.png" alt=""></p><blockquote><ul><li>$\sigma$为正态分布的标准差，$\sigma$越大图像越模糊、越平滑</li><li>m,n为二维模板的大小m*n</li><li>x,y为模板上元素的位置(x,y)</li></ul></blockquote><p>二维高斯函数生成的曲面是从中心开始的正态分布同心圆。每个像素的值都是周围相邻像素的加权平均。原始像素具有最大的权重，边缘像素权重越来越小，因此更高的保留了边缘效果。</p><p>在计算每个像素的离散近似时，$3\sigma$之外的像素都可以视为不起作用，因此图像处理程序只需要计算 $(6\sigma+1)\times(6\sigma+1) $的矩阵就可以了。</p><h4 id="（2）二维高斯模糊">（2）二维高斯模糊</h4><p>根据$\sigma$计算出高斯模板矩阵（大小为$(6\sigma+1)\times(6\sigma+1) $，值根据$G(x,y)$计算）</p><p>对高斯模板矩阵进行归一化处理（确保矩阵元素在$[0,1]$范围内），例如$5\times5$的高斯模板如下图，可以看出高斯模板是中心对称的。</p><p><img src="https://img.mahaofei.com/img/202112232023230-sift-theory-3.png" alt=""></p><p>利用此高斯模板矩阵与原图像做卷积，即可获得原图像的高斯模糊图像。卷积过程示意图如下：</p><p><img src="https://img.mahaofei.com/img/202112232023732-sift-theory-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232024140-sift-theory-5.png" alt=""></p><h4 id="（3）分离高斯模糊">（3）分离高斯模糊</h4><p>二维高斯模糊有两个不足之处：</p><ol><li>使用二维高斯模糊会造成边缘图像缺失，$\sigma$越大，缺失像素越多</li><li>模板变大时，高斯核的卷据运算量会大幅度提高</li></ol><p>解决方法：</p><p>利用高斯函数的可分离性（二维矩阵的变换效果等效于水平方向一维高斯矩阵变换加竖直方向一维高斯矩阵变换）。</p><ol><li>两次一维的高斯卷积将消除二维高斯矩阵所产生的边缘。</li><li>卷积运算只需要O(n×M×N)+O(m×M×N)次计算，而二维矩阵需要O(m×n×M×N)次计算。其中m,n为高斯矩阵的维数。M,N为二维图像的维数。</li></ol><p><img src="https://img.mahaofei.com/img/202112232024414-sift-theory-6.png" alt=""></p><h3 id="2-2-尺度空间">2.2 尺度空间</h3><h4 id="（1）尺度空间的概念">（1）尺度空间的概念</h4><ol><li><p><strong>概念</strong></p><p>在图像信息处理模型中引入一个被视为尺度的参数，通过连续变化尺度参数获得多尺度下的尺度空间表示序列，对这些序列进行尺度空间主轮廓的提取，并以该主轮廓作为特征向量，实现边缘、角点检测和不同分辨率的特征提取。</p></li><li><p><strong>特点</strong></p><p>将传统的但尺度图像信息处理技术纳入尺度不断变化的动态分析框架中。更容易获取图像的本质特征。尺度空间中各尺度图像的模糊程度逐渐变大，能够模拟人在距离目标由近到远时目标在视网膜上的形成过程。</p></li><li><p><strong>优点</strong></p><p>1）尺度空间算子对图像的分析不受图像的灰度水平和对比度变化的影响，即满足灰度不变性和对比度不变性；</p><p>2）尺度空间算子对图像的分析和图像的位置、大小、角度以及仿射变换无关，即满足平移不变性、尺度不变性、欧几里德不变性以及仿射不变性。</p></li></ol><h4 id="（2）尺度空间的表示">（2）尺度空间的表示</h4><p>尺度空间 $L(x,y,z)$ 定义为变化尺度的高斯函数 $G(x,y,\sigma)$ 与原图像 $I(x,y)$ 的卷积。</p><p><img src="https://img.mahaofei.com/img/202112232025921-sift-theory-7.png" alt=""></p><p>其中$\sigma$为尺度因子，$\sigma$越小对应模糊程度越小，相应的尺度约小。因此大尺度对应图像的概貌特征，小尺度对应图像的细节特征。</p><p><img src="https://img.mahaofei.com/img/202112232025197-sift-theory-8.png" alt=""></p><h4 id="（3）高斯金字塔的构建方法">（3）高斯金字塔的构建方法</h4><p>尺度空间在实现时使用高斯金字塔表示，高斯金字塔构建分为两步：1）对图像做降采样；2）对图像做高斯平滑。</p><p>金字塔模型是指将原始图像不断进行降采样，得到一系列大小不同的图像，由大到小，由下到上。原图像为金字塔的第一层，每次降采样所得到的新图像为金字塔的一层。为了让尺度体现其连续性，高斯金字塔在简单降采样的基础上加上了高斯滤波。</p><p>如上图所示，将图像金字塔每层的一张图像使用不同参数做高斯模糊，Octave表示一幅图像可产生的图像组数，Interval表示一组图像包括的图像层数。另外，降采样时，高斯金字塔上一组图像的初始图像(底层图像)是由前一组图像的倒数第三张图像隔点采样得到的。</p><p>高斯金字塔的层数计算：</p><p><img src="https://img.mahaofei.com/img/202112232025038-sift-theory-9.png" alt=""></p><blockquote><p>M,N：原图像大小<br>t：塔顶图像的最小维度的对数值</p></blockquote><p><img src="https://img.mahaofei.com/img/202112232026124-sift-theory-10.png" alt=""></p><h3 id="2-4-极值检测方法">2.4 极值检测方法</h3><p>由于要在尺度空间中寻找图像的极值点，因此在实际计算中，使用高斯金字塔每组中相邻上下两层图像相减，得到高斯差分图像（Difference of Gaussian ，简称DOG），进行极值检测。即两个相邻尺度的差（这里用常数k区分相邻的尺度）：</p><p>$D(x, y, σ) = (G(x, y, kσ)−G(x, y, σ))∗I(x, y)$</p><p>​$=L(x, y, kσ)−L(x, y, σ)$</p><p>为了寻找高斯差分函数函数的极值点，每一个像素点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小。如图所示，中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。</p><p><img src="https://img.mahaofei.com/img/202112232026929-sift-theory-11.png" alt=""></p><p>由于要在相邻尺度进行比较，由于高斯差分金字塔的每一组图像，只能在中间的层进行极值点检测，最上和最下层无法进行。</p><p>为了在每组中检测S个尺度的极值点，则DOG金字塔每组需S+2层图像，而DOG金字塔由高斯金字塔相邻两层相减得到，则高斯金字塔每组需S+3层图像，实际计算时S在3到5之间。</p><h3 id="2-5-极值检测的采样频率">2.5 极值检测的采样频率</h3><p>检测局部极大值和极小值，在采样点同层的8个邻域点和上下相邻层的各9个邻域点之中选择，只有大于或这些所有的邻域点才能称为极值。经过检测后绝大多数的采样点都被剔除了。</p><p>其中重要问题就是确定图像和尺度的采样频率，以可靠的检测极值，但事实上极值点可以非常接近，因此需要找到一种平衡效率和完整性的解决方案。</p><h4 id="（1）尺度域的采样频率">（1）尺度域的采样频率</h4><p>经过大量实验数据得到：</p><p>（1）当采样更多尺度时，可重复性没有继续提高，因为这会导致更多的局部极值被检测到，但这些极值平均来说不太稳定，不太可能在被转换后的图像中检测到。</p><p>（2）当采样规模增大时，关键点的数量增加，正确匹配的总数量增加，由于实际使用时物体识别的成功更多取决于正确匹配关键点的数量，而不是正确匹配的百分比，因此使用大量的样本是最好的。但是这会导致计算成本的增加，所以Lowe建议<strong>每组使用3个尺度样本</strong></p><h4 id="（2）空间域的采样频率">（2）空间域的采样频率</h4><p>需要确定在一个尺度内图像域的采样频率，假设极值点可以任意靠近，那么在空间域的采样频率和检测率之间也会有类似的平衡。这里Lowe经过实验，建议选择使用$\sigma=1.6$。</p><p>并且由于在进行极值检测之前进行了差分处理，因此丢弃了最高的空间频率，为了充分利用输入，可以在构建金字塔第一级之前使用线性插值将输入图像的大小增加一倍。</p><h2 id="三、关键点定位">三、关键点定位</h2><h3 id="3-1-关键点的准确定位">3.1 关键点的准确定位</h3><p>离散空间的极值点不是图像真正的极值点。</p><p><img src="https://img.mahaofei.com/img/202112232026016-sift-theory-12.png" alt=""></p><p>为了提高关键点的稳定性，需要对尺度空间函数进行曲线拟合。利用尺度空间函数的Taylor展开式，导数在极值点处为0，求得$x$的偏移量实现对关键点的精确定位。</p><p>将尺度空间函数$D(x,y,\sigma)$进行泰勒展开，使原点与采样点重合。</p><p><img src="https://img.mahaofei.com/img/202112232027590-sift-theory-13.png" alt=""></p><p>对$D(x,y,\sigma)$求导并令其等于零，求得$\hat{x}=−\frac{∂^2D^{-1}}{∂x^2}\frac{∂D}{∂x}$即为$x$的偏移量。</p><h3 id="3-1-消除边缘响应">3.1 消除边缘响应</h3><p>为了稳定，仅去除低对比度的关键点是不够的，还需要消除高斯差分函数带来的边缘响应。在边缘梯度方向的主曲率较大，垂直方向（沿边缘方向）的主曲率较小。主曲率可以通过Hessian矩阵计算：</p><p><img src="https://img.mahaofei.com/img/202112232027721-sift-theory-14.png" alt=""></p><p>其特征值正比于D的主曲率，由于我们只需要特征值的比值$r$，因此可以避免求出特征值的结果。设$\alpha$为较大的特征值，$\beta$为较小的特征值，取$\alpha=r\beta$，利用迹和行列式的特点：</p><p><img src="https://img.mahaofei.com/img/202112232028879-sift-theory-15.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232028531-sift-theory-16.png" alt=""></p><p>因此当两特征值相等时，上式$\frac{Tr(H)^2}{Det(H)}=\frac{(r+1)^2}{r}$有最小值，并且该式随着比值$r$增大而增大，因此要检验主曲率是否在某个阈值以下，只需要检验</p><p>$\frac{Tr(H)^2}{Det(H)}&lt;\frac{(r+1)^2}{r}$。当满足条件时保留特征点，否则剔除。（常用T=1.2）</p><h2 id="四、梯度方向分配">四、梯度方向分配</h2><h3 id="4-1-梯度大小方向求解">4.1 梯度大小方向求解</h3><p>为了使关键点描述子具有旋转不变性，利用图像的局部特征给每一个关键点分配一个基准方向，使描述子对图像旋转具有不变性。对于在高斯差分金字塔中检测出的关键点，采集其所在高斯金字塔图像$3\sigma$邻域窗口的像素的梯度和方向分布特征。梯度的模和方向如下：</p><p><img src="https://img.mahaofei.com/img/202112232029555-sift-theory-17.png" alt=""></p><h3 id="4-2-梯度统计">4.2 梯度统计</h3><p>完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。梯度直方图将0~360°方向分为36份，每个柱子代表10°范围，如图直方图的峰值代表关键点的主方向。</p><p><img src="https://img.mahaofei.com/img/202112232029678-sift-theory-18.png" alt=""></p><p>以直方图中最大值作为该关键点的主方向，为了增强匹配的鲁棒性，只保留峰值大于主方向峰值80％的方向作为该关键点的辅方向。</p><h2 id="五、关键点描述子">五、关键点描述子</h2><p>经过上面的步骤，每一个关键点都拥有位置、尺度、方向三个信息。</p><p>下一步是为每个关键点建立一个描述符，用一组向量将这个关键点描述出来，使其不随各种变化而改变，使其不随光照、视角等变化而变化。</p><h3 id="5-1-描述符表示">5.1 描述符表示</h3><h4 id="（1）特征向量表示">（1）特征向量表示</h4><p>首先在关键点周围采样图像的梯度大小和方向，利用关键点的尺度选择图像的高斯模糊程度。为了实现方向不变性，描述子的坐标和梯度方向是相对于关键点方向旋转的。</p><p><img src="https://img.mahaofei.com/img/202112232029018-sift-theory-19.png" alt=""></p><p>使用一个$\sigma$等于子窗口宽度的一半的高斯加权函数来为每个采样点的大小赋值。（为了避免随着窗口位置的微小变化导致的描述符的突然变化，同时减少远离描述符中心的梯度影响，这些梯度最容易配准错误）</p><p>描述符由一个包含所有方向直方图条目值的向量构成，Lowe经过实验证明最好的选择是：每个关键点划分4个领域，对应4个描述子，每个描述子使用4x4的方向直方图阵列，每个直方图中有8个梯度方向，因此每个关键点采用4x4x8=128个特征向量。</p><h4 id="（2）归一化处理">（2）归一化处理</h4><p>对特征向量进行修正，减小光照变化对特征向量的影响。</p><ol><li>对比度影响消除</li></ol><blockquote><p>因为图像对比度的变化即每个像素值乘以一个常数，因此归一化会消除对比度的影响。</p></blockquote><p>因此首先将向量归一化为单位长度。</p><ol start="2"><li>照明条件影响消除</li></ol><blockquote><p>图像亮度是每个图像像素加上一个常数，因此亮度变化不会影响图像的梯度，所以描述符对于光照的仿射变化是不变的。（在不考虑非线性光照的情况下）</p></blockquote><p>考虑照明条件变化，可以通过将单位特征向量阈值划为不大于0.2（Lowe实验测得），减少较大梯度的影响，然后重新归一化。此时匹配大梯度不再重要，方向的分布更加重要。</p><h2 id="六、物体识别的应用">六、物体识别的应用</h2><p>目标识别首先通过将每个关键点独立地与从训练图像中提取出的关键点数据库进行匹配来完成。由于模糊的特征和背景影响，一开始匹配肯定是不准确的。所以需要至少有三个特征的聚类首先被识别出来，这些聚类与对象姿态一致，其正确性就比单个特征匹配要高得多。然后对每个聚类进行几何拟合检查，根据拟合结果接受或拒绝。</p><ol><li>从训练图像中识别关键点数据库中的最近邻，找到每个关键点的最佳候选匹配。（最近邻可以使用最小欧式距离）</li><li>如果图像特征在数据库中没有任何正确的匹配，则丢弃。</li><li>如果有多个匹配结果，则定义第二个最近邻为已知来自不同物体。在相似距离内可能会有许多其他错误匹配。我们可以将次近匹配视为在特征空间的这一部分内提供错误匹配密度的估计。</li></ol><h2 id="七、总结">七、总结</h2><p>SIFT特征具有稳定性和不变性，在图像处理和计算机视觉领域有着很重要的作用。</p><p><strong>SIFT算法的主要实现过程</strong></p><ol><li><p><strong>尺度空间极值检测</strong></p></li><li><p><strong>关键点定位</strong></p></li><li><p><strong>方向分配</strong></p></li><li><p><strong>关键点描述和匹配</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> 视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQt5图形界面GUI开发过程记录</title>
      <link href="/post/6c1e143c.html"/>
      <url>/post/6c1e143c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、PyQT的简介与安装">一、PyQT的简介与安装</h2><h3 id="1-1-常用的图形界面GUI">1.1 常用的图形界面GUI</h3><p>目前主流的python图形界面有Tkinter、PyQT5/PySide2、wxPython等。</p><table><thead><tr><th>图形界面</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Tkinter</td><td>Python标准库、稳定、发布程序较小</td><td>控件少，无法拖拽设计界面</td></tr><tr><td>PyQt5/PySide2</td><td>控件比较丰富、用户多、有designer设计界面</td><td>库比较大，发布出来的程序比较大</td></tr><tr><td>wxPython</td><td>控件比较丰富</td><td>文档少、用户少</td></tr></tbody></table><h3 id="1-2-PyQT5的安装">1.2 PyQT5的安装</h3><p>直接在命令行使用pip工具安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyqt5-tools</span><br></pre></td></tr></table></figure><p>将PyQt5安装目录下的<code>\plugins\platforms</code>这个路径添加到环境变量Path中。（先找python安装目录<code>Python39</code>或<code>Python38</code>，再找下面的<code>\Lib\site-packages\PyQt5\Qt5</code>）</p><p>如我的路径是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\82785\AppData\Local\Programs\Python\Python39\Lib\site-packages\PyQt5\Qt5\plugins\platforms</span><br></pre></td></tr></table></figure><p><strong>注：设置环境变量后，需要重启电脑，因为新的环境变量要重启后才能被系统识别</strong></p><h2 id="二、PyQt的基本使用">二、PyQt的基本使用</h2><h3 id="2-1-QApplication">2.1 QApplication</h3><p>提供整个图形界面程序的底层管理功能，如初始化、程序入口参数处理、用户事件处理等。</p><ul><li>在创建控件之前，必须先创建QApplication。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = QApplication([])</span><br></pre></td></tr></table></figure><ul><li>在程序末尾，需要添加事件处理循环代码，用于接受输入事件，并分配给相应对象进行处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure><h3 id="2-2-界面控件">2.2 界面控件</h3><p>QMainWindow、QPlainTextEdit、QPushButton是三个控件类，分别是界面的主窗口、文本框、按钮。<code>要想在界面上创建一个控件，就需要在程序代码中创建空间对应的类的实例对象</code>。</p><ul><li>控件是层层嵌套的：<br>创建文本框和按钮时，都需要一个参数window，就是指定父控件对象（主窗口）。<br>而实例化主窗口时，不需要指定父控件，因为主窗口就是最上层控件了。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPlainTextEdit(window)</span><br><span class="line">QPushButton(<span class="string">&#x27;文本框&#x27;</span>, window)</span><br></pre></td></tr></table></figure><ul><li>move方法决定了控件的显示位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.move(<span class="number">300</span>, <span class="number">310</span>)<span class="comment"># 主窗口左上角相对屏幕左上角位置</span></span><br><span class="line">textEdit.move(<span class="number">10</span>,<span class="number">25</span>)<span class="comment"># 文本框左上角相对父窗口左上角位置</span></span><br></pre></td></tr></table></figure><ul><li>resize方法决定了控件显示大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.resize(<span class="number">600</span>, <span class="number">400</span>)<span class="comment"># 主窗口宽600像素，高400像素</span></span><br><span class="line">textEdit.resize(<span class="number">200</span>,<span class="number">150</span>)<span class="comment"># 文本框宽200像素，高150像素</span></span><br></pre></td></tr></table></figure><ul><li>show方法将所有放在主窗口的控件显示出来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.show()</span><br></pre></td></tr></table></figure><h3 id="2-3-界面动作处理">2.3 界面动作处理</h3><p>在Qt系统中，当控件被点击、输入文本、拖拽等操作时，会发出信号Signal。</p><p>要想使程序对这些操作进行响应，就要预先在代码中指定处理signal的函数，这样的函数称为slot。</p><p>如定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buttonPress</span>()：</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;按钮被按下了&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后使用如下代码，让button被按下时，执行buttonPress()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.clicked.connect(buttonPress)</span><br></pre></td></tr></table></figure><h3 id="2-4-窗口封装为类">2.4 窗口封装为类</h3><p>为了模块化、便于使用，以及避免控件中出现的变量名冲突，通常会把<strong>一个窗口和其包含的控件封装到类中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PySide2.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QPushButton,  QPlainTextEdit,QMessageBox</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindows</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.window = QMainWindow()</span><br><span class="line">        self.window.resize(<span class="number">500</span>, <span class="number">400</span>)</span><br><span class="line">        self.window.move(<span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        self.window.setWindowTitle(<span class="string">&#x27;示例程序&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.textEdit = QPlainTextEdit(self.window)</span><br><span class="line">        self.textEdit.setPlaceholderText(<span class="string">&quot;文本框提示语&quot;</span>)</span><br><span class="line">        self.textEdit.move(<span class="number">10</span>, <span class="number">25</span>)</span><br><span class="line">        self.textEdit.resize(<span class="number">300</span>, <span class="number">350</span>)</span><br><span class="line"></span><br><span class="line">        self.button = QPushButton(<span class="string">&#x27;统计&#x27;</span>, self.window)</span><br><span class="line">        self.button.move(<span class="number">380</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">        self.button.clicked.connect(self.handleCalc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handleCalc</span>(<span class="params">self</span>):</span><br><span class="line">        text = self.textEdit.toPlainText()</span><br><span class="line">        <span class="comment"># 处理程序</span></span><br><span class="line"></span><br><span class="line">app = QApplication([])</span><br><span class="line">mywindow = MyWindows()</span><br><span class="line">mywindow .window.show()</span><br><span class="line">app.exec_()</span><br></pre></td></tr></table></figure><h2 id="三、界面设计Qt-Designer">三、界面设计Qt Designer</h2><h3 id="3-1-Qt-Designer的简单介绍">3.1 Qt Designer的简单介绍</h3><p>Qt Designer是一个QT界面生成器，避免了像Tkinter需要将想象的图形界面用代码一行一行写出来。Qt Designer是一种图形化界面设计工具，通过拖拽控件，就可以实现界面布局的设计。</p><p>在python安装目录下的<code>Lib\site-packages\qt5_applications\Qt\bin\designer.exe</code>，这个可执行文件就是Qt Designer程序。</p><p><img src="https://img.mahaofei.com/img/202112232018944-pyqt5-1.png" alt=""></p><p>打开Qt Designer后，界面左侧是控件列表，右侧是对象查看器和属性编辑器。</p><p><img src="https://img.mahaofei.com/img/202112232018814-pyqt5-2.png" alt=""></p><p>创建窗体后，可以直接将左侧的控件，如文本框、按钮等拖入到窗体中，手动调整其大小和位置。在右侧可以修改每个空间的属性。</p><p>创建好图形界面后，点击视图-预览可以查看界面效果，点击保存按钮，即可将图形界面保存为<code>.ui</code>的文件，需要修改界面时可以直接再打开<code>.ui</code>就可以修改界面。</p><h3 id="3-2-布局">3.2 布局</h3><p>简单的控件拖拽布局就不介绍了，这里说一下布局方式。</p><p>常用的布局方式有</p><table><thead><tr><th>布局</th><th>样式</th></tr></thead><tbody><tr><td>水平布局</td><td><img src="https://img.mahaofei.com/img/202112232019148-pyqt5-3.png" alt=""></td></tr><tr><td>垂直布局</td><td><img src="https://img.mahaofei.com/img/202112232019433-pyqt5-4.png" alt=""></td></tr><tr><td>表格布局</td><td><img src="https://img.mahaofei.com/img/202112232020951-pyqt5-5.png" alt=""></td></tr><tr><td>表单布局</td><td><img src="https://img.mahaofei.com/img/202112232020207-pyqt5-6.png" alt=""></td></tr></tbody></table><p>比如点选几个控件，右键设置为水平布局。这样几个空间就组合成了一个大的整体的“控件”。</p><p>再将几个设置好的水平布局选中，右键设置为垂直布局，这样就算是非常快速地制作好了一个非常简单的UI。</p><p><img src="https://img.mahaofei.com/img/202112232021341-pyqt5-7.png" alt=""></p><h3 id="3-3-控件调整">3.3 控件调整</h3><p><strong>（1）控件大小</strong></p><p>主要使用的是<code>sizePolicy</code>这个属性。</p><p>水平策略和垂直策略：</p><p><img src="https://img.mahaofei.com/img/202112232021554-pyqt5-8.png" alt=""></p><p>水平伸缩和垂直伸缩：描述多个部件在水平方向的大小比例，类似于权重。</p><blockquote><p>如两个在同一水平位置的部件的水平伸缩因子分别为1和2，则二者宽带的大小比例为1:2，如果该水平方向再无其他控件，则二者各占布局管理器宽度的1/3和2/3。</p></blockquote><p><strong>（2）控件间距</strong></p><p>上下间距：给控件添加<code>layout</code>属性，通过调整上下的padding和margin来调整间距。</p><p>左右间距：给控件添加<code>layout</code>调整左右的padding和margin来调整间距，或添加<code>horizontal spacer</code>属性调整。</p><h2 id="四、Python程序">四、Python程序</h2><h3 id="4-1-ui文件转换python程序">4.1 ui文件转换python程序</h3><p>使用cmd将目录切换到<code>.ui</code>文件所在目录，使用如下命令生成代码。（请将命令中的name替换成文件名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyuic5 -o name.py name.ui</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232021448-pyqt5-9.png" alt=""></p><h3 id="4-2-主程序调用ui">4.2 主程序调用ui</h3><p>这时如果尝试运行刚刚生成的python程序是没有用的，因为生成的文件没有程序入口。因此我们需要创建一个主程序用来调用ui程序。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"><span class="comment"># 导入designer工具生成的模块</span></span><br><span class="line"><span class="comment"># 注意导入时filename替换成生成的.py文件名，Ui_file替换成.py文件的类名</span></span><br><span class="line"><span class="keyword">from</span> filename <span class="keyword">import</span> Ui_filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_excel_combine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment"># 将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment"># 程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><h3 id="4-3-设置按钮、文本框的响应程序">4.3 设置按钮、文本框的响应程序</h3><p>在主程序的MyMainForm类中进行设置，以按钮和文本框为例</p><p><strong>（1）按钮按下处理程序</strong></p><p>例如下面的代码，当按钮被按下时，自动执行括号内的处理函数<code>button_clicked_handle</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buttonname.clicked.connect(button_clicked_handle)</span><br></pre></td></tr></table></figure><p><strong>（2）文本框显示处理程序</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textBrowser.setPlainText(<span class="string">&#x27;显示的字符串&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-4-示例代码">4.4 示例代码</h3><p>我写的代码是合并多个excel数据的程序，其中的GUI部分代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入程序运行必须模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># PyQt5中使用的基本控件都在PyQt5.QtWidgets模块中</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QFileDialog</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> QIcon</span><br><span class="line"><span class="comment"># 导入designer工具生成的模块</span></span><br><span class="line"><span class="keyword">from</span> excel_combine_ui <span class="keyword">import</span> Ui_excel_combine</span><br><span class="line"></span><br><span class="line">dir_choose = <span class="string">&quot;&quot;</span></span><br><span class="line">filename = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMainForm</span>(QMainWindow, Ui_excel_combine):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MyMainForm, self).__init__(parent)</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.cwd = os.getcwd() <span class="comment"># 获取当前程序文件位置</span></span><br><span class="line">        self.sourceButton.clicked.connect(self.slot_source_button)</span><br><span class="line">        self.targetButton.clicked.connect(self.slot_target_button)</span><br><span class="line">        self.combineButton.clicked.connect(self.slot_combine_button)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_source_button</span>(<span class="params">self</span>):</span><br><span class="line">        files, filetype = QFileDialog.getOpenFileNames(self, <span class="string">&quot;选择多个采购申请表&quot;</span>, self.cwd, <span class="string">&quot;All Files (*);;PDF Files (*.pdf);;Text Files (*.txt)&quot;</span>)</span><br><span class="line">        <span class="keyword">global</span> filename</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取消选择\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        filename_print = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            filename.append(file)</span><br><span class="line">            filename_print += file</span><br><span class="line">            filename_print += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        self.textBrowser.setPlainText(filename_print)</span><br><span class="line">        <span class="comment"># print(&quot;文件筛选器类型：&quot;, filetype)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_target_button</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">global</span> dir_choose</span><br><span class="line">        dir_choose = QFileDialog.getExistingDirectory(self, <span class="string">&quot;选择保存目录&quot;</span>, self.cwd)</span><br><span class="line">        <span class="keyword">if</span> dir_choose == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;取消选择\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.textBrowser_2.setPlainText(dir_choose)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slot_combine_button</span>(<span class="params">self</span>):</span><br><span class="line">        wb_template = app.books.<span class="built_in">open</span>(<span class="string">&#x27;采购申请单模板.xls&#x27;</span>)  <span class="comment"># 打开工作簿</span></span><br><span class="line">        combine(wb_template, filename, dir_choose+<span class="string">&#x27;\采购申请表汇总.xls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 固定的，PyQt5程序都需要QApplication对象。sys.argv是命令行参数列表，确保程序可以双击运行</span></span><br><span class="line">    app1 = QApplication(sys.argv)</span><br><span class="line">    app1.setWindowIcon(QIcon(<span class="string">&#x27;logo.png&#x27;</span>))</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    myWin = MyMainForm()</span><br><span class="line">    <span class="comment"># 将窗口控件显示在屏幕上</span></span><br><span class="line">    myWin.show()</span><br><span class="line">    <span class="comment"># 程序运行，sys.exit方法确保程序完整退出。</span></span><br><span class="line"></span><br><span class="line">    sys.exit(app1.exec_())</span><br><span class="line">    <span class="comment"># button.clicked.connect(handleCalc) 按钮按下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232022811-pyqt5-10.png" alt=""></p><blockquote><p>更多控件的使用方法可以参考这位博主的文章：<br>链接：<a href="https://blog.csdn.net/weixin_40841247/article/details/88781601">https://blog.csdn.net/weixin_40841247/article/details/88781601</a></p></blockquote><h2 id="五、发布程序">五、发布程序</h2><h3 id="5-1-安装pyinstaller">5.1 安装pyinstaller</h3><p>要将写好的python程序打包成exe可执行程序需要使用pyinstaller，使用pip命令安装pyInstaller：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><h3 id="5-2-打包exe">5.2 打包exe</h3><ol><li><p>打开cmd窗口，进入写好的python程序所在的目录</p></li><li><p>使用如下的命令打包exe，例如我的主程序是<code>main.py</code>，我用到的包有<code>PyQt5</code>和<code>xlwings</code>，我的图标文件是<code>logo.ico</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller main.py --noconsole --hidden-import <span class="string">&quot;PyQt5.QtXml&quot;</span>,<span class="string">&quot;xlwings&quot;</span> --icon=<span class="string">&quot;logo.ico&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232022909-pyqt5-11.png" alt=""></p><p>由于pyInstaller只能分析出需要哪些代码文件。 而程序动态打开的资源文件，比如图片、excel、ui这些，它是不会帮你打包的。</p><p>而我的程序需要从调用xls表格文件，手动拷贝到dist/main目录中。</p><p>然后，再双击运行 main.exe，即可成功。</p><h3 id="5-3-改进：减少打包程序的大小">5.3 改进：减少打包程序的大小</h3><p>刚刚使用命令行直接打包，发现打包出来的程序非常大。原因是打包时系统会将很多原本用不到的依赖库一并打包起来。经过在网上查找方法，发现可以使用虚拟环境，原理是新建一个虚拟环境，然后在虚拟环境中安装程序的依赖库，然后在虚拟环境中完成打包。</p><p><strong>（1）使用pipenv创建虚拟环境</strong></p><p>创建python虚拟环境，需要系统已经安装好python虚拟环境。打开cmd。</p><ol><li>安装pipenv</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure><ol start="2"><li>进入一个空目录，初始化虚拟python环境（注意python版本需要与系统安装的版本一致）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv --python 3.9</span><br></pre></td></tr></table></figure><ol start="3"><li>进入虚拟环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure><p><strong>（2）安装程序依赖</strong></p><p>在虚拟环境中，只安装python程序使用到的库，尽可能减少打包程序的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br><span class="line">pip install pyqt5</span><br><span class="line">pip install xlwings</span><br></pre></td></tr></table></figure><p><strong>（3）虚拟环境中打包程序</strong></p><p>在虚拟环境中直接使用pyinstaller打包程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller main.py --noconsole --hidden-import <span class="string">&quot;PyQt5.QtXml&quot;</span>,<span class="string">&quot;xlwings&quot;</span> --icon=<span class="string">&quot;logo.ico&quot;</span></span><br></pre></td></tr></table></figure><p>这样打包完成后的程序就小了很多。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>g2o图优化简介与基本使用方法</title>
      <link href="/post/7851485c.html"/>
      <url>/post/7851485c.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、g2o简介">一、g2o简介</h3><p>g2o（General Graphic Optimization）是一个基于图优化的库，将非线性优化与图论结合起来的理论，我们可以利用g2o求解任何可以表示为图优化的最小二乘问题。</p><blockquote><p>图优化就是把优化问题表现成图的方式。图由顶点和边组成，其中顶点表示优化变量，边表示误差项，对任意一个非线性?&gt; 最小二乘问题，我们都可以构建与之对应的图。<br>（注：这里的图是图论意义上的图，可以用概率论里面的定义，贝叶斯图或因子图。）</p></blockquote><h3 id="二、g2o安装">二、g2o安装</h3><p>首先安装g2o的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qt5-qmake qt5-default libqglviewer-dev-qt5 libsuitesparse-dev libcxsparse3 libcholmod3 </span><br></pre></td></tr></table></figure><p>然后到github下clone此工程，然后编译安装，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RainerKuemmerle/g2o.git</span><br><span class="line"><span class="built_in">cd</span> g2o/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>g2o的头文件在<code>/usr/local/g2o</code>下，库文件在<code>/usr.local/lib</code>下。</p><h3 id="三、利用g2o拟合曲线">三、利用g2o拟合曲线</h3><h4 id="1-拟合步骤">1. 拟合步骤</h4><p><strong>① 定义顶点和边的类型（优化变量与误差项）</strong><br><strong>② 构建图</strong><br><strong>③ 选择优化算法</strong><br><strong>④ 调用g2o进行优化，返回结果</strong></p><h3 id="2-实验-拟合曲线">2. 实验-拟合曲线</h3><p>此示例程序还依赖opencv、Eigen、Ceres库，需要预先安装。</p><p><strong>main.cpp文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/g2o_core_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_vertex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/base_unary_edge.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/block_solver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_levenberg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_gauss_newton.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/core/optimization_algorithm_dogleg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;g2o/solvers/dense/linear_solver_dense.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的顶点（优化变量）（参数：维度、数据类型）</span></span><br><span class="line"><span class="comment">// 优化变量维数：3维    数据类型：Eigen::Vector3d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingVertex</span> : <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">3</span>, Eigen::Vector3d&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    EIGEN_MAKE_ALIGNED_OPERATOR_NEW     <span class="comment">// 字节对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;           <span class="comment">// 设定被优化变量的原始值、重置成员函数的估计值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="type">const</span> <span class="type">double</span> *update)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _estimate += Eigen::<span class="built_in">Vector3d</span>(update);           <span class="comment">// 更新优化变量（估计值）。增量方程计算出增量△x后，通过此函数对估计值进行调整</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读盘</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存盘</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 曲线模型的边（误差项）（参数：观测值维度、类型、连接定点类型）</span></span><br><span class="line"><span class="comment">// 边的模型：BaseUnaryEdge   连接顶点个数：1    测量值数据类型：double  顶点类型：CurveFittingVertex</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurveFittingEdge</span> : <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">1</span>, <span class="type">double</span>, CurveFittingVertex&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">CurveFittingEdge</span><span class="params">(<span class="type">double</span> x)</span>:BaseUnaryEdge(),_x(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算曲线模型误差</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);        <span class="comment">// _vertices[]存储顶点信息</span></span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        _error(<span class="number">0</span>, <span class="number">0</span>) = _measurement - std::<span class="built_in">exp</span>(<span class="built_in">abc</span>(<span class="number">0</span>, <span class="number">0</span>) * _x * _x + <span class="built_in">abc</span>(<span class="number">1</span>,<span class="number">0</span>) * _x + <span class="built_in">abc</span>(<span class="number">2</span>, <span class="number">0</span>));        <span class="comment">// _error存储computeError()函数计算的误差</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算雅克比矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> CurveFittingVertex *v = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> CurveFittingVertex *&gt; (_vertices[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">const</span> Eigen::Vector3d abc = v-&gt;<span class="built_in">estimate</span>();</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">exp</span>(abc[<span class="number">0</span>] * _x * _x + abc[<span class="number">1</span>] * _x + abc[<span class="number">2</span>]);</span><br><span class="line">        _jacobianOplusXi[<span class="number">0</span>] = -_x * _x * y;</span><br><span class="line">        _jacobianOplusXi[<span class="number">1</span>] = -_x * y;</span><br><span class="line">        _jacobianOplusXi[<span class="number">2</span>] = -y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">read</span><span class="params">(istream &amp;in)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">write</span><span class="params">(ostream &amp;out)</span> <span class="type">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _x;    <span class="comment">//x值；（y值为_measurement测量值）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义数据参数</span></span><br><span class="line">    <span class="type">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;    <span class="comment">//真实参数值</span></span><br><span class="line">    <span class="type">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;   <span class="comment">//估计参数值</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                            <span class="comment">//数据点个数</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                   <span class="comment">//噪声Sigma值</span></span><br><span class="line">    <span class="type">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">    cv::RNG rng;                            <span class="comment">//随机数产生器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成100个带高斯噪声的数据</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建图优化</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::BlockSolver&lt;g2o::BlockSolverTraits&lt;<span class="number">3</span>, <span class="number">1</span>&gt;&gt; BlockSolverType;    <span class="comment">// 配置BlockSolver，每个误差项优化变量维度为3，误差值维度为1</span></span><br><span class="line">    <span class="keyword">typedef</span> g2o::LinearSolverDense&lt;BlockSolverType::PoseMatrixType&gt; LinearSolverType;    <span class="comment">// 创建BlockSolver，并用定义的线性求解器初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置梯度下降的方法，创建总求解器solver</span></span><br><span class="line">    <span class="keyword">auto</span> solver = <span class="keyword">new</span> g2o::<span class="built_in">OptimizationAlgorithmGaussNewton</span>(g2o::<span class="built_in">make_unique</span>&lt;BlockSolverType&gt;(g2o::<span class="built_in">make_unique</span>&lt;LinearSolverType&gt;()));</span><br><span class="line">    g2o::SparseOptimizer optimizer;     <span class="comment">//创建系数优化器</span></span><br><span class="line">    optimizer.<span class="built_in">setAlgorithm</span>(solver);     <span class="comment">//设置求解方法</span></span><br><span class="line">    optimizer.<span class="built_in">setVerbose</span>(<span class="literal">true</span>); <span class="comment">//打开调试输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中加入顶点</span></span><br><span class="line">    CurveFittingVertex *v = <span class="keyword">new</span> <span class="built_in">CurveFittingVertex</span>();</span><br><span class="line">    v-&gt;<span class="built_in">setEstimate</span>(Eigen::<span class="built_in">Vector3d</span>(ae, be, ce));</span><br><span class="line">    v-&gt;<span class="built_in">setId</span>(<span class="number">0</span>);</span><br><span class="line">    optimizer.<span class="built_in">addVertex</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图中加入边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        CurveFittingEdge *edge = <span class="keyword">new</span> <span class="built_in">CurveFittingEdge</span>(x_data[i]);</span><br><span class="line">        edge-&gt;<span class="built_in">setId</span>(i);                     <span class="comment">//定义边的编号（决定在H矩阵中的位置）</span></span><br><span class="line">        edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>, v);           <span class="comment">//设置连接的顶点</span></span><br><span class="line">        edge-&gt;<span class="built_in">setMeasurement</span>(y_data[i]);    <span class="comment">//设置观测值</span></span><br><span class="line">        edge-&gt;<span class="built_in">setInformation</span>(Eigen::Matrix&lt;<span class="type">double</span>, <span class="number">1</span>, <span class="number">1</span>&gt;::<span class="built_in">Identity</span>() * <span class="number">1</span> / (w_sigma * w_sigma));    <span class="comment">//信息矩阵：协方差矩阵的逆</span></span><br><span class="line">        optimizer.<span class="built_in">addEdge</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行优化</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Start optimization&quot;</span> &lt;&lt; endl;</span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//记录算法执行时间</span></span><br><span class="line">    optimizer.<span class="built_in">initializeOptimization</span>(); <span class="comment">//初始化</span></span><br><span class="line">    optimizer.<span class="built_in">optimize</span>(<span class="number">10</span>);    <span class="comment">//执行10次</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; s.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3d abc_estimate = v-&gt;<span class="built_in">estimate</span>();   <span class="comment">//获取当前值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;estimated model: &quot;</span> &lt;&lt; abc_estimate.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="built_in">project</span>(g2oCurveFitting)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"># OpenCV库</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Eigen库</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"># Ceres库</span><br><span class="line"><span class="built_in">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># g2o库</span><br><span class="line"><span class="built_in">list</span>( APPEND CMAKE_MODULE_PATH /home/huffie/slam/<span class="number">3</span>rdparty/g2o/cmake_modules ) #刚才clone的项目文件夹</span><br><span class="line"><span class="built_in">set</span>(G2O_ROOT /usr/local/include/g2o)</span><br><span class="line"><span class="built_in">find_package</span>(G2O REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;G2O_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(g2oCurveFitting main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting  g2o_stuff   g2o_core )</span><br><span class="line"><span class="built_in">target_link_libraries</span>(g2oCurveFitting $&#123;CERES_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Ceres基本使用方法】使用Ceres拟合曲线求解最小二乘问题</title>
      <link href="/post/1efb54e0.html"/>
      <url>/post/1efb54e0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Ceres简介">一、Ceres简介</h3><p>Ceres是一个最小二乘问题求解库，我们只需要定义待优化的问题，然后交给它计算即可。</p><p><strong>① 基本概念</strong><br>常用的最小二乘问题形式如下：</p><p><img src="https://img.mahaofei.com/img/202112232017086-ceres-introduction-1.png" alt=""></p><ul><li>参数块：$x_1$, … $x_n$等优化变量</li><li>代价函数（残差块/误差项）：$f_i$</li><li>核函数：ρ(·)，目标函数由许多平方项经过核函数求和自称</li></ul><p><strong>② 使用方法</strong></p><ol><li>定义每个参数块。参数块就是简单的向量，也可以是四元数、李代数等特殊的结构。</li><li>定义残差块的计算方式。残差块对参数块进行自定义计算，返回残差值，然后求平方和作为目标函数的值。</li><li>定义雅可比的计算方式。</li><li>把所有的参数块和残差块加入Ceres定义的Problem对象中，调用Solve函数求解</li></ol><h3 id="二、Ceres安装">二、Ceres安装</h3><p>首先下载Ceres的源代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceres-solver/ceres-solver.git</span><br></pre></td></tr></table></figure><p>安装ceres所需要的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libsuitesparse-dev libcxsparse3 libgflags-dev libgoogle-glog-dev libgtest-dev</span><br></pre></td></tr></table></figure><p>然后进入文件夹编译安装ceres，这里耗时比较久大概20min左右。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ceres-solver/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装完成后，如果在<code>/usr/local/include/ceres/</code>目录下能找到Ceres的头文件，并且也有库文件<code>/usr/local/lib/libceres.a </code>，说明安装成功了，可以使用Ceres进行优化计算了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /usr/local/include/ceres/</span><br><span class="line">ll /usr/local/lib/libceres.a </span><br></pre></td></tr></table></figure><h3 id="三、使用Ceres拟合曲线">三、使用Ceres拟合曲线</h3><p>此示例程序依赖opencv、Eigen库，需要预先安装。</p><p><strong>main.cpp</strong>文件代码程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ceres/ceres.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建代价函数的计算模型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CURVE_FITTING_COST</span>&#123;</span><br><span class="line">    <span class="built_in">CURVE_FITTING_COST</span>(<span class="type">double</span> x, <span class="type">double</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载()，仿函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> T *<span class="type">const</span> abc, <span class="comment">// 模型参数，有3维</span></span></span></span><br><span class="line"><span class="params"><span class="function">            T *residual)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = <span class="built_in">T</span>(_y) - ceres::<span class="built_in">exp</span>(abc[<span class="number">0</span>] * <span class="built_in">T</span>(_x) * <span class="built_in">T</span>(_x) + abc[<span class="number">1</span>] * <span class="built_in">T</span>(_x) + abc[<span class="number">2</span>]); <span class="comment">// y-exp(ax^2+bx+c)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义数据参数</span></span><br><span class="line">    <span class="type">double</span> ar = <span class="number">1.0</span>, br = <span class="number">2.0</span>, cr = <span class="number">1.0</span>;    <span class="comment">//真实参数值</span></span><br><span class="line">    <span class="type">double</span> ae = <span class="number">2.0</span>, be = <span class="number">-1.0</span>, ce = <span class="number">5.0</span>;   <span class="comment">//估计参数值</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">100</span>;                            <span class="comment">//数据点个数</span></span><br><span class="line">    <span class="type">double</span> w_sigma = <span class="number">1.0</span>;                   <span class="comment">//噪声Sigma值</span></span><br><span class="line">    <span class="type">double</span> inv_sigma = <span class="number">1.0</span> / w_sigma;</span><br><span class="line">    cv::RNG rng;                            <span class="comment">//随机数产生器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成100个带高斯噪声的数据</span></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; x_data, y_data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="type">double</span> x = i / <span class="number">100.0</span>;</span><br><span class="line">        x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">        y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(ar * x * x + br * x + cr) + rng.<span class="built_in">gaussian</span>(w_sigma * w_sigma));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> abc[<span class="number">3</span>] = &#123;ae, be, ce&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建最小二乘问题</span></span><br><span class="line">    ceres::Problem problem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="comment">//添加误差项。使用自动求导，模板参数：误差类型、输出维度、输入维度、维数要与前面struct中一致</span></span><br><span class="line">        problem.<span class="built_in">AddResidualBlock</span>(<span class="keyword">new</span> ceres::<span class="built_in">AutoDiffCostFunction</span>&lt;CURVE_FITTING_COST, <span class="number">1</span>, <span class="number">3</span>&gt;(<span class="keyword">new</span> <span class="built_in">CURVE_FITTING_COST</span>(x_data[i], y_data[i])),<span class="literal">nullptr</span>,abc);</span><br><span class="line">        <span class="comment">//nullptr为核函数不使用为空，abc为待估计参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置并运行求解器</span></span><br><span class="line">    ceres::Solver::Options options;     <span class="comment">//定义配置项</span></span><br><span class="line">    options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;  <span class="comment">//配置增量方程的解法</span></span><br><span class="line">    options.minimizer_progress_to_stdout = <span class="literal">true</span>;    <span class="comment">//输出到cout</span></span><br><span class="line">    ceres::Solver::Summary summary; <span class="comment">//定义优化信息</span></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//计时：求解开始时间</span></span><br><span class="line">    ceres::<span class="built_in">Solve</span>(options, &amp;problem, &amp;summary);  <span class="comment">//开始优化求解！</span></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::<span class="built_in">now</span>();  <span class="comment">//计时：求解结束时间</span></span><br><span class="line">    chrono::duration&lt;<span class="type">double</span>&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;<span class="type">double</span>&gt;&gt;(t2 - t1);  <span class="comment">//计算求解耗时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;solve time cost = &quot;</span> &lt;&lt; time_used.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s.&quot;</span> &lt;&lt; endl;  <span class="comment">//输出求解耗时</span></span><br><span class="line">    cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl;  <span class="comment">//输出简要优化信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;estimated a, b, c = &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a:abc)    <span class="comment">//输出优化变量</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CMakeLists.txt</strong>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="built_in">project</span>(ceresCurveFitting)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"># OpenCV库</span><br><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;OpenCV_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Ceres库</span><br><span class="line"><span class="built_in">find_package</span>(Ceres REQUIRED)</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CERES_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># Eigen库</span><br><span class="line"><span class="built_in">include_directories</span>(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br><span class="line"></span><br><span class="line"># 定义可执行文件</span><br><span class="line"><span class="built_in">add_executable</span>(ceresCurveFitting main.cpp)</span><br><span class="line"></span><br><span class="line"># 链接库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(ceresCurveFitting $&#123;OpenCV_LIBS&#125;)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(ceresCurveFitting $&#123;CERES_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232017359-ceres-introduction-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS外接usb摄像头标定方法</title>
      <link href="/post/130b716a.html"/>
      <url>/post/130b716a.html</url>
      
        <content type="html"><![CDATA[<p>usb_cam官方文档：<a href="http://wiki.ros.org/camera_calibration">http://wiki.ros.org/camera_calibration</a><br>camera_calibrate官方文档：<a href="http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration">http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration</a><br>棋盘格也在上面的链接中下载。</p><p>摄像头标定的目的是消除相机畸变，具体畸变原理可以参考之前的文章<a href="https://blog.csdn.net/weixin_44543463/article/details/120659447">【相机模型与去畸变方法详解】</a>。usb摄像头在ros系统标定过程大致可以分成几个步骤。①安装usb_camera驱动包；② 运行usb_cam读取usb摄像头图像；③下载打印棋盘格并进行摄像头标定。</p><h3 id="1-安装usb-camera驱动包">1. 安装usb_camera驱动包</h3><ul><li>进入工作空间的src目录（这里工作空间目录可能都不一样，自行修改）</li><li>下载usb_cam源代码</li><li>编译安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ros-drivers/usb_cam.git</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="2-运行usb-cam读取摄像头图像">2. 运行usb_cam读取摄像头图像</h3><p>首先打开一个终端，运行<code>roscore</code></p><p>然后再打开一个终端，运行<code>usb_cam-test.launch</code>启动文件（由于刚才下载的源代码中由测试文件，因此可以直接启动）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/usb_cam/launch</span><br><span class="line">roslaunch usb_cam-test.launch</span><br></pre></td></tr></table></figure><p>默认情况下开启的是电脑自带摄像头，如果需要启动外置摄像头，则修改一下launch文件，将参数第一行的value改为<code>value=&quot;/dev/video1&quot;</code>，然后重新编译一下。</p><blockquote><p>如果更改后启动报错，那么执行<code>ls /dev/video*</code>命令看看外界摄像头是那个，再将launch文件改为对应的video2或video3。<br>比如我的usb摄像头就是 /dev/video2</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;video_device&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/dev/video1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果出现如下错误<br>ERROR: cannot launch node of type [usb_cam/usb_cam_node]: usb_cam<br>ROS path [0]=/opt/ros/kinetic/share/ros<br>ROS path [1]=/opt/ros/kinetic/share<br>首先进入工作空间目录</p></blockquote><h3 id="3-进行摄像头标定">3. 进行摄像头标定</h3><p>再次打开一个终端（前两个分别运行<code>roscore</code>和<code>usb_cam-test</code>）</p><p><strong>① 查看主题名称</strong></p><p>输入<code>rostopic list</code>查看ros中的主题，检查是否有<code>/usb_cam/camera_info</code>和<code>/usb_cam/image_raw</code>两个主题。（主题名可能会不一样，有可能是/usb_cam_node记住自己的这两个主题的名字）</p><p><img src="https://img.mahaofei.com/img/202112232015769-camera-calibrate-1.png" alt=""></p><blockquote><p>如果出现 ImportError: No module named cv2的问题，请参考下面这篇文章<br>文章链接：<a href="https://blog.csdn.net/weixin_44543463/article/details/120717831#pic_center">【ImportError: No module named cv2问题的解决方法（修改python默认版本）】</a></p></blockquote><p><strong>② 执行命令启动标定程序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.03 image:=/usb_cam/image_raw camera:=/usb_cam</span><br></pre></td></tr></table></figure><p>其中的8x6是指的棋盘格内部角点的个数，如下图我下载的棋盘格内部角点是8x6的。如果你是11x8角点的棋盘格，那么命令里面的8x6替换成11x8即可。</p><p><img src="https://img.mahaofei.com/img/202112232016343-camera-calibrate-2.png" alt=""></p><p><strong>③ 变换角度使程序记录样本</strong></p><p>拿着棋盘格纸多变幻几个角度，离远离近，边边角角都采集一些样本，当命令行里看到sample接近50的时候，标定按钮calibrate就会变亮了。</p><p><strong>④ 进行标定并保存</strong><br>点击CALIBRATE按钮进行标定，等待一小段时间后，就可以在命令行中看到标定的结果。<br>标定没有问题的花，点击COMMIT按钮就可以保存了，保存之后，下次再启动usb_camera就会自动使用标定的参数，可以发现摄像头不再畸变了。</p><p><img src="https://img.mahaofei.com/img/202112232016191-camera-calibrate-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232016631-camera-calibrate-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil5 C51版 下载与安装教程（51单片机编程软件）</title>
      <link href="/post/6c3a51dc.html"/>
      <url>/post/6c3a51dc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>阿里云盘<br>链接：<a href="https://www.aliyundrive.com/s/ttZBZXBNMja">https://www.aliyundrive.com/s/ttZBZXBNMja</a><br>下载完成后将文件后缀名改回【.7z】即可正常解压。</p></blockquote><ol><li>解压安装包，右键【C51-V957.exe】，<strong>以管理员身份运行</strong></li></ol><p><img src="https://img.mahaofei.com/img/202112232002909-keil51-1.png" alt=""></p><ol start="2"><li>莫得选择，<strong>点击next</strong>继续安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232002704-keil51-2.png" alt=""></p><ol start="3"><li><strong>同意</strong>用户协议，<strong>点击next</strong>继续</li></ol><p><img src="https://img.mahaofei.com/img/202112232003825-keil51-3.png" alt=""></p><ol start="4"><li>选择安装路径，<strong>路径不能有中文</strong>，进行安装（注：如果想要安装51和MDK两个版本的Keil，也就是想要编写51单片机和32单片机两种程序，需要安装在两个单独的文件夹中）</li></ol><p><img src="https://img.mahaofei.com/img/202112232003419-keil51-4.png" alt=""></p><ol start="5"><li><strong>信息随便输</strong>，输完直接<strong>点击next</strong>就可以</li></ol><p><img src="https://img.mahaofei.com/img/202112232003599-keil51-5.png" alt=""></p><ol start="6"><li>安装过程很快，大约十几秒，点击finish完成安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232004114-keil51-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232004458-keil51-7.png" alt=""></p><ol start="7"><li>回到桌面，找到【Keil5】的快捷方式，右键<strong>以管理员身份运行</strong>，然后打开【File -&gt; License Management】选项卡</li></ol><p><img src="https://img.mahaofei.com/img/202112232004254-keil51-8.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232004032-keil51-9.png" alt=""></p><ol start="8"><li>在解压的安装包中找到【Crack.exe】文件，<strong>右键以管理员身份运行</strong></li></ol><p><img src="https://img.mahaofei.com/img/202112232005088-keil51-10.png" alt=""></p><ol start="9"><li>在【License Management】中<strong>复制CID</strong>，<strong>粘贴到破解程序</strong>中，target选择C51，<strong>点击Generate</strong>生成激活码</li></ol><p><img src="https://img.mahaofei.com/img/202112232005496-keil51-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232005539-keil51-12.png" alt=""></p><ol start="10"><li><p>将激活码粘贴回【License Management】下方的输入框中，并点击【Add LIC】</p><p><img src="https://img.mahaofei.com/img/202112232006203-keil51-13.png" alt=""></p></li><li><p>可以看到已经成功激活，激活时间到2032年</p><p><img src="https://img.mahaofei.com/img/202112232006493-keil51-14.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil5 MDK版 下载与安装教程（STM32单片机编程软件）</title>
      <link href="/post/1b083906.html"/>
      <url>/post/1b083906.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>阿里云盘<br>链接：<a href="https://www.aliyundrive.com/s/42a1npEEsrw">https://www.aliyundrive.com/s/42a1npEEsrw</a><br>下载完成后将文件后缀名改回【.7z】即可正常解压。</p></blockquote><ol><li>解压安装包，<strong>以管理员身份运行</strong>【MDK528.exe】</li></ol><p><img src="https://img.mahaofei.com/img/202112232006461-keilmdk-1.png" alt=""></p><ol start="2"><li>按步骤一直安装就可以，每一步我都在下面截了图，可以对照一下。</li></ol><p><img src="https://img.mahaofei.com/img/202112232007055-keilmdk-2.png" alt=""></p><ol start="3"><li>选择我同意用户协议，然后next</li></ol><p><img src="https://img.mahaofei.com/img/202112232007859-keilmdk-3.png" alt=""></p><ol start="4"><li>选择安装位置，一定要和Keil C51版本安装在<strong>不同的文件夹</strong>中</li></ol><p><img src="https://img.mahaofei.com/img/202112232007389-keilmdk-4.png" alt=""></p><ol start="5"><li>信息随便填</li></ol><p><img src="https://img.mahaofei.com/img/202112232010807-keilmdk-5.png" alt=""></p><ol start="6"><li>等待安装，大约耗时1分钟左右</li></ol><p><img src="https://img.mahaofei.com/img/202112232010318-keilmdk-6.png" alt=""></p><ol start="7"><li>如果安装过程中弹出需要安装某驱动，一定要安装</li></ol><p><img src="https://img.mahaofei.com/img/202112232011061-keilmdk-7.png" alt=""></p><ol start="8"><li>不需要展示新特性，直接下一步点击finish完成即可。</li></ol><p><img src="https://img.mahaofei.com/img/202112232011656-keilmdk-8.png" alt=""></p><ol start="9"><li>出现下面这个包安装界面，直接关闭即可，后续我们手动安装包，要快得多</li></ol><p><img src="https://img.mahaofei.com/img/202112232012974-keilmdk-9.png" alt=""></p><blockquote><p>如果之前安装过Keil51版本，想要两个版本共存，需要加入以下步骤。如果仅安装Keil MDK版，可跳过此部分。</p><ol><li><p>打开C51安装路径，找到 TOOLS.INI  这个文件</p></li><li><p>以记事本打开【TOOLS.INI】这个文件，复制 [C51]（包括）以下的全部内容</p></li><li><p>粘贴至MDK-ARM安装目录下的  TOOLS.INI 文件末尾，保存，关闭。</p></li></ol><p><img src="https://img.mahaofei.com/img/202112232012255-keilmdk-10.png" alt=""></p></blockquote><ol start="10"><li><p>在桌面找到【Keil 5】的快捷方式，右键以管理员身份运行。然后打开【File -&gt; License Management】选项卡。</p><p><img src="https://img.mahaofei.com/img/202112232012315-keilmdk-11.png" alt=""></p></li><li><p>复制右上角的CID</p><p><img src="https://img.mahaofei.com/img/202112232013981-keilmdk-12.png" alt=""></p></li><li><p>打开解压的安装包，找到【keygen.exe】，右键以管理员身份运行</p><p><img src="https://img.mahaofei.com/img/202112232013788-keilmdk-13.png" alt=""></p></li><li><p><strong>粘贴CID</strong>到对应的输入框中，<strong>target选择ARM</strong>，然后点击<strong>Generate生成激活码</strong>。</p><p><img src="https://img.mahaofei.com/img/202112232014581-keilmdk-14.png" alt=""></p></li><li><p>复制生成的激活码，回到Keil中的【License Management】对话框，在下方LIC中粘贴激活码，然后点击Add LIC激活成功。（激活的日期过了也不影响使用）</p><p><img src="https://img.mahaofei.com/img/202112232014618-keilmdk-15.png" alt=""></p></li><li><p>安装剩下的两个库文件，直接双击就可以安装。（两个库文件分别对应STM32F1和F4的芯片）</p><p><img src="https://img.mahaofei.com/img/202112232014820-keilmdk-16.png" alt=""></p></li><li><p>至此安装完成，可以正常使用。</p><p><img src="https://img.mahaofei.com/img/202112232015660-keilmdk-17.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS+Gazebo仿真差速小车并实现控制</title>
      <link href="/post/fc92db80.html"/>
      <url>/post/fc92db80.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本工程的功能包有两个，分别用于<strong>gazebo仿真</strong>与<strong>键盘控制运动</strong><br>功能包原文件如下：<br>diff_wheeled_robot_control : <a href="https://huffie.lanzouw.com/iXilxvdqola">https://huffie.lanzouw.com/iXilxvdqola</a><br>diff_wheeled_robot_gazebo: <a href="https://huffie.lanzouw.com/ixG3uvdqoyd">https://huffie.lanzouw.com/ixG3uvdqoyd</a></p></blockquote><p><strong>准备工作：</strong><br>如果你是第一次使用gazebo，需要先安装下面的包才可以正常使用：<br>（这里以noetic版本为例，如果你是其他版本的ros，自行更换中间的代码即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-gazebo-ros-pkgs ros-noetic-gazebo-ros ros-noetic-gazebo-msgs ros-noetic-gazebo-plugins ros-noetic-gazebo-ros-control</span><br></pre></td></tr></table></figure><p>安装完成后，在命令行执行  <code>gazebo</code>命令检查是否正确安装，如果看到下面的界面说明安装没有问题。</p><p><img src="https://img.mahaofei.com/img/202112232001567-ros-gazebo-1.png" alt=""></p><p>然后再在命令行中运行下面的命令，检查Gazebo的ROS接口是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore &amp; rosrun gazebo_ros gazebo</span><br></pre></td></tr></table></figure><p>这个命令会运行roscore，同时也会启动gazebo，如果能看到gazebo的界面说明没有问题。</p><h3 id="一、创建小车模型">一、创建小车模型</h3><p><strong>1. 首先创建一个功能包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg diff_wheeled_robot_gazebo roscpp tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><blockquote><p>如果之前没有创建过ROS工作空间，可以先执行如下命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></blockquote><p><strong>2. 创建基本文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> diff_wheeled_robot_gazebo/</span><br><span class="line"><span class="built_in">mkdir</span> urdf meshes launch world</span><br></pre></td></tr></table></figure><p><strong>3. 复制模型文件</strong><br>将<a href="https://huffie.lanzouw.com/ixG3uvdqoyd">提供的gazebo工程包</a>urdf文件夹中的 <code>diff_wheeled_robot.xacro</code> 文件和 <code>wheel.urdf.xacro</code> 文件复制进自己的工程的urdf文件夹内。</p><p>同时将mesh文件夹中万向轮的三维模型 <code>caster_wheel.stl</code> 文件复制进自己工程的meshes文件夹内。</p><p>关于xacro的代码解释，可以参考另一篇机械臂相关内容：<a href="https://blog.csdn.net/weixin_44543463/article/details/120607629">urdf与xacro的使用方法 &amp; 机械臂模型仿真示例</a></p><p><strong>4. 创建launch文件</strong><br>回到上一级，进入launch文件夹，创建一个<code>diff_wheeled_gazebo.launch</code>文件，并在其中添加如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- We resume the logic in empty_world.launch --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg debug)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg use_sim_time)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg headless)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- urdf xml robot description loaded on the Parameter Server--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find diff_wheeled_robot_gazebo)/urdf/diff_wheeled_robot.xacro&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Run a python script to the send a service call to gazebo_ros to spawn a URDF robot --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;urdf_spawner&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">args</span>=<span class="string">&quot;-urdf -model diff_wheeled_robot -param robot_description&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5. 编译并启动节点，查看机器人模型</strong><br>首先编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_gazebo diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><p>可以看到已经正常启动Gazebo，并且小车的模型也已经正常加载出来了</p><p><img src="https://img.mahaofei.com/img/202112232001178-ros-gazebo-2.png" alt=""></p><h3 id="二、控制小车移动">二、控制小车移动</h3><p><strong>1. 插件介绍</strong><br>控制小车移动所使用的插件是 <code>libgazebo_ros_diff_drive.so</code> 。此插件的添加代码已经写在了xacro文件中如下：</p><p><img src="https://img.mahaofei.com/img/202112232001660-ros-gazebo-3.png" alt=""></p><p>其中可以指定的参数包括轮子的关节、轮子的间距、车轮直径、里程计的主题等等。这里面最重要的一个参数是控制命令主题 <code>commandTopic</code>，用于驱动车轮的运动。在这里我们可以通过向 <code>/cmd_vel</code> 主题发布数据来控制小车的运动。</p><p><strong>2. 测试运动</strong><br>在gazebo仿真正常运行的情况下，新打开一个终端输入如下指令，可以使小车进行圆周运动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -r 10 /cmd_vel geometry_msgs/Twist <span class="string">&#x27;&#123;linear: &#123;x: 0.5, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 0.5&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112232001294-ros-gazebo-4.png" alt=""></p><h3 id="三、键盘控制小车移动">三、键盘控制小车移动</h3><p><strong>1. 创建功能包</strong><br>创建一个功能包用于驱动小车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin/src</span><br><span class="line">catkin_create_pkg diff_wheeled_robot_control rospy tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><p>将<a href="https://huffie.lanzouw.com/iXilxvdqola">control工程包</a>中的<code>launch</code>文件夹和<code>scripts</code>文件夹复制到新创建的功能包中。</p><p><strong>2. 编译启动仿真</strong></p><p>回到工作空间目录进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>启动仿真程序</p><p>首先和之前一样启动小车的仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_gazebo diff_wheeled_gazebo.launch</span><br></pre></td></tr></table></figure><p>然后新打开一个终端启动键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch diff_wheeled_robot_control keyboard_teleop.launch</span><br></pre></td></tr></table></figure><p>这时候终端窗口内会出现提示，在终端内按下按键即可控制小车</p><p><img src="https://img.mahaofei.com/img/202112232002981-ros-gazebo-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112232002842-ros-gazebo-6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabVIEW2020下载与安装教程</title>
      <link href="/post/38b2093b.html"/>
      <url>/post/38b2093b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接:  <a href="https://pan.baidu.com/s/15mAoxOT_9aMnUQet08Wj4g">https://pan.baidu.com/s/15mAoxOT_9aMnUQet08Wj4g</a><br>提取码: evvm</p></blockquote><p>此教程为Labview2020 中文版的安装教程，英文版安装过程相同。</p><ol><li>打开解压后的文件夹，<strong>进入安装包目录</strong>，双击运行【<strong>Install.exe</strong>】开始安装。<br><img src="https://img.mahaofei.com/img/202112230940458-labview2020-1.png" alt=""></li><li>接受许可协议，<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230941389-labview2020-2.png" alt=""></li><li>直接<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230941226-labview2020-3.png" alt=""></li><li>莫得选择，继续<strong>下一步</strong><br><img src="https://img.mahaofei.com/img/202112230942373-labview2020-4.png" alt=""></li><li><strong>等待十多秒</strong>安装相关组件，然后会<strong>弹出选择菜单</strong>，按照默认选择<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202112230942043-labview2020-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230942214-labview2020-6.png" alt=""></li><li><strong>我接受，然后下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943289-labview2020-7.png" alt=""></li><li>还是莫得选择，继续<strong>接受，然后下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943520-labview2020-8.png" alt=""></li><li>核对信息，正常安装不会有问题，<strong>直接下一步</strong><br><img src="https://img.mahaofei.com/img/202112230943878-labview2020-9.png" alt=""></li><li><strong>等待安装</strong>，安装过程耗时分钟左右<br><img src="https://img.mahaofei.com/img/202112230944483-labview2020-10.png" alt=""></li><li><strong>选择yes</strong><br><img src="https://img.mahaofei.com/img/202112230944354-labview2020-11.png" alt=""></li><li>选择<strong>不加入用户体验改进计划</strong>，<strong>确定</strong><br><img src="https://img.mahaofei.com/img/202112230944025-labview2020-12.png" alt=""></li><li>在弹出的登陆页面<strong>点击取消</strong><br><img src="https://img.mahaofei.com/img/202112230944296-labview2020-13.png" alt=""></li><li>不需要重启，<strong>点击右上角x关闭安装程序即可</strong><br><img src="https://img.mahaofei.com/img/202112230945782-labview2020-14.png" alt=""></li><li>打开安装包，找到【<strong>NI License Acticator 1.2</strong>】，右键<strong>以管理员身份运行</strong><br><img src="https://img.mahaofei.com/img/202112230945417-labview2020-15.png" alt=""></li><li>将<strong>全部选项右键激活</strong><br><img src="https://img.mahaofei.com/img/202112230945106-labview2020-16.png" alt=""></li><li>至此完成安装，在开始菜单找到安装好的程序启动<br><img src="https://img.mahaofei.com/img/202112230946133-labview2020-17.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112230946156-labview2020-18.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ImportError No module named cv2问题的解决方法（修改python默认版本）</title>
      <link href="/post/cad41dc4.html"/>
      <url>/post/cad41dc4.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述-2">问题描述</h3><p>在调用opencv安装包时，会出现 <strong>ImportError: No module named cv2</strong> 的问题：</p><p><img src="https://img.mahaofei.com/img/202112231958111-no-module-1.png" alt=""></p><h3 id="产生原因">产生原因</h3><p>我确定我已经安装了opencv，但为什么还是显示没有此模块。查阅资料后发现是因为安装opencv是会安装到它默认的python版本，而这个python版本与系统默认使用的版本不一致，才会导致找不到模块。</p><p>例如我的电脑里安装了python2.7和python3.8两个版本，ubuntu系统启动程序默认使用python2.7，而opencv则安装在python3.8环境中。</p><h3 id="解决方法-2">解决方法</h3><blockquote><p>首先确定你是不是真的没有安装opencv的python支持，可以运行如下代码安装：</p><p>sudo pip3 install opencv-python</p><p>如果安装完还不能解决问题，看以下步骤</p></blockquote><p>更改系统的默认python版本，改为所使用的高版本。</p><p>可以先使用<code>ls /usr/bin/python*</code>查看系统中存在的python版本</p><p><img src="https://img.mahaofei.com/img/202112231958436-no-module-2.png" alt=""></p><p>然后移除软连接，更改python默认版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /user/bin/python</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/python3.5 /usr/bin/python</span><br></pre></td></tr></table></figure><p> <br>再次启动之前的程序，正常启动，不再显示ImportError: No module named cv2了！</p><p><img src="https://img.mahaofei.com/img/202112231959476-no-module-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urdf与xacro的使用方法 &amp; 机械臂模型仿真示例</title>
      <link href="/post/2a57a647.html"/>
      <url>/post/2a57a647.html</url>
      
        <content type="html"><![CDATA[<p>为什么要创建机器人的三维模型，原因在于机器人机器人仿真工具可以帮助我们体现发现设计中的一些关键错误。<br>而模型仿真的含义，在于我们创建的是机器人模型，因此不一定和实际机器人长得一模一样。但因为是仿真，所以模型必须具备所有的真实硬件特点。</p><h3 id="一、机器人建模的工具">一、机器人建模的工具</h3><p>ROS提供了许多功能包帮助我们进行机器人的建模，并使用ROS进行仿真。例如urdf、kdl_parser、robot_state_publisher、collada_urdf等等。</p><blockquote><p><strong>urdf是一种机器人模型的描述格式，基于XML规范，通过树状结构进行链接，因此机器人只能通过关节进行刚性连接</strong></p></blockquote><p><strong>1. robot_mode</strong><br>robot_model是一个包含了许多功能包的功能包集，包括如urdf等功能包。可以辅助我们创建机器人三维模型。</p><p><strong>2. 有关URDF的功能包</strong></p><ul><li><strong>joint_state_publisher</strong>：读取机器人模型描述文件、发布各关节信息、可使用RViz仿真、验证各关节旋转平移关系。</li><li><strong>kdl_parser</strong>：发布关节状态、正向/逆向运动学分析。</li><li><strong>robot_state_publisher</strong>：读取当前机器人关节状态，发布机器人的位姿状态。</li></ul><p><strong>3. xacro</strong><br>xacro相当于urdf的升级版本，可以让urdf更易读。并且xacro可以被用来描述复杂的机器人模型。</p><h3 id="二、URDF模型">二、URDF模型</h3><h4 id="2-1-URDF模型介绍">2.1 URDF模型介绍</h4><p><strong>1. URDF介绍</strong><br>URDF是一种机器人模型的描述文件，通过创建<code>.urdf</code>的文件，并使用xml标签来描述机器人模型。</p><p><strong>2. URDF常用标签</strong></p><ul><li><strong>robot</strong>：概述整个机器人模型，定义机器人的名字，连接件和关节。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;name of robot&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span>......<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span>&gt;</span>......<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>link</strong>：描述机器人某个刚体的外观属性<code>&lt;visual /&gt;</code>，包括大小、形状、颜色，也可以描述动态特性如惯性参数<code>&lt;inertial&gt;</code>、碰撞特性<code>&lt;collision&gt;</code>。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;name of link&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">visual</span>&gt;</span>............<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inertial</span>&gt;</span>..........<span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collision</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>joint</strong>：代表机器人的关节，可以机器人的定义运动学和动力学参数，也可以限制机器人的运动和速度。不同的关节标签代表了不同的关节类型如下</li></ul><table><thead><tr><th>joint标签</th><th>代表关节类型</th></tr></thead><tbody><tr><td><code>&lt;revolute&gt;</code></td><td>旋转副（有角度限制）</td></tr><tr><td><code>&lt;continuous&gt;</code></td><td>旋转副（无限旋转）</td></tr><tr><td><code>&lt;prismatic&gt;</code></td><td>移动副</td></tr><tr><td><code>&lt;fixed&gt;</code></td><td>固定副</td></tr><tr><td><code>&lt;float&gt;</code></td><td>浮动副</td></tr><tr><td><code>&lt;planar&gt;</code></td><td>平面副</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;name of joint&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;link2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calibration</span>&gt;</span>......<span class="tag">&lt;/<span class="name">calibration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span> <span class="attr">......</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span> <span class="attr">......</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>gazebo</strong>：包含了Gazebo仿真器的一些仿真参数，可以使用此标签引入gazebo插件、gazebo物理属性设置等等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;link1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Black<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-创建功能包">2.2 创建功能包</h4><p><strong>1. 首先进入catkin工作空间中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br></pre></td></tr></table></figure><blockquote><p>如果之前没有创建过ROS工作空间，可以先执行如下命令创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>2. 创建功能包</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg robot_description_pkg roscpp tf geometry_msgs urdf rviz xacro</span><br></pre></td></tr></table></figure><p><strong>3. 创建基本文件夹</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> robot_description_pkg</span><br><span class="line"><span class="built_in">mkdir</span> urdf meshes launch</span><br></pre></td></tr></table></figure><p>urdf文件夹主要用来保存机器人模型的描述文件；meshes文件用来保存模型文件；launch文件夹保存驱动文件，我们会需要创建启动文件启动RViz来展示机器人模型。</p><h4 id="2-3-创建URDF模型">2.3 创建URDF模型</h4><p>以一个平移与倾斜机构为例，如下图所示</p><p><strong>1. 创建urdf文件</strong><br>进入刚才创建的urdf文件夹下，新建一个<code>pan_tilt.urdf</code>文件，并输入以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;pan_tilt&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义了base_link --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;visual&gt;标签描述了在仿真环境的外观，包括几何外形&lt;geometry&gt;（圆柱形cylinder）等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.2&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 0 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义了关节pan_joint，以及其关节类型：旋转副（有限制） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 旋转副连接的两个刚体分别为base_link和pan_link --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;pan_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;pan_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.1&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;300&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-3.14&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;3.14&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span>=<span class="string">&quot;50&quot;</span> <span class="attr">friction</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;pan_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.4&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.09&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 1 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;tilt_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;pan_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;tilt_link&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.2&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;300&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-4.64&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;-1.5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dynamics</span> <span class="attr">damping</span>=<span class="string">&quot;50&quot;</span> <span class="attr">friction</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;tilt_link&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">length</span>=<span class="string">&quot;0.4&quot;</span> <span class="attr">radius</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">rpy</span>=<span class="string">&quot;0 1.5 0&quot;</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;green&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0 0 1&quot;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 检查urdf文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf pan_tilt.urdf</span><br></pre></td></tr></table></figure><p>如果urdf文件没有问题，会输出如下信息</p><p><img src="https://img.mahaofei.com/img/202112231956685-urdf-xacro-1.png" alt=""></p><p><strong>3. 创建launch文件</strong><br>进入之前创建的launch文件夹，创建<code>view_demo.launch</code>文件，并添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description_pkg)/urdf/pan_tilt.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_description_pkg)/urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. 启动节点查看仿真模型</strong><br>首先编译工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>然后启动节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch robot_description_pkg view_demo.launch </span><br></pre></td></tr></table></figure><p>打开后会发现出现Unknown frame map的提示，这时候只需要将<code>Fixed Frame</code>改为<code>base_link</code>即可。</p><p><img src="https://img.mahaofei.com/img/202112231957653-urdf-xacro-2.png" alt=""></p><p>然后在左下角点击<code>Add</code>，添加<code>RobotModel</code>就可以正常看到机器人模型了。</p><p><img src="https://img.mahaofei.com/img/202112231957351-urdf-xacro-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231957826-urdf-xacro-4.png" alt=""></p><h3 id="三、Xacro模型">三、Xacro模型</h3><p>URDF模型虽然简单，但存在一些问题，例如代码重用性不好（重复代码只能复制），模块化不好（不能引用其它URDF文件）等等。<br>而xacro是urdf的Plus版本，它通过创建macro来描述模型，macro可以被复用，也可以被其他文件引用，让代码更可读。</p><h4 id="3-1-Xacro的使用示例">3.1 Xacro的使用示例</h4><p>将经常改变的部分参数值统一定义在文件开头，这样改变参数值更简单，而不用在代码中一个一个参数找，然后代替它们。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.01&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;base_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;pan_link_length&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.4&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xacro:property</span> <span class="attr">name</span>=<span class="string">&quot;pan_link_radius&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231957996-urdf-xacro-5.png" alt=""></p><h4 id="3-2-数学表达式">3.2 数学表达式</h4><p>在xacro标签的<code>$&#123;&#125;</code>中可以使用数学表达式进行基本的运算，支持的数学运算包括+，-，×，÷。求幂和模运算不支持。</p><h4 id="3-3-xacro到URDF的转换">3.3 xacro到URDF的转换</h4><p>如果编写完成了xacro的模型文件，可以使用下面的命令完成到urdf的转换。其中<code>&gt;</code>两侧分别是转换前后的xacro和urdf文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro.py filename.xacro &gt; newfilename.urdf</span><br></pre></td></tr></table></figure><h3 id="四、实例：7自由度机械臂">四、实例：7自由度机械臂</h3><h4 id="4-1-7自由度机械臂介绍">4.1 7自由度机械臂介绍</h4><p>我们知道确定机械臂末端的位姿需要6个自由度（3坐标+3方向），因此七自由度机械臂属于冗驱机构，即我们可以通过针对同一个位姿得到不同的关节配置，这样可以有效提高机器人柔性和功能性，并且更容易避免碰撞。</p><h4 id="4-2-创建前的准备工作">4.2 创建前的准备工作</h4><p><strong>① 机械臂清单明细</strong></p><table><thead><tr><th>项目</th><th>参数</th></tr></thead><tbody><tr><td>自由度</td><td>7</td></tr><tr><td>机械臂长度</td><td>50cm</td></tr><tr><td>臂展</td><td>35cm</td></tr><tr><td>刚体数</td><td>12</td></tr><tr><td>关节数</td><td>11</td></tr></tbody></table><p><strong>② 关节列表</strong></p><table><thead><tr><th>序号</th><th>关节名称</th><th>关节类型</th><th>角度限制</th></tr></thead><tbody><tr><td>1</td><td>bottom_joint</td><td>固定（Fixed）</td><td>–</td></tr><tr><td>2</td><td>shoulder_pan_joint</td><td>旋转（Revolute）</td><td>-150~114</td></tr><tr><td>3</td><td>shoulder_pitch_joint</td><td>旋转（Revolute）</td><td>-67~109</td></tr><tr><td>4</td><td>elbow_roll_joint</td><td>旋转（Revolute）</td><td>-150~41</td></tr><tr><td>5</td><td>elbow_pitch_joint</td><td>旋转（Revolute）</td><td>-92~110</td></tr><tr><td>6</td><td>wrist_roll_joint</td><td>旋转（Revolute）</td><td>-150~150</td></tr><tr><td>7</td><td>wrist_pitch_joint</td><td>旋转（Revolute）</td><td>92-113</td></tr><tr><td>8</td><td>gripper_roll_joint</td><td>旋转（Revolute）</td><td>-150~150</td></tr><tr><td>9</td><td>finger_joint1</td><td>移动（Prismatic）</td><td>0~3cm</td></tr><tr><td>10</td><td>finger_joint2</td><td>移动（Prismatic）</td><td>0~3cm</td></tr></tbody></table><h4 id="4-3-模型代码详解">4.3 模型代码详解</h4><p>代码中主要由几部分组成<br><strong>① 常量定义</strong><br>定义常用的数学常量以及各机械臂刚体的参数值，例如下面的代码片段就分别为数学常量的定义以及肩部刚体的参数值定义。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constants --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;M_SCALE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.001 0.001 0.001&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;M_PI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3.14159&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Shoulder pan link properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shoulder_pan_width&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.04&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;shoulder_pan_len&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.08&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>② 惯性矩阵定义</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;inertial_matrix&quot;</span> <span class="attr">params</span>=<span class="string">&quot;mass&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mass&#125;&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 传动件配置</strong><br>通过使用<code>&lt;transmission&gt;</code>标签定义连接执行器的关节，它可以定义电机的类型、参数，硬件接口的类型以及ROS控制器的接口等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;transmission_block&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;tran1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;motor1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④ 引用其他xacro文件</strong><br>通过使用<code>&lt;xacro:include&gt;</code>标签，可以引用其他xacro文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:include</span> <span class="attr">filename</span>=<span class="string">&quot;$(find mastering_ros_robot_description_pkg)/urdf/sensors/xtion_pro_live.urdf.xacro&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑤ 插入简单模型</strong><br>与urdf一样，使用mesh标签插入一些基础的形状如圆柱体、长方体等等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;bottom_link&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot; 0 0 -0.04&quot;</span>  <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 0.02&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Brown&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot; 0 0 -0.04&quot;</span>  <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;1 1 0.02&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collision</span>&gt;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-4-在rviz中仿真">4.4 在rviz中仿真</h4><p><strong>① 将xacro文件转换为urdf模型</strong><br>首先进入到存放xacro文件的目录下，运行如下代码从<code>.xacro</code>文件生成<code>.urdf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun xacro xacro seven_dof_arm.xacro &gt; seven_dof_arm.xacro.urdf</span><br></pre></td></tr></table></figure><p>然后可以检查urdf文件是否正确生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_urdf seven_dof_arm.xacro.urdf</span><br></pre></td></tr></table></figure><p><strong>② 编辑launch文件</strong><br>进入launch文件夹，编辑launch文件如下，基本与上一小节一样，这里不再过多赘述</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description_pkg)/urdf/seven_dof_arm.xacro.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher_gui&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find robot_description_pkg)/urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>③ 编译运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">roslaunch robot_description_pkg view_arm.launch</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231958358-urdf-xacro-6.png" alt=""></p><blockquote><p>功能包文件<br>链接：<a href="https://huffie.lanzouw.com/ieTZMv5t3fi">https://huffie.lanzouw.com/ieTZMv5t3fi</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机模型与去畸变方法详解</title>
      <link href="/post/6e0a2557.html"/>
      <url>/post/6e0a2557.html</url>
      
        <content type="html"><![CDATA[<p>相机我们都熟悉，可以将三维空间的点集映射到二维平面中。而这映射过程，就需要我们使用几何模型去描述。</p><p>最简单最基础的模型就是针孔相机模型，它描述了相机的基本投影与成像的惯性。</p><p>但是我们常用的相机都是存在透镜的，因为透镜的缘故，光线投影成像时就会产生畸变，这时就需要畸变模型进行更准确的描述了。</p><p>此外，在许多场合还会需要利用摄像头实现测距功能，因此这里也介绍了双目相机模型和RGB-D深度相机模型。</p><h3 id="一、针孔相机模型">一、针孔相机模型</h3><p>实际物体的各点转换为图像上像素的过程可概括为<br>① 首先获得世界坐标系下实际点的坐标<br>② 将世界坐标系的坐标转换成相机坐标系下的坐标<br>③ 相机坐标系的坐标映射为图像上的某一个像素点</p><h4 id="1-1-成像原理">1.1 成像原理</h4><p>我们中学都做过小孔成像的物理实验，现实的空间点经过小孔投影后，在平面上会成一个倒立的像。而且实际点到光轴的距离X，与图像上对应点到中心的距离X’，其比值与实际点到小孔的垂直距离以及焦距有关。</p><p><img src="https://img.mahaofei.com/img/202112231944496-camera-models-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231944774-camera-models-2.png" alt=""></p><p>这样，我们可以在成像平面上可以得到真实物体的等比例放缩后的图像。不过相机中，我们最后获得的是一个个像素，因此还需要对所成的像进行采样和量化。</p><h4 id="1-2-实际坐标与像素坐标的关系">1.2 实际坐标与像素坐标的关系</h4><p>我们设在成像平面上固定一个像素坐标系ouv，<strong>原点o在图像左上角，u轴与x轴同向平行，v轴与y轴反向平行</strong>。这样像素坐标系和物理成像之间差了一个缩放和原点的平移。设像素坐标在u轴缩放了α倍，在v轴缩放了β倍，则关系式如下：</p><p><img src="https://img.mahaofei.com/img/202112231945301-camera-models-3.png" alt=""></p><p>将两个等式中的X’和Y’用上面的关系式替换为X与Y的表达式</p><p><img src="https://img.mahaofei.com/img/202112231945240-camera-models-4.png" alt=""></p><p>改写成矩阵形式更加简洁形象</p><p><img src="https://img.mahaofei.com/img/202112231946066-camera-models-5.png" alt=""></p><p>这样，就得到了<strong>实际点P与像素点(u,v)之间的对应关系</strong>，并且由中间量组成的矩阵称为相机的内参数矩阵K。这个内参数矩阵通常相机厂商会提供，如果没有则需要自己进行相机标定。</p><h4 id="1-3-如何获得实际坐标">1.3 如何获得实际坐标</h4><p>我们通常说的某个点的空间位置是以世界坐标系为基础描述的，但是在相机模型中，我们需要实际点相对于相机的位置关系。而且由于相机是在运动的，因此利用变化矩阵的相关知识可以得到下面的式子</p><p><img src="https://img.mahaofei.com/img/202112231946623-camera-models-6.png" alt=""></p><p>其中相机的R，t就是相机的外参，外参会随相机运动而变化，内参则不会发生改变。</p><h3 id="二、畸变相机模型">二、畸变相机模型</h3><h4 id="2-1-两种常见畸变的介绍">2.1 两种常见畸变的介绍</h4><p>实际的相机为了获得更好的成像效果，通常会在相机前方加入透镜，透镜的加入会使得光线传播收到影响，即真实世界的直线在图像中变成了曲线，这种叫径向畸变。径向畸变又分为桶形畸变和枕形畸变。</p><p><img src="https://img.mahaofei.com/img/202112231948890-camera-models-7.png" alt=""></p><p>同时由于安装误差，透镜和成像平面不会完全平行，也会使投影位置发生变化，这种叫切向畸变。</p><h4 id="2-2-去畸变方法">2.2 去畸变方法</h4><p><strong>① 对于径向畸变</strong><br>径向畸变可以看做坐标点沿长度方向发生了变化，即坐标点距离原点距离变了。通常使用的模型如下，假设畸变成多项式关系，使用三个参数k1, k2, k3表达畸变。</p><p><img src="https://img.mahaofei.com/img/202112231948919-camera-models-8.png" alt=""></p><p>其中 [$x_{distorted}$, $y_{distorted}$] 是畸变后的点的归一化坐标。r表示点p与坐标系原点的距离。<br><strong>② 对于切向畸变</strong><br>切向畸变可以看做坐标点沿切线方向发生了变化，即水平夹角变了。通常使用p1, p2两个参数表达切向畸变，具体公式如下。</p><p><img src="https://img.mahaofei.com/img/202112231949498-camera-models-9.png" alt=""></p><p><strong>③ 综合方法</strong><br>结合上面两种径向畸变和切向畸变的公式，可以得到综合的去畸变公式，也就是说我们通过五个畸变系数就可以确定点在像素平面的正确位置。</p><p><img src="https://img.mahaofei.com/img/202112231949756-camera-models-10.png" alt=""></p><h4 id="2-3-示例程序">2.3 示例程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">string image_file = <span class="string">&quot;./distorted.png&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//定义畸变系数</span></span><br><span class="line">        <span class="type">double</span> k1 = <span class="number">-0.28340811</span>, k2 = <span class="number">0.07395907</span>, p1 = <span class="number">0.00019359</span>, p2 = <span class="number">1.76187114e-05</span>;</span><br><span class="line">        <span class="comment">//相机内参</span></span><br><span class="line">        <span class="type">double</span> fx = <span class="number">458.654</span>, fy = <span class="number">457.296</span>, cx = <span class="number">367.215</span>, cy = <span class="number">248.375</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入图像，灰度图</span></span><br><span class="line">        Mat image = <span class="built_in">imread</span>(image_file, <span class="number">0</span>);</span><br><span class="line">        Mat image_undistort = <span class="built_in">Mat</span>(image.rows, image.cols, CV_8UC1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个像素，计算后去畸变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; image.rows; v++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; image.cols; u++)&#123;</span><br><span class="line">                <span class="comment">//根据公式计算去畸变图像上点(u, v)对应在畸变图像的坐标(u_distorted, v(distorted))，建立对应关系</span></span><br><span class="line">                        <span class="type">double</span> x = (u - cx) / fx;</span><br><span class="line">                        <span class="type">double</span> y = (v - cy) / fx;</span><br><span class="line">                        <span class="type">double</span> r = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">                        <span class="type">double</span> x_distorted = x*(<span class="number">1</span>+k1*r*r+k2*r*r*r*r)+<span class="number">2</span>*p1*x*y+p2*(r*r+<span class="number">2</span>*x*x);</span><br><span class="line">                        <span class="type">double</span> y_distorted = y*(<span class="number">1</span>+k1*r*r+k2*r*r*r*r)+<span class="number">2</span>*p2*x*y+p1*(r*r+<span class="number">2</span>*x*x);</span><br><span class="line">                        <span class="type">double</span> u_distorted = fx * x_distorted + cx;</span><br><span class="line">                        <span class="type">double</span> v_distorted = fy * y_distorted + cy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将畸变图像上点的坐标，赋值到去畸变图像中（最近邻插值）</span></span><br><span class="line">                        <span class="keyword">if</span> (u_distorted &gt;= <span class="number">0</span> &amp;&amp; v_distorted &gt;=<span class="number">0</span> &amp;&amp; u_distorted &lt; image.rows &amp;&amp; v_distorted &lt; image.cols)&#123;</span><br><span class="line">                                image_undistort.<span class="built_in">at</span>&lt;uchar&gt;(v, u) = image.<span class="built_in">at</span>&lt;uchar&gt;((<span class="type">int</span>)v_distorted, (<span class="type">int</span>)u_distorted);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                image_undistort.<span class="built_in">at</span>&lt;uchar&gt;(v, u) = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Distorted Image&quot;</span>, image);</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Undistorted Image&quot;</span>, image_undistort);</span><br><span class="line">        <span class="built_in">waitKey</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231950737-camera-models-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231950996-camera-models-12.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PC端】各大网站VIP视频免费观看的一种方法</title>
      <link href="/post/868ab6af.html"/>
      <url>/post/868ab6af.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/ed0a954c38ff402899d5e249a893195a.gif" alt=""></p><h2 id="一、安装TamperMonkey扩展程序（油猴）-2">一、安装TamperMonkey扩展程序（油猴）</h2><p>需要使用Edge浏览器或Chrome浏览器。</p><h3 id="1-1-如何使用Edge浏览器安装油猴-2">1.1 如何使用Edge浏览器安装油猴</h3><p>使用Edge浏览器安装油猴十分简单，直接进入<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?hl=zh-CN">【扩展应用商店】</a>安装即可。</p><h3 id="1-2-如何使用Chrome浏览器安装油猴-2">1.2 如何使用Chrome浏览器安装油猴</h3><ol><li>如果可以科学上网，进入<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">【Chrome扩展程序商店】</a>，点击右侧的添加至chrome即可。<br>ps.查外文文献查资料会经常需要科学上网。<br><img src="https://img.mahaofei.com/img/202112230934697-vip-2.png" alt=""></li><li>如果无法打开上面的网页，可以<a href="https://huffie.lanzouw.com/i6TuUuhjdyd">【点此下载】</a>离线包。①将下载的压缩文件解压；②打开浏览器扩展程序管理页面；③右上角打开开发者模式；④将解压出来的【TamperMonkey.crx】文件拖到到此页面。<br><img src="https://img.mahaofei.com/img/202112230935440-vip-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230936262-vip-4.png" alt=""></li></ol><h2 id="二、安装油猴脚本-2">二、安装油猴脚本</h2><p>各个浏览器都一样，直接<a href="https://greasyfork.org/zh-CN/scripts/370634-%E6%87%92%E4%BA%BA%E4%B8%93%E7%94%A8-%E5%85%A8%E7%BD%91vip%E8%A7%86%E9%A2%91%E5%85%8D%E8%B4%B9%E7%A0%B4%E8%A7%A3%E5%8E%BB%E5%B9%BF%E5%91%8A-%E5%85%A8%E7%BD%91%E9%9F%B3%E4%B9%90%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%AD%89%E5%A4%9A%E5%90%88%E4%B8%80%E7%89%88-%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0-%E6%94%BE%E5%BF%83%E4%BD%BF%E7%94%A8">进入此页面</a>安装即可</p><p><img src="https://img.mahaofei.com/img/202112230936366-vip-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112230937609-vip-6.png" alt=""></p><p>安装完成后不会有任何提示。</p><h2 id="三、测试">三、测试</h2><p>这时候随便打开一个付费视频网页，会看到左侧多了一个VIP的弹窗，这里可以更换视频源进行播放。这里以其中一个名叫B站1的源进行测试。</p><p><img src="https://img.mahaofei.com/img/202112230938392-vip-7.png" alt=""></p><p>可以看到视频正常播放（账号不是VIP），这里的视频源有的有弹幕，有的没有弹幕，有的会在视频中嵌入广告，有的则不会嵌入广告，还请自动忽略视频中可能飘过的各种博彩信息。</p><p><img src="https://img.mahaofei.com/img/202112230939099-vip-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保研问题汇总</title>
      <link href="/post/b9343102.html"/>
      <url>/post/b9343102.html</url>
      
        <content type="html"><![CDATA[<p>能找到这篇文章说明你真的有认真在看，加油！相信你一定能收获最好的结果！</p><p>下面谈到的问题都是我面试的时候被问到过的，仅供参考，每个学校的面试风格有所区别，但整体上是差不多的。</p><h3 id="一、简历问题">一、简历问题</h3><ol><li>介绍一下你参加过哪些科研训练/简单介绍一下你的科研经历</li><li>介绍一下你使用过哪些视觉的方法（简历上有写到相关项目）</li><li>说几个OpenCV里用到的函数，这些函数的具体功能是什么</li><li>机器人是一个大类，没有考虑过具体的细分方向？</li><li>什么是SLAM（回答问题时说研究方向对SLAM感兴趣）</li><li>看你简历，你掌握的东西不少，为什么学的这么杂，有没有哪一项是比较厉害的。（简历最下面写了比较多的掌握技能）</li></ol><h3 id="二、项目问题">二、项目问题</h3><ol><li>简单介绍一下你这个XXXXXX项目/介绍一个你觉得做的最好的项目。</li><li>你在这个项目中主要参与哪些工作</li><li>你们做的机器人有多少条腿，为什么是这么多条腿，这些腿的布局是怎么选的，为什么这么选，是怎么进行计算比较的？（考察项目设计方案，是不是真的自己做的）</li><li>你做的这个项目有没有实现预期的功能？</li><li>机器人内部有哪些传感器？</li><li>机器人内部的加速度传感器的采样频率是多少？</li></ol><h3 id="三、闲聊问题">三、闲聊问题</h3><ol><li>想来我校读研的原因，为什么会选择我们学校，有多大概率来。</li><li>你报名了几个夏令营，我们学校在你的意向中排第几顺位？</li></ol><h3 id="四、英文问题">四、英文问题</h3><ol><li>介绍一下你的校园</li><li>你对哪个研究方向感兴趣</li></ol><blockquote><p>我只在上交、哈工大遇到了英文问题，其它学校都是全程中文，也可能是我报名的学校学院比较巧。下面几个是朋友遇到的英文问题，在这里列出来，也作为参考。</p><ol start="3"><li><p>介绍一下自己的家乡</p></li><li><p>你最喜欢哪个季节</p></li></ol></blockquote><h3 id="五、专业问题">五、专业问题</h3><ol><li>什么是PID，比例环节是不是会让系统更稳定，PID分别对系统误差有什么影响？</li><li>什么是装配精度？装配精度包括哪几方面？</li><li>什么是阿贝原则？举两个例子解释阿贝原则。</li><li>材料的强度和刚度有什么区别？</li><li>影响材料弹性模量的因素有哪些？</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>保研经验分享</title>
      <link href="/post/95ebe1c5.html"/>
      <url>/post/95ebe1c5.html</url>
      
        <content type="html"><![CDATA[<h3 id="〇、关于我">〇、关于我</h3><h4 id="0-1-个人信息">0.1 个人信息</h4><p><strong>机械电子工程专业，绩点3.95/4，专业排名1/133，无科研成果，11项省级以上竞赛，一篇专利、一篇软著</strong></p><h4 id="0-2-夏令营情况">0.2 夏令营情况</h4><p><strong>入营且通过</strong>：哈工大机电学院、沈自所、大连理工、中科大工程科学学院</p><p><strong>入营未通过</strong>：上交机动学院、天大机械学院（与期末冲突）、华科机械学院、</p><p><strong>未入营</strong>：浙大机械学院、华科机械学院、清深先进制造学部、自动化所、北理机电学院、西交机械学院、哈深机电学院</p><h4 id="0-3-预推免情况">0.3 预推免情况</h4><p><strong>入营并通过</strong>：天大机械学院</p><p><strong>入营未通过</strong>：无</p><p><strong>未入营</strong>：上交机动学院、浙大控制学院、自动化所、西交机械学院、北航自动化</p><h4 id="0-4-最终去向">0.4 最终去向</h4><p>哈工大机电学院机器人所</p><h3 id="一、保研流程">一、保研流程</h3><p>保研大概可以分为三个阶段，分别是<strong>夏令营</strong>，<strong>预推免</strong>，和<strong>九推</strong>。夏令营5月到7月各大学校发一轮优秀营员，预推免8月-9月再发一轮拟录取offer，然后9月28号在研究生报名系统里填报学校的时候还有机会捡漏。</p><h4 id="1-1-夏令营">1.1 夏令营</h4><p>首先是夏令营，夏令营应该是最早的一批面试。夏令营一般会线上或线下举办一些讲座，宣传一下学校学院，然后就是关键面试，面试结束，夏令营就算结束了。只要夏令营面试通过拿到“优秀营员”，就说明只要你9月28日开放报名系统后填这个学校的志愿，你就会被录取。当然这里也会有一些例外情况，后面会再说。</p><p><strong>① 夏令营如何报名</strong></p><p>夏令营的报名从5月份就开始了，然后一直持续到7月。大部分学校集中在6月多报名，七月多面试。这期间你需要去各个学校官网、学院官网、或者研招办官网、或者通过一些公众号，及时了解各个学校的通知。大部分学校的报名时间就1-2周，如果错过了就没办法报名了。</p><p><strong>② 夏令营的报名策略</strong></p><p>夏令营相对来说通过难度会大一些，而且有的学校是线下开展，可能需要占用3-4天的时间。但是我还是建议你们尽可能的多报一些学校，冲刺的、稳妥的、保底的，都报几个学校。我当时报了十多个快20个学校，最后通过材料初审的也就那么几个学校。另外能参加面试的尽量参加，一方面给自己更多的机会，另一方面可以涨涨面试经验。</p><h4 id="1-2-预推免">1.2 预推免</h4><p>夏令营结束之后，下一个可以参加学校面试的就是预推免阶段了。夏令营没有拿到很好的offer的话，预推免还可以继续报名这个学校，而且预推免的通过难度相对小一些，更有可能冲刺到好学校。</p><p><strong>① 预推免如何报名</strong></p><p>预推免的报名时间大概在8月-9月上旬，也是看看学校、学院、学校研招网这些官方网站，或者公众号了解通知</p><p><strong>② 预推免的报名策略</strong></p><p>预推免的面试一般是9月初了，这时候建议根据自己夏令营的情况，报名一些冲刺的学校，有些学校的材料可能会很麻烦，但是大家尽量报名吧，不通过也没事，尽量别留下遗憾就行。</p><h4 id="1-3-九推">1.3 九推</h4><p>九月推免，一般就是说9月28号在国家研究生报名系统里报名学校了。报名学校的时候，按理说还是可以报名学校然后给你面试的，但是好的学校基本都已经通过夏令营和预推免招到了足够的学生，只有方向不太好的学院才会出现报名的人太少，系统开放之后可以再报名捡漏的情况，这样风险太大，一般还是在夏令营和预推免拿到学校的offer后，你这边报名他们学校，然后那边老师确认一下，就算完成了。</p><p>整体就是这么个流程，从5月持续到9月底。</p><h3 id="二、保研如何准备">二、保研如何准备</h3><h4 id="2-1-院校选择（自身定位）">2.1 院校选择（自身定位）</h4><p>院校的选择主要是要考虑学院实力，学院的整体研究方向，学校所在地域这些因素。</p><p>学院实力根据第四轮学科评估，看是A+还是A还是A-，大体判断学院实力。</p><p>学院的整体研究方向主要去学院官网看就可以，学院官网会介绍学院的一些研究成果等等，或者打开几个老师的主页，看看老师们大都在做什么。</p><p>学校所在地域，这一点需要根据你未来的发展方向选择。</p><p>而具体到要报名哪些学校，每个人就都不太一样了，一方面要考虑自己的未来发展方向，另一方面根据自身的综合实力，可以参考专业往年的情况。</p><h4 id="2-2-材料方面">2.2 材料方面</h4><p>保研申请的材料虽然多，但每个学校需要的东西都是差不多的，报名完第一个以后，后面的就都差不多了。需要的材料大家尽量提前准备，并且要随着对保研的了解还有面试过程要不断修改。需要的材料，随便找一个学校的预推免或夏令营通知就可以看到了，下面这个图片就是某高校夏令营的申请材料要求。</p><p>最好提前准备的材料包括：个人简历，个人陈述1000字左右，推荐信，有的学校线上面试会需要PPT。</p><p><img src="https://img-blog.csdnimg.cn/723bd0953c134211891e7cb60912a40e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGFsZl9B,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h4 id="2-3-关于面试">2.3 关于面试</h4><p>我也参加了大大小小好多学校的面试了，总结下来面试基本流程就是，首先是自我介绍，然后可能会问你几个英语问题考察一下你的英语能力，包括研究方向，介绍本科学校等等。然后就是根据简历、自我介绍的东西问你问题，绝大部分都是问你项目有关的内容，问专业课的倒是并不多。其次就是和你聊聊天，比如对什么感兴趣，报了哪些学校，联系老师了没。</p><p>所以大家最好能提前准备好2分钟左右的自我介绍，多熟练熟练。然后好好看看项目的内容，所有的细节问题都要能答的上来。另外准备准备一些常规的问题，比如说研究方向啥的。这里我放了我遇到的一些<a href="https://www.mahaofei.com/04_essays/01_experience/01_questions/">面试问题</a>，仅供参考。</p><h4 id="2-3-联系老师">2.3 联系老师</h4><p>我是挺建议提前联系老师的，尤其是那种想要特别想要去的学校，最好提前联系老师，因为你不联系，老师可能就没名额了。我遇到的最离谱的是，六月多上交一位老师的名额就满了，虽然这是极少数情况，但是还是越厉害的老师，名额就越抢手，建议提前邮件联系，记得用学校的邮箱。</p><h3 id="三、经验分享">三、经验分享</h3><h4 id="3-1-导师的选择">3.1 导师的选择</h4><p>导师的所有信息，在学院官网的师资队伍页面都可以看到。</p><ol><li><p>导师的类型，学术大牛教授型、年轻有为奋斗型，不同的导师可能会决定着你研究生阶段的生活状态。</p></li><li><p>导师的研究方向，可以看老师主页的个人简介，以及做过的项目，还有最近发的论文。</p></li><li><p>导师的人品，网上搜导师评价网、导师点评网，问去过的学长学姐，渠道很多，虽然看似与科研没什么关系，但实际上影响很大</p></li></ol><h4 id="3-2-夏令营与预推免的报名策略">3.2 夏令营与预推免的报名策略</h4><p>根据上一届的学长学姐的情况来看，预推免比夏令营更有机会冲刺高等院校，也就是说你在夏令营尽可能多参加一些，一方面是积累面试经验，重要的是一定要有一个保底的offer，这样预推免就主要准备比保底offer更好的学校就可以了，这样主动性会大一些。</p><h4 id="3-3-信息的获取">3.3 信息的获取</h4><p><strong>① 官方渠道</strong>： 学校官网、学院官网、学校。注意这三个网站是不一样的，有的学校会在这些网站都发布推免招生信息，但有的学校只在学院官网发通知，有的学校只在研招网发通知，这些网站报名的时候最好都看看。不要出现你以为学校还没发通知，其实是发了通知你没看到这种情况。</p><p>**① 公众号：**保研、保研人、保研圈、预研家等等。这些公众号上会不定时的推送保研的最新资讯，比如xxx所高校发布夏令营招生通知，然后下面一大堆链接。公众号里也有很多保研的经验分享。</p><h3 id="四、题外话">四、题外话</h3><p>其实我最后还是想讲一下关于个人规划这件事，因为保研过程中你肯定会面临很多选择，包括对专业研究方向的选择，读研读博的计划，导师的选择，学校的选择，城市的选择等等。</p><p>但这些所有的选择其实都归结于你对与自己未来有怎样的规划，你是想读研读博一条路做科研，还是想读研出去企业工作，还是想读研然后考选调走公务员，还是说打算自己创业等等。</p><p>这些不同的个人规划，对应的是不同的选择。但当你确定了自己的发展路线之后，这些看起来很纠结的问题就不会那么纠结了。可能有的人会说，我现在不知道自己未来要走哪条路，我想先走一步看一步，但是我比较认为，越早能确定自己的人生路线，更早的开始努力是最值得的，如果你读完研发现自己想做的和自己在做的完全不一样，到那时后悔就晚了，已经付出了巨大的时间成本了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何访问Google。。学术来查阅文献</title>
      <link href="/post/96c83ac9.html"/>
      <url>/post/96c83ac9.html</url>
      
        <content type="html"><![CDATA[<p>高效的文献检索方法，网上有很多，包括主题检索、篇名检索、作者检索、单位检索、刊名检索、分类检索、序号检索等等方法。还有各种逻辑运算符来强化检索的指向性。</p><p>文献的下载大多时通过sci-hub实现，但是这些检索和下载功能的实现，大多需要依赖一些方法才能正常访问，本文主要介绍这些加速访问的方法。</p><h3 id="一、免费方法">一、免费方法</h3><h4 id="1-谷歌访问助手">1. 谷歌访问助手</h4><p>谷歌访问助手：<a href="https://huffie.lanzouw.com/iRTKwusg31i">点此下载</a></p><p>需要搭配Chrome浏览器使用，下载完成后，打开谷歌浏览器的扩展程序页面（<a href="">chrome://extensions/</a>）将crx文件拖到此页即可，安装完成。然后按照插件内的指示即可实现某些网页的加速。<strong>（不过这个插件偶尔会被封一段时间，无法访问）</strong></p><h4 id="2-免费机场节点">2. 免费机场节点</h4><p>之前有曾经使用过一段时间的免费机场节点，但大都连接速度满，且不稳定，目前我知道的机场节点大多数都已被封，下面这两个之前用过，现在应该还可以用，但是不知道稳定性如何。</p><p><strong><a href="https://j01.best/">① 几鸡</a></strong></p><p><strong><a href="https://ikuuu.co/">② ikuuu</a></strong></p><h3 id="二、我的推荐">二、我的推荐</h3><p>在很久之前，我也是使用各种免费的工具，例如google访问助手等插件，以及一些免费的节点等。但是这些方法存在两个问题：①访问速度很慢，虽然能打开某些网页，但是加载速度难以忍受；②最关键的是不稳定，google访问助手经常被封，免费节点也是不知道哪天就关了。并且，目前我需要经常访问一些网站，例如github、外文文献等网站，所以我换成了更稳定的付费节点。</p><p><strong><a href="https://mojie.link/#/register?code=eXhdl9bj">① 魔戒</a></strong></p><p>推荐套餐：1元10G流量（不限时间）</p><p><img src="https://img.mahaofei.com/img/202112230931736-findpaper-1.png" alt=""></p><p><strong><a href="https://xn--fjqzfu8n.xyz/#/register?code=AunMGOQO">② 可乐云</a></strong></p><p>推荐套餐：2.5元/月（10G流量）</p><p>新注册的用户有24小时5G流量试用，可以试试。</p><ul><li><p><strong>适合轻度使用的用户（不看视频）</strong></p></li><li><p><strong>开代理浏览国内网页时不消耗流量，只有国内无法访问的网页才会消耗流量</strong></p></li></ul><p><img src="https://img.mahaofei.com/img/202112230932447-findpaper-2.png" alt=""></p><p><strong>③ 其他类似网站还有很多，有兴趣的可以到<a href="https://fanqiangdang.com/forum.php">【论坛】</a>中找找，这里就只列出我用过的两个。</strong></p><h3 id="三、如何使用">三、如何使用</h3><p>这里以<a href="https://mojie.link/#/register?code=eXhdl9bj">魔戒</a>为例</p><p><strong>1. 下载安装clash</strong></p><blockquote><p>Github链接：<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/">https://github.com/Fndroid/clash_for_windows_pkg/releases/</a></p><p>在这里下载【Clash.for.Windows.Setup.0.18.3.exe】然后安装即可。</p></blockquote><p>如果无法打开github，可以使用我提供的百度网盘链接</p><blockquote><p>百度网盘链接：<a href="https://pan.baidu.com/s/1GPtfNo3CGfOl6VgujZdAHA">https://pan.baidu.com/s/1GPtfNo3CGfOl6VgujZdAHA</a></p><p>提取码：clas</p></blockquote><p><strong>2. 添加订阅</strong></p><p>打开机场网站，找到【我的订阅 -&gt; 一键订阅 -&gt; 导入到Clash】，即可成功完成订阅的添加。</p><p><img src="https://img.mahaofei.com/img/202112230932948-findpaper-3.png" alt=""></p><p>或者复制订阅地址，粘贴到Clash中的如下图所示位置，点击Download，一样可以添加订阅。</p><p><img src="https://img.mahaofei.com/img/202112230933772-findpaper-4.png" alt=""></p><p><strong>3. 进入【General】页面，打开【System Proxy】，即可成功访问Google Scholar等网站。</strong></p><p><img src="https://img.mahaofei.com/img/202112230933274-findpaper-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112230933339-findpaper-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112230933377-findpaper-7.gif" alt=""></p><blockquote><p>谨记：本方法仅用于学习交流使用，禁止用于商业用途，严禁访问除学习研究外的其他网站，否则一切后果请用户自负。本页所有信息来自网络，仅供学习参考。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows各版本与Office全系列激活方法</title>
      <link href="/post/c5d699a.html"/>
      <url>/post/c5d699a.html</url>
      
        <content type="html"><![CDATA[<p>这里提供一个工具的下载链接：<a href="https://huffie.lanzouw.com/i1w7Vuxyzxa">https://huffie.lanzouw.com/i1w7Vuxyzxa</a>，解压后以管理员身份运行。</p><p>具体功能和使用方法不必多说，看图即可。</p><p><strong>需要注意：解压之前一定退出所有安全管家，如果还是找不到，看一下是不是被Windows Defender删掉了</strong></p><p><img src="https://img.mahaofei.com/img/202112230939435-winoffice-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘不限速下载方法</title>
      <link href="/post/e5808c6a.html"/>
      <url>/post/e5808c6a.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装TamperMonkey扩展程序（油猴）">一、安装TamperMonkey扩展程序（油猴）</h2><p>需要使用Edge浏览器或Chrome浏览器。</p><h3 id="1-1-如何使用Edge浏览器安装油猴">1.1 如何使用Edge浏览器安装油猴</h3><p>使用Edge浏览器安装油猴十分简单，直接进入<a href="https://microsoftedge.microsoft.com/addons/detail/tampermonkey/iikmkjmpaadaobahmlepeloendndfphd?hl=zh-CN">【扩展应用商店】</a>安装即可。</p><h3 id="1-2-如何使用Chrome浏览器安装油猴">1.2 如何使用Chrome浏览器安装油猴</h3><ol><li><p>如果可以科学上网，进入<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">【Chrome扩展程序商店】</a>，点击右侧的添加至chrome即可。<br>ps.查外文文献查资料会经常需要科学上网。<br><img src="https://img.mahaofei.com/img/202112230923512-tampermonkey.png" alt=""></p></li><li><p>如果无法打开上面的网页，可以<a href="https://huffie.lanzouw.com/i6TuUuhjdyd">【点此下载】</a>离线包。①将下载的压缩文件解压；②打开浏览器扩展程序管理页面；③右上角打开开发者模式；④将解压出来的【TamperMonkey.crx】文件拖到到此页面。</p></li></ol><p><img src="https://img.mahaofei.com/img/202112230924215-chrome-extension.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230924091-chrome-extension.png" alt=""></p><h2 id="二、安装油猴脚本">二、安装油猴脚本</h2><p>这一步不论什么浏览器都一样。打开<a href="https://greasyfork.org/zh-CN/scripts/418182-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%AE%80%E6%98%93%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%A4%8D%E6%B4%BB%E7%89%88">【此网页】</a>，安装脚本即可。</p><p>ps. 油猴是一个非常实用的插件，GreasyFork里面有很多实用的脚本，想了解的可以自行探索。<br><img src="https://img.mahaofei.com/img/202112230925109-greasyfork.png" alt=""><br><img src="https://img.mahaofei.com/img/202112230927139-baiduwangpan.png" alt=""></p><h2 id="三、开始下载">三、开始下载</h2><h3 id="3-1-准备IDM">3.1 准备IDM</h3><p>如果你已经在使用IDM，那么可以跳过这一步。</p><p>如果没有，可以使用刚才解压的文件夹中的IDM绿色版。</p><ol><li>将压缩包解压后运行【绿化.bat】；<br><img src="https://img.mahaofei.com/img/202112230928396-lvhua.png" alt=""></li><li>运行【IDMan.exe】</li><li>打开【选项】菜单，点击【下载】栏，将用户代理UA修改为：<strong>softxm;netdisk</strong><br><img src="https://img.mahaofei.com/img/202112230929578-daili.png" alt=""></li><li>点击【连接】栏，将最大连接数设置为<strong>4</strong>，点击【确定】<br><img src="https://img.mahaofei.com/img/202112230929559-linknumber.png" alt=""></li></ol><h3 id="3-2-选择文件下载">3.2 选择文件下载</h3><ol><li><p>打开<a href="https://pan.baidu.com/">【百度网盘网页版】</a>，选择一个要下载的文件。（注意只能是一个文件，不能是文件夹）。</p></li><li><p>点击上方的简易下载助手下载。<br><img src="https://img.mahaofei.com/img/202112230929410-xiazai1.png" alt=""></p></li><li><p>点击【获取直链地址】，并【复制直链地址】<br><img src="https://img.mahaofei.com/img/202112230930860-xiazai2.png" alt=""></p></li><li><p>打开IDM，选择新建下载任务，粘贴刚才的直链地址进行下载。<br>下载速度根据当前网络状况，校园网一般在<strong>2MB/s~10MB/s</strong><br><img src="https://img.mahaofei.com/img/202112230930623-ceshi.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
          <category> 破解方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自控力极差的人如何自救？——来自Clei的回答</title>
      <link href="/post/cbce80b0.html"/>
      <url>/post/cbce80b0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：Clei<br>链接：<a href="https://www.zhihu.com/question/21368231/answer/90497581">https://www.zhihu.com/question/21368231/answer/90497581</a><br>来源：知乎</p></blockquote><p>很多人觉得自己计划完不成，拖延，生活中养成种种恶习的根源在于自制力不强，以为增强了自制力，一切问题就能迎刃而解——<strong>这个想法是错的，自制力并不是解决这些问题的关键。</strong></p><p>那什么才是呢？诸位稍安勿燥，这个后面自然会讲到，但在此之前，且听我讲一个哈佛学霸的故事。</p><p><strong>一. 75%真实的故事</strong></p><p>故事主人公叫 Tal ，是哈佛大学心理系大三的学生，同时也是学校壁球队的主力。他每天很早起床去跑步，然后去学校，一天的课程结束后，他会去球场和教练进行常规训练、打比赛，在此之后，他会去健身房健身，然后回家，做作业，看书学习，睡觉。日复一日，从不间断。</p><p>于是大家纷纷认为 Tal 童鞋是一个高度自律的学霸。Tal 童鞋也是这么看待自己的，直到寒假到来。</p><p>作为学霸，寒假当然不会满足于过过圣诞节，看看之前很火的天朝剧《Nirvana in Fire》（琅琊榜），Tal 打算预学两门下学期的课，完成一个 Research Project，并且平均每天保持1小时以上的锻炼。</p><p><img src="https://img.mahaofei.com/img/202112231940097-self-control-1.png" alt=""></p><p>嗯，结局喜闻乐见：Tal 童鞋跪了，他唯一的成就是如愿看完了 Huge（胡歌）主演的这部大作，哦对，还胖了四斤。啥，你问学习研究和锻炼呢？Tal 只在头两天看了10页书，加起来锻炼了一个小时而已。</p><p>看到这里我知道有人要跳出来说：“不！这不是真的！学霸辣么自律，寒假计划怎么会失败？！一定是你瞎编的！”</p><p>对，如你所见，我瞎编了25%的部分，但那仅仅是具体的失败细节，事实仍然没有变化——Tal童鞋的计划的的确确泡汤了。不信你看，下面是他的原话，还有视频截图为证。</p><blockquote><p>I can’t wait to have the freedom without squash and just focus on my classes. Catch up on all the readings and writings and stuff. Winter holiday came. I stopped playing completely. And instead of becoming more productive, I became far less productive.<br>我等不及没有壁球的自由，以专注于我的学习，追上阅读、写作的进度。寒假来了，我不用再进行（壁球）训练了，但与高效学习相反，我反而效率变低很多。</p></blockquote><p><img src="https://img.mahaofei.com/img/202112231940884-self-control-2.png" alt=""></p><p>有些读者已经认出 Tal 了，没错，他现在是哈佛的 Tal 教授，这张图来自于他广为流传的《积极心理学》课程的第11集的39分47秒。（借机安利下，作为哈佛当年最受欢迎的选修课没有之一，这门课于2010年被网易公开课收录，并取了个很鸡汤的名字，叫《哈佛幸福课》，此后长期霸占排行榜第一，累计观看数早已破千万。）</p><p><strong>二.学霸们的困扰</strong></p><p>Tal 教授用亲身经历证明了，在寒假计划这种事上，学霸和普通人其实有着同样的困扰。有人会说Tal 是个例，但不是的，我的很多朋友都是学霸，即使是在 MIT 念 Phd 的哥们，也会面临在家睡到中午起不来，学习计划迟迟无法落实的问题。</p><p>当然，还是有人会举手，说不对啊，我就认识那种寒假计划很充实，还全都落实了的学霸！对，没错，我们姑且把这样的人称之为“成熟体学霸&quot;，把前面那些计划泡汤了的称为“幼年体学霸”。在你们见到的那些学霸里，相当一部分仍处于“幼年体”，仍会和普通人一样，受到自控力和拖延症的困扰。</p><p>那么问题来了，“幼年体学霸”是如何成长为“成熟体学霸“的呢？</p><p><img src="https://img.mahaofei.com/img/202112231941417-self-control-3.png" alt=""></p><p>（上面这张图好暴露年龄啊！）</p><p>虽然计划泡汤了，学霸毕竟是学霸，很快展现出了他与普通人的区别：</p><p>普通人是这样的：计划失败 -&gt; 沮丧 -&gt; 骂自己一顿 -&gt; 制订新计划 -&gt; 继续失败</p><p>学霸是这样的：<strong>计划失败 -&gt; 沮丧 -&gt; 骂自己一顿 -&gt; 深度思考计划为啥失败 -&gt; 改善问题 -&gt; 制订新计划</strong></p><p>当然新计划可能成功，也可能失败，失败之后，学霸会重复上述流程。久而久之，新计划中失败的越来越少，成功的越来越多，学霸也实现了幼年期到成熟期的进化。</p><p>那么为啥计划会失败呢？明明学霸们平时是拥有高度自控力的，难道到了寒假自控力会失效？</p><p>这就要说到自控力的假象了。</p><p><strong>三.自控力的假象与真相</strong></p><p>不知道大家有没有这样一种感觉：高考前是自己学习力和自控力的巅峰，那时候每天都要做好多题，学到很晚，但第二天还是精神抖擞，继续奋战；上了大学之后，时间宽裕了，反而变得懒散了，没有之前学习的劲头和毅力了，到了假期更是懒得一发不可收拾，熬夜看剧、晚睡晚起、暴饮暴食那都是家常便饭。</p><p>为什么会这样呢？难道时间越宽裕，自控力就越薄弱？这显然不科学。那就是因为时间越宽裕，我们越容易懈怠和堕落？但这是结果，并不是原因。<strong>我们以为自己的自控力曾经很强，上大学后变弱了，放假后则因为懈怠愈发孱弱——这其实这个假象。那真相是什么？</strong></p><p>Tal老师为我们揭示了两个真相：</p><p><strong>1.保证我们高效运转的其实是习惯，而不是自控力。</strong></p><p>想想在高考之前的那种紧张的学习氛围里，我们被动的养成了很多习惯——每天规律的上课、自习、吃饭和睡觉，我们目标明确——每个月、每个星期乃至每天复习什么，老师们都替我们安排好了。这些我们习以为常，就像你每天早上起床都会自动去刷牙一样自然（说不刷牙的你走开！）</p><p>你想想想你起床后刷牙的过程：穿衣服（好吧我知道有人不穿），拿起杯子和牙刷，走到卫生间，接水，挤牙膏，开始刷。即使你可能还睡眼惺忪，但这一套流程你仍然能精确无比、毫不费力的执行下来。这个过程需要一丢丢的自控力吗？基本不需要对不对？</p><p><img src="https://img.mahaofei.com/img/202112231941053-self-control-4.png" alt=""></p><p>所以高中的那些学习，其实并不需要太多自控力**。**而当你进了大学，课程安排变得自由了，你丧失了那些被动习惯，开始自己规划学习和生活时，才是需要自控力的时候。而此时，很多人不得不面对第二个真相：</p><p><strong>2.人的自控力是有限的</strong></p><p>很多人不知道，**自控力和肌肉力量一样是有限的。**这个结论被大量的心理学实验证明，大家上网搜索一下就能看到，我这里不做赘述，我只打个比方，相信能帮你更好的理解这个结论：</p><p>想象下，当你搬宿舍、或是换教室时，你把一摞又一摞沉重的书本，吃力的从这个屋子搬到那个屋子之后，你双臂酸软，腰酸背疼，严重者可能连一杯水都举不起来——因为你的肌肉力量耗尽了。</p><p>自控力也一样，我们在日常生活中要面对各种各样的诱惑：桌上昨天新买的一大堆零食，双十一淘宝主页玲琅满目的商品，男神胡歌的新剧又开播了……我们要反复抵抗这些诱惑才能专注于那些重要的目标，比如学习和减肥。每拒绝一次诱惑，你的自制力就消耗一分，如果面临的诱惑太多，总会有一个时刻，我们会累到无力抵抗，任由暴饮暴食、刷爆淘宝、熬夜看剧这些行为支配我们的生活。</p><p><img src="https://img.mahaofei.com/img/202112231942455-self-control-5.png" alt=""></p><p>当然现实没有那么可怕，肌肉酸痛过两天会恢复，自制力嘛，你睡个好觉也能回归正常。有意思的是，不同人天生力气不一样，自制力强弱也不一样，自制力超群或是弱到掉渣的，在人群中都占很小的比例，大多数人都处在中间那个状态——不好也不坏。</p><p>所以我们得出的结论是：学霸就是那群天生自制力超群的人？如果是这样，那我写这篇文章也太没意思了。</p><p>有机智的童鞋马上反应过来了：哦！既然我们可以锻炼肌肉，自制力也是可以锻炼的，对吧！我们只要把自制力锻炼到很强就可以了！</p><p>这话没错，然而肌肉力量有极限，自制力也是有极限的。生活中，我们面临的诱惑如此之多，靠后天锻炼出来的自制力依然会不够用。另一方面，就像上面讲到的第一点：<strong>无论是校园里的“成熟期学霸”，还是社会里的精英人士，其高效的学习和生活，并不像我们往常以为的那样，依赖于强大的自制力，而是得益于后天构建起来的习惯体系。</strong></p><p><img src="https://img.mahaofei.com/img/202112231942065-self-control-6.png" alt=""></p><p><strong>如何利用我们有限的自制力，去构建这样一套体系，才是我最想说的东西</strong>，当年的Tal童鞋，也是在意识到这个问题之后，才开始了他的翻盘之旅，成功进化为成熟体学霸，最后成为哈佛教授，走上人生巅峰的。（好吧别打我，我承认后面这段是我瞎编的。）</p><p>但是构建习惯体系，并不是一件轻松的事情，原因有两个：</p><p>1.很多人没有意识到，有一个看不见的敌人在阻挠我们的行动，</p><p>2.很多人不知道，习惯背后的原理。</p><p><strong>四. 看不见的敌人</strong></p><p>很多人都想要减肥，想要健身，但大多数人的状况是：决定要减肥或健身后，制定了详细的计划，买了一堆装备，办了几千块的健身卡，却在去了不到三次后，将这些东西都束之高阁。</p><p>为什么建立一个锻炼的习惯这么难呢？因为太多人不了解习惯背后的原理，更重要的原因是，<strong>太多人太急了，太想在短期内看到显著的改变。</strong></p><p>是的，我们都希望一夜暴富，一朝成名，都喜欢看“穷小子白手起家创业成功，一年变身亿万富翁”、“胖女孩半年瘦身八十斤俘获男神芳心”的故事。但这些不是我们的错，<strong>我们之所以天生短视，喜欢即时的反馈和满足感，是因为大脑里，住着一个看不见的敌人在捣乱。首先你得意识到它的存在，然后才能战胜它。</strong></p><p>在几百万年前，我们的祖先还茹毛饮血的时候，资源稀缺，吃了上顿没下顿，大脑需要持续的分泌化学物质，它们促使人们去寻找并摄入食物，热量越高越好，把自身的脂肪储存的越多越好；如果不是这种机制，人类很可能存活不到今天。</p><p><img src="https://img.mahaofei.com/img/202112231942782-self-control-7.png" alt=""></p><p>可我们不是原始人，我们进化出了更高级的控制单元，所以我们学会了计划，学会了为达成长期目标放弃短期利益。<strong>但原始的那部分大脑并没有消亡，它依然在时刻争夺着身体的控制权，促使我们孜孜不倦的寻求即时的满足感。</strong></p><p>所以你明白了吗？为什么在认真学习时，忽然会冒出“学这么久了，看一集美剧吧！”的念头；为什么晚饭吃了不少，睡前还是管不住自己伸向零食的手；为什么你打开手机想要背单词，却鬼使神差的戳开了微博；这些的本质都是原始大脑在作怪。</p><p>好了，看到这里，你意识到敌人的存在了，即大脑的原始部分；你也意识到它惯用的伎俩——即时满足感。但这还不够，要打败它，你得掌握科学的武器，也就是习惯的原理。</p><p><strong>五.习惯的原理</strong></p><p>习惯的养成，依赖于四个部分：<strong>触机（cue）、惯性行为（routine）、奖励（reward）和信念（belief）：</strong></p><blockquote><p>**触机：**即触发习惯的原因，你可以想象成手枪的扳机，按下扳机，子弹就打出去了。习惯的触机有很多，可能是时间、地点或场景。你早上刷牙的触机是起床这个动作；去吃午饭是因为时间到了（额，好吧，还有肚子饿了）；有人习惯睡前刷微博，那么触机可能是你躺下来盖上被子。触机本身没有好坏之分，决定习惯好坏的，是它引发的惯性行为。<br>**惯性行为：**之所以叫惯性，是因为它是无意识的，比如一打开电脑就先上网看看娱乐新闻；比如睡前一定要刷一下朋友圈。在建立新习惯的过程中，<strong>我们的自制力，就用于修正那些引起拖延的旧行为，将其替换为新的惯性</strong>。在更正坏习惯时，你需要格外留意引发它的触机，同时关注自己的行为，不断提醒自己不要重蹈覆辙。这一步是最消耗时间和精力的过程，可能要与旧习惯反复拉锯，因为良好惯性行为的建立不仅需要有自制力去克服旧的行为，还需要在行为结束时获得正向的反馈，也就是下面要说的“奖励”。<br><strong>奖励：这是习惯养成中至关重要的一环，它往往被人们忽略</strong>。为什么坏习惯容易养成且难以改变？因为它们的奖励往往即时而明显：打游戏、刷网页、吃零食这些哪个不是这样？好习惯难以形成，也恰恰因为短期的奖励不够明显。背单词、健身、练书法这些行为往往需要较长的时间才能看到效果，有些人天生能从过程中获得精神激励，但很多人不行，那我们需要人为的赋予自己奖励：比如记录自己的成长和进步、时不时发个微博鼓励下自己、达成一些小目标时吃顿好的庆祝下等等（啊喂也不要暴饮暴食啊！）<br>关于奖励，稍稍多说几句。诸如学习、健身这种事本身是有点反人性的，有没有什么办法能快速建立正向奖励机制呢？这个展开能写两本书…知乎上有很多学习、健身相关的优质答案了，我这里不赘述。我想提供一种思维：<strong>积极的、开放性的、成长性的思维。即多去看看那些享受学习、享受健身的人是怎么做到这些事情的，尝试去学习他们的方法，把目光放在积极面上，而不是怀疑自己能力不行，觉得自己做不好。</strong> 此外，强化你的“信念”有助于你获得精神上的正反馈。 <strong>信念：</strong> 这是支撑你建立习惯的内在动力：你想要每天背单词，是为了干掉英语考试；你想要学会弹吉他，是为了能在各种晚会上一显身手；你想要规律饮食、早睡早起，是为了身体健康；你想要健身减肥，可能是想俘获女神/男神的芳心。总之，你是想成为一个更好的人。<strong>信念能让你你在养成好的习惯时获得精神上的正向反馈，同时，你的信念越强烈，就越能忍受改变过程中的痛苦与反复。</strong></p></blockquote><p>明白了这些，可以更好的帮你建立习惯，而关于如何建立习惯，有太多的技巧，诸如远离诱惑、分解目标、建立记录和反馈机制……多的能写出一本书（事实上有很多关于习惯的书了，后面我会推荐一本），我这里想说点心态上的东西，也是我在踩了无数坑后，用斑斑血泪换到的重要经验：</p><p><strong>六. 三点心态</strong></p><p><strong>1.接受自己是个普通人</strong></p><p>真的，大家都是普通人，承认这一点没啥可耻的。拿我最喜欢的肌肉模型举例子吧，我始终觉得，建立习惯也好，培养能力也好，都跟锻炼肌肉是一码事：你今天只能举30斤的哑铃，下周你最多举35斤，你不能说明天我就要举60斤。同样的，如果你之前从没去过健身房，不要指望刚开始一周能去三次，更科学的计划，是从一周去一次做起；如果你之前沉迷游戏，一周打七天，不要指望明天就能戒掉它，科学一点的目标，是下周只打六天。</p><p>承认自己一口气吃不成个胖子，敢于面对现实，也是成熟的标志之一，不是吗？《积极心理学》中的建议是：<strong>对于一般人，一个月能建立一到两个习惯就很不错了</strong>。不要太贪心，你真能做到，一年下来至少养成12个习惯，你能够爆掉大多数人了。</p><p>允许自己失败，允许自己休息，在此之上，我特别想强调的是：对自己少一些苛责，多一些鼓励。</p><p><strong>2.少一些苛责，多一些鼓励</strong></p><p>**我们从小到大接受的教育，太过于强调严格自律和自我批评，却很少教我们如何鼓励自己。**太多人放弃改变，是因为在反复的失败后，用批评和苛责扑灭了自己内心的火种。</p><p>我大学最堕落的两年，深受这种思想所害，最后让我走出来的，不止是不甘堕落，更是每次失败后，像对待朋友，有时甚至是像对待小孩子一样，鼓励自己，哄自己：“这周计划锻炼三次，只锻炼了一次？没事，也比不锻炼强吧，是不是计划不合理？下周试试两次吧！”“今天计划要学的又没学完，下午还刷了两个小时网页……没关系，比昨天好啦！昨天刷了大半天好嘛！”。</p><p>计划失败了，大多数人会羞愧，会痛苦，会责骂自己。<strong>但少有人去安慰自己，告诉自己“没关系，你是个普通人，你总会有脆弱的时候”；少有人像鼓励朋友一样鼓励自己，跟自己说“加油，还有机会，来！想一想下次怎么可以做得更好”。</strong></p><p><img src="https://img.mahaofei.com/img/202112231943683-self-control-8.png" alt=""></p><p>真的，在与欲望和弱点搏斗的过程中，我们大多数时候是没有队友的，你只有自己给自己打气。</p><p>嗯，有人担心过多的自我安慰会让自己松懈，所以我要强调的最后一点，是行动。</p><p><strong>3.行动起来，从现在开始</strong></p><p>**无论你苛责还是鼓励自己，最后引发改变的，是行动。**想做什么，现在就开始做吧，不要等到以后。在我的认知中，90%的“明天再说”等于“明天就忘” 。想看书的，今晚睡前就拿起来，哪怕只看一页；想锻炼的，今天就蹦跶起来，哪怕只是一组4分钟的燃脂训练；想学画画的，今天就画起来，哪怕就画一个水杯。</p><p><strong>只要你做了，无论多少，你都是在行动，都是改变，而如上一点所说：再微小的改变，都值得褒奖。</strong></p><p>就像虽然90%的人看了这篇回答，过两天还是会忘记。但我觉得吧，不要紧啦，大家都是普通人嘛，别苛责自己，至少这么长的文章，你都快看完了，对不对？你还是很棒哒！而且看了这篇文章本身，就是“从现在做起”的体现啊！</p><p>你看，学以致用嘛，我就是这么看得开 ╮(￣▽￣&quot;)╭</p><p>最后，送一句我爱极了的话给大家：</p><blockquote><p>Incremental change is better than ambitious failure.<br>逐步的改善好过雄心勃勃的失败。</p></blockquote><p><strong>End. 后记-为什么要写这篇文字</strong></p><p>**我曾是一个学渣，很渣很渣的那种：**我背着笔记本去图书馆，却刷了半天的网页，又看了半天的电影，晚上我把自己骂一顿，决定明天好好学习，结果第二天又故态复萌；我曾整天翘课打游戏，晚上通宵到早上7点，睡到中午1点，起来吃碗泡面，下午继续打，这样循环了一个多学期。我不是没有想过改变，但每一次下定决心后的热血，都持续不到三天，很快就会陷入计划失败-&gt; 自责 -&gt; 重新计划-&gt; 计划失败的恶性循环。</p><p>在相当长的一段时间里，我都以为自控力是限制自己进步的最大阻碍，我痛恨没有毅力的自己，觉得这辈子没啥出息了。直到后来，见了很多很多人，读了很多很多书，我才明白以前很多对于自控、习惯和效率的理解都是错的。在那以后，我慢慢摆脱了诸如自控失败、拖延症这类问题的困扰，变成了别人眼中的“学霸”；我找到了自己喜欢做的事情，每天过得忙碌而有意义。</p><p>而为了达到今天的状态，我走了太多太多的弯路，我也看到太多人，跟我掉进同样的坑里，想要爬出来，却因为力气用错了地方而徒劳无功。<strong>即使是寒假计划失败这样一件看上去很小的事，背后却隐藏着太多的学问</strong>，它们分散在不同的书与课程里，没有足够经历的人，难以一窥全貌，结果就是反复的掉进坑里，在爬坡的过程中耗尽了心力，最终放弃了自己。</p><p><strong>我常常想，如果当年有人告诉我正确的道理和方法，我的人生会不会顺遂很多？</strong></p><p>所以我啰啰嗦嗦的写这么多，哪怕只对一个读者有用，就不枉我花二十多个小时，去琢磨和修改这篇东西。</p><p>最后的最后，再送两段话给大家：</p><blockquote><p>“在生活的过程中，会有很多次机会，让你不得不面对自己身上的缺陷和弱点，事实会一次又一次提醒你，你是一个不完美的人，需要改变。可人的本性是懒惰又脆弱的，大部分人选择麻痹自己，转向短期的即时刺激（上网购物打游戏，暴食社交一夜情），少数人选择改变自己，于是就会有痛苦，有反复，有成功和放弃。”<br>“没有人生来完美，每一个趋近于优秀的人格，都是经过了多次自我改造的结果。没有试图去改变的人，继续重复着自己日复一日的生活，看着那些早已看过的烂熟于心的风景，而对于正在改变的人来说，每一天都是新的。”</p></blockquote><p>这两段话来自知友</p><p><a href="http://www.zhihu.com/people/20366583aa36670a6aab34635a37bcfd">@陈诺</a></p><p>，我稍有改动，基本没有曲解原意，推荐大家看看她的回答，很多答案对我帮助很大。</p><p><strong>在改变的路上没有捷径，只有不懈的坚持和科学的方法</strong>，祝你们每一天都和之前不一样，每一天都是新的，大家共勉。</p><p><strong>Ref.推荐阅读 &amp; 参考文献</strong></p><p>一篇回答无法解决所有的问题，希望能给大家一些启发。这篇回答的所有重要观点，几乎都来自于下面这些书和课程，推荐给大家：</p><ol><li><a href="https%3A//book.douban.com/subject/10786473/">自控力 (豆瓣)</a></li><li><a href="https%3A//book.douban.com/subject/20507212/">习惯的力量 (豆瓣)</a></li><li><a href="https://www.bilibili.com/video/BV1kx411S7ZU">哈佛大学公开课：幸福课</a></li></ol><p>另附一篇回答，为什么期望短期内获得大幅改变的想法不切实际而且有害：</p><ul><li><a href="https://www.zhihu.com/question/29147255/answer/152408781">人可能在短时间内各方面都得到大幅提高吗</a>？</li></ul><p><strong>真·后记（2016.3.18更新）</strong></p><p>这篇回答短时间内获得了大量的赞，这令我始料未及。我想强调一点，这篇文章的初衷，是给大家一些启发，让大家对习惯和自控有一些正确的认知。更全面科学的解答，我还是极力推荐大家学一学上面的书和课程。</p><p>此外，一夜顿悟从而扭转人生这样的事极少发生。<strong>真正的顿悟（例如王阳明龙场悟道）之所以能发生，源于之前长期的实践和思考，是量变的积累遇到了合适的契机，从而引发了质变。</strong></p><p>改变没有捷径，它是漫长的过程，它始于你的意愿，在正确的行动下得到积极的结果。《自控力》这本书很多人买了，有多少真的看完了？又有多少人长期对照自己的问题回去翻阅过三遍以上？又有多少人按它讲的方法去冥想、去运动、去观察记录自己的行为？《幸福课》也有很多人看过，又有多少人认真的做笔记，按课里的方法去设定目标、去挑战风险、去写感恩记录、去关注事物的积极面？</p><p><strong>懂得很多道理只是前提，决定你能不能过好这一生的，是你的选择和行动。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大疆RoboMaster技术总监：我是如何成为一名机器人工程师的</title>
      <link href="/post/d782e1e8.html"/>
      <url>/post/d782e1e8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者 | YY硕</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><p>来源：知乎</p></blockquote><h2 id="▌前言">▌前言</h2><p>很多朋友私信问我对机器人和人工智能感兴趣，该怎么展开学习。最近稍微有点空，我写写我的看法。</p><p>两年前，我在知乎回答<a href="https://www.zhihu.com/question/20435673/answer/29927998">如何定义「机器人」？</a>中试图给机器人做出一个比较仔细的定义，我觉得机器人和人工智能最大的区别在于是否要和物理世界进行交互。今年初在另一篇知乎回答里<a href="https://www.zhihu.com/question/36653316/answer/85774195">对机器人或人工智能的研究会帮助我们更好的了解人类自己吗？</a>我说到传感器是和物理世界交互的基础。后来，我又在知乎回答<a href="https://www.zhihu.com/question/45766810/answer/100301388">有哪些与控制、机器人等相关的 quotes？</a>中提到莫拉维克悖论（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Moravec%27s_paradox">Moravec’s paradox</a>），谈到了机器人学里公认的难题是在物理世界中实现类人的活动能力。</p><p>把之前的回答再翻出来是为了支持以下观点：<strong>机器人学的核心问题是做好和物理世界的交互</strong>。现在主流的机器人学分支里，处理与物理世界的交互的学科分为三类：<strong>传感器和处理算法（激光雷达，多目视觉，融合算法）；多刚体系统动力学控制（工业机器人动力学控制和接触力控制）；机器人自主移动</strong>（locomotion不知道该怎么翻译，轮式、足式、飞行等移动机器人的研究）。我建议对机器人学有兴趣的同学着重在这几个问题上面。</p><p>另外，根据世界第一的机器人教育机构卡耐基梅隆大学的机器人学博士的<a href="https://www.ri.cmu.edu/wp-content/uploads/2017/01/COSAug2016.pdf">课程分类方式</a>，机器人学有四个核心领域：</p><ol><li>感知。视觉传感器、图像传感器、触觉和力传感器、惯导等。</li><li>认知。人工智能、知识表达、规划、任务调度、机器学习等。</li><li>行为。运动学、动力学、控制、manipulation和locomotion等。</li><li>数学基础。最优估计、微分几何、计算几何、运筹学等。</li></ol><p>结合卡耐基梅隆大学的核心课程要求，我觉得我定义的机器人学核心问题算是基本没跑偏的。本文后面谈到的机器人项目都是以上述观点和课程要求为基础。</p><p>一些可能有争议性的观点：</p><ol><li><p>机器人学是富人的活动。虽然工业越来越发达，但好的开发板和电机还是非常贵。如果要下定决心学习机器人学并且做出实物，你必须找到做实物出来的资金。要么是自己花钱，要么就得找学校的机器人社团，或者找什么愿意资助年轻人学习的贵人。另外现在没有任何一本完整的书可以教你怎么造一个四旋翼空中机器人或者大狗机器人，你需要参考十几本不同的教科书，这些书不管中文版还是英文版都很贵。</p></li><li><p>机器人学是屠龙之术。这话是 Ninebot 创始人说的。虽然最近几年，平衡车、扫地机器人、多旋翼飞行器让机器人学开始进入人们的生活，但是可行的商业应用还是很少，而且已有的机器人和理论都还很难解决好与物理世界交互这件事情。所以一定要确保自己在机器人学这个道路上同时练好了能去其他行当吃饭的技能，比如编程、机械设计和硬件设计。也要做好心理准备，接受自己有可能在学会屠龙之术以后几年都造不出对社会有用的东西的事实。</p></li><li><p>基于上述所说的观点，如果是已经工作之后才想要学习机器人的话，可能已经太迟了，因为很可能兴趣战胜不了客观限制因素。如果作为兴趣去学习，只能学到做巡线小车和舵机机械臂什么的，可能也满足不了中二病的创造欲。</p></li></ol><p>个人认为机器人学是一个艰苦的道路，想要成为一个独挡一面的机器人工程师需要多年理论和实践的同步训练。理论学习和动手实践的过程还要互相排好时间表，在做某个实践项目的同时去学习最相关理论往往可以达到事半功倍的效果，但是同时那些不太相关的理论会看起来非常枯燥，因此如何妥善安排自己的实践项目也是很重要的事情。</p><p><strong>这篇文章里我计划介绍一个电子工程、机械工程和计算机专业学生从大学一年级到研究生二年级的机器人学习计划，基本是我对自己过去学习方式的一个总结。</strong></p><p>按照这个方法来学习，能够成为一个能力全面，但是稍微偏软件一点的机器人工程师。这个六年的学习计划，估算下来，全年中每天在上课和完成课程要求之外要投入学习时间 6-8 个小时，这些时间一方面用于阅读课程知识的英文教材，一方面用于阅读其他学科的教材，一方面用于实践项目。</p><p>机器人工程师在大型项目里的定位类似于飞机系统里的总体设计师。和机械工程师、硬件工程师、软件工程师、算法工程师、控制工程师比起来，机器人工程师参与某个具体技术的时间较少，但是能够听得懂所有工程师说的话，能够作为不同模块间的协调人，带领整个团队去攻坚。当然如果机器人工程师能够在一个领域达到那个领域的工程师的优秀水平，肯定更好。</p><p>由于时间仓促，再加上个人水平有限，文章中如有纰漏和错误，恭请读者指出，谢谢。如果同学还有什么想知道的内容和教材，也欢迎留言交流。</p><h2 id="▌大一">▌大一</h2><p>刚上大一，你的机器人生涯开始了。先看看学校的校园网能不能翻墙，不能的话自己去买个一年一百多块钱的 VPN，先确保自己能上 Google，不要心疼 VPN 的钱，这能让你在之后的职业生涯里节省上万块钱。然后去注册一个gmail 账号，再注册 stackoverflow 账号，再注册 github 的账号，再注册CSDN 账号，注册完登录上去逛逛，暂时先不要问为什么。</p><p>英语水平一定程度上会是机器人工程师水平的限制因素，英语是同学们在大学最该努力学的一门课，而且不止要把它当成课，要当成一种技能，当成生活的一部分。当你开始努力学习一些高级的机器人知识以后，有可能会非常难以找到中文的参考资料，这个时候如果啃不下英文的资料，进步速度和眼界就会受到很大影响。因此大一的时候要多看看红宝书，看看美剧。</p><p>不管是什么专业背景的同学，大学一年级一定要上好的课是微积分和线性代数。线性代数的重要性需要特别强调。<strong>一般来说，优秀的工程师和科学家在职业生涯中要学至少五次线性代数</strong>，大一学一遍、学凸优化的时候学一遍、学线性系统的时候学一遍、学机器学习的时候学一遍……如果在第一遍学的时候就看到对的书，刷到对的题，那么以后的学习会轻松很多。</p><p>网上有很多对于如何学好线性代数的讨论，比如知乎问题<a href="https://www.zhihu.com/question/20534668">如何理解线性代数？ - 数学学习</a>。Matrix67大神的文章<a href="https://link.zhihu.com/?target=http%3A//www.matrix67.com/blog/archives/4294">随记：我们需要怎样的数学教育？</a>也很有启发。我个人对学习线性代数的建议是两本书，一本叫做《Linear Algebra Done Right》，另一本叫做<a href="https://www.math.brown.edu/~treil/papers/LADW/book.pdf">《Linear Algebra Done Wrong》</a>，我比较喜欢的是Done Wrong这本书，第一它是免费的，第二只需要读前6章两百页就够了，第三它页边距很大，打印出来有很多空白做练习题。另外一个较好的教材是<a href="https://link.zhihu.com/?target=http%3A//open.163.com/special/opencourse/daishu.html">麻省理工公开课：线性代数</a>。不论如何，学线性代数一定要用国外的教材，千万不要用国内的教材。啃英文书很累，但是考虑到之后还要啃更多的英文书，线性代数已经算是很入门的了，一定要啃下来，同时还要刷足够多的课后题。</p><p>学完线性代数以后，一个自然而然的问题就是怎么能用计算机自己去计算矩阵的乘法、向量的乘法、向量的内积。因此引入了编程的学习。</p><p>不管同学的专业是什么，一定要在大学一年级尽早开始学编程。至于用哪种语言开始学习编程，我推荐Python，比较好的教材是<a href="https://link.zhihu.com/?target=http%3A//open.163.com/special/opencourse/bianchengdaolun.html">麻省理工学院公开课：计算机科学及编程导论</a>，比较好的Python开发学习环境是<a href="%5Bhttp://www.continuum.io/downloads%5D(https://link.zhihu.com/?target=http%3A//www.continuum.io/downloads)">Anacoda</a>。熟悉Python以后，同学就可以开始玩玩Python的数值计算包Numpy，这个时候线性代数题基本上也刷的差不多，可以通过Numpy帮助自己解决线性代数问题了。</p><p>对任何人来说，Python是一把瑞士军刀，你可以用他干很多东西，比如自动回复邮件、自动收集信息。但是真要去造机器人，合适的工具并不是瑞士军刀，而是C/C++这样简单粗暴的锤子和螺丝刀般的工具。在学习Python学到一定程度的时候（比如你听说有一种叫做cython的东西），最好开始学习C，而且要强迫自己练习用C的一维数组和指针来实现矩阵的加法、乘法、求逆等操作。之所以有高级的Python或者Java（不要问我Java哪里高级了）这些语言以后我们还需要去学C，是因为机器人上常用的不是完整的电脑，而是计算量有局限的嵌入式系统，嵌入式系统开发基本只能用C或者更低级的语言。</p><p>学习C我个人入门用的是清华大学出版的《<a href="https://link.zhihu.com/?target=http%3A//product.dangdang.com/8880276.html">C++语言程序设计</a>》。虽然这个书标题是C++，但其实没什么太大问题。不过国内的C语言教材都有个巨大的问题是不引导学生去用Linux。近年来更好的一个教材是<a href="https://link.zhihu.com/?target=http%3A//songjinshan.com/akabook/zh/index.html">http://songjinshan.com/akabook/zh/index.html</a>，这个网站的教材非常好，因为他教育学生用Linux环境作为程序编译的环境，而且还引入了一些计算机体系结构的介绍。</p><p>IT行业的程序员都会争论高级语言和低级语言哪个好，Linux和Windows哪个好，而对于机器人工程师来说，从现在到可预见的未来里，C是最好的语言，Linux是最好的操作系统，这都毋庸置疑。甚至对于Linux的发行版该选哪个，我们都是很少有质疑的：Ubuntu（<a href="https://link.zhihu.com/?target=http%3A//www.ubuntu.com/global">The leading OS for PC, tablet, phone and cloud</a>）。原因是机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http%3A//www.ros.org/">ROS.org | Powering the world’s robots</a>）是基于Ubuntu开发的，因此在Ubuntu上运行最稳定。注意Ubuntu出了一个中文版叫做Kylin，个人感觉比较坑，建议大家不要装中文版。Ubuntu 作为一个开源操作系统，总是在快速迭代，2016年8月比较稳定的版本是14.04和16.04，建议同学安装14.04。</p><p>当你把C学得差不多，开始要学写包含多个头文件的程序时，一定要同时学习makefile的知识。这时候要上网去搜“Makefile详解”（<a href="https://link.zhihu.com/?target=http%3A//tieba.baidu.com/p/591519800">Makefile详解（超级好）_mingw吧</a>）这篇文章看。</p><p>我自己在大学一年级的时候还学习了HTML和Javascript，到大一结束的时候已经能够熟练用Javascript手写一些动态页面。我个人觉得HTML和Javascript也是机器人工程师必备的技术，而不只是软件工程师的玩具。这是因为web技术实际上已经渗透到了编程的方方面面，比如json开始是Javascript里的一种object定义的方式，但现在已经成为了一种很标准的数据交互、参数配置的格式。另外AJAX能够帮助初学者理解一定的网络技术原理，而网络技术也是机器人工程师必备的技能。</p><p>再者，制作GUI（图形用户界面）是常规debug的办法，而近年来一个流行的趋势是用webkit嵌入程序用HTML和Javascript作为图形界面的后端，而在机器人操作系统ROS（<a href="https://link.zhihu.com/?target=http%3A//www.ros.org/">ROS.org | Powering the world’s robots</a>）里，通过rosbridge可以非常方便地把机器人程序的数据传递到websocket上，这句话看不懂没关系，反正你知道学学HTML和Javascript很重要就是了。</p><p>更重要的是，HTML文档背后的DOM (Document Object Model)深刻地体现了面向对象的思想。大学中的面向对象程序设计一般都讲C++，在我看来应该讲HTML和Javascript。这一点不细说了，如果同学们去学习HTML和Javascript，自然会体会到。学习HTML和Javascript比较好的资料是<a href="https://link.zhihu.com/?target=http%3A//www.w3schools.com/">http://www.w3schools.com/</a>，把网站左侧的“Learn HTML”、“Learn CSS”、“Learn Javascript”和“Learn JQuery”学完就行，别的部分还有很多花哨的技术，没有必要去学了。为了培养自己对Javascript的兴趣，可以上<a href="https://link.zhihu.com/?target=http%3A//threejs.org/examples/">three.js / examples</a>跪着看看热闹。</p><p>以上介绍的这些知识点、书和资料应该在大一期间就全部看完，然后利用大一的暑假好好巩固这些知识。比如开始用HTML和Javascript做一个自己的个人主页，刷一刷编程的题目，学用Python的奇技淫巧（比方说做一个自己的个人主页）。另外还可以抽时间学学数学知识，比如开始看看代数和离散数学。我大一的时候看到了两篇文章，认识到了数学的重要性，一个是MIT的CV大牛林达华写的[<a href="https://link.zhihu.com/?target=https%3A//www.douban.com/group/topic/11115261/">转]MIT牛人解说数学体系</a>，另一个是前Goolge研究员吴军博士写的《数学之美》（<a href="https://link.zhihu.com/?target=https%3A//book.douban.com/subject/10750155/">数学之美 (豆瓣)</a>）。当时林达华还在MIT读博士，而《数学之美》还没有成书。两篇文章看完以后我感觉自己整个人对数学的认识上了一个新的层次，此后一直在注意提高自己的数学水平，几年下来觉得收益很大。在之后的介绍里我还会多次强调需要学的数学知识和对应的教材。</p><h2 id="▌大二">▌大二</h2><p>上大二的时候，你已经会了基本的编程知识和基本的数学知识。大二这一年应该投入在嵌入式系统的学习中，同时继续拓展自己多方面的能力。学校的机器人社团，比如做Robocon，RoboMasters的团队应该在招新了，赶快去加入，有了学长学姐的指导以及同辈朋友的鞭策，应该会进步的快一点。</p><p>大二应该掌握的技能：Solidworks画基本的机械图，基本的数字电路知识、数模转换，51单片机、AVR单片机、STM32单片机原理，UART、SPI、I2C、CAN等协议的原理和数据收发，STM32开发板的使用，电机转动和驱动的原理，PID的原理，调试四轮机器人底盘的移动，基本的传感器如陀螺仪、码盘、红外线、超声波的原理和读取方式，网络知识如配置IP配置路由器等，微电子焊接，金工技术。我在知乎回答<a href="https://www.zhihu.com/question/34670420/answer/59676472">如果程序员每天都浅尝辄止地学一些不同的新技术，长久以往，人会变成什么样子呢？</a>里谈过机器人工程师需要的技能数量是IT行业全栈工程师技能数量的三倍以上，这些技能的基础都应该在大二开始积累。</p><p>如果同学们的专业是机械工程相关，那么大二的时候要深入学习solidworks做图，买机械加工手册学习各种机械的奇技淫巧。你的专业知识还不足以让你进行缜密的受力分析，不过你可以尽量多做一些机械结构出来感受它们的乐趣。</p><p>如果同学们的专业是硬件、电路相关，那么大二的时候要深入学习Altium Designer做图、制板、焊板。你要从现在开始，就给自己积累一个工作记录，可以就是简单的txt文件，记录你做过所有板子的bug、解决方案、学到的原理图、PCB layout的注意事项等等。积累很多年以后，你的这个工作记录会值很多钱。</p><p>学习这些技能的最好的方式，就是参加自己学校机器人社团的训练和方案设计。一般来说，学校的机器人社团招新之后会有训练和测试，让新人分组去做机器人，这个过程中如果愿意努力学，提高得会很快。如果你所在的大学是机器人比赛强校，比如西安交通大学，电子科技大学，哈尔滨工业大学，华中科技大学，东北大学等等（排名不分先后，没有提到你们学校名字的话我表示抱歉），那么你很幸运，你们学校的机器人社团有很好的积淀，有很多资源可以帮助你学习。基本上只要天天泡实验室，保证自己每天只睡6-7个小时（但还是要多去跑步、游泳保持身体健康），勤于向学长学姐请教，那么一定会提高得很快。</p><p>大二阶段特别要强调的是对动手能力的培养，包括机械材料的加工、电路焊接、制作导线和接头、连接路由器、配置网络、做网线等等。机械加工的工具有螺丝刀、锯、钻、锤子、车床、铣床、钻床，进阶选手可以学一下氧焊，这个比较危险，我没尝试过；电路焊接的工具有焊机、焊锡、洗板水、松香、吸锡器；制作导线的工具有剪子、剥线钳、夹头钳、网线钳各种钳；网络配置就是连连路由器插插网线，但是Linux系统下配置网络有时会非常麻烦，一定要多积累这方面的知识，因为将来你造的机器人多半会顶着一个无线路由器跑来跑去，甚至有的机器人上各个模块自己就能组起一个小局域网。这些技能的熟练掌握需要你花很多时间去做真正能用的机器人来练手。</p><p>对于该选择造一个怎么样的“真正能用的机器人”练手，最好的选择肯定是机器人比赛中的机器人。如果参加Robocon，你会跟着学长学姐们学着造有人那么高的巨大机械；如果参加RoboMasters，你会学着造比汽车还要灵活的机器人以及快速发弹的机构。其他一些小型的比赛比如飞思卡尔智能车，也是很好的训练，因为飞思卡尔智能车已经发展得很成熟，参加这个比赛的参赛资料就够学一阵子的，学完以后能够获得比较多的机器人技能。</p><p>如果没有太多学校机器人社团的资源，同学们还有一些小型的比赛比如挑战杯、大创比赛等等可以选择，以三五个人的小团队参与这些比赛。如果同学所在的学校连这些比赛都不组织大家参与，那就只好自己花钱了。国内开源机器人社区有很多资源可以利用来学习，比如自己买<a href="https://link.zhihu.com/?target=http%3A//www.makeblock.com/">Arduino STEM educational Robot kits Building Platform</a>的各种开发套件做简单的机器人。Arduino的开发环境可能有些人不喜欢，因为它对硬件做了一级封装，如果更希望接触到单片机的本质，可以自己买STM32开发板学习。俗话说，没有什么嵌入式系统是一块STM32实现不了的，如果有，就用两块。STM32是ARM Cortex‑M家族中最为广泛应用的一款单片机，在网上也有很多的教材和开发板可供选择。在国内著名的电子论坛<a href="https://link.zhihu.com/?target=http%3A//www.amobbs.com/forum-3020-1.html">STM32/8 分论坛帖子清单 (amoBBS 阿莫电子论坛)</a>上，有很多参考资料，有问题也可以在这里和大家讨论学习。</p><p>如果你很想参加机器人比赛，身边也恰好有一些志同道合的小伙伴，但是学校不支持。没关系，来找我，我尽量通过大疆的关系说服你们学校支持你们参加 RoboMasters。</p><p>虽然你是以机器人比赛为主线在探索机器人技术，但是要时刻记得，机器人比赛给你的理论方面的训练很差，还会让你养成一些坏习惯，比如凡事都希望用一些糙猛快的办法来解决。由于通常整个团队都没有太多的项目管理经验，到比赛前一段时间才会加紧功夫去做机器人，很多时候就会用“山寨”的办法去处理机器人的故障。比如说某个承重结构用久了会弯，为了赶比赛的进度，就拿锤子敲直了、再加一条辅助的结构在旁边继续用，而没有细致地去做建模、受力分析，思考是什么原因导致承重结构会变形。再比如说调PID参数就是生调乱改，而没有基于机器人的动力学模型去估测参数的大概范围。</p><p>大二的暑假，有可能你跟着学校的机器人队参加了一些机器人比赛。这是一个反思总结的好时机，为什么机器人队取得了这样那样的成绩？整个团队怎样才能更有效率？明年如何继续招新？暑假要把时间花在技术积累上面，这个时候可以回头思考思考之前准备比赛时用糙猛快的办法解决的问题如何能够细致地去解决。</p><p>如果大二的暑假没有参加机器人比赛，可以做一个舵机机器人，比如 6 条腿的蜘蛛，比如码垛机器人。舵机是机器人工程师的好朋友，一定要好好掌握。</p><p>另外你其他方面的能力也不能落下。大二结束的时候，你的 Linux 应该用的很熟练了，除了 makefile，你也用起了 cmake。你也应该开始理解 Github 存在的意义，因为你已经上去读了很多别人的代码，你也把自己的一些课程设计和小项目放在了 Github 上面。另外大二基本上了本专业一些比较难的基础课程，比如自动控制原理、机器学习、概率统计、材料和力学等课程，同学们会看到这些课程里又用到了线性代数和微积分的知识，以及建模的知识。这时候可以把大一的物理、线性代数和微积分再翻出来看看。</p><p>同学的学校应该给大二到大三的学生有开设面向对象的程序设计，一般用 Java 或 C++ 教授。在面向对象的程序课里面，一定要积累 3000 行左右的代码的开发经验。经典的面向对象程序设计的练习通常是写游戏，比如俄罗斯方块，吃豆人等等，一定要自己能够做到完全手写一个完整的项目出来。</p><p>另外你可以开始学习Matlab当中的神器Simulink了。在大二这一年的学习中，你可能在不少课程里多多少少用到了Matlab。假设你已经在我的推荐下喜欢上了Python，你可能会觉得Matlab的计算工具没有比Python强多少；假设你自己在别人的推荐下喜欢上了mathematica（<a href="https://www.zhihu.com/question/27834147">Mathematica 到底有多厉害？ - Wolfram Mathematica</a>），你可能会觉得和Mathematica这种神一样的语言比起来，Matlab弱爆了。但是要注意的是，Matlab最强大的工具是Simulink，通过它你几乎可以仿真一切的物理系统和控制系统。我建议同学可以通过Simulink实现一个倒立摆，然后理解Matlab的强大之处。对此我强烈推荐一个很好的教材（<a href="https://link.zhihu.com/?target=http%3A//ctms.engin.umich.edu/CTMS/index.php%3Fexample%3DIntroduction%26section%3DSimulinkControl">http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction§ion=SimulinkControl</a>），它详细介绍了一些经典的控制系统如何分析以及用Simulink实现。然后我再强烈推荐一个讲Simulink里面一个更加和物理仿真贴近的工具Simscape（<a href="https://link.zhihu.com/?target=http%3A//www.mathworks.com/help/control/examples/control-of-an-inverted-pendulum-on-a-cart.html">Control of an Inverted Pendulum on a Cart</a>）的文章。阅读并实现了这两篇文章里的内容，同学应该会对倒立摆有了比较深刻的认识。倒立摆是机器人学中一个非常重要的模型，因为火箭、导弹、双足机器人、四足机器人，基本都是倒立摆的变形。你自己实现出来的simulink模型一定要存好，以后可能还会再拿出来仔细看。</p><p>如果你按照我之前说的方法探索了一些HTML和Javascript的技术，那么JQuery，bootstrap，AngularJS你已经多多少少知道是怎么回事了。web后端的技术，比如PHP和MySQL，也可以了解一下，LAMP要学会怎么配置。如果有同学找你帮忙写小网站，尽量去帮个忙，帮别人做网站是提高自己系统编程能力的好练习。在做网站的过程中你可能还会顺便学一学如何用Photoshop和Illustrator让网站显得更漂亮。这些技能有最好，没空学也没关系。</p><h2 id="▌大三">▌大三</h2><p>大三开始的时候，你可以在学校的机器人队里担任重要角色了，或者能够带领一个小团队参加小型的机器人比赛。你在系里甚至院里都小有名气了，可能有的人叫你大神，有的人觉得你技术还不错。但是一定要记得你现在的水平放到别的地方应该不算什么。每年我都往大疆的RoboMasters夏令营招进100个和你现在的水平相当的同学。</p><p>大三一定要培养出自己一个人独立造出一个完整机器人的能力，比如一个Robocon水平的机器人，或者一个RoboMasters的战车，或者一个四旋翼飞行器。</p><p>Robocon水平的机器人，涉及大量的机械设计，单片机开发，电机驱动的开发，码盘和超声波等传感器的读取，底盘运动学的计算，PID调试，任务调度逻辑的调试，舵机控制。RoboMasters的战车的机械部分简单一些，但是还需要进行云台的控制、发弹系统的控制、功率控制等方面的知识，另外你也可以不搞这些部分，学习学习视觉识别和自动打击，那么就要开始研究OpenCV（<a href="https://link.zhihu.com/?target=http%3A//opencv.org/">OpenCV | OpenCV</a>）了。</p><p>四旋翼飞行器的机械部分最简单，但是算法比较复杂。对于大三学生来说，从零开始一步到位写一个稳定的飞控比较困难，因为飞控里面有很多细小的知识点要注意。目前我没有发现什么比较好的书籍推荐，已有的一些关于四旋翼系统的书要么太浅（上来就教你焊电路），要么太深（上来就教你state estimation），听说 <a href="https://www.zhihu.com/people/liu-top">@Liu Top</a>的exbot小组在写一个教材，我是非常期待的。学习四旋翼飞行器有下面几个步骤：</p><p><strong>第一步：自己调一个小四轴飞起来</strong></p><p>现在开源社区的人言必pixhawk，其实我觉得从学习的角度来说，pixhawk太贵，而且不适合学习，我比较推荐的是 <a href="https://link.zhihu.com/?target=https%3A//chiplab7.taobao.com/">首页-第七实验室</a> 这家淘宝店卖的STM32F405飞控，买回来以后自己再随便买个机架（比如大疆F450）、接收机和遥控，就能按照飞控板附带的学习资料、调试软件飞起来。</p><p><strong>第二步：看硬件图、读代码</strong></p><p>chiplab7 的飞控板附带一大堆学习资料，对加速度计、陀螺和磁感计都有很仔细的解释，硬件链路图也很详细。chiplab7 淘宝掌柜的又很认真负责，我学用的时候，发现代码有 bug 和看不懂的地方，都可以直接找掌柜问。</p><p>看完代码以后，对一个飞控系统的基本模块：姿态解算、控制解算、混控输出、遥控器处理、嵌入式处理就很明白了。然而这里面有很多技术是需要另外学习的。除了基本的嵌入式编程以外，还有要把大二大三学的信号处理方面的知识再捡起来看看。因为飞行器在空中有振动，会让加速度计产生噪声，为了把这些噪声去除掉，需要对加速度计给出的信号做低通滤波处理，如何选择滤波器的参数呢？如果滤波滤得太狠，延迟就会比较大，对控制的表现会有影响；如果滤波滤得不够，可能会有一些低频的噪声偶尔会出现，导致加速度计的观测不能用。另外最重要的是要理解姿态解算和控制解算这两块知识。chiplab7 的飞控板的代码采用的是最简单的互补滤波算法做为姿态解算模块，然后控制解算是对欧拉角的三个角度做闭环 PID 控制，基本都是基础的基础了。</p><p><strong>第三步：小修小改加深理解</strong></p><p>chiplab7 的飞控是靠气压计定高的，飞行效果非常奔放。这时候可以淘宝买个 20 块钱的超声波模块，然后自己写个高度环去稳定飞控的定高表现。</p><p>我觉得这个过程至关重要，因为高度控制相对来说是个比较直观理解 PID 控制的方式，而且 chiplab7 的飞控加高度控制非常好加。工作量不大，因为改善效果很显著，所以可以让人很有成就感，加深继续学习的乐趣。</p><p><strong>第四步：理解核心的数学和控制知识</strong></p><p>这一部分大三是肯定来不及学的，但是我还是在这里列出来，因为这些知识你之后都需要慢慢学，我也会在之后不断重复提到这些知识点。</p><p>姿态解算和控制解算涉及的知识有：</p><ol><li><p>刚体姿态的表示、运动学方程和动力学方程。主要是对牛顿-欧拉方程的认识和理解、刚体姿态的欧拉角表示法、姿态与角速度的关系等等。</p><p>这部分说复杂不复杂，说简单也不简单，我同样是没有找到一本完整的书全都介绍过的，是学了好几个不同的书和论文以后搞明白的。现在看起来是从维基百科入手比较靠谱。</p></li><li><p>自动控制原理。讲 PID 的书和文章就多了去了，没有太多复杂的书。</p></li><li><p>线性估计基本原理。其实就是互补滤波：<a href="https://link.zhihu.com/?target=http%3A//www.pieter-jan.com/node/11">Reading a IMU Without Kalman: The Complementary Filter</a> 。拿这个关键词百度各种搜就会了。</p></li></ol><p><strong>第五步：重头开始造轮子</strong></p><p>知乎著名网友 vczh 曾经说过，学习要抱着勇于造轮子的心态才能进步。所以在熟悉了别人飞控基础上，可以自己重头造一个飞控的轮子。可以自己从芯片开始重新画一个飞控板，读读 STM32 的芯片手册、读读各种传感器的芯片手册，自己手画一个飞控的原理图、做 PCB layout、制板自己焊元件，全套花不了 1000 块钱，能够加深很多对硬件的理解。这一部分如果大三没空，也可以不搞了。</p><p>制造整个机器人的过程中要特别重视文档的积累。在你大三末期，你可能随着学校的机器人队备战比赛，你可能主力负责一台机器人。你应该自己列一个excel表格，把机器人用了几颗螺丝，几根导线，每个零件的规格是什么，都列出来。这个表格一方面可以用来帮助团队管理机器人的物料，一方面也是你自己的经验技术积累，将来你做的其他机器人可能多多少少都是Robocon、RoboMasters 机器人的变形。</p><p>另一个积累是建一个自己的buglist，buglist包括什么呢，可以像冷大这样：<a href="https://www.zhihu.com/question/46824735/answer/115202408?from=profile_answer_card">做控制、机器人等算法工程师是怎样一种体验？ - 冷哲的回答</a>，就简单把一些自己的发生过的问题和最后的解决办法罗列下来。比如说“杜邦线接插位不稳固容易脱开，接好后应该用电工胶布再裹一圈”，“外发给淘宝加工的机械图纸，要特别注意和加工商沟通有没有漏掉一些细节，如沉头螺丝孔，关键的倒角”等等。你也可以帮其他机器人的问题也做这样的记录。buglist可以就是一个简单的文本文件，如果你一直往里面积累自己工作中的记录，等你将来工作了，这个文件可能会值很多钱。</p><p>大三的时候学校应该会开设软件工程的课程。不管你是不是这个专业，上不上这门课，都应该主动去听一听，甚至跟着课程的设计作业一起做一做。软件工程我觉得是机器人工程师必须具备的意识，因为一个机器人系统里涉及大量的硬件系统和软件功能，软件的部分往往还会涉及不同的语言、不同的编译环境、不同的开发工具链。几个人合作的话，大家的专业背景、编程习惯都不相同，这就导致不同的代码和模块之间的协议沟通非常复杂，必须尽早用UML和其他软件工程的工具帮助团队理解和互相沟通。</p><p>大三的时候学校应该还会开设操作系统原理和嵌入式系统原理的课程，而大二的时候讲过计算机组成原理（所谓的微机原理）。从大三开始同学需要开始体会实时操作系统和非实时操作系统的区别、原理以及使用时需要注意的地方。这是一个比较杂的知识点，我目前没有找到很好的教材去介绍。在STM32 上，有 freeRTOS，uCOS，Vxworks 这么几种实时操作系统；Linux 是一种非实时操作系统，但是可以通过打补丁变成实时操作系统。这些操作系统的细节在机器人开发中都会多多少少被涉及到，同学们可以随时上 Google 和 CSDN 去查大神们的介绍。</p><p>另外特别重要的一点是机器人系统里的嵌入式平台都有烧坏的可能性，有可能在某个嵌入式 Linux 平台上面辛辛苦苦写了一个多月代码，这个平台突然烧坏了，代码也就丢了。因此你的机器人如果有嵌入式 Linux 系统在里面，一定要尽早顶起来路由器，代码定时提交 SVN 或者 git。</p><p>大三的暑假你可能会作为学校机器人队的主力去参赛了。备战比赛和参赛是一件磨练心性的事情。我在学生时代体会过和胜利擦肩而过的痛苦，体会过没机会再来一年的遗憾；也在负责大疆 RoboMasters 比赛的过程中被那些痛苦和遗憾的学生当做发泄的对象，非常有感触。我觉得参加机器人比赛，很努力，然后失败了，是一件让人快速成长的事情。同学如果有机会，一定应该参加至少一届机器人比赛。</p><p>大三的暑假你也可以选择来参加大疆的RoboMasters夏令营，关于夏令营大家可以看这个知乎问答了解更多：<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>。每年我们都在全国范围内寻找有一定技术基础的学生，让他们一起分组做一个自动机器人的挑战。这个夏令营，作为组织负责人，不谦虚地说，我觉得应该是全世界范围内最好的技术类夏令营。</p><p>大三的暑假有一件很重要的事情就是思考自己大四应该干什么。一般来说，你现在的能力保本校研究生肯定没有问题，当然你也可以选择考其他学校的研究生或者出国留学。虽然说你现在能力已经很全面了，但是你还需要2-3年的时间全面提升自己更多的能力，才能迈向卓越之路。不管是出国还是保研，最重要的目的是给自己争取到未来2-3年能够在一个优秀的环境中安心提升自己，有比较好的学习资源，能够参与到一些不错的项目中去。可能其他有些行当，出国留学始终是比在国内待着更好的选择，但是机器人行业并不是这样。我们国家这两年在机器人方面提高也很快，而且我们国家现在比较有钱。就像我开始说的那样，机器人是富人的活动，现在你在国内也能找到一些很有钱的实验室可以造比较牛逼的机器人。另外国外很多比较强的机器人公司也都在做比较敏感的军方项目，去找实习可能比较受限制。</p><p>出国去学机器人学方面的知识你有很多不错的选择，比如世界第一的机器人研究院卡耐基梅隆大学，或者麻省理工学院的CSAIL实验室。北美传统计算机四大名校（麻省理工学院，卡耐基梅隆大学，斯坦福大学，加州大学伯克利分校）里，除了斯坦福大学热火朝天在搞人工智能以外，其他几个学校的机器人研究都很不错。除了四大名校，你还有很多其他的选择，就像我开始说的那样，机器人是富人的活动，如果想接触到最好的机器人资源，你要选择有钱的实验室，而不是有名的实验室。</p><p>另外你还需要在大三的尾巴上选定自己将来的细分研究方向，而且开始往这个方向深挖，也就是我在文章开始提到的感知、认知、行为几个方向。当然同时你也不能放松其他方面的知识，尤其是数学基础。我在大三的暑假专门找数学系的同学给我开了个数学小讲座，学习了一点抽象代数的知识，对我后来学习密码学帮助很大。同时我也读了一些拓扑方面的教材（有一本很神奇的书叫做Topopogy Without Tears <a href="https://link.zhihu.com/?target=http%3A//www.topologywithouttears.net/">http://www.topologywithouttears.net/</a>），这样才理解了为什么数学分析要用奇怪的符号去解释一些看起来很浅显的道理。</p><p>大三阶段的机器人工程师该学什么基础数学是众说纷纭的，在我看来，你要基本掌握“群是什么”，能够用代数的眼光去证明&quot;det(AB) = det(A)det(B)&quot;，还要能理解“用一张纸就可以变出克莱因瓶”（当然是在四维空间里）。另外，你这个时候也要能够意识到自己需要再学一遍线性代数。</p><h2 id="▌大四">▌大四</h2><p>大四开始了，你可以开始深挖自己的研究方向，同时也要开始学一些高级一点的通用技术和理论，这时候你和一般的机械、电子、计算机学生就不太一样了，你虽然也在狂编程，但也在狂学习物理和数学。通用技术包括ROS，simulink，gazebo和Vrep等工具。通用理论包括，再学一遍线性代数，学学凸优化、数值计算、旋转表示法等方面的知识。这些知识你在大四仅仅只能开一个头，因为你的大四要实习、毕业、考研、毕设，你会非常地忙。有些人会在大四进实验室和老师发论文，我个人觉得发论文这件事没必要操之过急。你的整个大学期间应该用在广泛涉猎各种各样的知识上面，而不是深入某一个细小的研究问题。</p><p>大四可以开始读一些著名入门书籍，我把这些书不分先后地列出来，你没有必要全部去读，而且每本书先读前几章就够了，能读多少尽量读多少。</p><ol><li><p>概率机器人学，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623">https://www.amazon.com/Probabilistic-Robotics-Intelligent-Autonomous-Agents/dp/0262201623</a></p></li><li><p>凸优化，<a href="https://link.zhihu.com/?target=https%3A//web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf</a></p></li><li><p>线性系统理论，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579">https://www.amazon.com/Linear-System-Electrical-Computer-Engineering/dp/0199959579</a></p></li><li><p>Multiple View Geometry in Computer Vision，<a href="https://link.zhihu.com/?target=http%3A//www.robots.ox.ac.uk/~vgg/hzbook/">Multiple View Geometry in Computer Vision</a></p></li><li><p>线性估计，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642">https://www.amazon.com/Linear-Estimation-Thomas-Kailath/dp/0130224642</a></p></li><li><p>《机器学习》，周志华老师的书。</p></li><li><p>An Invitation to 3-D Vision，<a href="https://link.zhihu.com/?target=https%3A//www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf">https://www.eecis.udel.edu/~cer/arv/readings/old_mkss.pdf</a></p></li><li><p>Modern Control Systems，<a href="https://link.zhihu.com/?target=https%3A//www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580">https://www.amazon.com/Modern-Control-Systems-12th-Richard/dp/0136024580</a></p></li><li><p>Rigid Body Dynamics，<a href="https://link.zhihu.com/?target=http%3A//authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf">http://authors.library.caltech.edu/25023/1/Housner-HudsonDyn80.pdf</a>。说实话刚体动力学理论我没有找到特别好的书。但是刚体动力学理论很重要。</p></li><li><p>Feedback Systems: An Introduction for Scientists and Engineers，<a href="https://link.zhihu.com/?target=http%3A//www.cds.caltech.edu/~murray/amwiki/index.php/Main_Page">FBSwiki</a></p></li></ol><p>就像我开始说的那样，这些书，大部分特别贵，还好有一些业界良心的作者放出了他们书的电子版。当然你也可以去一些名字都不能说的网站去找影印版。</p><p>在读上面这些书的时候，matlab，python都要放在手边，然后把书里面的知识尽量实践出来。很多教科书里都会在章节后面的习题里放一些写明是用matlab做的习题，要尽量多做一些这样的题。</p><p>你可能早就听说了ROS的大名，但是最好不要在大四之前去碰它。因为ROS用了很多操作系统和网络的底层技术。我在知乎回答<a href="https://www.zhihu.com/question/21958225/answer/20255931">高手可以谈谈ROS机器人操作平台开发的一些经验吗？ - YY硕的回答</a>里有简单的介绍。ROS的设计目标是把机器人的控制和传感器处理的软件和它的硬件隔离开，用上ROS以后，你可以方便地用到很多能直接跑的软件代码。但是ROS从入门到精通需要至少一年以上的时间，你必须不断地用，不断地尝试新的代码和硬件，才能对它熟悉起来。</p><p>ROS 的可视化工具 Rviz 里面对于机器人旋转的表示用的是四元数，而在你之前研究四旋翼飞行器时，里面的代码表示旋转用的是欧拉角，做姿态解算用的可能是四元数。这个时候要开始有意识地去学习旋转表示法之间的区别和联系。</p><p>要重视大四期间的实习和毕业设计。很多大四的学生毕业设计都会非常颓地做一下，我觉得是不好的。要把做毕业设计的过程看做一个正式的项目。这个项目除了做好技术方面的工作，也要做好展示方面的工作。中国工程师的一大特点是，不会表达自己，可能做的东西水平很高，但是做出PPT就会犯字体花哨不正式、一页上面字太多，图文没有联系等表达上的问题。通过PPT介绍、展示自己的成果在工程师的职业生涯的任何一个阶段都非常重要，它甚至也一定程度上限制了机器人工程师能够达到的高度。只有能够把自己的成果清晰地表达给自己的团队，才能获得其他人的反馈、通过沟通提高团队的整体凝聚力和知识水平，这样自己在团队能够获得更多的认可，有助于团队整体工作效率的提高。我每年去参加几次学术会议，都在会议上感觉到一些中国的科研人员走到国际上以后，演讲能力很差就会导致他们的科研成果不受重视。当然其他国家的科研人员也是这样。</p><p>为了写出美观的技术报告和毕业论文，你可以开始学习Latex。Latex作为国际国内第一写作神器，学习资料在网上有很多。Latex的学习和使用同样也是需要不断地熟能生巧，多写多练就熟悉了。写毕业论文有个问题是怎么做出精美的矢量图，我推荐<a href="https://link.zhihu.com/?target=https%3A//inkscape.org/en/">Draw Freely | Inkscape</a>，一个比Illustrator更轻量化、但是有些功能反而更强大的免费软件。</p><p>对于那些想申请出国留学的同学，你要做一个自己个人的成果展示，用网页的形式呈现比较好。把自己 Github 链接（如果你按我说的，大学第一天就申请 Github 账号，现在已经是一个三年的老油条了）、做过的机器人视频、写过的技术报告和文章（最好是英文的）放在上面。</p><p>关于毕业设计的选题，我推荐这么几个：</p><ol><li>手写双目视觉里程计。涉及到图像处理、特征匹配、位置解算、空间变换等等。</li><li>手写四旋翼飞行器基于 GPS 的轨迹规划。涉及到深挖四旋翼飞行器的运动原理、IMU 原理、轨迹生成和优化等。</li><li>造一个被推了也不会倒的双足舵机机器人。涉及到舵机控制、倒立摆建模、动力学分析、PID 控制、IMU 原理等。</li><li>深度学习训练一个小车追人跑。涉及到深度学习工具包使用、数据集采集、数据集分析、小车控制等。</li><li>机械臂给人端茶倒水。这个相对来说土豪一点，因为能直接拿来用的机械臂都很贵，这个要看实验室有没有条件了。涉及到多自由度机械臂原理的学习、工具包的使用、轨迹规划等等。</li></ol><p>这几个项目要做好，都要持续投入三个月以上的时间以及一定的资金，每一个都是理论多于实践。当然同学们自己也可以自己选择自己的毕业设计题目，但是最好还是选做出来能跑能飞的东西，同时避免选择需要花大量时间去拧螺丝、焊板子的题目，尽量买现成的电机、开发板、3D 打印结构，大四要多给自己留时间去看书和写代码。</p><p>大四到研究生之前的暑假，最好去一些比较不错的机器人公司实习一下，比如说大疆。当然你也可以继续做机器人比赛，比如RoboMasters和大疆的飞行器比赛。</p><h2 id="▌研究生一年级">▌研究生一年级</h2><p>研究生的时候，你的目标比较清晰了，就是做一种机器人至少两年时间，并从中发掘出可以发表论文的知识点。上面我给出的书单里面，你要开始精读里面的几本。、</p><p>如果做机器人视觉定位、传感器融合方面的研究，1、4、5、7四本书一定要精读。</p><p>如果做控制系统的研究，3、8、9、10一定要精读。</p><p>如果做规划算法的研究，那么还要读其他偏CS一些的书，比如讲A* search，random forest，图论方面知识的教材。由于我在这方面造诣不深，就不托大了。</p><p>如果学习随机系统的控制和最优控制，除了1、2、3，还要读一本神书<a href="https://www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">Stochastic models estimation and control</a>。</p><p>如果研究机器人视觉定位，几种常用的定位算法：PTAM（<a href="https://link.zhihu.com/?target=http%3A//www.robots.ox.ac.uk/~gk/PTAM/">Parallel Tracking and Mapping for Small AR Workspaces (PTAM)</a>），ROS的标配VO（<a href="https://link.zhihu.com/?target=http%3A//wiki.ros.org/viso2_ros">viso2_ros - ROS Wiki</a>），SVO（<a href="https://link.zhihu.com/?target=https%3A//github.com/uzh-rpg/rpg_svo">GitHub - uzh-rpg/rpg_svo: Semi-direct Visual Odometry</a>），LSD-SLAM（<a href="https://link.zhihu.com/?target=http%3A//vision.in.tum.de/research/vslam/lsdslam">http://vision.in.tum.de/research/vslam/lsdslam</a>）ORB-SLAM（<a href="https://link.zhihu.com/?target=https%3A//github.com/raulmur/ORB_SLAM2">GitHub - raulmur/ORB_SLAM2: Real-Time SLAM for Monocular, Stereo and RGB-D Cameras, with Loop Detection and Relocalization Capabilities</a>），都必须自己学习之后全部跑一遍。只会用OpenCV的函数和这些工具包并不能说明你会视觉定位，必须要能自己手写出一个能用的才算。国内有一个很厉害的SLAM专家叫高翔，他的博客要关注一下：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/gaoxiang12/tag/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人 - 标签</a>。由于SLAM这两年很火，研究的人很多，所以网上可以参考的资料也很多，比如<a href="https://link.zhihu.com/?target=https%3A//github.com/hcdth011/ROS-Hydro-SLAM">https://github.com/hcdth011/ROS-Hydro-SLAM</a>，就在ROS上实现了几种定位算法的对比。</p><p>我现在非常不建议同学们选择从四旋翼飞行器的动力学控制里找问题作为研究课题。因为四旋翼飞行器的特点已经被研究透了。目前国际上对多旋翼飞行器的研究主要集中在造一些奇葩形状的飞行器，以及给多旋翼飞行器上安装一个机械臂去做力控制，这样做就对多旋翼飞行器控制的动力学造成了一些影响。因此需要同学对动力学和多自由度机械臂控制有比较深的认识。</p><p>自动导航和驾驶是这两年的热点，一方面汽车的自动化是大势所趋，另一方面多旋翼飞行器异军突起，产生了很多对自动飞行的需求。除了机器人视觉定位算法以外，同学还需要学习其他的传感器，以及这些传感器与视觉定位算法怎么融合。这里面有很多坑，比如计算量的问题，怎么保证融合算法不崩，怎么处理传感器的延时等等，都需要同学结合自己的项目去踩，坑踩得多了才能成长。如果大家想找一个多旋翼飞行器平台研究自动导航，我推荐大疆的M100，我已经在知乎回答<a href="https://www.zhihu.com/question/31586826/answer/65274168">RoboMasters2015夏令营是怎样的？</a>里吹过一波M100，前面说过的今年夏令营的知乎回答<a href="https://www.zhihu.com/question/49986388">参加Robomasters 2016夏令营是怎样一种体验? - DJI 大疆创新</a>里也有人帮我吹了一波。</p><p>一些大学里学过的知识点，是必须结合研究生期间的项目的需求弄得很清楚的，比如三大变换（傅里叶变换，拉普拉斯变换，Z变换），旋转表示法（欧拉角、四元数、旋转矩阵），数值计算怎么防止矩阵出现数值问题等等。除了自己的项目，还需要把凸优化、卡尔曼滤波还有多自由度机械臂的控制学习一下。这三个领域的知识，是任何一种机器人都会用的到比较难的知识。</p><p>凸优化和凸优化的各种变形是非常重要的知识，因为各行各业里的研究问题，多半是会建立一个优化问题去解决的。</p><p>上面提到的《Convex Optimization》<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf%EF%BC%8C%E4%B9%9F%E6%98%AF%E4%B8%80%E6%9C%AC%E7%A5%9E%E4%B9%A6%EF%BC%8C%E5%90%8C%E5%AD%A6%E4%BB%AC%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%A4%E7%9C%9F%E8%AF%BB%E4%B8%80%E8%AF%BB%E3%80%82">https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf，也是一本神书，同学们一定要认真读一读。</a></p><p>Matlab、Python、C++都有一些现成的工具包可以帮助你解优化问题，不过最好同学们能自己手写一些基本的优化算法，比如gradient descend，barrier method等等。另外现在主流的SLAM算法，后端都是通过一种叫做g2o的优化算法来出效果的。而且g2o能够整合bundle adjustment 和structure-from-motion这两大计算机视觉里的关键问题，可以说是一种很好的计算思想了，非常有必要学习一下g2o。</p><p>卡尔曼滤波在上面书单里的1和3都有提到，同时在神书<a href="https://link.zhihu.com/?target=https%3A//www.cs.unc.edu/~welch/kalman/media/pdf/maybeck_ch1.pdf">Stochastic models estimation and control</a>也有相当多的篇幅。卡尔曼滤波有好几种证明的方法，同学最好能自己学会1-2种。</p><p>多自由度的机械臂的难点在于机械臂的运动学正反解、运动学控制和动力学控制，基本是一个建模分析和数值算法实现的问题。如果你所在的学校没有一个财力雄厚的机器人实验室的话，你基本上没有机会接触到多自由度的机械臂。这时候之前学到的Simulink和就要学的Gazebo就派上用场了，你可以用Simscape里面的刚体搭一个多自由度机械臂，然后通过Simulink仿真去学习机械臂的控制；也可以用Gazebo的URDF语言写一个机械臂，然后通过Gazebo和ROS的接口去控制机械臂；也可以用ROS里面的著名工具包<a href="https://link.zhihu.com/?target=http%3A//moveit.ros.org/">MoveIt! Motion Planning Framework</a>，不过MoveIt的问题是，他只能仿真运动学，而不能仿真动力学。工业领域对多自由度的机械臂控制通常用一个叫做D-H表示法的建模工具（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters">Denavit</a>），这个东西我并不太会。我只会向同学们推荐我导师的著作<a href="http://www.cds.caltech.edu/~murray/books/MLS/pdf/mls94-complete.pdf">《A mathematical introduction to robotic manipulation》</a></p><p>有一个非常神奇的事实：《A mathematical introduction to robotic manipulation》这本机械臂控制领域的著名教材的第二章和计算机视觉领域的著名教材《An Invitation to 3-D Vision》的第二章基本是一样的，都在讲旋转表示法。这是因为所有的旋转表示法都可以归纳为一种优雅的李群结构：SO(3)群。而计算机视觉和机械臂控制都涉及到理解刚体的旋转，事实上用计算系统去观测和控制所有的刚体构成的系统，理解旋转都是很关键的问题。旋转表示法应该作为研究生阶段的一个重要学习的知识点。</p><p>李群和李代数是刚体旋转表示背后的数学理论，如果想要深挖一些，可以看这篇文章<a href="%5Bhttp://www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf%5D(https://link.zhihu.com/?target=http%3A//www.cmls.polytechnique.fr/perso/renard/Hall_Group.pdf)">An elementary introduction to groups and representations的前50页</a>。这是我自己读着觉得最好的文章，当然网上也有很多其他的介绍。</p><p>研究生阶段还要培养的一个能力是借助各种工具仿真机器人系统的能力。显然地，很多机器人系统真的造出来的话造价昂贵，需要在实际制造之前写一个比较真实的仿真系统出来测试算法。我觉得做仿真系统的能力直接衡量了机器人工程师的技术水平。</p><p>当你开始要搭一个仿真系统的时候，第一步是通过欧拉方程和牛顿方程确定刚体的运动特点，甚至要自己写刚体二阶微分方程；第二步是确定刚体之间的互联关系，设计不同类型的关节，如果有软性连接需要加入弹簧阻尼模型；第三步是确定被仿真的刚体系统会不会和外界产生碰撞或者其他形式的力，如果有的话，需要设计合适的接触力和摩擦力仿真的模型。多旋翼飞行器的仿真是很简单的，不需要考虑什么接触力。但是多自由度机械臂基本都需要仿真接触力，不和物理世界去交互的机械臂只有很小的实用意义。而能够自行运动locomotion系统，比如双足、多足机器人，则涉及到更多的接触力，多到接触力都会影响仿真系统的数值稳定性。搭建一个仿真系统需要很强的系统建模能力和数值分析的能力，虽然Simulink、Gazebo、Vrep提供了不同程度的工具简化你的工作，但是要让仿真系统能够稳定运行，必须要能深入其中的细节。有些看起来很高大上的仿真工具，比如Nvida的PhysX，在仿真的时候是忽略掉科里奥利力的，如果不理解仿真的本质，可能就会忽略这一个重要的缺陷。</p><h2 id="▌研究生二年级">▌研究生二年级</h2><p>你的学习计划接近尾声。现在你已经进入了一个很好的状态：看到一个机器人，能够很果断地分析出它用了什么传感器、执行器、计算平台大概是什么量级，他的执行机构能够承受多少力量。看到一个新的算法，能够大约判断清楚它的执行流程，在什么环节做了优化。看到一个新的没学过的知识，能够分析出它和你以前学过的什么知识有联系，你还需要再学什么才能弄明白这个知识点。</p><p>研究生二年级要深化第一年学到的那些技术和知识，要做到完整地读过四五本书，五十篇以上的论文。你已经积累了几万行代码的经验，也能熟练地谈论谁家的电机回差小，谁家的电机线性程度好。</p><p>你这个时候可以去写作一些论文，也可以开始学习一些更高级的技术和工具，比如用FPGA和GPU优化算法、魔改Linux内核、玩玩液压系统、了解更多机器学习的知识比如强化学习等等。你也可以从计算机图形学或者计算力学里面找到一些帮助你更好进行机器人仿真和系统分析的工具。由于你懂很多机器人方面的知识，你可以给学校的机器人队做指导，或者带队参加一些比较有挑战性的机器人比赛。</p><p>写到这里，我就不可能给出很多不同领域的指导了，因为随着学习的进一步深化，我自己熟悉的领域也在收缩。我只能对几个领域给出我的意见。</p><p>对视觉定位和传感器融合来说，SLAM急需新的突破，目前通过几何约束去实现loop closure看起来已经走入了死路，没法有更多的发展了，下一步可行的方向是与深度学习进行结合。具体的一些介绍可以阅读行业中大牛的一篇文章<a href="https://link.zhihu.com/?target=http%3A//www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html">http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html</a>，记述了几个业界大牛们最新的观点。传感器融合技术，目前还有很多问题可以探索，因为传感器的延时、不均匀的信号，会给定位系统造成困扰，如何去除这些干扰，需要建立比较复杂的非线性优化问题，具体可以关注香港科技大学Shaojie Shen的工作。</p><p>对于多自由度机械手和机器人的locomotion来说，这里面还有非常多可以探索的研究问题。我前面提过接触力和摩擦力很难仿真，大神告诉我现在没有任何一种工具和理论能把接触力和摩擦力正确仿真出来，因此如何在机器人系统里妥善处理对这些力的控制，就是很难的问题了。现在业界的一个前沿发展方向，也是利用机器学习技术来帮助机器人学会处理这些外力，不过人类目前最优秀的多自由度机器人系统，Berkeley的Brett机器人，叠几块积木就要用十分钟（<a href="https://link.zhihu.com/?target=http%3A//news.berkeley.edu/2015/05/21/deep-learning-robot-masters-skills-via-trial-and-error/">New ‘deep learning’ technique enables robot mastery of skills via trial and error</a>），显然还有很多提升的空间。这方面的问题同学可以关注知乎大神<a href="https://www.zhihu.com/people/70bcce80353eccd2938cbfa2ac856aab">@戴泓楷</a><a href="https://www.zhihu.com/people/0eeca981bb238839881694643181fa91">@周佳骥</a>。</p><p>最后我想再强调一遍表达能力的重要性。你可以从自己带的课程和机器人队入手，把自己这几年来学过的知识做成 PPT 讲给学生们听，然后让他们给你反馈。多做这样的练习，提升自己做演讲的能力，这将来会让你受益匪浅。</p><p>研究生二年级之后，你可以准备进机器人公司工作了，也可以根据你自己感兴趣的研究方向申请博士接着努力。由于你已经掌握了广博的知识和技能，你的职业生涯将会大有作为。</p><h2 id="▌结束语">▌结束语</h2><p>我从 2008 年展开自己的机器人生涯。那一年波士顿动力刚刚发布他们的大狗机器人，Python 还是很小众的语言，Ubuntu 8.04 还很不稳定，Chrome 还没有多少人知道。在之后的几年中我目击了深度神经网络的复兴，看到波士顿动力的机器人日渐强大，经历了 ROS 的起源和繁荣，帮助了大疆的崛起，深深为这个产业的未来感到激动。我希望这篇文章能够帮助更多的年轻人进入机器人学的海洋，为未来机器人学的继续发展贡献力量。</p><blockquote><p>原文地址：<a href="https://zhuanlan.zhihu.com/p/22266788">https://zhuanlan.zhihu.com/p/22266788</a></p><p>如有侵权，请邮件联系：<a href="haofei_ma@163.com">haofei_ma@163.com</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ROS系统基本功能的使用详解（基本指令/节点/服务/启动文件/动态参数）</title>
      <link href="/post/9187e22b.html"/>
      <url>/post/9187e22b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建工作空间">一、创建工作空间</h2><p><strong>1. 新建文件夹</strong><br>新建一个<code>catkin_ws</code>的文件夹，并在里面创建<code>src</code>子目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/dev/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws/src</span><br></pre></td></tr></table></figure><p><strong>2. 初始化工作空间</strong><br>在刚创建的src子目录中，使用如下命令创建工作空间，但此时工作空间中还没有任何功能包，只有CMakeLists.txt。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p><strong>3. 编译工作空间</strong><br>回到工作空间的顶层目录<code>catkin_ws</code>文件夹中，使用<code>catkin_make</code>命令执行编译。编译完成后使用<code>ll</code>指令可以看到生成了<code>build</code>和<code>devel</code>两个文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p><strong>4. 完成配置</strong><br>重新加载<code>setup.bash</code>文件，完成工作空间创建的最后一步配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><p>其实如果你在<code>~/.bashrc</code>中加入了此命令行，就可以通过重启终端得到同样的效果，添加命令如下，其中<code>noetic</code>是我的ros系统的版本号，如果你的版本不同，务必更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="二、创建与编译ROS功能包">二、创建与编译ROS功能包</h2><p><strong>1. 创建功能包</strong><br>功能包可以通过手动方式创建，但为了方便，通常会使用<code>catkin_create_pkg</code>命令创建功能包，此命令的格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg [package_name] [depend1] [depend2] [depend3]</span><br></pre></td></tr></table></figure><p>其中的depend依赖项包括：</p><ul><li><code>std_msgs</code>：包含常见的消息类型，表示基本数据类型和其他基本的消息构造。</li><li><code>roscpp</code>：使用C++编写ROS的各种功能。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="built_in">cd</span> ~dev/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_package std_msgs roscpp</span><br></pre></td></tr></table></figure><p><strong>2. 编译功能包</strong><br>回到<code>catkin_ws</code>文件夹下执行编译操作，如果没有报错，则说明功能包编译成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h2 id="三、ROS的基本命令">三、ROS的基本命令</h2><h3 id="3-1-节点">3.1 节点</h3><p><strong>1. rosnode指令</strong><br>rosnode工具可以打印ROS节点的相关信息，具体命令如下：</p><table><thead><tr><th>rosnode指令</th><th>作用</th><th></th></tr></thead><tbody><tr><td><code>rosnode ping NODE</code></td><td>测试节点的连通性</td><td></td></tr><tr><td><code>rosnode list</code></td><td>列出活动节点</td><td></td></tr><tr><td><code>rosnode info NODE</code></td><td>输出此节点的信息</td><td></td></tr><tr><td><code>rosnode machine</code></td><td>打印运行在特定计算机中的节点</td><td></td></tr><tr><td><code>rosnode kill NODE</code></td><td>结束节点进程</td><td></td></tr><tr><td><code>rosnode cleanup</code></td><td>将无法访问的节点的注册信息清除</td><td></td></tr></tbody></table><p><strong>2. 运行节点</strong><br>首先使用<code>roscore</code>指令启动ros程序，然后再打开一个新的终端窗口执行接下来的操作。</p><p>我们可以使用<code>rosrun</code>指令运行一个节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>节点成功运行后再次使用<code>rosnode list</code>可以看到正在运行的节点，使用<code>rosnode info /turtlesim</code>可以查看此节点的详细信息，包括发布（Publications）、订阅（Subscriptions）以及节点具有的服务（Services）等。</p><h3 id="3-2-主题">3.2 主题</h3><p><strong>1. rostopic指令</strong><br>节点可以通过发布主题和订阅主题实现数据的传输，通过主题的消息传输不需要节点直接连接，一个主题可以有多个订阅者和多个发布者。要实现主题与节点之间的交互，可以使用rostopic指令。</p><table><thead><tr><th>rostopic指令</th><th>作用</th></tr></thead><tbody><tr><td><code>rostopic bw TOPIC</code></td><td>显示主题所用的带宽</td></tr><tr><td><code>rostopic echo TOPIC</code></td><td>将主题的消息输出到屏幕</td></tr><tr><td><code>rostopic find TOPIC</code></td><td>查找主题</td></tr><tr><td><code>rostopic hz TOPIC</code></td><td>显示主题发布频率</td></tr><tr><td><code>rostopic info TOPIC</code></td><td>输出主题详细信息</td></tr><tr><td><code>rostopic list TOPIC</code></td><td>列出活动主题</td></tr><tr><td><code>rostopic pubs TOPIC</code></td><td>将数据发布到主题</td></tr><tr><td><code>rostopic type TOPIC</code></td><td>输出主题的类型</td></tr></tbody></table><p><strong>2. 发布主题</strong><br>可以通过<code>rostopic list</code>列出当前节点的主题。通过echo参数可以打印节点发出的消息，如：<code>rostopic echo /turtle1/cmd_vel</code>。</p><p>此外，我们也可以直接通过<code>rostopic pub</code>发布主题，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- <span class="string">&#x27;&#123;linear: &#123;x: 1, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 1&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231935919-ros-basic-1.png" alt=""></p><h3 id="3-3-服务">3.3 服务</h3><p><strong>1. rosservice指令</strong><br>服务是节点之间相互通信的另一种方法，服务允许节点发送请求和接受响应。可以使用rosservice指令操作服务。</p><ul><li><code>roservice args /service</code>：输出服务参数</li><li><code>rosservice call /service</code>：根据命令行参数调用服务</li><li><code>rosservice find msgtype</code>：根据服务类型查询服务</li><li><code>rosservice info /service</code>：输出服务信息</li><li><code>rosservice list</code>：列出活动服务清单</li><li><code>rosservice type /service</code>：输出服务类型</li><li><code>rosservice uri /service</code>：输出ROSRPC URI服务</li></ul><p><strong>2. 服务的使用</strong><br>使用<code>rosservice list</code>可以列出所有的服务，使用<code>rosservice call [service] [args]</code>可以调用某个服务，例如<code>rosservice call /clear</code>可以清除海龟图上的线条。</p><p>此外，使用<code>rossrv show turtlesim/Spawn</code>可以查看/spawn服务的详细参数。</p><p><img src="https://img.mahaofei.com/img/202112231935033-ros-basic-2.png" alt=""></p><p>通过这些参数就可以调用/spawn服务创建第二只海龟。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn 3 3 0.5 <span class="string">&quot;new_turtle&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231936813-ros-basic-3.png" alt=""></p><h3 id="3-4-参数服务器">3.4 参数服务器</h3><p><strong>1. rosparam指令</strong><br>参数服务器存储了所有节点都可以访问的共享数据，可以通过rosparam指令管理参数服务器。</p><table><thead><tr><th>rosparam指令</th><th>作用</th></tr></thead><tbody><tr><td><code>rosparam set parameter value</code></td><td>设置参数值</td></tr><tr><td><code>rosparam get parameter</code></td><td>获取参数值</td></tr><tr><td><code>rosparam load file</code></td><td>从文件加载参数</td></tr><tr><td><code>rosparam dump file</code></td><td>将参数保存至文件</td></tr><tr><td><code>rosparam delete parameter</code></td><td>删除参数</td></tr><tr><td><code>rosparam list</code></td><td>列出所有参数名</td></tr></tbody></table><p><strong>2. 使用参数服务器</strong><br>以小海龟程序为例，通过rosparam list列出参数列表，可以看到背景background是turtlesim节点的参数，因此我们可以通过get指令获取参数值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br><span class="line">rosparam get /turtlesim/background_g</span><br><span class="line">rosparam <span class="built_in">set</span> /turtlesim/background_g 200</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231936964-ros-basic-4.png" alt=""></p><h2 id="四、节点的创建与运行">四、节点的创建与运行</h2><p>这一部分会以一个具体实验为例，通过创建一个talker和一个listener并实现两者之间的信息交流，进而介绍创建节点的方法。</p><h3 id="4-1-创建源文件">4.1 创建源文件</h3><p>首先进入工作空间<code>~/dev/catkin_ws</code>文件夹中的功能包<code>test_package/src/</code>文件夹中，在这里创建两个cpp文件，分别作为消息的发送方和接收方。在这里我讲两个源文件分别命名<code>talker.cpp</code>和<code>listener.cpp</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//talker.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span><span class="comment">//包含ros节点的必要文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span><span class="comment">//包含要使用的消息类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);<span class="comment">//启动节点并设置名称</span></span><br><span class="line">        ros::NodeHandle n;<span class="comment">//设置节点进程的句柄</span></span><br><span class="line">        ros::Publisher chatter_pub = n.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;message&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//将节点设置成发布者，并设置主题名称为message，缓冲区1000个消息</span></span><br><span class="line">        <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//数据发送频率10HZ</span></span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">                std_msgs::String msg;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; <span class="string">&quot;I&#x27;m talker node~~~&quot;</span>;</span><br><span class="line">                msg.data = ss.<span class="built_in">str</span>();<span class="comment">//创建了一个消息变量</span></span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s&quot;</span>, msg.data.<span class="built_in">c_str</span>());<span class="comment">//屏幕输出消息信息</span></span><br><span class="line">                chatter_pub.<span class="built_in">publish</span>(msg);<span class="comment">//发布消息</span></span><br><span class="line">                ros::<span class="built_in">spinOnce</span>();<span class="comment">//如果有订阅者出现，就会更新所有主题</span></span><br><span class="line">                loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listener.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，节点每收到一条消息都会调用此函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">messageCallback</span><span class="params">(<span class="type">const</span> std_msgs::String::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;I am listener, I heard: [%s]&quot;</span>,msg-&gt;data.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;message&quot;</span>, <span class="number">1000</span>, messageCallback);</span><br><span class="line">        <span class="comment">//创建一个订阅者，从message主题获取消息，设置缓冲区1000个消息，处理消息的回调函数为messageCallback</span></span><br><span class="line">        ros::<span class="built_in">spin</span>();<span class="comment">//消息回调处理，调用后不再返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-修改CMakeLists-txt">4.2 修改CMakeLists.txt</h3><p>编辑<code>catkin_ws/src/test_package/</code>中的CMakeLists.txt，在最后加入如下的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include_directories(</span><br><span class="line">        include</span><br><span class="line">        $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 指定编译后可执行文件的名称</span><br><span class="line">add_executable(talker src/talker.cpp)</span><br><span class="line">add_executable(listener src/listener.cpp)</span><br><span class="line"># 定义目标的依赖文件</span><br><span class="line">add_dependencies(talker test_package_generate_messages_cpp)</span><br><span class="line">add_dependencies(listener test_package_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-编译节点">4.3 编译节点</h3><p>回到工作空间根目录进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>如果出现<code>The dependency target does not exist.</code>的错误，将CMakeLists.txt开头的cmake版本改为2.8.3即可。</p><p>编译完成后需要设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/ros/tr3_6/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="4-4-运行节点">4.4 运行节点</h3><p>然后开始运行节点，首先运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>然后再打开两个窗口分别运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_package example1_a</span><br><span class="line">rosrun test_package example1_b</span><br></pre></td></tr></table></figure><p>可以看到消息的接受和发送。</p><p><img src="https://img.mahaofei.com/img/202112231936146-ros-basic-5.png" alt=""></p><h2 id="五、服务的创建与使用">五、服务的创建与使用</h2><p>本节将创建两个节点，分别作为服务器和客户端，通过服务的调用实现两个节点的数据传输，并实现数字求和的功能。</p><h3 id="5-1-创建msg文件">5.1 创建msg文件</h3><p>使用服务之前，首先需要创建msg和srv文件，它们用于说明传输的数据类型和数据值。<br><strong>1. 首先创建msg文件</strong><br>在<code>test_package</code>功能包下创建<code>msg</code>文件夹，并在<code>msg</code>文件夹中创建一个新的文件<code>test_msg.msg</code>。在文件中输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">int32 num3</span><br></pre></td></tr></table></figure><p><strong>2. 编辑package.xml文件</strong><br>在<code>package.xml</code>文件中找到下面两行，取消这两行的注释<code>&lt;!-- --&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 编辑CMakeLists.txt文件</strong><br>打开功能包目录下的<code>CMakeLists.txt</code>文件。</p><p>找到<code>find_package()</code>，在其中加入<code>message_generation</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>找到如下的两段，取消注释，并将刚才创建的<code>test_message.msg</code>消息名称加入其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Generate messages in the <span class="string">&#x27;msg&#x27;</span> folder</span><br><span class="line"><span class="title function_">add_message_files</span><span class="params">(</span></span><br><span class="line"><span class="params">  FILES</span></span><br><span class="line"><span class="params">  test_msg.msg</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Generate added messages and services with any dependencies listed here</span><br><span class="line"><span class="title function_">generate_messages</span><span class="params">(</span></span><br><span class="line"><span class="params">  DEPENDENCIES</span></span><br><span class="line"><span class="params">  std_msgs</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p><strong>4. 编译测试</strong><br>进行完以上的步骤后，使用下面的命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译完成后，要检查刚才创建的msg文件是否成功编译，使用<code>rosmsg show</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosmsg show test_package/test_msg</span><br></pre></td></tr></table></figure><p>如果输出内容与<code>test_msg.msg</code>文件内的内容一致，说明编译正确。</p><h3 id="5-2-创建srv文件">5.2 创建srv文件</h3><p><strong>1. 创建srv文件</strong><br>在<code>test_package</code>功能包下创建<code>srv</code>文件夹，并在<code>srv</code>文件夹中创建一个新的文件<code>test_srv.srv</code>。在文件中输入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">int32 num3</span><br><span class="line">---</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure><p><strong>2. 编辑package.xml文件</strong><br>在创建msg文件时已经完成了package.xml文件的编辑，这里不需要额外的修改。</p><p><strong>3. 编辑CMakeLists.txt</strong><br>找到<code>catkin_package</code>，将其注释取消，并加入正确的数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES test_package</span><br><span class="line">#  CATKIN_DEPENDS roscpp std_msgs</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">  CATKIN_DEPENDS message_runtime</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>取消<code>add_service_files</code>的注释，并添加刚创建的服务文件的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Generate services in the <span class="string">&#x27;srv&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">add_service_files</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  FILES</span></span></span><br><span class="line"><span class="params"><span class="function">  test_srv.srv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p><strong>4. 编译测试</strong><br>完成上面的文件创建和修改后，使用下面的命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译完成后，要检测服务文件编译是否正确，可以使用<code>rossrv show</code>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rossrv show test_package/test_srv.srv</span><br></pre></td></tr></table></figure><p>如果打印内容与<code>test_srv.srv</code>文件内的内容一致，说明编译正确。</p><h3 id="5-3-创建-cpp源文件">5.3 创建.cpp源文件</h3><p><strong>1. 创建源文件</strong><br>在功能包文件夹中的src目录下<code>catkin_ws/test_package/src</code>，创建两个<code>.cpp</code>文件，分别为<code>server.cpp</code>和<code>client.cpp</code>，分别作为服务器和客户端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test_package/test_srv.h&quot;</span><span class="comment">//包含创建的srv文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对三个变量求和，并将计算结果发送给其他节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(test_package::test_srv::Request &amp;req, test_package::test_srv::Response &amp;res)</span></span>&#123;</span><br><span class="line">        res.sum = req.num1 + req.num2 + req.num3;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;request: num1=%ld, num2=%ld, num3=%ld&quot;</span>, (<span class="type">int</span>)req.num1, (<span class="type">int</span>)req.num2, (<span class="type">int</span>)req.num3);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">int</span>)res.sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_3_ints_server&quot;</span>);</span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        <span class="comment">//创建服务&quot;add_3_ints&quot;的服务端，并在ROS中广播</span></span><br><span class="line">        ros::ServiceServer service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;add_3_ints&quot;</span>, add);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to add 3 ints!&quot;</span>);</span><br><span class="line">        ros::<span class="built_in">spin</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test_package/test_srv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;add_3_ints_client&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;usage: add_3_ints_client num1 num2 num3&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ros::NodeHandle n;</span><br><span class="line">        <span class="comment">//以&quot;add_3_ints&quot;为名称创建客户端</span></span><br><span class="line">        ros::ServiceClient client = n.<span class="built_in">serviceClient</span>&lt;test_package::test_srv&gt;(<span class="string">&quot;add_3_ints&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建srv文件的一个实例，并在其中加入需要发送的数据值</span></span><br><span class="line">        test_package::test_srv srv;</span><br><span class="line">        srv.request.num1 = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        srv.request.num2 = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line">        srv.request.num3 = <span class="built_in">atoll</span>(argv[<span class="number">3</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用服务并发送数据，如果调用成功，服务端会返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">if</span>(client.<span class="built_in">call</span>(srv))&#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sum: %ld&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)srv.response.sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service add_3_ints&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>2. 编辑CMakeLists.txt</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(server src/server.cpp)</span><br><span class="line">add_executable(client src/client.cpp)</span><br><span class="line"></span><br><span class="line">add_dependencies(server test_package_generate_messages_cpp)</span><br><span class="line">add_dependencies(client test_package_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">target_link_libraries(client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-测试程序">5.4 测试程序</h3><p>回到<code>catkin_ws</code>工作空间中，进行编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/dev/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>编译完成后，先打开一个终端，运行<code>roscore</code>，然后再打开两个新终端窗口，分别运行如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_package server</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun test_package client 6 4 2</span><br></pre></td></tr></table></figure><p>可以看到服务端和客户端实现了消息的通信，完成了三个数字的求和计算。</p><p><img src="https://img.mahaofei.com/img/202112231937487-ros-basic-6.png" alt=""></p><h2 id="六、启动文件的配置">六、启动文件的配置</h2><p>在前面，我们已经实现了节点的创建和使用，但是每个节点都需要打开不同的命令行窗口执行，如果节点数目更多，那么启动节点将会是一件非常麻烦的事情。</p><p>通过启动文件我们可以在命令行窗口实现启动多个节点，只需要运行后缀名为<code>.launch</code>的文件即可启动多个节点。</p><h3 id="6-1-创建-launch文件">6.1 创建.launch文件</h3><p>首先在功能包内创建一个名为<code>launch</code>的文件夹，并在其中创建<code>test.launch</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line"><span class="built_in">mkdir</span> launch</span><br><span class="line"><span class="built_in">cd</span> launch</span><br><span class="line">vim test.launch</span><br></pre></td></tr></table></figure><p>在<code>test.launch</code>文件内输入如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;test_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;test_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-启动节点">6.2 启动节点</h3><p>上面编写的启动文件可以启动前文实验的<code>talker</code>和<code>listener</code>两个节点，启动命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch test_package test.launch</span><br></pre></td></tr></table></figure><p>系统会输出以下信息，说明启动成功。</p><p><img src="https://img.mahaofei.com/img/202112231937973-ros-basic-7.png" alt=""></p><p>使用<code>rosnode list</code>可以列出活动的节点，可以看到我们已经成功启动了<code>talker</code>和<code>listener</code>两个节点。</p><p><img src="https://img.mahaofei.com/img/202112231938050-ros-basic-8.png" alt=""></p><p>如果想看到两个节点传递的信息，可以使用<code>rqt_console</code></p><p><img src="https://img.mahaofei.com/img/202112231938582-ros-basic-9.png" alt=""></p><h2 id="七、动态参数的使用">七、动态参数的使用</h2><p>一般情况下，我们编写一个节点时，只能以数据初始化节点内的变量，如果我们想要改变这些变量值，可以使用主题，服务或参数服务器，但这种方式无法在线动态更新，如果listener不主动查询，我们无法知道参数是否更新。有时我们需要在线动态更新参数，这时就需要使用动态参数。</p><h3 id="7-1-创建配置文件">7.1 创建配置文件</h3><p>首先在功能包内新建一个名为<code>cfg</code>的文件夹，并在其内创建一个<code>test.cfg</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line"><span class="built_in">mkdir</span> cfg</span><br><span class="line"><span class="built_in">cd</span> cfg</span><br><span class="line">vim test.cfg</span><br></pre></td></tr></table></figure><p>在<code>test.cfg</code>内添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化ROS并导入参数生成器</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">PACKAGE = <span class="string">&quot;test_package&quot;</span></span><br><span class="line"><span class="keyword">from</span> dynamic_reconfigure.parameter_generator_catkin <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化参数生成器，通过gen我们可以添加参数</span></span><br><span class="line">gen = ParameterGenerator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入不同的参数类型并设置默认值、描述、取值范围等</span></span><br><span class="line"><span class="comment"># gen.add(name, type, level, description, default, min, max)</span></span><br><span class="line">gen.add(<span class="string">&quot;double_param&quot;</span>, double_t, <span class="number">0</span>, <span class="string">&quot;A double parameter&quot;</span>, <span class="number">.1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">gen.add(<span class="string">&quot;str_param&quot;</span>, str_t, <span class="number">0</span>, <span class="string">&quot;A string parameter&quot;</span>, <span class="string">&quot;test_default_string&quot;</span>)</span><br><span class="line">gen.add(<span class="string">&quot;int_param&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;An Integer parameter&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">gen.add(<span class="string">&quot;bool_param&quot;</span>, bool_t, <span class="number">0</span>, <span class="string">&quot;A Boolean parameter&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">size_enum = gen.enum([gen.const(<span class="string">&quot;Low&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;Low is 0&quot;</span>), gen.const(<span class="string">&quot;Medium&quot;</span>, int_t, <span class="number">1</span>, <span class="string">&quot;Medium is 1&quot;</span>), gen.const(<span class="string">&quot;High&quot;</span>, int_t, <span class="number">2</span>, <span class="string">&quot;High is 2&quot;</span>), gen.const(<span class="string">&quot;Exlarge&quot;</span>, int_t, <span class="number">3</span>, <span class="string">&quot;Exlarge is 3&quot;</span>)], <span class="string">&quot;Select from the list&quot;</span>)</span><br><span class="line"></span><br><span class="line">gen.add(<span class="string">&quot;size&quot;</span>, int_t, <span class="number">0</span>, <span class="string">&quot;Select from the list&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, edit_method=size_enum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成必要的文件并退出程序</span></span><br><span class="line">exit(gen.generate(PACKAGE, <span class="string">&quot;test_package&quot;</span>, <span class="string">&quot;test_&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于<code>test.cfg</code>是由ROS执行的可执行文件，因此我们需要改变文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x test.cfg</span><br></pre></td></tr></table></figure><h3 id="7-2-修改CMakeLists-txt添加配置文件的编译">7.2 修改CMakeLists.txt添加配置文件的编译</h3><p>打开<code>CMakeLists.txt</code>，找到<code>find_package</code>，在最后加入<code>dynamic_reconfigure</code>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">  dynamic_reconfigure</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>找到<code>generate_dynamic_reconfigure_options</code>，取消注释，并将内部的配置文件改为刚创建的配置文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## Generate dynamic reconfigure parameters in the <span class="string">&#x27;cfg&#x27;</span> <span class="function">folder</span></span><br><span class="line"><span class="function"><span class="title">generate_dynamic_reconfigure_options</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  cfg/test.cfg</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><h3 id="7-3-创建节点">7.3 创建节点</h3><p>接下来需要创建一个具有动态配置支持的新节点。</p><p>在<code>src</code>文件夹下创建一个新文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscd test_package</span><br><span class="line">vim src/dynamic_param.cpp</span><br></pre></td></tr></table></figure><p>在文件中写入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dynamic_reconfigure/server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;test_package/test_Config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数将输出参数的新值，参数名称必须与test.cfg配置文件相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(test_package::test_Config &amp;config, <span class="type">uint32_t</span> level)</span></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Reconfigure Request: %d %f %s %s %d&quot;</span>, config.int_param, config.double_param, config.str_param.<span class="built_in">c_str</span>(), config.bool_param?<span class="string">&quot;True&quot;</span>:<span class="string">&quot;False&quot;</span>, config.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">        ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_dynamic_reconfigure&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化服务器</span></span><br><span class="line">        dynamic_reconfigure::Server&lt;test_package::test_Config&gt; server;</span><br><span class="line"><span class="comment">//向服务器发送回调函数，当服务器得到重新配置请求，会调用回调函数        </span></span><br><span class="line">        dynamic_reconfigure::Server&lt;test_package::test_Config&gt;::CallbackType f;</span><br><span class="line">        f = boost::<span class="built_in">bind</span>(&amp;callback, _1, _2);</span><br><span class="line">        server.<span class="built_in">setCallback</span>(f);</span><br><span class="line"></span><br><span class="line">        ros::<span class="built_in">spin</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="7-4-修改CMakeLists-txt添加节点的编译">7.4 修改CMakeLists.txt添加节点的编译</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(dynamic_param src/dynamic_param.cpp)</span><br><span class="line"><span class="built_in">add_dependencies</span>(dynamic_param test_package_gencfg)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(dynamic_param $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-5-运行配置">7.5 运行配置</h3><p>打开三个终端命令行窗口，分别运行如下的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun test_package dynamic_param</span><br><span class="line">rosrun rqt_reconfigure rqt_reconfigure</span><br></pre></td></tr></table></figure><p>执行完成后，会看到一个<code>rqt_reconfigure</code>窗口，在这个窗口中就可以动态的配置节点的参数，并且在调整参数时，可以看到命令行打印参数的改变。<br><img src="https://img.mahaofei.com/img/202112231938492-ros-basic-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《cmake practice》总结  cmake的构建过程与基本指令</title>
      <link href="/post/4e7d4c9e.html"/>
      <url>/post/4e7d4c9e.html</url>
      
        <content type="html"><![CDATA[<h2 id="〇、基本语法规则">〇、基本语法规则</h2><h3 id="0-1-变量">0.1 变量</h3><p>  变量使用 ${VALUENAME} 方式取值，但是在IF控制语句中直接使用变量名。</p><ol><li><code>CMAKE_BINARY_DIR</code> 或 <code>PROJECT_BINARY_DIR</code> 或 <code>&lt;ProjectName&gt;_BINARY_DIR</code>：均代表编译目录。如果是内部构建，就是指工程顶层目录；如果是外部构建，就是指工程编译发生的目录。</li><li><code>CMAKE_SOURCE_DIR</code> 或 <code>PROJECT_SOURCE_DIR</code> 或 <code>&lt;ProjectName&gt;_SOURCE_DIR</code>：均代表工程顶层目录。</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：代表当前处理的 CMakeLists.txt 所在的路径。</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>：如果是内部构建，与<code>CMAKE_CURRENT_SOURCE_DIR</code>相同；如果是外部构建，则代表目标编译目录。</li><li><code>CMAKE_CURRENT_LIST_FILE</code>：这个变量所在的CMakeLists.txt的完整路径。</li><li><code>CMAKE_CURRENT_LIST_LINE</code>：这个变量所在的行。</li><li><code>CMAKE_MODULE_PATH</code>：定义cmake模块所在的路径</li><li><code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code>：分别重新定义最终结果的存放目录。</li><li><code>PROJECT_NAME</code>：项目名称</li></ol><h3 id="0-2-指令规则">0.2 指令规则</h3><p>  1. 基本语法为：指令(参数1 参数2 …)<br>  2. 参数之间使用空格或分号隔开，例如<code>ADD_EXECUTABLE(hello main.c;func.c)</code><br>  3. 指令不区分大小写，参数和变量区分大小写，但推荐全部使用大写指令<br>  4. 当文件名中含有空格时，必须使用双引号，例如<code>SET(SRC_LIST &quot;fu nc.c&quot;)</code></p><h3 id="0-3-基本构建过程">0.3 基本构建过程</h3><p>  1. 编写程序与CMakeLists.txt文件<br>  2. 建立外部编译目录：<code>mkdir build</code><br>  3. 进入外部编译目录：<code>cd build</code><br>  4. 构建工程：<code>cmake ..</code><br>  5. 实际构建：<code>make</code><br>  6. 运行程序：<code>./&lt;Executable Filename&gt;</code><br>  7. 清理工程：<code>make clean</code></p><h2 id="一、基本指令">一、基本指令</h2><h3 id="1-PROJECT指令">1. PROJECT指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROJECT(projectname [CXX] [C] [Java])</span><br><span class="line"># 例：PROJECT(HELLO)</span><br></pre></td></tr></table></figure><p>  定义工程名称，并可制订工程支持的语言，默认支持所有语言。此指令隐式的定义了两个变量 <code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCE_DIR</code>。</p><h3 id="2-SET指令">2. SET指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"># 例<span class="number">1</span>：SET(SRC_LIST main.c)</span><br><span class="line"># 例<span class="number">2</span>：SET(EXECUTABLE_OUPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br></pre></td></tr></table></figure><p>  用来显式的定义变量。<br>  在<code>ADD_EXECUTABL</code>所在的CMakeLists.txt文件中，添加如例2的语句，可以修改最终目标二进制文件输出的路径为<code>build/bin</code></p><h3 id="3-MESSAGE指令">3. MESSAGE指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">&quot;message to display&quot;</span>)</span><br><span class="line"># 例：MESSAGE(STATUS <span class="string">&quot;This is BINARY dir $&#123;HELLO_BINARY_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><p>  用于向终端输出用户定义的信息，包括三种类型</p><ul><li>SEND_ERROR：产生错误，生成过程被跳过</li><li>STATUS：输出前缀为-的信息</li><li>FATAL_ERROR：立即终止所有cmake过程</li></ul><h3 id="4-ADD-EXECUTABLE指令">4. ADD_EXECUTABLE指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_EXECUTABLE(&lt;Executable Filename&gt; $&#123;SRC_LIST&#125;)</span><br><span class="line"># 例：ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>  定义工程会生成文件名为<code>&lt;Executable Filename&gt;</code>的可执行文件，相关的源文件是SRC_LIST中定义的源文件列表。</p><h3 id="5-ADD-SUBDIRECTORY指令">5. ADD_SUBDIRECTORY指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br><span class="line"># 例：ADD_SUBDIRECTORY(src bin)</span><br></pre></td></tr></table></figure><p>  用于将子目录加入当前工程，并可以指定其二进制文件存放的位置。<code>EXCLUDE_FROM_ALL</code>含义是将此目录从编译过程中排除。（例：将src子目录加入工程，并制订编译输出路径为bin，那么编译结果都将放在<code>build/bin</code>中）</p><h3 id="6-INSTALL指令">6. INSTALL指令</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">INSTALL</span>(TARGETS targets... [EXPORT &lt;<span class="keyword">export</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br><span class="line"># 例：<span class="built_in">INSTALL</span>(FILES COPYRIGHT README DESTINATION share/doc/cmake/test)</span><br><span class="line"># 例：<span class="built_in">INSTALL</span>(PROGRAMS runprog.sh DESTINATION bin)</span><br></pre></td></tr></table></figure><p>  INSTALL指令用于安装各种类型的文件，参数中的TARGETS就是要安装的文件，可以是二进制文件、动态库、静态库。在各个CMakeLists.txt中编写好INSTALL指令后就可以开始安装了。<br>  安装的过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=&lt;Install Path&gt;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="7-ADD-DEPENDENCIES指令">7. ADD_DEPENDENCIES指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)</span><br></pre></td></tr></table></figure><p>  定义target以来的其他target，确保在本项目编译前，其他target已经被构建</p><h3 id="8-ADD-TEST与ENABLE-TESTING指令">8. ADD_TEST与ENABLE_TESTING指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD_TEST(testname Exename arg1 arg2 ...)</span><br><span class="line">ENABLE_TEST()</span><br></pre></td></tr></table></figure><p>  用于创建test目标，生成makefile后就可以通过make test进行测试了。</p><h3 id="9-EXEC-PROGRAM">9. EXEC_PROGRAM</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">EXEC_PROGRAM</span>(Executable</span><br><span class="line">[directory in which to run]</span><br><span class="line">[ARGS &lt;arguments to executable&gt;]</span><br><span class="line">[OUTPUT_VARIABLE &lt;var&gt;]</span><br><span class="line">[RETURN_VALUE &lt;var&gt;])</span><br></pre></td></tr></table></figure><p>  用于指定在特定的目录运行某个程序。</p><h2 id="三、静态库与动态库的构建与使用">三、静态库与动态库的构建与使用</h2><h3 id="3-1-静态库和动态库的构建方法">3.1 静态库和动态库的构建方法</h3><p>  1. 在工程目录下新建一个<code>lib</code>文件夹，并将其添加进工程目录中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 工程目录下的CMakeLists.txt</span><br><span class="line"><span class="title function_">PROJECT</span><span class="params">(HELLOLIB)</span></span><br><span class="line"><span class="title function_">ADD_SUBDIRECTORY</span><span class="params">(lib)</span></span><br></pre></td></tr></table></figure><p>  2. 在<code>lib</code>文件夹下创建源文件。<br>  3. 在<code>lib</code>目录下创建<code>CMakeLists.txt</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SET(LIBHELLO_SRC hello.c)</span><br><span class="line">#创建动态库</span><br><span class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">#创建静态库</span><br><span class="line">ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">#实现动态库版本号</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>)</span><br><span class="line">#安装共享库和头文件</span><br><span class="line">INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br><span class="line">INSTALL(FILES hello.h DESTINATION include/hello)</span><br></pre></td></tr></table></figure><p>  4. 安装共享库和头文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="3-2-外部共享库和头文件的使用">3.2 外部共享库和头文件的使用</h3><p>  1. 在新工程目录下创建<code>src</code>目录，并在其中编写源文件main.c<br>  2. 编写工程目录下<code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROJECT(NEWHELLO)</span><br><span class="line">ADD_SUBDIRECTORY(src)</span><br></pre></td></tr></table></figure><p>  3. 编写<code>src</code>目录下的<code>CMakeLists.txt</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ADD_EXECUTABLE(main main.c)</span><br><span class="line"># 添加头文件搜索路径</span><br><span class="line">INCLUDE_DIRECTORIES(/usr/include/hello)</span><br><span class="line"># 将目标文件链接到共享库</span><br><span class="line">TARGET_LINK_LIBRARIES(main libhello.so)</span><br><span class="line"># 或：TARGET_LINK_LIBRARIES(main hello)</span><br><span class="line"># 或链接到静态库：TARGET_LINK_LIBRARIES(main libhello.a)</span><br></pre></td></tr></table></figure><p>  4. 构建运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>参考自<a href="https://huffie.lanzoui.com/i2kKdu0fu9e">《cmake practice》</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OpenCV/C++】KNN算法识别数字的实现原理与代码详解</title>
      <link href="/post/c386d502.html"/>
      <url>/post/c386d502.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、KNN原理">一、KNN原理</h2><h3 id="1-1-KNN原理介绍">1.1 KNN原理介绍</h3><p>  KNN算法，即K最近邻算法，顾名思义其<strong>原理是当要预测一个新的值x的时候，根据离他最近的K个点大多属于什么类别来判断x属于哪个类别</strong>。</p><blockquote><p><a href="https://www.cnblogs.com/listenfwind/p/10311496.html">zzzzMing -大数据技术-深入浅出KNN算法</a></p><p><img src="https://img.mahaofei.com/img/202112231933950-opencv-knn-1.png" alt=""></p><p>  K=3时，x最近的三个图形包括两个三角形、一个圆形，因为2&gt;1，所以x更有可能是三角形。</p><p><img src="https://img.mahaofei.com/img/202112231934427-opencv-knn-2.png" alt=""></p><p>  K=5时，x最近的五个图形包括两个三角形、三个圆形，因为3&gt;2，所以x更有可能是圆形。</p></blockquote><p>  同理类比到图像识别方面，<strong>使用KNN算法前我们需要有大量的训练样本，并且知道每个样本所属的类别。</strong>（例如大量的数字图片，并且知道每个图片代表数字几）。当我们要识别数字时，本质上就是在训练样本中找与要识别的图像最接近的K个样本，然后统计出K个样本中出现最多的数字是哪个，那就是要识别的数字。</p><h3 id="1-2-KNN的关键参数">1.2 KNN的关键参数</h3><p><strong>① 寻找多少最近邻样本 - K的选择</strong></p><p>  K值决定着图像识别过程中，寻找的最近邻的图像个数，由上面的例子可以看出，选择不同的K，识别结果可能完全不同，因此K值是KNN算法中最关键的参数之一，它直接影响着模型的性能。</p><p>  K值如果过小，那么此时识别结果就会很受样本质量的影响。如果训练样本存在某些错误或噪音，而寻找最近邻样本时正好找到了这些项，那么识别结果一定是错的，而增大K值，多寻找样本，会有效降低样本噪音的影响。</p><p>  K值如果过大，假设K值等于训练样本数，那么无论要识别的图片是什么，识别结果都是样本中最多的那个类别。</p><p>  那么K值应该如何选择呢？理论上来说K值与识别准确率的关系是存在一个极值的，可以通过多次实验，根据结果选择一个最好的K值。（例如K=3时准确率72；K=5时准确率91；K=8时准确率81，那么选择K=5会是一个相对较好的选择）</p><p><strong>② 如何判断“接近”程度 - 距离的计算</strong><br>  距离计算函数一般使用曼哈顿距离或欧氏距离。</p><p>  曼哈顿距离就是样本特征每一个维度的差值之合。（对应于图像，就是两图像每个像素做差）</p><p><img src="https://img.mahaofei.com/img/202112231934104-opencv-knn-3.png" alt=""></p><p>  欧式距离是样本特征在每一个维度上差值的平方和的根。</p><p><img src="https://img.mahaofei.com/img/202112231935896-opencv-knn-4.png" alt=""></p><h2 id="二、KNN算法识别手写数字">二、KNN算法识别手写数字</h2><blockquote><p>KNN算法识别手写数字的源程序 - <a href="https://huffie.lanzoui.com/iQaVetwgsoj">点此下载</a></p></blockquote><h3 id="2-1-训练过程代码详解">2.1 训练过程代码详解</h3><p>  首先，我们要获得训练样本。OpenCV安装目录中给我们提供了手写数字的样本图片<code>opencv\sources\samples\data\digits.png</code>。这个图片中每个数字有5x100个样本，并且每个数字所占的像素均为20x20，因此可以从这个图片中提取我们需要的训练样本。</p><p>  我们按列裁剪样本图片，<strong>每裁剪一个样本，就将其添加到data中，并同时将对应的数字添加到lable中</strong>。这样一来，我们就获得了图片和数字一一对应的data和lable数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/data/digits.png&quot;</span>);</span><br><span class="line">Mat gray;</span><br><span class="line"><span class="built_in">cvtColor</span>(img, gray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> m = gray.rows / b;   <span class="comment">//原图为1000*2000</span></span><br><span class="line"><span class="type">int</span> n = gray.cols / b;   <span class="comment">//裁剪为5000个20*20的小图块</span></span><br><span class="line">Mat data, labels;   <span class="comment">//特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> offsetCol = i * b; <span class="comment">//列上的偏移量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> offsetRow = j * b;  <span class="comment">//行上的偏移量</span></span><br><span class="line">                              <span class="comment">//截取20*20的小块</span></span><br><span class="line">        Mat tmp;</span><br><span class="line">        <span class="built_in">gray</span>(<span class="built_in">Range</span>(offsetRow, offsetRow + b), <span class="built_in">Range</span>(offsetCol, offsetCol + b)).<span class="built_in">copyTo</span>(tmp);</span><br><span class="line">        <span class="comment">//reshape  0：通道不变  其他数字，表示要设置的通道数</span></span><br><span class="line">        <span class="comment">//reshape  表示矩阵行数，如果设置为0，则表示保持原有行数不变，如果设置为其他数字，表示要设置的行数</span></span><br><span class="line">        data.<span class="built_in">push_back</span>(tmp.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">//序列化后放入特征矩阵</span></span><br><span class="line">        labels.<span class="built_in">push_back</span>((<span class="type">int</span>)j / <span class="number">5</span>);  <span class="comment">//对应的标注</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  利用这个训练样本就可以创建KNN模型了。</p><p>  如果需要测试模型的识别准确度，可以从刚才获得的5000个样本中，选择前3000个样本作为训练数据，后2000个作为测试数据。用KNN模型计算测试数据的在样本中的识别正确情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">data.<span class="built_in">convertTo</span>(data, CV_32F); <span class="comment">//uchar型转换为cv_32f</span></span><br><span class="line"><span class="type">int</span> samplesNum = data.rows;</span><br><span class="line"><span class="type">int</span> trainNum = <span class="number">500</span>;</span><br><span class="line">Mat trainData, trainLabels;</span><br><span class="line">trainData = <span class="built_in">data</span>(<span class="built_in">Range</span>(<span class="number">0</span>, trainNum), Range::<span class="built_in">all</span>());   <span class="comment">//前3000个样本为训练数据</span></span><br><span class="line">trainLabels = <span class="built_in">labels</span>(<span class="built_in">Range</span>(<span class="number">0</span>, trainNum), Range::<span class="built_in">all</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用KNN算法</span></span><br><span class="line"><span class="type">int</span> K = <span class="number">5</span>;</span><br><span class="line">Ptr&lt;TrainData&gt; tData = TrainData::<span class="built_in">create</span>(trainData, ROW_SAMPLE, trainLabels);</span><br><span class="line">model = KNearest::<span class="built_in">create</span>();</span><br><span class="line">model-&gt;<span class="built_in">setDefaultK</span>(K);</span><br><span class="line">model-&gt;<span class="built_in">setIsClassifier</span>(<span class="literal">true</span>);</span><br><span class="line">model-&gt;<span class="built_in">train</span>(tData);</span><br><span class="line"><span class="comment">//预测分类</span></span><br><span class="line"><span class="type">double</span> train_hr = <span class="number">0</span>, test_hr = <span class="number">0</span>;</span><br><span class="line">Mat response;</span><br><span class="line"><span class="comment">// compute prediction error on train and test data</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; samplesNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Mat sample = data.<span class="built_in">row</span>(i);</span><br><span class="line">    <span class="type">float</span> r = model-&gt;<span class="built_in">predict</span>(sample);   <span class="comment">//对所有行进行预测</span></span><br><span class="line">                                        <span class="comment">//预测结果与原结果相比，相等为1，不等为0</span></span><br><span class="line">    r = std::<span class="built_in">abs</span>(r - labels.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(i)) &lt;= FLT_EPSILON ? <span class="number">1.f</span> : <span class="number">0.f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; trainNum)</span><br><span class="line">        train_hr += r;  <span class="comment">//累积正确数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        test_hr += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_hr /= samplesNum - trainNum;</span><br><span class="line">train_hr = trainNum &gt; <span class="number">0</span> ? train_hr / trainNum : <span class="number">1.</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;</span>,</span><br><span class="line">    train_hr * <span class="number">100.</span>, test_hr * <span class="number">100.</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-预测分类的实现过程">2.2 预测分类的实现过程</h3><p>  训练样本制作完毕后，预测分类就非常简单了，将要识别的图像读取进来，进行二值化处理，然后调整大小到与样本图片一样大（20x20）。将处理好的图片push到test中，就可以直接使用刚才创建的KNN模型进行预测了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预测分类</span></span><br><span class="line">Mat img = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/test/4.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">cvtColor</span>(img, img, COLOR_BGR2GRAY);</span><br><span class="line"><span class="comment">//threshold(src, src, 0, 255, CV_THRESH_OTSU);</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, img);</span><br><span class="line"><span class="built_in">resize</span>(img, img, <span class="built_in">Size</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line">Mat test;</span><br><span class="line">test.<span class="built_in">push_back</span>(img.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">test.<span class="built_in">convertTo</span>(test, CV_32F);</span><br><span class="line"><span class="type">int</span> result = model-&gt;<span class="built_in">predict</span>(test);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="三、KNN算法识别印刷数字">三、KNN算法识别印刷数字</h2><blockquote><p>KNN算法识别印刷数字的源程序 -<a href="https://huffie.lanzoui.com/iXh7Ktwgsvg">点此下载</a><br>  识别印刷体数字与识别手写数字的原理相同，只是训练样本有区别。这里我制作了1000张不同字体的训练样本，加载方式例如：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//训练结果不存在，重新训练</span></span><br><span class="line"><span class="type">int</span> add_image_num = <span class="number">1000</span>;   <span class="comment">//扩充训练数据的文件夹个数</span></span><br><span class="line"><span class="type">int</span> filenum = <span class="number">0</span>;</span><br><span class="line">Mat data, labels;   <span class="comment">//特征矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; add_image_num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Mat addimg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/knn_test/images/data/&quot;</span> + <span class="built_in">to_string</span>(filenum) + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">    <span class="built_in">cvtColor</span>(addimg, addimg, COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//threshold(src, src, 0, 255, CV_THRESH_OTSU);</span></span><br><span class="line">    <span class="built_in">resize</span>(addimg, addimg, <span class="built_in">Size</span>(<span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    data.<span class="built_in">push_back</span>(addimg.<span class="built_in">reshape</span>(<span class="number">0</span>, <span class="number">1</span>));  <span class="comment">//序列化后放入特征矩阵</span></span><br><span class="line">    labels.<span class="built_in">push_back</span>((<span class="type">int</span>)((filenum++) % <span class="number">10</span>));  <span class="comment">//对应的标注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  训练样本加载完毕后，使用与上面相同的方式创建KNN模型，然后进行预测识别即可。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解opencv摄像头数字识别</title>
      <link href="/post/985d20fe.html"/>
      <url>/post/985d20fe.html</url>
      
        <content type="html"><![CDATA[<p>  本文的目标是实现<strong>识别摄像头图像中的数字</strong>。实际应用场景包括<strong>车牌号识别</strong>，部分竞赛的<strong>A4纸打印数字识别</strong>。项目实现结果如下，完整工程文件<a href="https://download.csdn.net/download/weixin_44543463/22349857">点此下载</a>：</p><p><img src="https://img.mahaofei.com/img/202112231926851-digital-recognize-1.png" alt=""></p><blockquote><p>  <strong>摄像头数字识别分为两个步骤：</strong></p><ol><li>提取图像中的ROI区域，如截取车牌的矩形区域，或截取A4纸的图像。</li><li>对ROI区域进行数字识别。</li></ol></blockquote><p>  数字识别相对来说较为简单，先介绍数字识别的方法和原理。</p><h2 id="一、数字识别的两种方式">一、数字识别的两种方式</h2><h3 id="1-1-轮廓提取法">1.1 轮廓提取法</h3><p>  实现思路为对ROI区域进行轮廓提取，然后将所有找到的轮廓与模板逐一匹配识别，相似度大于所设阈值，可视为识别成功。</p><p>  寻找轮廓所使用的函数为findContours()，利用此函数将所有寻找到的轮廓保存在contours中，然后使用循环画出包围每一个轮廓的最小矩形。</p><p>  利用每一个小矩形，提取图像中的每一个轮廓图像，将其与模板做差，如果差值越小，说明像素越接近，相似程度越高，以此来实现数字匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮廓提取主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取一张图像，转换为灰度图并进行二值化处理</span></span><br><span class="line">    Mat srcImage = <span class="built_in">imread</span>(<span class="string">&quot;E://Program//OpenCV//vcworkspaces//ogr_test//images//txt.jpg&quot;</span>);  <span class="comment">//读取图片</span></span><br><span class="line">    Mat dstImage, grayImage, binImage;</span><br><span class="line">    srcImage.<span class="built_in">copyTo</span>(dstImage);  <span class="comment">//将读取到的图片，深拷贝为dstImage</span></span><br><span class="line">    <span class="built_in">cvtColor</span>(srcImage, grayImage, COLOR_BGR2GRAY);                  <span class="comment">//转换灰度图</span></span><br><span class="line">    <span class="built_in">threshold</span>(grayImage, binImage, <span class="number">100</span>, <span class="number">255</span>, cv::THRESH_BINARY_INV);     <span class="comment">//转换二值图，设置阈值，高于100认为255</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找轮廓</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;  <span class="comment">//定义轮廓和层次结构</span></span><br><span class="line">    vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">    <span class="built_in">findContours</span>(binImage, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_NONE); <span class="comment">//寻找轮廓</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt;::iterator It;</span><br><span class="line">    Rect a4rect[<span class="number">15</span>];<span class="comment">//假设最多不会超过15个轮廓</span></span><br><span class="line"><span class="keyword">for</span> (It = contours_rec.<span class="built_in">begin</span>(); It &lt; contours_rec.<span class="built_in">end</span>(); It++) &#123;                        <span class="comment">//画出包围数字的最小矩形</span></span><br><span class="line">a4rect[i].x = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().x;</span><br><span class="line">a4rect[i].y = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().y;</span><br><span class="line">a4rect[i].width = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">br</span>().x - (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().x;</span><br><span class="line">a4rect[i].height = (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">br</span>().y - (<span class="type">float</span>)<span class="built_in">boundingRect</span>(*It).<span class="built_in">tl</span>().y;</span><br><span class="line"><span class="keyword">if</span> ((a4rect[i].height &gt; <span class="number">80</span>) &amp;&amp; (a4rect[i].width &gt; <span class="number">50</span>) &amp;&amp; (a4rect[i].height &lt; <span class="number">300</span>) &amp;&amp; (a4rect[i].width &lt; <span class="number">300</span>)) &#123;</span><br><span class="line"><span class="built_in">rectangle</span>(dstImage, a4rect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//在原图像中用红框画出识别到的各轮廓</span></span><br><span class="line"><span class="built_in">rectangle</span>(binImage, a4rect[i], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;dstImage&quot;</span>, dstImage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将图像轮廓逐一与模板匹配</span></span><br><span class="line">Mat num[<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> matchingNum = <span class="number">0</span>;<span class="comment">//匹配到的数字</span></span><br><span class="line"><span class="type">int</span> matchingRate = <span class="number">0</span>;<span class="comment">//相似率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="built_in">a4binImg</span>(a4rect[j]).<span class="built_in">copyTo</span>(num[j]);<span class="comment">//提取包围数字的矩形区域至num[j]</span></span><br><span class="line">        <span class="built_in">imgMatch</span>(num[j], matchingRate, matchingNum);<span class="comment">//数字匹配</span></span><br><span class="line">        <span class="keyword">if</span> (matchingRate &lt; <span class="number">400000</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; matchingNum &lt;&lt; <span class="string">&quot;\t匹配率：&quot;</span> &lt;&lt;  matchingRate &lt;&lt; endl;</span><br><span class="line"><span class="comment">//imwrite(to_string(matchingNum) + &quot;.jpg&quot;, num[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  两图像相减之前，需要先制作一张模板，你可以自己在记事本里敲0-9的数字，截图，使用上面的函数imwrite出来一份模板。也可以到我的<a href="https://github.com/HuffieMa/digital_recongize/tree/master/images">github中下载</a>，其中0.jpg-9.jpg就是模板文件。</p><p><img src="https://img.mahaofei.com/img/202112231927793-digital-recognize-2.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有像素点和，用于求两图像相减后所得图像的所有像素之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getPixelSum</span><span class="params">(Mat&amp; image)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; image.rows; row++) &#123;</span><br><span class="line">uchar* current_pixel = image.<span class="built_in">ptr</span>&lt;uchar&gt;(row);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; image.cols; col++) &#123;</span><br><span class="line">a += *current_pixel++;<span class="comment">//指针遍历像素点反转颜色</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板匹配函数，两图像做差</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">imgMatch</span><span class="params">(Mat&amp; image, <span class="type">int</span>&amp; rate, <span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">Mat imgSub;</span><br><span class="line"><span class="type">double</span> min = <span class="number">10e6</span>;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line">rate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">Mat templatimg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/OGR/images/&quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot;.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line"><span class="built_in">resize</span>(image, image, <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">48</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);<span class="comment">//将两图像大小调至相同</span></span><br><span class="line"><span class="built_in">resize</span>(templatimg, templatimg, <span class="built_in">Size</span>(<span class="number">32</span>, <span class="number">48</span>), <span class="number">0</span>, <span class="number">0</span>, cv::INTER_LINEAR);</span><br><span class="line"><span class="built_in">absdiff</span>(templatimg, image, imgSub);</span><br><span class="line">rate = <span class="built_in">getPixelSum</span>(imgSub);</span><br><span class="line"><span class="keyword">if</span> (rate &lt; min) &#123;</span><br><span class="line">min = rate;</span><br><span class="line">num = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-行列扫描法">1.2 行列扫描法</h3><p>  此方法主要参考<a href="https://blog.csdn.net/LTG01/article/details/50492556">opencv 数字识别详细教程</a>这篇文章，在此感谢LTG01大佬的无私分享。</p><p>  <br>  <strong>基本过程为：</strong></p><ol><li>将图像二值化处理，使数字部分为白色，其余部分为黑色。</li><li>对一个图像先<strong>逐行扫描求和</strong>，如果第一行像素和为0，则继续向下扫描，直到碰到像素和不为0的行，将行数记下来，此为数字的顶部。</li><li>继续向下扫描，此时会从上到下逐渐扫描数字所在的每一行，当行像素和再次为0时，再将行数记录下来，代表已经到了数字的底部，将顶部与底部之间的区域截取出来。</li><li>，对截取出来的图像进行<strong>逐列扫描求和</strong>，过程同上，记录出数字的左右列号，根据左右列号即可从刚才截取出的图像中，取出包含数字的最小图像。</li><li>利用此最小图像与模板匹配。</li></ol><p><img src="https://img.mahaofei.com/img/202112231928486-digital-recognize-3.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取图像并进行二值化处理</span></span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/ogr_test/images/txt.jpg&quot;</span>,IMREAD_GRAYSCALE);</span><br><span class="line">    Mat grayImage;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">    <span class="built_in">threshold</span>(src, grayImage, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY_INV);     <span class="comment">//转换二值图，设置阈值，高于50认为255</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;grayimg&quot;</span>, grayImage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行行列扫描</span></span><br><span class="line">    Mat leftImg, rightImg, topImg, bottomImg;</span><br><span class="line">    <span class="type">int</span> topRes = <span class="built_in">cutTop</span>(grayImage, topImg, bottomImg);<span class="comment">//对二值图像逐行扫描，获得行像素之和&gt;0的部分topImg，以及剩余部分bottomImg</span></span><br><span class="line">    <span class="type">int</span> matchNum = <span class="number">-1</span>, matchRate = <span class="number">10e6</span>;</span><br><span class="line"><span class="keyword">while</span> (topRes == <span class="number">0</span>)<span class="comment">//当仍存在行像素和&gt;0的部分时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> leftRes = <span class="built_in">cutLeft</span>(topImg, leftImg, rightImg);<span class="comment">//对行像素之和&gt;0的部分topImg逐列扫描，获得列像素之和&gt;0的部分leftImg，以及剩余部分rightImg</span></span><br><span class="line">        <span class="keyword">while</span> (leftRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">imgMatch</span>(leftImg, matchNum, matchRate);<span class="comment">//数字识别</span></span><br><span class="line"><span class="comment">//getSubtract(topImg);</span></span><br><span class="line">            <span class="built_in">imshow</span>(<span class="string">&quot;num&quot;</span>, leftImg);</span><br><span class="line">            <span class="keyword">if</span> (matchRate &lt; <span class="number">300000</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;识别数字：&quot;</span> &lt;&lt; matchNum &lt;&lt; <span class="string">&quot;\t\t匹配度：&quot;</span> &lt;&lt; matchRate &lt;&lt; endl;</span><br><span class="line">                <span class="comment">//imwrite(to_string(matchingNum) + &quot;.jpg&quot;, num[j]);</span></span><br><span class="line">            &#125;</span><br><span class="line">Mat srcTmp = rightImg.<span class="built_in">clone</span>();</span><br><span class="line">            leftRes = <span class="built_in">cutLeft</span>(srcTmp, leftImg, rightImg);<span class="comment">//对剩余部分rightImg继续逐列扫描</span></span><br><span class="line">        &#125;</span><br><span class="line">        Mat srcTmp = bottomImg.<span class="built_in">clone</span>();</span><br><span class="line">        topRes = <span class="built_in">cutTop</span>(srcTmp, topImg, bottomImg);<span class="comment">//对剩余部分bottomImg继续逐行扫描</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  有关扫描法识别数字的完整代码见我的<a href="https://github.com/HuffieMa/digital_recongize/tree/scan">Github的scan分支</a>。</p><h2 id="二、提取图像中的ROI区域">二、提取图像中的ROI区域</h2><p>  提取ROI区域的步骤如下：</p><ol><li>读取摄像头每一帧图像</li><li>对图像进行二值化处理</li><li>对图像进行形态学处理</li><li>设置限制条件寻找目标区域，并框选（这一步是重点）</li></ol><h3 id="2-1-读取摄像头图像">2.1 读取摄像头图像</h3><p>  摄像头的读取原理在之前的文章中已有介绍<a href="https://blog.csdn.net/weixin_44543463/article/details/119054844">《摄像头视频的读取与存储》</a>。主要使用函数为 <code>capture.read()</code>，此函数用于捕获视频的每一帧，并返回刚刚捕获的帧。示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类，打开电脑默认摄像头传参0，如果有外置摄像头参数为1</span></span><br><span class="line">    <span class="type">int</span> frame_width = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH);<span class="comment">//获取摄像头的宽、高、帧数、FPS</span></span><br><span class="line">    <span class="type">int</span> frame_height = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line">    Mat frame;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">        capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line">        <span class="comment">//flip(frame, frame, 1);//将读取的视频左右反转</span></span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//每次循环显示一帧图像，frame就是每帧图像</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">333</span>);<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    capture.<span class="built_in">release</span>();<span class="comment">//释放视频</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231928575-digital-recognize-4.png" alt=""></p><h3 id="2-2-对图像进行二值化处理">2.2 对图像进行二值化处理</h3><p>  通过每个像素的颜色分量将图片进行二值化。正常曝光情况下<strong>A4纸的BGR均为215左右</strong>，<strong>车牌的颜色信息大约为B=138，G=63，R=23</strong>。但是在不同环境下颜色信息可能会有偏差，因此需要将条件在一定程度上放宽，再通过其他一些条件来准确查找目标区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图像二值化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryProc</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pixelB, pixelG, pixelR;  <span class="comment">//记录各通道值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> DifMax = <span class="number">40</span>;             <span class="comment">//基于颜色区分的阈值设置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> WhiteMax = <span class="number">50</span>;   <span class="comment">//判断白色</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> B = <span class="number">215</span>, G = <span class="number">215</span>, R = <span class="number">215</span>; <span class="comment">//各通道的阈值设定，针对与A4纸</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; image.rows; i++)   <span class="comment">//通过颜色分量将图片进行二值化处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; image.cols; j++)</span><br><span class="line">&#123;</span><br><span class="line">pixelB = image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]; <span class="comment">//获取图片各个通道的值</span></span><br><span class="line">pixelG = image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">pixelR = image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">abs</span>(B - pixelB) &lt; DifMax) &amp;&amp; (<span class="built_in">abs</span>(G - pixelG) &lt; DifMax) &amp;&amp; (<span class="built_in">abs</span>(R - pixelR) &lt; DifMax) &amp;&amp; <span class="built_in">abs</span>(pixelB - pixelG) &lt; WhiteMax &amp;&amp; <span class="built_in">abs</span>(pixelG - pixelR) &lt; WhiteMax &amp;&amp; <span class="built_in">abs</span>(pixelB - pixelR) &lt; WhiteMax)</span><br><span class="line">&#123;                                           <span class="comment">//将各个通道的值和各个通道阈值进行比较</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">255</span>;     <span class="comment">//符合颜色阈值范围内的设置成白色</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">0</span>;        <span class="comment">//不符合颜色阈值范围内的设置为黑色</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231928141-digital-recognize-5.png" alt=""></p><h3 id="2-3-形态学处理">2.3 形态学处理</h3><p>  可以看出二值画处理后已经比较明显完整的显示出A4纸区域，但是仍然存在一些噪点，此时进行形态学处理，以消除这些噪点干扰。对图像<strong>先膨胀再腐蚀</strong>，可以填充细小空间，连接临近物体和平滑边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形态学处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">morphTreat</span><span class="params">(Mat&amp; binImg)</span> </span>&#123;</span><br><span class="line">Mat BinOriImg;     <span class="comment">//形态学处理结果图像</span></span><br><span class="line">Mat element = <span class="built_in">getStructuringElement</span>(MORPH_RECT, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">//设置形态学处理窗的大小</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(binImg, binImg, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);     <span class="comment">//进行多次膨胀操作</span></span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">dilate</span>(binImg, binImg, element);</span><br><span class="line"></span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);      <span class="comment">//进行多次腐蚀操作</span></span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="built_in">erode</span>(binImg, binImg, element);</span><br><span class="line"><span class="comment">//imshow(&quot;形态学处理后&quot;, BinOriImg);        //显示形态学处理之后的图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(binImg, binImg, CV_BGR2GRAY);   <span class="comment">//将形态学处理之后的图像转化为灰度图像</span></span><br><span class="line"><span class="built_in">threshold</span>(binImg, binImg, <span class="number">100</span>, <span class="number">255</span>, THRESH_BINARY); <span class="comment">//灰度图像二值化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  矩形窗的大小与膨胀腐蚀的次数会影响处理结果，处理完的结果大致如下。</p><p><img src="https://img.mahaofei.com/img/202112231929044-digital-recognize-6.png" alt=""></p><h3 id="2-4-设置限制条件寻找目标区域">2.4 设置限制条件寻找目标区域</h3><p>  经过形态学处理，图像中已经可以明显看到A4纸所在的区域，但是图像中仍然不可避免存在其他与A4纸颜色接近的物体，在这里也会显示为白色。<strong>这时就需要我们根据A4纸区域的特点设置限制条件，从这些白色区域中找到代表A4纸所在的区域。</strong></p><p>  在这里我使用的限制条件主要有以下几个：</p><ol><li>矩形面积在一定范围内</li><li>长宽比A4纸为1.414，一定程度放宽后作为限制条件</li><li>短边长度在一定范围内</li></ol><p>  首先寻找图像中的轮廓，利用轮廓面积初步判断，对轮廓面积符合条件的进一步获取其外接矩形。计算此矩形的各个参数（顶点坐标、长宽、面积、倾斜角度等），然后根据限制条件对此矩形进行判别。<br>  如果矩形区域符合条件，那么就需要将其截取出来，并根据先前计算的倾斜角度将A4纸图像摆正，便于后续对其中的数字进行识别。旋转图像的函数需要一些数学知识，旋转前后的图像的长宽有一定函数关系。（h’、w’为旋转后图像高、宽）</p><p><img src="https://img.mahaofei.com/img/202112231929478-digital-recognize-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231930121-digital-recognize-8.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图像旋转</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotateProc</span><span class="params">(Mat&amp; image, <span class="type">double</span> angle)</span> </span>&#123;</span><br><span class="line">Mat M;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line">M = <span class="built_in">getRotationMatrix2D</span>(<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), angle, <span class="number">1.0</span>);<span class="comment">//定义变换矩阵M</span></span><br><span class="line"><span class="type">double</span> cos = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//求cos值</span></span><br><span class="line"><span class="type">double</span> sin = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//求sin值</span></span><br><span class="line"><span class="type">int</span> nw = <span class="built_in">abs</span>(cos * w - sin * h) / <span class="built_in">abs</span>(cos * cos - sin * sin);<span class="comment">//计算新的长、宽</span></span><br><span class="line"><span class="type">int</span> nh = <span class="built_in">abs</span>(cos * h - sin * w) / <span class="built_in">abs</span>(cos * cos - sin * sin);</span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) += (nw / <span class="number">2</span> - w / <span class="number">2</span>);<span class="comment">//计算新的中心</span></span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) += (nh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">warpAffine</span>(image, image, M, <span class="built_in">Size</span>(nw, nh), INTER_LINEAR, <span class="number">0</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//imshow(&quot;Rotation&quot;, dst);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************** 提取A4纸区域并识别数字 *****************************/</span></span><br><span class="line"><span class="type">double</span> length, area, rectArea;     <span class="comment">//定义轮廓周长、面积、外界矩形面积</span></span><br><span class="line"><span class="type">double</span> long2Short = <span class="number">0.0</span>;           <span class="comment">//长边/短边</span></span><br><span class="line">Rect rect;           <span class="comment">//外界矩形</span></span><br><span class="line">RotatedRect box;  <span class="comment">//外接矩形</span></span><br><span class="line">CvPoint2D32f pt[<span class="number">4</span>];    <span class="comment">//矩形定点变量</span></span><br><span class="line">Mat pts;    <span class="comment">//矩形定点变量</span></span><br><span class="line"><span class="type">double</span> axisLong = <span class="number">0.0</span>, axisShort = <span class="number">0.0</span>;<span class="comment">//矩形的长边和短边</span></span><br><span class="line"><span class="type">double</span> Length;     <span class="comment">//中间变量</span></span><br><span class="line"><span class="type">float</span>  angle = <span class="number">0</span>;      <span class="comment">//记录倾斜角度</span></span><br><span class="line"><span class="type">double</span> location_x = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> location_y = <span class="number">0.0</span>;</span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">vector&lt;Vec4i&gt;hierarchy;</span><br><span class="line"><span class="built_in">findContours</span>(binImg, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//绘制轮廓的最小外接矩形  </span></span><br><span class="line">length = <span class="built_in">arcLength</span>(contours[i], <span class="literal">true</span>);      <span class="comment">//获取轮廓周长</span></span><br><span class="line">area = <span class="built_in">contourArea</span>(contours[i]);<span class="comment">//获取轮廓面积</span></span><br><span class="line"><span class="keyword">if</span> (area &gt; <span class="number">2000</span> &amp;&amp; area &lt; <span class="number">300000</span>)<span class="comment">//矩形区域面积大小判断，符合条件的继续</span></span><br><span class="line">&#123;</span><br><span class="line">rect = <span class="built_in">boundingRect</span>(contours[i]);<span class="comment">//计算矩形边界</span></span><br><span class="line">box = <span class="built_in">minAreaRect</span>(contours[i]);<span class="comment">//获取轮廓的矩形</span></span><br><span class="line"><span class="built_in">boxPoints</span>(box, pts);<span class="comment">//获取矩形四个顶点坐标（左上，右上，右下，左下）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; pts.rows; row++) &#123;<span class="comment">//从列表中依次读出四个顶点坐标</span></span><br><span class="line">pt[row].x = pts.<span class="built_in">at</span>&lt;uchar&gt;(row, <span class="number">0</span>);</span><br><span class="line">pt[row].y = pts.<span class="built_in">at</span>&lt;uchar&gt;(row, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">angle = box.angle;              <span class="comment">//得到倾斜角度</span></span><br><span class="line"><span class="keyword">if</span> (angle &gt; <span class="number">45</span>) &#123;<span class="comment">//对于逆时针偏转的情况，倾斜角度为-(90-angle)</span></span><br><span class="line">angle = angle - <span class="number">90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axisLong = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pt[<span class="number">1</span>].x - pt[<span class="number">0</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(pt[<span class="number">1</span>].y - pt[<span class="number">0</span>].y, <span class="number">2</span>));  <span class="comment">//计算长轴（勾股定理）</span></span><br><span class="line">axisShort = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pt[<span class="number">2</span>].x - pt[<span class="number">1</span>].x, <span class="number">2</span>) + <span class="built_in">pow</span>(pt[<span class="number">2</span>].y - pt[<span class="number">1</span>].y, <span class="number">2</span>)); <span class="comment">//计算短轴（勾股定理）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (axisShort &gt; axisLong)<span class="comment">//如果短轴大于长轴，交换数据</span></span><br><span class="line">&#123;</span><br><span class="line">Length = axisLong;</span><br><span class="line">axisLong = axisShort;</span><br><span class="line">axisShort = Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rectArea = axisLong * axisShort;<span class="comment">//计算矩形的实际面积</span></span><br><span class="line"></span><br><span class="line">long2Short = axisLong / axisShort;<span class="comment">//计算长宽比</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 长宽比A4纸为1.414，利用长宽比、矩形面积和短边长度作为限制条件</span></span><br><span class="line"><span class="keyword">if</span> (long2Short &gt; <span class="number">1</span> &amp;&amp; long2Short &lt; <span class="number">1.8</span>  &amp;&amp; rectArea &gt; <span class="number">5000</span> &amp;&amp; rectArea &lt; <span class="number">300000</span> &amp;&amp; axisShort &gt; <span class="number">50</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">rectangle</span>(frame, rect, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//在摄像头图像中画出矩形区域</span></span><br><span class="line"><span class="keyword">if</span> (rect.width &gt; <span class="number">100</span> &amp;&amp; rect.height &gt; <span class="number">100</span> &amp;&amp; axisShort&gt;<span class="number">100</span>) &#123;<span class="comment">//缩小矩形范围，便于数字识别</span></span><br><span class="line">rect.x += <span class="number">40</span>;</span><br><span class="line">rect.y += <span class="number">40</span>;</span><br><span class="line">rect.width -= <span class="number">40</span>;</span><br><span class="line">rect.height -= <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//显示摄像头拍摄画面</span></span><br><span class="line">location_x = rect.x + rect.width / <span class="number">2</span>;<span class="comment">//获得矩形中心坐标，即A4纸中心坐标</span></span><br><span class="line">location_y = rect.y + rect.height / <span class="number">2</span>;</span><br><span class="line">Mat a4Img = <span class="built_in">frame</span>(rect);<span class="comment">//提取A4纸区域</span></span><br><span class="line">Mat a4binImg;</span><br><span class="line"><span class="built_in">cvtColor</span>(a4Img, a4binImg, CV_BGR2GRAY);   <span class="comment">//将A4纸区域转化为灰度图像</span></span><br><span class="line"><span class="built_in">threshold</span>(a4binImg, a4binImg, <span class="number">120</span>, <span class="number">255</span>, THRESH_BINARY); <span class="comment">//灰度图像二值化</span></span><br><span class="line"><span class="built_in">colorReverse</span>(a4binImg);<span class="comment">//颜色反转</span></span><br><span class="line"><span class="built_in">rotateProc</span>(a4binImg, angle);<span class="comment">//根据前所计算角度，对图像进行旋转，保证数字水平存在</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;A4&quot;</span>, a4binImg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************  数字识别方法  ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所获得的a4binImg就是经过二值化处理后的A4纸区域</span></span><br><span class="line"><span class="comment">//使用上面介绍的数字识别方法即可级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231933401-digital-recognize-9.gif" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231933798-digital-recognize-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加Follow me on CSDN效果</title>
      <link href="/post/666fc0fa.html"/>
      <url>/post/666fc0fa.html</url>
      
        <content type="html"><![CDATA[<p>  <a href="http://huffie.cn/">http://huffie.cn/</a>这是我的博客，可以在此查看效果。</p><h3 id="简介">简介</h3><p>  效果图如下（右上角）：</p><p><img src="https://img.mahaofei.com/img/202112231924025-fellowme-csdn-1.png" alt=""></p><p>  网络上比较多的是Fork me on Github效果，其实要实现Follow me on CSDN原理是一样的。</p><p>  只需要将想要的效果图片下载下来ps一下，然后再上传到某个图床（或者说上传到CSDN），就可以得到此图片的url，替换到代码中即可。如下是我制作的两张图片，需要的小伙伴直接拿。（源代码见文末）</p><p><img src="https://img-blog.csdnimg.cn/abe3797b7d77419b81ecc02dd1bf8c34.png" alt=""><br><img src="https://img-blog.csdnimg.cn/1f8e1ef9be9f4f7db01fe3a2d57829de.png" alt=""><br>  更多的效果图片可以在<a href="https://github.blog/2008-12-19-github-ribbons/">项目地址</a>下载，想要其他效果的自己p一下就可以了。</p><h3 id="实现方法">实现方法</h3><p>粘贴复制如下的代码到<code>themes\hexo-theme-next\layout\_layout.njk</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面 如图)，并把href改为你的csdn主页</p><p>黑色版本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Follow me on CSDN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">width</span>=<span class="string">&quot;149&quot;</span> <span class="attr">height</span>=<span class="string">&quot;149&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 0; right: 0; border: 0;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img-blog.csdnimg.cn/abe3797b7d77419b81ecc02dd1bf8c34.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;attachment-full size-full&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Fork me on GitHub&quot;</span> <span class="attr">data-recalc-dims</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>白色版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Follow me on CSDN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">width</span>=<span class="string">&quot;149&quot;</span> <span class="attr">height</span>=<span class="string">&quot;149&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 0; right: 0; border: 0;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img-blog.csdnimg.cn/1f8e1ef9be9f4f7db01fe3a2d57829de.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;attachment-full size-full&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Fork me on GitHub&quot;</span> <span class="attr">data-recalc-dims</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231925595-fellowme-csdn-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+next的侧边栏背景与字体颜色设置方法</title>
      <link href="/post/f8e8e418.html"/>
      <url>/post/f8e8e418.html</url>
      
        <content type="html"><![CDATA[<p>  由于next主题经过了几次更新，查阅了许多资料都说要修改<font color="red"> custom.styl </font>这个配置文件，但是我的主题内没有此文件，经过翻阅大量的资料，终于找到了侧边栏的配置文件位置。</p><p>  对于<font color="red"> Muse </font>和<font color="red"> Mist</font>主题，其侧边栏的配置文件为<code>Hexo\themes\hexo-theme-next\source\css\_schemes\Muse\_sidebar.styl</code>。</p><p>  对于<font color="red"> Pisces</font>和<font color="red"> Gemini</font>主题，其侧边栏的配置文件为<code>Hexo\themes\hexo-theme-next\source\css\_schemes\Pisces\_sidebar.styl</code>。</p><p>  在此配置文件中，可以找到<font color="red"> .sidebar</font>，修改其内部的属性参数即可实现<strong>设置侧边栏背景图片和字体颜色</strong>的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.<span class="property">sidebar</span> &#123;</span><br><span class="line">  <span class="comment">//设置背景图片，图片放在Hexo\themes\hexo-theme-next\source\images目录下</span></span><br><span class="line">  <span class="attr">background</span>:<span class="title function_">url</span>(<span class="regexp">/images/</span>sidebar-bg.<span class="property">jpg</span>);</span><br><span class="line">  background-<span class="attr">size</span>: cover;</span><br><span class="line">  background-<span class="attr">position</span>:center;</span><br><span class="line">  background-<span class="attr">repeat</span>:no-repeat;</span><br><span class="line">  <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (not hexo-<span class="title function_">config</span>(<span class="string">&#x27;back2top.sidebar&#x27;</span>)) &#123;</span><br><span class="line">    box-<span class="attr">shadow</span>: inset <span class="number">0</span> 2px 6px black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">position</span>: fixed;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attr">transition</span>: all $transition-ease-out;</span><br><span class="line">  <span class="attr">width</span>: $sidebar-desktop;</span><br><span class="line">  z-<span class="attr">index</span>: $zindex-<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  a &#123;</span><br><span class="line">    <span class="comment">//设置文字颜色</span></span><br><span class="line">border-bottom-<span class="attr">color</span>: #<span class="variable constant_">FFFFFF</span>;</span><br><span class="line"><span class="attr">color</span>: #<span class="variable constant_">FFFFFF</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">  border-bottom-<span class="attr">color</span>: $FFFFFF;</span><br><span class="line">  <span class="attr">color</span>: #<span class="variable constant_">FFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231923871-hexo-sidebar-1.png" alt=""></p><p>  另外，侧边栏中头像下方的作者姓名和描述的字体颜色，可以在根目录下的站点配置文件中<code>_config.yml</code>中修改。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Half_A</span> <span class="string">Studio</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Huffie&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="comment"># 例如设置白色字体的description</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&lt;font</span> <span class="string">color=&quot;#FFFFFF&quot;&gt;Done</span> <span class="string">is</span> <span class="string">better</span> <span class="string">than</span> <span class="string">perfect.&lt;/font&gt;</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">Control</span> <span class="string">Robot</span> <span class="string">Programming</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Huffie</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>设置完成后效果如下：</p><p><img src="https://img.mahaofei.com/img/202112231924723-hexo-sidebar-2.png" alt=""></p><p><a href="http://huffie.cn/">http://huffie.cn/</a>这是我的博客，可以在此查看效果。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo为文章设置目录与标签的方法</title>
      <link href="/post/c30fb19e.html"/>
      <url>/post/c30fb19e.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建目录页">1. 创建目录页</h3><p>  在网站根目录下执行以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>  <font color='red'> Hexo\source</font> 目录中会生成一个<font color='red'> categories </font>文件夹，文件夹内有一个<font color='red'> <a href="http://index.md">index.md</a> </font>文件，打开此文件，将其中的<font color='red'> type</font> 修改为<font color='red'> categories</font> 即可。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h3 id="2-创建标签页">2. 创建标签页</h3><p>  创建标签页与创建目录页方法相同。在网站根目录下执行以下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>  <font color='red'> Hexo\source</font> 目录中会生成一个<font color='red'> tags</font>文件夹，文件夹内也有一个<font color='red'> <a href="http://index.md">index.md</a> </font>文件，打开此文件，将其中的<font color='red'> type</font> 修改为<font color='red'> tags</font> 即可。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-08-16 10:27:28</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><h3 id="3-为文章设置目录与标签">3. 为文章设置目录与标签**</h3><p>  在<font color='red'> Hexo\source_posts</font> 目录中创建.md文件即新建了一篇博客，在文章的开头部分添加如下代码</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 这里是文章的标题</span><br><span class="line">date: 这里是发表时间，如：2021-08-15 08:15:16</span><br><span class="line">description: 这里填写摘要。也可以把摘要这一段删去，在文章中想要截断的地方加入&lt;!--more--&gt;，这样在首页就只显示开头到截断的内容，而不会显示全文</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">-</span> 分类</span><br><span class="line"><span class="bullet">-</span> 子分类</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> 标签1</span><br><span class="line"><span class="section">- 标签2</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中next主题的个性化配置</title>
      <link href="/post/27cabb08.html"/>
      <url>/post/27cabb08.html</url>
      
        <content type="html"><![CDATA[<p>  Hexo与next主题的安装方法，网上有很多教程，这里不再赘述，直接开始next主题的配置方法。<br>  在Hexo中一般有两个_config.yml文件，一个在根目录下，我称之为网站配置文件，一个在主题目录中，我称之为主题配置文件。</p><h2 id="一、主题常用配置">一、主题常用配置</h2><p>next 主题的配置一般是指修改主题配置文件 <font color='red'> Hexo\themes\hexo-theme-next_config.yml </font> 文件。<br>在_config.yml 中可以修改许多常见的设置。</p><h3 id="1-更换主题（Scheme-Setting）">1. 更换主题（Scheme Setting）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主题</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 黑暗模式</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-菜单设置（Menu-Settings）">2. 菜单设置（Menu Settings）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用/禁用：菜单图标和项目徽章</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="3-侧边栏设置（Sidebar-Settings）">3. 侧边栏设置（Sidebar Settings）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 侧边栏位置</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 手动定义侧边栏宽度。如果注释，将默认为</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">240</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏显示 (只对 Muse | Mist 主题生效), 可用的变量有:</span></span><br><span class="line">  <span class="comment">#  - post    自动展开（默认值）</span></span><br><span class="line">  <span class="comment">#  - always  在所有页面显示侧边栏</span></span><br><span class="line">  <span class="comment">#  - hide    仅在单击侧边栏切换图标时展开</span></span><br><span class="line">  <span class="comment">#  - remove  完全删除侧边栏，包括侧边栏切换</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 侧边栏填充像素</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="comment"># 侧边栏与顶部菜单栏的偏移量(像素) (只对 Pisces | Gemini 主题生效).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">b2t:</span> <span class="literal">true</span> <span class="comment">#是否提供一键置顶</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span> <span class="comment">#是否显示当前阅读进度</span></span><br></pre></td></tr></table></figure><h3 id="4-侧边栏头像（Sidebar-Avatar）">4. 侧边栏头像（Sidebar Avatar）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 侧边栏头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># 替换默认图像并在这里设置头像的url</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># 如果为true，头像将以圆圈显示</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># 如果为true，鼠标悬停在头像上时，头像将会旋转</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="5-社交链接（Social-Links）">5. 社交链接（Social Links）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">CSDN:</span> <span class="string">https://blog.csdn.net/weixin_44543463</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-cuttlefish</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/HuffieMa</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:haofei_ma@163.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/huffie65380272</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure><blockquote><p>这里可能会需要自定义图标，可以在<a href="https://fontawesome.com/v5.15/icons">fontawesome</a>网站中搜索想要的图标，然后在这里使用 <code>fa fa-图标名称</code> 或  <code>fab fa-图标名称</code> 来调取所需要的图标。（如 <code>fab fa-cuttlefish</code> 、 <code>fa fa-grip-lines-vertical</code>）</p></blockquote><h2 id="二、网站配置">二、网站配置</h2><p>网站配置一般是指修改配置文件 <font color='red'> Hexo_config.yml </font> 文件。<br>在_config.yml 中可以修改许多常见的设置。</p><h3 id="1-网站基本配置（网站名称、作者名字、中英文切换）">1. 网站基本配置（网站名称、作者名字、中英文切换）</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Half_A</span> <span class="string">Studio</span>  <span class="comment">#浏览器顶部标签栏的显示</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Huffie</span><span class="comment">#侧边栏中的作者名字</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">#讲此处修改为zh-CN即可切换中文</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-主页显示文章数">2. 主页显示文章数</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure><h2 id="三、翻译设置">三、翻译设置</h2><p>网站切换为中文后，我们发现一些翻译不太符合我的要求，比如它把每一篇博客叫做日志，如果想修改，可以打开翻译配置文件 <font color='red'> Hexo\themes\hexo-theme-next\languages\zh-CN.yml</font> 进行修改</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】人脸检测的实现方法</title>
      <link href="/post/30c67132.html"/>
      <url>/post/30c67132.html</url>
      
        <content type="html"><![CDATA[<p>  <strong>本文的目标是实现对于摄像头内的人脸进行实时检测。</strong></p><h2 id="一、文件准备">一、文件准备</h2><p>  首先需要到opencv的<a href="https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector">github网站</a>上下载<code>opencv/samples/dnn/face_detector/</code>中所有的文件，并覆盖到本地的<code>...\opencv\sources\samples\dnn\face_detector</code>这个目录中。然后用记事本打开weights.meta4文件，下载其中两个url对应的文件。</p><p>  由于下载过程可能需要<strong>科学上网</strong>，因此我将所需要的文件打包 <a href="https://download.csdn.net/download/weixin_44543463/21068345">face_detector.zip</a>，大家将压缩包解压后将里面所有文件复制到本地目录<code>...\opencv\sources\samples\dnn\face_detector</code>中即可。</p><p><img src="https://img.mahaofei.com/img/202112231922222-opencv-notes15-1.png" alt=""></p><h2 id="二、程序设计">二、程序设计</h2><h3 id="2-1-主要函数">2.1 主要函数</h3><p><strong>1. blobFromImage()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">blobFromImage</span>(InputArray image, <span class="comment">//输入神经网络进行处理的图片</span></span><br><span class="line">  <span class="type">double</span>  scalefactor=<span class="number">1.0</span>, <span class="comment">//对像素值进行一定的尺度缩放</span></span><br><span class="line">      <span class="type">const</span>  Size&amp; size = <span class="built_in">Size</span>(),<span class="comment">//神经网络在训练的时候要求输入的图片尺寸</span></span><br><span class="line">  <span class="type">const</span>  Scalar&amp; mean = <span class="built_in">Scalar</span>(), <span class="comment">//需要将图片整体减去的平均值</span></span><br><span class="line">  <span class="type">bool</span> swapRB = <span class="literal">false</span>, <span class="comment">//BGR的顺序是否要交换，如果为true则为RGB</span></span><br><span class="line">  <span class="type">bool</span>  crop = <span class="literal">false</span>,<span class="comment">//是否需要裁剪</span></span><br><span class="line">  <span class="type">int</span>  ddepth = CV_32F</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>2. net.forward()</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat probs = net.forward(); </span><br></pre></td></tr></table></figure><p>其输出有四个维度</p><ul><li>第一个维度：所有图像中每个图像的index</li><li>第二个维度：当前图像是第几个批次batchid，第几张图imageid</li><li>第三个维度：框的个数；</li><li>第四个维度：每个框有七个值，前两个是类型和dst，第三个是置信度，最后四个是矩形的左上角和右下角</li></ul><h3 id="2-2-示例程序-2">2.2 示例程序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::faceDetector_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建VideoCapture类</span></span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">Mat frame;</span><br><span class="line"></span><br><span class="line"><span class="comment">////读取模型和配置参数</span></span><br><span class="line">std::string root_dir = <span class="string">&quot;E:/Program/OpenCV/opencv/sources/samples/dnn/face_detector/&quot;</span>;</span><br><span class="line">dnn::Net net = dnn::<span class="built_in">readNetFromTensorflow</span>(root_dir+<span class="string">&quot;opencv_face_detector_uint8.pb&quot;</span>, root_dir+<span class="string">&quot;opencv_face_detector.pbtxt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实时检测</span></span><br><span class="line"><span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line"><span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line"><span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line">Mat blob = dnn::<span class="built_in">blobFromImage</span>(frame, <span class="number">1.0</span>, <span class="built_in">Size</span>(<span class="number">300</span>, <span class="number">300</span>), <span class="built_in">Scalar</span>(<span class="number">104</span>, <span class="number">177</span>, <span class="number">123</span>), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//scalefactor=1.0表示图像的色彩保存在0到255之间；size和mean参数保存在models.yml中。两个false表示不需要rgb的转换也不需要剪切</span></span><br><span class="line">net.<span class="built_in">setInput</span>(blob);<span class="comment">//将数据读入模型中。（blob结果是NCHW。N是个数，C通道数，H高度，W宽度）</span></span><br><span class="line">Mat probs = net.forward(); </span><br><span class="line"><span class="comment">//输出的第一个纬度所有图像中，每个图像的index；</span></span><br><span class="line"><span class="comment">//第二纬度，当前图像是第几个批次batchid，第几张图imageid；</span></span><br><span class="line"><span class="comment">//第三个纬度表示有多少个框；</span></span><br><span class="line"><span class="comment">//第四个纬度，每个框有七个值，前两个是类型和dst，第三个是置信度，最后四个是矩形的左上角和右上角</span></span><br><span class="line"><span class="function">Mat <span class="title">detectionMat</span><span class="params">(probs.size[<span class="number">2</span>], probs.size[<span class="number">3</span>], CV_32F, probs.ptr())</span></span>;</span><br><span class="line"><span class="comment">//框的个数为行数，每个框的七个值为每行的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; detectionMat.rows; i++) &#123;</span><br><span class="line"><span class="type">float</span> confidence = detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">2</span>);<span class="comment">//取出第三个值：置信度</span></span><br><span class="line"><span class="keyword">if</span> (confidence &gt; <span class="number">0.6</span>) &#123;</span><br><span class="line"><span class="comment">//再乘以图像的宽度或高度才能变为真实的</span></span><br><span class="line"><span class="type">int</span> x1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">3</span>) * frame.cols);</span><br><span class="line"><span class="type">int</span> y1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">4</span>) * frame.rows);</span><br><span class="line"><span class="type">int</span> x2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">5</span>) * frame.cols);</span><br><span class="line"><span class="type">int</span> y2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(detectionMat.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i, <span class="number">6</span>) * frame.rows);</span><br><span class="line"><span class="function">Rect <span class="title">box</span><span class="params">(x1, y1, x2 - x1, y2 - y1)</span></span>;</span><br><span class="line"><span class="built_in">rectangle</span>(frame, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Face Dector&quot;</span>, frame);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">33</span>);<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231922622-opencv-notes15-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像的模糊处理方法（均值滤波与高斯模糊）</title>
      <link href="/post/f5f492d2.html"/>
      <url>/post/f5f492d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、均值滤波">一、均值滤波</h2><h3 id="1-1-均值滤波的原理">1.1 均值滤波的原理</h3><p>  均值滤波用到的是图像卷积原理。由下图所示，卷积核为三阶单位矩阵时，进行均值滤波，原图像的每个三阶子矩阵都会求其均值，并将均值赋给中间的元素。</p><p>  以左上角为例：<br>（$A_{11}$·1+$A_{12}$·1+$A_{13}$·1+<br> $A_{21}$·1+$A_{22}$·1+$A_{23}$·1+<br> $A_{31}$·1+$A_{32}$·1+$A_{33}$·1 ）/  9 -&gt;$A_{22}$</p><p><img src="https://img.mahaofei.com/img/202112231920160-opencv-notes14-1.png" alt=""></p><h3 id="1-2-OpenCV中的均值滤波">1.2 OpenCV中的均值滤波</h3><p>  在OpenCV/C++中，提供了blur函数用于实现上述的均值滤波操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">blur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size ksize,<span class="comment">//卷积核Size类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">Point anchor=Point(<span class="number">-1</span>,<span class="number">-1</span>),<span class="comment">//Point类型的锚点（-1表示锚点在核中心）</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> borderType=BORDER_DEFAULT<span class="comment">//边界模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>  其中 <code>Size(w, h)</code>来表示内核的大小，w 为像素宽度，h为像素高度。</p><p>  根据上面的 <code>blur()</code> 函数的定义，可以写出均值滤波的测试代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::blur_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">blur</span>(image, dst, <span class="built_in">Size</span>(<span class="number">10</span>, <span class="number">10</span>), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Blur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  下图是卷积核为 <code>Size(10,10)</code> 的效果。</p><p><img src="https://img.mahaofei.com/img/202112231920250-opencv-notes14-2.png" alt=""></p><p>  下图为卷积核为 <code>Size(1,15)</code> 的效果。</p><p><img src="https://img.mahaofei.com/img/202112231921584-opencv-notes14-3.png" alt=""></p><h2 id="二、高斯模糊">二、高斯模糊</h2><p>  有时候我们并不希望模糊处理时卷积核的系数都一样。而高斯模糊就是用于解决这类问题的一个方法。高斯模糊产生的系数在中心最大，离中心越远系数越小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::GaussianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图片，可以使是任意通道数，该函数对通道是独立处理的</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图片</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size ksize,<span class="comment">//高斯内核大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> sigmaX,<span class="comment">//高斯内核在X方向的标准偏差</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> sigmaY,<span class="comment">//高斯内核在Y方向的标准偏差</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> borderType<span class="comment">//判断图像边界的模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>ksize</code>的行数和列数允许不相同，但必须是正奇数。<br>如果sigmaY为0，他将和sigmaX的值相同，如果他们都为0，那么他们由ksize的行数列数计算得出。</p><p>示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::gaussianBlur_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">GaussianBlur</span>(image, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">15</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;GaussianBlur&quot;</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231921544-opencv-notes14-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】什么是图像的直方图？如何获取直方图？</title>
      <link href="/post/b524babf.html"/>
      <url>/post/b524babf.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是图像直方图">一、什么是图像直方图</h2><p>  图像直方图是图像像素值的统计学特征、计算代价较小，具有图像平移、旋转、缩放不变性等众多优点，广泛地应用于图像处理的各个领域，特别是灰度图像的阈值分割、基于颜色的图像检索以及图像分类、反向投影跟踪。常见的分为灰度直方图和颜色直方图。</p><p>  简单来说，图像对计算机来说就是一个一个像素点的数值，像素值又有一定的取值范围，所以我们可以统计出来这些像素值出现的频率，统计结果就是一个直方图。</p><p>  对图像进行平移、旋转等操作后，图像的直方图信息不会变化。因此即使两张图像的直方图完全一样，图像有可能不是同一个图像。</p><h2 id="二、如何计算图像直方图">二、如何计算图像直方图</h2><p>OpenCV中提供了如下的函数用于计算图像的直方图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcHist</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Mat* images,<span class="comment">//源图像组</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nimages,<span class="comment">//源图像组图像个数</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">int</span>* channels,<span class="comment">//图像信道</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArray mask,<span class="comment">//可选的掩码，如果不为空，则必须是8-bit数组，而且大小和原图像相同</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray hist,<span class="comment">//输出直方图数组</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> dims,<span class="comment">//处理直方图的维数正数</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">int</span>* histSize,<span class="comment">//每一维的直方图的尺寸大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">float</span>** ranges,<span class="comment">//直方图每一维的数据大小范围</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> uniform=<span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> accumulate=<span class="literal">false</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::histShow_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 三通道分离，用于分别绘制三个通道的直方图</span></span><br><span class="line">std::vector&lt;Mat&gt; bgr_plane;</span><br><span class="line"><span class="built_in">split</span>(image, bgr_plane);</span><br><span class="line"><span class="comment">// 定义参数变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> channels[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bins[<span class="number">1</span>] = &#123; <span class="number">256</span> &#125;;</span><br><span class="line"><span class="type">float</span> hranges[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">255</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span>* ranges[<span class="number">1</span>] = &#123; hranges &#125;;</span><br><span class="line">Mat b_hist;</span><br><span class="line">Mat g_hist;</span><br><span class="line">Mat r_hist;</span><br><span class="line"><span class="comment">// 计算Blue, Green, Red通道的直方图</span></span><br><span class="line"><span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), b_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"><span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), g_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"><span class="built_in">calcHist</span>(&amp;bgr_plane[<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">Mat</span>(), r_hist, <span class="number">1</span>, bins, ranges);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示直方图</span></span><br><span class="line"><span class="type">int</span> hist_w = <span class="number">512</span>;</span><br><span class="line"><span class="type">int</span> hist_h = <span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> bin_w = <span class="built_in">cvRound</span>((<span class="type">double</span>)hist_w / bins[<span class="number">0</span>]);</span><br><span class="line">Mat histImage = Mat::<span class="built_in">zeros</span>(hist_h, hist_w, CV_8UC3);</span><br><span class="line"><span class="comment">// 归一化直方图数据</span></span><br><span class="line"><span class="built_in">normalize</span>(b_hist, b_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"><span class="built_in">normalize</span>(g_hist, g_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"><span class="built_in">normalize</span>(r_hist, r_hist, <span class="number">0</span>, histImage.rows, NORM_MINMAX, <span class="number">-1</span>, <span class="built_in">Mat</span>());</span><br><span class="line"><span class="comment">// 绘制直方图曲线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; bins[<span class="number">0</span>]; i++) &#123;</span><br><span class="line"><span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line"><span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(b_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line"><span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(g_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">line</span>(histImage, <span class="built_in">Point</span>(bin_w * (i - <span class="number">1</span>), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i - <span class="number">1</span>))),</span><br><span class="line"><span class="built_in">Point</span>(bin_w * (i), hist_h - <span class="built_in">cvRound</span>(r_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(i))), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示直方图</span></span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Histogram Demo&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Histogram Demo&quot;</span>, histImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231918681-opencv-notes13-1.png" alt=""></p><h2 id="三、二维直方图">三、二维直方图</h2><p>  我们知道RGB虽然有三个通道，但转到HSV色彩空间中只有H和S表示颜色，而V表示亮度。因此要表示一个图像的颜色只有两个维度H和S，因此可以组成一个平面的直方图形式。</p><p>  二维直方图的计算调用函数与一维直方图相同，使用的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::histShow2_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 2D 直方图</span></span><br><span class="line">Mat hsv, hs_hist;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//RGB转HSV</span></span><br><span class="line"><span class="type">int</span> hbins = <span class="number">30</span>, sbins = <span class="number">32</span>;<span class="comment">//设置二维直方图的直方个数</span></span><br><span class="line"><span class="type">int</span> hist_bins[] = &#123; hbins, sbins &#125;;</span><br><span class="line"><span class="type">float</span> h_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;<span class="comment">//H：0-180</span></span><br><span class="line"><span class="type">float</span> s_range[] = &#123; <span class="number">0</span>, <span class="number">256</span> &#125;;<span class="comment">//S：0-256</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span>* hs_ranges[] = &#123; h_range, s_range &#125;;</span><br><span class="line"><span class="type">int</span> hs_channels[] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;<span class="comment">//选择通道0和通道1</span></span><br><span class="line"><span class="built_in">calcHist</span>(&amp;hsv, <span class="number">1</span>, hs_channels, <span class="built_in">Mat</span>(), hs_hist, <span class="number">2</span>, hist_bins, hs_ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行归一化</span></span><br><span class="line"><span class="type">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">minMaxLoc</span>(hs_hist, <span class="number">0</span>, &amp;maxVal, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//找到最大值</span></span><br><span class="line"><span class="type">int</span> scale = <span class="number">10</span>;</span><br><span class="line">Mat hist2d_image = Mat::<span class="built_in">zeros</span>(sbins * scale, hbins * scale, CV_8UC3);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; hbins; h++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; sbins; s++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> binVal = hs_hist.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(h, s);</span><br><span class="line"><span class="type">int</span> intensity = <span class="built_in">cvRound</span>(binVal * <span class="number">255</span> / maxVal);</span><br><span class="line"><span class="built_in">rectangle</span>(hist2d_image, <span class="built_in">Point</span>(h * scale, s * scale),</span><br><span class="line"><span class="built_in">Point</span>((h + <span class="number">1</span>) * scale - <span class="number">1</span>, (s + <span class="number">1</span>) * scale - <span class="number">1</span>),</span><br><span class="line">Scalar::<span class="built_in">all</span>(intensity),</span><br><span class="line"><span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">applyColorMap</span>(hist2d_image, hist2d_image, COLORMAP_JET);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;H-S Histogram&quot;</span>, hist2d_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231919044-opencv-notes13-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】摄像头视频的读取与存储</title>
      <link href="/post/4182df17.html"/>
      <url>/post/4182df17.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-如何读取摄像头">1. 如何读取摄像头</h3><p>  在图像处理中，读取视频并进行处理是必不可少的操作，在OpenCV中，读取摄像头的视频所用到的主要函数为 <code>capture()</code>。<br>  ①VideoCapture类的构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>()</span><br><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">const</span> string&amp; filename)</span><br><span class="line">VideoCapture::<span class="built_in">VideoCapture</span>(<span class="type">int</span> device)</span><br></pre></td></tr></table></figure><p>  ②读取摄像头视频的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">VideoCapture&amp; capture.<span class="built_in">read</span>(Mat&amp; image)</span><br></pre></td></tr></table></figure><p>此函数用于捕获视频的每一帧，并返回刚刚捕获的帧如果没有视频帧被捕获，返回false。<br>  <br>  读取摄像头视频的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::video_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类</span></span><br><span class="line">Mat frame;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line"><span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line"><span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//每次循环显示一帧图像</span></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">10</span>);<span class="comment">//两帧读取的间隔时间</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">capture.<span class="built_in">release</span>();<span class="comment">//释放视频</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-视频的存储">2. 视频的存储</h3><p>  视频的存储所用到的是 <code>VideoWriter </code> 类。所使用到的类属性和方法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> string&amp; filename,<span class="comment">//文件路径</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> fourcc,<span class="comment">//四个字符用来表示压缩帧的codec</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> fps,<span class="comment">//被创建视频流的帧率</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size frameSize,<span class="comment">//视频流的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> isColor=<span class="literal">true</span><span class="comment">//True则每一帧为彩色图，否则为灰度图</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中fourcc编码格式可选参数如下：</p><table><thead><tr><th>参数</th><th>编码格式</th></tr></thead><tbody><tr><td>CV_FOURCC(‘P’,‘I’,‘M’,‘1’)</td><td>MPEG-1</td></tr><tr><td>CV_FOURCC(‘M’,‘J’,‘P’,‘G’)</td><td>motion-jpeg</td></tr><tr><td>CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’)</td><td>MPEG-4.2</td></tr><tr><td>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘3’)</td><td>MPEG-4.3</td></tr><tr><td>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘X’)</td><td>MPEG-4</td></tr><tr><td>CV_FOURCC(‘U’, ‘2’, ‘6’, ‘3’)</td><td>H263</td></tr><tr><td>CV_FOURCC(‘I’, ‘2’, ‘6’, ‘3’)</td><td>H263I</td></tr><tr><td>CV_FOURCC(‘F’, ‘L’, ‘V’, ‘1’)</td><td>FLV1</td></tr><tr><td>-1</td><td>弹出一个编码器选择框</td></tr></tbody></table><p>保存摄像头视频的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::video_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//创建VideoCapture类</span></span><br><span class="line"><span class="type">int</span> frame_width = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_WIDTH);<span class="comment">//获取摄像头的宽、高</span></span><br><span class="line"><span class="type">int</span> frame_height = capture.<span class="built_in">get</span>(CAP_PROP_FRAME_HEIGHT);</span><br><span class="line"></span><br><span class="line">VideoWriter writer;<span class="comment">//创建VideoWriter类</span></span><br><span class="line"><span class="type">int</span> fourcc = writer.<span class="built_in">fourcc</span>(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;X&#x27;</span>);<span class="comment">//定义编码格式</span></span><br><span class="line">writer.<span class="built_in">open</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/test.mp4&quot;</span>, fourcc, <span class="number">30</span>, <span class="built_in">Size</span>(frame_width, frame_height), <span class="literal">true</span>);<span class="comment">//保存视频</span></span><br><span class="line"></span><br><span class="line">Mat frame;<span class="comment">//定义Mat对象用于存储每一帧数据</span></span><br><span class="line"><span class="keyword">while</span> (capture.<span class="built_in">isOpened</span>()) &#123;</span><br><span class="line">capture.<span class="built_in">read</span>(frame);<span class="comment">//逐帧读取视频</span></span><br><span class="line"><span class="built_in">flip</span>(frame, frame, <span class="number">1</span>);<span class="comment">//将读取的视频左右反转</span></span><br><span class="line"><span class="keyword">if</span> (frame.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果视频结束或未检测到摄像头则跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">writer.<span class="built_in">write</span>(frame);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Video&quot;</span>, frame);<span class="comment">//每次循环显示一帧图像</span></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">33</span>);<span class="comment">//两帧读取的间隔时间 1s/30fps=33ms</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">//按下q键退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">capture.<span class="built_in">release</span>();<span class="comment">//释放视频</span></span><br><span class="line">writer.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231918357-opencv-notes12-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像变换方法总结（放缩、翻转、旋转）</title>
      <link href="/post/81619dc7.html"/>
      <url>/post/81619dc7.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、图像放缩Resize">一、图像放缩Resize</h3><p><strong>1.1 基本知识</strong><br>  图像放缩用到了许多插值方法，常见的差值算法有线性插值、立方差值、双立方差值、采样放缩算法等等。<br>  所使用的API为 <code>resize()</code>，函数的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">Size dsize,<span class="comment">//输出尺寸</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> fx=<span class="number">0</span>,<span class="comment">//水平缩放比例</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> fy=<span class="number">0</span>,<span class="comment">//垂直缩放比例</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> interpolation=INTER_LINEAR<span class="comment">//插值方式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>其中dsize为0时，fx和fy均不可为零；fx和fy为0时，输出图像按dsize输出</li><li>interpolation内插方式有以下四种：<ul><li>CV_INTER_NEAREST  最邻近插值点法</li><li>CV_INTER_LINEAR   双线性插值法</li><li>CV_INTER_AREA    邻域像素再取样插补</li><li>CV_INTER_CUBIC     双立方插补，4*4大小的补点</li></ul></li></ul></blockquote><p><strong>1.2 示例程序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::resize_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat zoomin, zoomout;<span class="comment">//定义输出图像</span></span><br><span class="line"><span class="type">int</span> h = image.rows;<span class="comment">//获取原图像的宽高</span></span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="built_in">resize</span>(image, zoomin, <span class="built_in">Size</span>(w * <span class="number">1.5</span>, h * <span class="number">1.5</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);<span class="comment">//图像放大1.5倍</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;zoomin&quot;</span>, zoomin);</span><br><span class="line"><span class="built_in">resize</span>(image, zoomout, <span class="built_in">Size</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, INTER_LINEAR);<span class="comment">//图像缩小2倍</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;zoomout&quot;</span>, zoomout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231913042-opencv-notes11-1.png" alt=""></p><h3 id="二、图像翻转flip">二、图像翻转flip</h3><p>  图像反转就是将图像左右或上下反转镜像。所用到的函数是 <code>flip()</code>，函数的定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::flip</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">cv::InputArray src, <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv::OutputArray dst, <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flipCode = <span class="number">0</span><span class="comment">// &gt;0: 沿y轴翻转, 0: 沿x轴翻转, &lt;0: x、y轴同时翻转</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>测试程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::flip_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">flip</span>(image, dst, <span class="number">0</span>);<span class="comment">//上下翻转</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;上下翻转&quot;</span>, dst);</span><br><span class="line"><span class="built_in">flip</span>(image, dst, <span class="number">1</span>);<span class="comment">//左右翻转</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;左右翻转&quot;</span>, dst);</span><br><span class="line"><span class="built_in">flip</span>(image, dst, <span class="number">-1</span>);<span class="comment">//对角线翻转（180°旋转）</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;对角线翻转（180°旋转）&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231916215-opencv-notes11-2.png" alt=""></p><h3 id="三、图像旋转warpAffine">三、图像旋转warpAffine</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::warpAffine</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArray M,<span class="comment">//变换矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">Sizedsize,<span class="comment">//输出图像大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>flags = INTER_LINEAR,<span class="comment">//插值方式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> borderMode = BORDER_CONSTANT,<span class="comment">//图像边缘像素模式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar&amp;borderValue = Scalar()<span class="comment">//边界填充值</span></span></span></span><br></pre></td></tr></table></figure><p>其中M变换矩阵可以通过如下函数获得，旋转矩阵的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M=cv2.<span class="built_in">getRotationMatrix2D</span>(center, angle, scale)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231916903-opencv-notes11-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231917769-opencv-notes11-4.png" alt=""></p><p>由于旋转之后，图像的大小会发生变化，因此需要重新计算图像的长宽，计算方法可以参考下图：</p><p><img src="https://img.mahaofei.com/img/202112231917211-opencv-notes11-5.png" alt=""></p><p>图像旋转的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::rotate_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst, M;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line">M = <span class="built_in">getRotationMatrix2D</span>(<span class="built_in">Point2f</span>(w / <span class="number">2</span>, h / <span class="number">2</span>), <span class="number">45</span>, <span class="number">1.0</span>);<span class="comment">//定义变换矩阵M</span></span><br><span class="line"><span class="type">double</span> cos = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//求cos值</span></span><br><span class="line"><span class="type">double</span> sin = <span class="built_in">abs</span>(M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//求sin值</span></span><br><span class="line"><span class="type">int</span> nw = cos * w + sin * h;<span class="comment">//计算新的长、宽</span></span><br><span class="line"><span class="type">int</span> nh = sin * w + cos * h;</span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, <span class="number">2</span>) += (nw / <span class="number">2</span> - w / <span class="number">2</span>);<span class="comment">//计算新的中心</span></span><br><span class="line">M.<span class="built_in">at</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2</span>) += (nh / <span class="number">2</span> - h / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">warpAffine</span>(image, dst, M, <span class="built_in">Size</span>(nw,nh), INTER_LINEAR,<span class="number">0</span>,<span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Rotation&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231917301-opencv-notes11-6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像像素数据类型的转换与归一</title>
      <link href="/post/f4ce9480.html"/>
      <url>/post/f4ce9480.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是归一化">一、什么是归一化</h2><p>  归一化就是要把需要处理的数据经过处理后（通过某种算法）限制在一定范围的之内。为了后面数据处理的方便，其次是保证程序运行时收敛加快。<br>  归一化的目的，是使得没有可比性的数据变得具有可比性，同时又保持相比较的两个数据之间的相对关系，如大小关系；或是为了作图，原来很难在一张图上作出来，归一化后就可以很方便的给出图上的相对位置等。</p><h2 id="二、归一化的方式">二、归一化的方式</h2><h3 id="2-1-基本API">2.1 基本API</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">normalize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArray dst, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> alpha = <span class="number">1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> beta = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> norm_type = NORM_L2, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> dtype = <span class="number">-1</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">InputArray mask = noArray()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>src</td><td>输入数组</td></tr><tr><td>dst</td><td>输出数组</td></tr><tr><td>alpha</td><td>归一化最小值</td></tr><tr><td>beta</td><td>归一化最大值</td></tr><tr><td>norm_type</td><td>归一化的类型</td></tr><tr><td>dtype</td><td>负数时输出数组的type与输入数组的type相同</td></tr><tr><td>mask</td><td>指示函数是否仅仅对指定的元素进行操作</td></tr></tbody></table><p>其中norm_type有以下几种类型：</p><ul><li>NORM_MINMAX:数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。</li><li>NORM_INF:此类型的定义没有查到，根据OpenCV 1的对应项，可能是归一化数组的C-范数(绝对值的最大值)</li><li>NORM_L1 :  归一化数组的L1-范数(绝对值的和)</li><li>NORM_L2: 归一化数组的(欧几里德)L2-范数</li></ul><h3 id="2-2-示例程序">2.2 示例程序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::normalize_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst;</span><br><span class="line">std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;<span class="comment">//CV_8UC3</span></span><br><span class="line">image.<span class="built_in">convertTo</span>(image, CV_32F);<span class="comment">//像素数据转换为浮点数数据</span></span><br><span class="line">std::cout &lt;&lt; image.<span class="built_in">type</span>() &lt;&lt; std::endl;<span class="comment">//CV_32FC3</span></span><br><span class="line"><span class="built_in">normalize</span>(image, dst, <span class="number">0</span>, <span class="number">1.0</span>, NORM_MINMAX);<span class="comment">//归一化</span></span><br><span class="line">std::cout &lt;&lt; dst.<span class="built_in">type</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Normalize&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】在OpenCV中响应键盘与鼠标操作</title>
      <link href="/post/a8150f32.html"/>
      <url>/post/a8150f32.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、键盘的响应">一、键盘的响应</h2><h3 id="1-1-基本知识-2">1.1 基本知识</h3><p>  按键的读取只需要使用waitKey()函数就可以实现，十分简单。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> waitKey（<span class="type">int</span> delay=<span class="number">0</span>）</span><br></pre></td></tr></table></figure><p>  <strong>函数参数为延时时间(ms)</strong>。<br>  delay&lt;=0时，等待时间无限长，按下按键时函数结束，<strong>返回按键的键值</strong>。·<br>  delay&gt;0时，等待delay毫秒按键响应，等待时间结束仍未按下按键则返回-1。</p><blockquote><p>本人opencv4+vs2019实操时，没有按键时不返回值，有按键按下时返回对应键值。</p></blockquote><h3 id="1-2-确定按键响应值">1.2 确定按键响应值</h3><p>  使用如下代码，可以测试自己的键盘对应的键值是多少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::key_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; k &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231911085-opencv-notes9-1.png" alt=""></p><h3 id="1-3-按键调节亮度">1.3 按键调节亮度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按下1时：图片亮度增大</span></span><br><span class="line"><span class="comment">按下2时，图片亮度减小</span></span><br><span class="line"><span class="comment">按下q时，程序退出*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::key_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(),image.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);<span class="comment">//增大或减小图片亮度的变化量</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;q&#x27;</span>) &#123;<span class="comment">// Quit</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;1&#x27;</span>) &#123;<span class="comment">//Key 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;You enter key 1 - Lightness Up.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">add</span>(image, m, image);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="string">&#x27;2&#x27;</span>) &#123;<span class="comment">//Key 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;You enter key 2 - Lightness Down.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">subtract</span>(image, m, image);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Key&quot;</span>, image);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、鼠标的响应">二、鼠标的响应</h2><h3 id="1-1-基本知识-3">1.1 基本知识</h3><p>  鼠标响应所使用的函数主要是 <code>setMouseCallback()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMousecallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> string&amp; winname,<span class="comment">//窗口的名字</span></span></span></span><br><span class="line"><span class="params"><span class="function"> MouseCallback onMouse,<span class="comment">//鼠标响应回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">void</span>* userdata=<span class="number">0</span><span class="comment">//传给回调函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>  其中onMouse响应回调函数函数，作用为指定窗口里每次鼠标时间发生的时候，被调用的函数指针。 这个函数的原型应该为的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_Mouse</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> event,<span class="comment">//事件回传代号</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> x,<span class="comment">//鼠标指针在图像坐标系的坐标x</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>y,<span class="comment">//鼠标指针在图像坐标系的坐标y</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> flags,<span class="comment">//CV_EVENT_FLAG的组合</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span>* userdata<span class="comment">//传递的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Event</th><th>作用</th></tr></thead><tbody><tr><td>EVENT_MOUSEMOVE</td><td>滑动</td></tr><tr><td>EVENT_LBUTTONDOWN</td><td>左键点击</td></tr><tr><td>EVENT_RBUTTONDOWN</td><td>右键点击</td></tr><tr><td>EVENT_MBUTTONDOWN</td><td>中键点击</td></tr><tr><td>EVENT_LBUTTONUP</td><td>左键放开</td></tr><tr><td>EVENT_RBUTTONUP</td><td>右键放开</td></tr><tr><td>EVENT_MBUTTONUP</td><td>中键放开</td></tr><tr><td>EVENT_LBUTTONDBLCLK</td><td>左键双击</td></tr><tr><td>EVENT_RBUTTONDBLCLK</td><td>右键双击</td></tr><tr><td>EVENT_MBUTTONDBLCLK</td><td>中键双击</td></tr></tbody></table><h3 id="1-2-示例程序">1.2 示例程序</h3><p>  在图像上实现拖动绘制矩形的画板功能。</p><p><img src="https://img.mahaofei.com/img/202112231912888-opencv-notes9-2.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">sp</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;<span class="comment">//起始点（初始值-1，-1）</span></span><br><span class="line"><span class="function">Point <span class="title">ep</span><span class="params">(<span class="number">-1</span>, <span class="number">-1</span>)</span></span>;<span class="comment">//结束点（初始值-1，-1）</span></span><br><span class="line">Mat temp;<span class="comment">//原图的克隆，用于实时刷新图片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on_draw</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span>* userdata)</span> </span>&#123;</span><br><span class="line">Mat bg = *(Mat*)userdata;<span class="comment">//回调函数传过来的图像数据</span></span><br><span class="line"><span class="keyword">if</span> (event == EVENT_LBUTTONDOWN) &#123;<span class="comment">//如果左键被按下</span></span><br><span class="line">sp.x = x;<span class="comment">//保存左键按下时的xy值</span></span><br><span class="line">sp.y = y;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Start point: &quot;</span> &lt;&lt; sp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_LBUTTONUP) &#123;<span class="comment">//如果左键被抬起</span></span><br><span class="line">ep.x = x;<span class="comment">//保存左键抬起时的xy值</span></span><br><span class="line">ep.y = y;</span><br><span class="line"><span class="type">int</span> dx = ep.x - sp.x;<span class="comment">//计算矩形长宽</span></span><br><span class="line"><span class="type">int</span> dy = ep.y - sp.y;</span><br><span class="line"><span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>) &#123;<span class="comment">//当矩形长宽都为正数时</span></span><br><span class="line"><span class="function">Rect <span class="title">box</span><span class="params">(sp.x, sp.y, dx, dy)</span></span>;</span><br><span class="line"><span class="built_in">rectangle</span>(bg, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//绘制矩形</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, bg);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;ROI&quot;</span>, <span class="built_in">temp</span>(box));<span class="comment">//显示ROI区域（被框选的区域）</span></span><br><span class="line">sp.x = <span class="number">-1</span>;<span class="comment">//起始点坐标复位</span></span><br><span class="line">sp.y = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_MOUSEMOVE) &#123;</span><br><span class="line"><span class="keyword">if</span> (sp.x &gt; <span class="number">0</span> &amp;&amp; sp.y &gt; <span class="number">0</span>) &#123;<span class="comment">//当起始点坐标不是初始值，且鼠标移动时</span></span><br><span class="line">ep.x = x;</span><br><span class="line">ep.y = y;</span><br><span class="line"><span class="type">int</span> dx = ep.x - sp.x;</span><br><span class="line"><span class="type">int</span> dy = ep.y - sp.y;</span><br><span class="line"><span class="keyword">if</span> (dx &gt; <span class="number">0</span> &amp;&amp; dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="function">Rect <span class="title">box</span><span class="params">(sp.x, sp.y, dx, dy)</span></span>;</span><br><span class="line">temp.<span class="built_in">copyTo</span>(bg);<span class="comment">//刷新屏幕，清除上一循环绘制的矩形</span></span><br><span class="line"><span class="built_in">rectangle</span>(bg, box, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);<span class="comment">//绘制新矩形</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, bg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::mouseDrawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, WINDOW_AUTOSIZE);<span class="comment">//创建一个窗口</span></span><br><span class="line"><span class="built_in">setMouseCallback</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, on_draw,(<span class="type">void</span>*)(&amp;image));<span class="comment">//调用鼠标回调函数</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mouse Drawing&quot;</span>, image);</span><br><span class="line">temp = image.<span class="built_in">clone</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】随机数的使用与随机线条的生成</title>
      <link href="/post/62112aac.html"/>
      <url>/post/62112aac.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、随机数的使用方法">一、随机数的使用方法</h2><p>  C和C++中提供了 <code>rand()</code> 和 <code>srand()</code> 函数用于产生随机数，使用C++编写OpenCV代码时也可以使用。同时OpenCV自身也提供了生成随机数的类RNG，使用起来也十分方便，以下主要介绍RNG类的使用方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RNG类对象的创建</span></span><br><span class="line"> <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="type">int</span> seed)</span></span>;<span class="comment">//使用种子seed产生一个RNG类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//产生一个在区间[a,b)的均匀分布的整数随机数</span></span><br><span class="line"><span class="type">int</span> x = rng.<span class="built_in">uniform</span>(a, b);</span><br><span class="line"><span class="comment">//产生一个在区间[0,1)的均匀分布的浮点随机数</span></span><br><span class="line"><span class="type">int</span> x = rng.<span class="built_in">uniform</span>(<span class="number">0.f</span>,<span class="number">1.f</span>);</span><br><span class="line"><span class="comment">//产生一个均值为0，标准差为2的高斯分布的随机数</span></span><br><span class="line"><span class="type">int</span> x = rng.<span class="built_in">gaussian</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="二、生成随机线条示例程序">二、生成随机线条示例程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::random_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);<span class="comment">//创建背景</span></span><br><span class="line"><span class="type">int</span> width = bg.cols;</span><br><span class="line"><span class="type">int</span> height = bg.rows;</span><br><span class="line"><span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">666</span>)</span></span>;<span class="comment">//种子随意设置</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//等待按键按下，同时限制两线条生成间隔实现</span></span><br><span class="line"><span class="type">char</span> k = <span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> x1 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, width);</span><br><span class="line"><span class="type">int</span> y1 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, height);</span><br><span class="line"><span class="type">int</span> x2 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, width);</span><br><span class="line"><span class="type">int</span> y2 = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, height);</span><br><span class="line"><span class="type">int</span> b = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">int</span> g = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="type">int</span> r = rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">line</span>(bg, <span class="built_in">Point</span>(x1, y1), <span class="built_in">Point</span>(x2, y2), <span class="built_in">Scalar</span>(b, g, r), <span class="number">1</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Randow image&quot;</span>, bg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231911051-opencv-notes8-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】几何图形的绘制方法</title>
      <link href="/post/904f4dcd.html"/>
      <url>/post/904f4dcd.html</url>
      
        <content type="html"><![CDATA[<p>  在正文开始之前，首先要知道屏幕中 <strong>(0, 0) 坐标点</strong>在左上角，最大坐标在右下角。</p><h2 id="一、基本图形的绘制">一、基本图形的绘制</h2><h3 id="1-矩形">1. 矩形</h3><p>  OpenCV中绘制矩形的函数为 <code>rectangle()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(InputOutputArray img, Rect rec, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness = <span class="number">1</span>, <span class="type">int</span> lineType = LINE_8, <span class="type">int</span> shift = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>InputOutputArray img</td><td>要绘制的目标图像</td></tr><tr><td>Rect rec</td><td>rect类对象</td></tr><tr><td>const Scalar&amp; color</td><td>线条的颜色</td></tr><tr><td>int thickness = 1</td><td>正数表示线条宽度，-1表示填充矩形</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr><tr><td>int shift = 0</td><td>坐标点的小数点位数</td></tr></tbody></table><p>绘制矩形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制矩形</span></span><br><span class="line">Rect rect;</span><br><span class="line">rect.x = <span class="number">250</span>;<span class="comment">//左上端点x坐标</span></span><br><span class="line">rect.y = <span class="number">170</span>;<span class="comment">//左上端点x坐标</span></span><br><span class="line">rect.width = <span class="number">100</span>;<span class="comment">//宽度</span></span><br><span class="line">rect.height = <span class="number">100</span>;<span class="comment">//高度</span></span><br><span class="line"><span class="built_in">rectangle</span>(image, rect, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231909891-opencv-notes7-1.png" alt=""></p><h3 id="2-圆形">2. 圆形</h3><p>  OpenCV中绘制圆形的函数为 <code>rectangle()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::circle</span> <span class="params">(InputOutputArray img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>InputOutputArray img</td><td>要绘制的目标图像</td></tr><tr><td>Point center</td><td>圆心坐标</td></tr><tr><td>int radius</td><td>圆的半径</td></tr><tr><td>const Scalar &amp;color</td><td>圆的颜色</td></tr><tr><td>int thickness=1</td><td>正数表示线条宽度，-1表示填充圆</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr><tr><td>int shift = 0</td><td>坐标点的小数点位数</td></tr></tbody></table><p>绘制圆形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制圆</span></span><br><span class="line"><span class="built_in">circle</span>(image, <span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">170</span>), <span class="number">20</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231909156-opencv-notes7-2.png" alt=""></p><p>  </p><h3 id="3-直线">3. 直线</h3><p>  OpenCV中绘制直线的函数为 <code>rectangle()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::line</span><span class="params">(InputOutputArray img, Point pt1, Point pt2, <span class="type">const</span> Scalar &amp;color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=LINE_8, <span class="type">int</span> shift=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>InputOutputArray img</td><td>要绘制的目标图像</td></tr><tr><td>Point pt1r</td><td>端点1的坐标</td></tr><tr><td>Point pt2</td><td>端点2的坐标</td></tr><tr><td>const Scalar &amp;color</td><td>线条的颜色</td></tr><tr><td>int thickness=1</td><td>线条宽度</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr><tr><td>int shift = 0</td><td>坐标点的小数点位数</td></tr></tbody></table><p>绘制圆形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制直线</span></span><br><span class="line"><span class="built_in">line</span>(image, <span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">170</span>), <span class="built_in">Point</span>(<span class="number">350</span>, <span class="number">270</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231909658-opencv-notes7-3.png" alt="">  </p><h3 id="4-椭圆">4. 椭圆</h3><p>  OpenCV中绘制椭圆的函数为 <code>ellipse()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp;img, <span class="type">const</span> RotatedRect&amp;box, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>Mat&amp;img</td><td>要绘制的目标图像</td></tr><tr><td>const RotatedRect&amp;box</td><td>椭圆类</td></tr><tr><td>const Scalar &amp;color</td><td>椭圆的颜色</td></tr><tr><td>int thickness=1</td><td>正数表示线条宽度，-1表示填充圆</td></tr><tr><td>int lineType = LINE_8</td><td>线条的类型</td></tr></tbody></table><blockquote><p>其中椭圆类RotatedRect的属性如下（示例）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;RotatedRect rrt;<span class="comment">//创建对象</span></span><br><span class="line">&gt;rrt.center = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);<span class="comment">//椭圆中心点</span></span><br><span class="line">&gt;rrt.size = <span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);<span class="comment">//椭圆大小（横轴，纵轴长度）</span></span><br><span class="line">&gt;rrt.angle = <span class="number">0</span>;<span class="comment">//旋转角度</span></span><br></pre></td></tr></table></figure></blockquote><p>绘制圆形的示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::drawing_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="comment">//绘制椭圆</span></span><br><span class="line">RotatedRect rrt;</span><br><span class="line">rrt.center = <span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">rrt.size = <span class="built_in">Size</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">rrt.angle = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ellipse</span>(image, rrt, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Drawing&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910341-opencv-notes7-4.png" alt=""></p><p>  </p><h2 id="二、多边形绘制方法">二、多边形绘制方法</h2><p>  多边形绘制的本质是定义一个由多个点组成的点集，以此连接点集中的各个点，从而形成多边形。</p><h3 id="2-1-多边形边框">2.1 多边形边框</h3><p>  绘制多边形的边框使用到的函数是 <code>ploylines()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::polylines</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArrayimg,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrayspts,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span>isClosed,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>img</td><td>要绘制的目标图像</td></tr><tr><td>pts</td><td>提前构造的点集</td></tr><tr><td>isClosed</td><td>多边形是否是封闭图形</td></tr><tr><td>color</td><td>多边形边框的颜色</td></tr><tr><td>thickness</td><td>线条宽度（只能为正数）</td></tr><tr><td>lineType</td><td>线条的类型</td></tr><tr><td>shift</td><td>坐标点的小数点位数</td></tr></tbody></table><p>示例程序：绘制五边形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建画布</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">std::vector&lt;Point&gt; pts;</span><br><span class="line">pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制多边形边框</span></span><br><span class="line"><span class="built_in">polylines</span>(bg, pts, <span class="literal">true</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">3</span>, LINE_AA, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>pts.push_back</code> 用于将点加入到点集数组中，用于不知道点集数量的情况。本程序已知共五个点，因此也可以使用如下的代码创建点集：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Point&gt; <span class="title">pts</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">pts[<span class="number">0</span>] = p1;</span><br><span class="line">pts[<span class="number">1</span>] = p2;</span><br><span class="line">pts[<span class="number">2</span>] = p3;</span><br><span class="line">pts[<span class="number">3</span>] = p4;</span><br><span class="line">pts[<span class="number">4</span>] = p5;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910682-opencv-notes7-5.png" alt=""></p><h3 id="2-2-多边形填充">2.2 多边形填充</h3><p>  绘制填充的多边形使用到的函数是 <code>fillPoly()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::fillPoly</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArrayimg,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrayspts,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar &amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>lineType = LINE_8,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span>shift = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>img</td><td>要绘制的目标图像</td></tr><tr><td>pts</td><td>提前构造的点集</td></tr><tr><td>color</td><td>多边形边框的颜色</td></tr><tr><td>lineType</td><td>线条的类型</td></tr><tr><td>shift</td><td>坐标点的小数点位数</td></tr></tbody></table><p>示例程序：绘制填充的五边形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建画布</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">std::vector&lt;Point&gt; pts;</span><br><span class="line">pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制封闭的五边形</span></span><br><span class="line"><span class="built_in">fillPoly</span>(bg, pts, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910612-opencv-notes7-6.png" alt=""></p><h3 id="2-3-绘制多个多边形">2.3 绘制多个多边形</h3><p>  绘制多个多边形使用到的函数是 <code>drawContours()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputOutputArray image,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> contourIdx,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> thickness=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> lineType=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray hierarchy=noArray(),</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> maxLevel=INT_MAX,</span></span></span><br><span class="line"><span class="params"><span class="function">Point offset=Point() )</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>img</td><td>要绘制的目标图像</td></tr><tr><td>contours</td><td>输入的轮廓组，每一组轮廓由点vector构成</td></tr><tr><td>contourIdx</td><td>画第几个轮廓，如果该参数为负值，则画全部轮廓</td></tr><tr><td>color</td><td>线条的颜色</td></tr><tr><td>thickness</td><td>线条宽度，负值或CV_FILLED表示填充轮廓内部</td></tr><tr><td>lineType</td><td>线条的类型</td></tr></tbody></table><p>示例程序：绘制一个五边形</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::polyDrawing_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建画布</span></span><br><span class="line">Mat bg = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">512</span>, <span class="number">512</span>), CV_8UC3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建五个点，作为多边形五个顶点</span></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">350</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p3</span><span class="params">(<span class="number">450</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p4</span><span class="params">(<span class="number">250</span>, <span class="number">450</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p5</span><span class="params">(<span class="number">80</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将五个点依次添加到点集中</span></span><br><span class="line">std::vector&lt;Point&gt; pts;</span><br><span class="line">pts.<span class="built_in">push_back</span>(p1);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p2);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p3);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p4);</span><br><span class="line">pts.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加点集到contours</span></span><br><span class="line"><span class="comment">//（相当于contours是点集的集合）</span></span><br><span class="line">std::vector&lt;std::vector&lt;Point&gt;&gt; contours;</span><br><span class="line">contours.<span class="built_in">push_back</span>(pts);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制多边形</span></span><br><span class="line"><span class="built_in">drawContours</span>(bg, contours, <span class="number">-1</span>, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Poly Drawing!&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231910132-opencv-notes7-7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】教你替换绿幕背景</title>
      <link href="/post/a5e6c283.html"/>
      <url>/post/a5e6c283.html</url>
      
        <content type="html"><![CDATA[<p>绿幕图像的背景替换需要经历①色彩空间转换、②提取绿幕区域、③反转绿幕区域、④复制图像，其中遇到的各种函数和代码也都在本文有详细介绍。</p><h2 id="一、色彩空间转换">一、色彩空间转换</h2><p>  要去除绿幕图像中的绿幕，首先需要<strong>将图像转换到hsv色彩空间</strong>，这样方便后续对图像的处理。使用 <code>cvtcolor()</code> 函数可以完成色彩空间的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst,<span class="comment">//输出图像矩阵</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> code,<span class="comment">//转换方式</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> dstCn = <span class="number">0</span><span class="comment">//目标图像通道数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>一般的使用方法如下，图像转换至hsv色彩空间的示例程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat hsv;<span class="comment">//存储转换后的hsv图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//进行色彩空间转换</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;hsv_image&quot;</span>, hsv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、提取绿幕区域">二、提取绿幕区域</h2><p>  图像转换到hsv色彩空间后，就可以进行色彩区域的提取了，这里使用的函数是 <code>inRange()</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inRange</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">InputArray src,<span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArraylowerb,<span class="comment">//下边界数组阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">InputArrayupperb,<span class="comment">//上边界数组阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">OutputArray dst<span class="comment">//输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，由于HSV的取值范围为H(0-180)、S(0-255)、V(0-255)。因此上下边界数组阈值可以通过如下表格获取</p><table><thead><tr><th> </th><th>黑</th><th>灰</th><th>白</th><th>红</th><th>橙</th><th>黄</th><th>绿</th><th>青</th><th>蓝</th><th>紫</th></tr></thead><tbody><tr><td>hmin</td><td>0</td><td>0</td><td>0</td><td>0/156</td><td>11</td><td>26</td><td>35</td><td>78</td><td>100</td><td>125</td></tr><tr><td>hmax</td><td>180</td><td>180</td><td>180</td><td>10/180</td><td>25</td><td>34</td><td>77</td><td>99</td><td>124</td><td>155</td></tr><tr><td>smin</td><td>0</td><td>0</td><td>0</td><td>43</td><td>43</td><td>43</td><td>43</td><td>43</td><td>43</td><td>43</td></tr><tr><td>smax</td><td>255</td><td>43</td><td>30</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td></tr><tr><td>vmin</td><td>0</td><td>46</td><td>221</td><td>46</td><td>46</td><td>46</td><td>46</td><td>46</td><td>46</td><td>46</td></tr><tr><td>vmax</td><td>46</td><td>220</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td><td>255</td></tr></tbody></table><p>  由于本文要替换绿幕，所以选择绿色的阈值，分别是：hmin=35、hmax=77、smin=43、smax=255、vmin=46、vmax=255。因此可以得到<strong>下边界数组为 <code>Scalar(35, 43, 46)</code> ，上边界数组为 <code>Scalar(77, 255, 255)</code></strong> 。</p><p>  因此提取绿幕的程序如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat hsv;<span class="comment">//存储转换后的hsv图像</span></span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);<span class="comment">//进行色彩空间转换</span></span><br><span class="line">Mat mask;<span class="comment">//存储提取绿幕区域后的图像</span></span><br><span class="line"><span class="built_in">inRange</span>(hsv, <span class="built_in">Scalar</span>(<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>), <span class="built_in">Scalar</span>(<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231907880-opencv-notes6-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231907662-opencv-notes6-2.png" alt=""></p><h2 id="三、替换背景">三、替换背景</h2><p>  前面已经完成了对绿幕区域的提取，接下来只需要对提取的区域反转，选择人物的区域，进而将人物复制到新背景即可。<br>  反转选择区域使用的是 <code>bitwise_not()</code> 函数。<br>  复制图像使用的是 <code>image.copyTo(newimage，mask)</code> 方法，作用是把mask和image重叠以后把mask中像素值为0（黑色）的点对应的image中的点变为透明，而保留其他点，将保留的点拷贝到newimage中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::inRange_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换色彩空间</span></span><br><span class="line">Mat hsv;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提取绿幕区域</span></span><br><span class="line">Mat mask;</span><br><span class="line"><span class="built_in">inRange</span>(hsv, <span class="built_in">Scalar</span>(<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>), <span class="built_in">Scalar</span>(<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>), mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;mask&quot;</span>, mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转提取人物区域</span></span><br><span class="line"><span class="built_in">bitwise_not</span>(mask, mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">//人物复制到新背景中</span></span><br><span class="line">Mat bg = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/plantbg.jpg&quot;</span>);<span class="comment">//背景图片</span></span><br><span class="line">image.<span class="built_in">copyTo</span>(bg, mask);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Finished&quot;</span>, bg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231908540-opencv-notes6-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231908875-opencv-notes6-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像通道的分离、合并与混合方法（C++）</title>
      <link href="/post/54b66be1.html"/>
      <url>/post/54b66be1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像通道的分离">一、图像通道的分离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> cv::Mat&amp; image, <span class="comment">//输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">vector&lt;Mat&gt;&amp; mv <span class="comment">// 输出的多通道序列（n个单通道序列）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>  输出的多通道序列一般使用 <code>std::vector&lt;Mat&gt; mv;</code> 来存储，<code>mv[0]</code> 、<code>mv[1]</code>、<code>mv[2]</code>、分别对应BGR三个通道。<br>  <br>  示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">std::vector&lt;Mat&gt; mv;</span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Blue Channel&quot;</span>, mv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Green Channel&quot;</span>, mv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Red Channel&quot;</span>, mv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231906925-opencv-notes5-1.png" alt=""></p><h2 id="二、通道的合并">二、通道的合并</h2><p>  但是现在显示的相当于是三张单通道的图像，也就相当于三张灰度图像。要想让三张图像恢复直观意义上的色彩，就需要使用下面通道合并的方法了。</p><p>  通道的合并需要用到 <code>merge()</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> vector&lt;cv::Mat&gt;&amp; mv, <span class="comment">// 输入的多通道序列(n个单通道序列)</span></span></span></span><br><span class="line"><span class="params"><span class="function">cv::OutputArray dst <span class="comment">// 输出图像，包含mv</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>  根据 <code>merge()</code> 函数的定义，我们只需要控制输入的多通道数组 <code>mv[]</code> 中的三个值，就可以实现通道的合并。</p><p>  示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">std::vector&lt;Mat&gt; mv;</span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line"></span><br><span class="line">Mat m1,m2,m3;</span><br><span class="line">mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">mv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(mv, m1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Blue Channel&quot;</span>, m1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line">mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">mv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(mv, m2);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Green Channel&quot;</span>, m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">split</span>(image, mv);</span><br><span class="line">mv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">mv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">merge</span>(mv, m3);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Red Channel&quot;</span>, m3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231906838-opencv-notes5-2.png" alt=""></p><p>  我们已经知道如何将图像的三个通道提取出来了，因此我们可以将三个通道进行任意组合，合并出我们想要的图片。</p><h2 id="三、通道的混合">三、通道的混合</h2><p>  通道的混合也是将三个通道进行任意排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++: <span class="function"><span class="type">void</span> <span class="title">mixChannels</span><span class="params">(<span class="type">const</span> Mat*src, <span class="type">size_t</span> nsrcs, Mat* dst, <span class="type">size_t</span> ndsts, <span class="type">const</span> <span class="type">int</span>* fromTo, <span class="type">size_t</span> npairs)</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>src</td><td>输入矩阵</td></tr><tr><td>nsrcs</td><td>输入矩阵的个数</td></tr><tr><td>dst</td><td>输出矩阵</td></tr><tr><td>ndsts</td><td>输出矩阵的个数</td></tr><tr><td>fromTo</td><td>序号对向量</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::channels_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line"><span class="type">int</span> ft[] = &#123; <span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span> &#125;;<span class="comment">//互换1、3通道</span></span><br><span class="line"><span class="built_in">mixChannels</span>(&amp;image,<span class="number">1</span>, &amp;dst,<span class="number">1</span>, ft,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Mix&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231906612-opencv-notes5-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】滚动条Trackbar的创建与使用详解</title>
      <link href="/post/9a77b96c.html"/>
      <url>/post/9a77b96c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Trackbar的创建方法">一、Trackbar的创建方法</h2><h3 id="1-1-createTrackbar">1.1 createTrackbar</h3><p>  OpenCV中使用<code>createTrackbar()</code>来创建滚动条，函数的使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">createTrackbar</span>(<span class="type">const</span> String&amp; trackbarname, <span class="type">const</span> String&amp; winname,<span class="type">int</span> value, <span class="type">int</span> count,TrackbarCallback onChange = <span class="number">0</span>,<span class="type">void</span> userdata = <span class="number">0</span>); </span><br></pre></td></tr></table></figure><table><thead><tr><th>位置</th><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>trackbar name</td><td>滚动条的名字</td></tr><tr><td>2</td><td>winname</td><td>绑定的窗口名字</td></tr><tr><td>3</td><td>value</td><td>滑块的初始位置</td></tr><tr><td>4</td><td>count</td><td>滑块的最大位置</td></tr><tr><td>5</td><td>TrackbarCallback</td><td>回调函数，拨动Trackbar返回的函数</td></tr><tr><td>6</td><td>userdata</td><td>用户传给回调函数的数据，不用默认为0</td></tr></tbody></table><h3 id="1-2-回调函数">1.2 回调函数</h3><p>  第五个参数回调函数TrackbarCallback，是指拨动Trackbar会产生一个事件，系统会捕捉这个事件，然后发送给相应的处理者，因此需要定义一个函数进行相应的处理。回调函数的定义规范如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callbackfunc</span><span class="params">(<span class="type">int</span> value, <span class="type">void</span>* userdata)</span></span>;</span><br></pre></td></tr></table></figure><p>value传入的是滑块位置变量。<br>userdata是打包的其他数据，可以通过如结构体的方法打包数据发送给回调函数。当createTrackbar函数最后一个参数为0时表示不使用userdata，这时可以通过全局变量为回调函数传递数据。</p><h2 id="二、使用Trackbar调节图片亮度">二、使用Trackbar调节图片亮度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分代码</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">onTrack</span><span class="params">(<span class="type">int</span> lightness, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">Mat src = *(Mat*)data;<span class="comment">//将void类型指针转换为Mat类型指针，然后再取数据</span></span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), src.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(lightness, lightness, lightness);</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(src, m, dst);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Change Lightness&quot;</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::checkBar_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="built_in">namedWindow</span>(<span class="string">&quot;Change Lightness&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lightness = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> max_value = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">createTrackbar</span>(<span class="string">&quot;Value Bar&quot;</span>, <span class="string">&quot;Change Lightness&quot;</span>, &amp;lightness, max_value, onTrack,(<span class="type">void</span> *)&amp;image);<span class="comment">//最后一个参数强制转换为void类型指针</span></span><br><span class="line"><span class="built_in">onTrack</span>(lightness, &amp;image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231905321-opencv-notes4-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】如何操作图像中的像素?</title>
      <link href="/post/3b23ab0d.html"/>
      <url>/post/3b23ab0d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、读写操作">一、读写操作</h2><h3 id="1-1-数组遍历">1.1 数组遍历</h3><p>  由于图像本质就是Mat矩阵，因此要读写像素点，可以<strong>采用数组遍历的方式访问</strong>Mat矩阵内的每一个元素。但我们要注意，灰度图和彩色图的通道数是不一样的，<strong>灰度图是单通道的，彩色图是三通道的</strong>。因此读写像素点就分为了读写灰度图像素和读写彩色图像素两种情况。</p><p>① 读写灰度图像素</p><p>  灰度图内每一个像素点对应Mat矩阵的一个值，因此访问灰度图的像素就相当于访问Mat矩阵的元素。其语法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读灰度图像素</span></span><br><span class="line"><span class="type">int</span> pv = image.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line"><span class="comment">//写灰度图像素（反转颜色）</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br></pre></td></tr></table></figure><p>  其中由于每个灰度图像素为1个字节（0-255），因此使用uchar。其中的row代表Mat矩阵行数，col代表列数。</p><p>② 读写彩色图像</p><p>  彩色图像中每个像素点对应Mat矩阵的三个值，访问方式类似灰度图像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读彩色图像素</span></span><br><span class="line">Vec3b bgr = image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line"><span class="comment">//写彩色图像素（反转颜色）</span></span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - bgr[<span class="number">0</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - bgr[<span class="number">1</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - bgr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>  由于访问彩色图像素点需要一次性读取三个值，因此我们使用了Vec3b这个结构（可以看成一个数组），可以直接将访问得到的三个值存储在Vec3b这个结构定义的变量中。<br>  如果彩色像素点的值是整型，需要用Vec3i；如果是浮点数类型，需要用vec3f。</p><p>③ 示例程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::pixelVisit_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> pv = image.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line">image.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//彩色图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">Vec3b bgr = image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - bgr[<span class="number">0</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - bgr[<span class="number">1</span>];</span><br><span class="line">image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - bgr[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Pixel Visit Demo&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231901936-opencv-notes3-1.png" alt=""></p><h3 id="1-2-指针遍历">1.2 指针遍历</h3><p>  指针遍历的原理与数组遍历类似。定义一个指针指向当前行的首地址，然后利用此指针即可遍历访问本行所有像素点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::pixelVisit_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line">uchar* current_row = image.<span class="built_in">ptr</span>&lt;uchar&gt;(row);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//彩色图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">*current_row++ = <span class="number">255</span> - *current_row;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Pixel Visit Demo&quot;</span>, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>current_row</code>随着循环的进行指向每一行的首地址。<br><code>*current_row++ = 255 - *current_row;</code>是指将 current_row 指向的值（灰度图的像素点或彩色图像素点的一个通道）色彩反转，然后令指针+1，使其指向下一个像素或像素的下一个通道。</p><h2 id="二、算术操作">二、算术操作</h2><h3 id="2-1-像素的">2.1 像素的</h3><p>  对一个图像Mat矩阵可以直接进行加减乘除（注意彩色图加法需要Scalar），<strong>加减法处理的结果就是增大/减小图像的亮度，乘除法同理</strong>，但要注意在处理时可能会使像素值<strong>超出(0~255)的范围，可以使用saturate_cast函数进行截断</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//image * m -&gt; dst</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::operators_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w = image.cols;</span><br><span class="line"><span class="type">int</span> h = image.rows;</span><br><span class="line"><span class="type">int</span> dims = image.<span class="built_in">channels</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; h; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; w; col++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//灰度图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> pv = image.<span class="built_in">at</span>&lt;uchar&gt;(row, col);</span><br><span class="line">image.<span class="built_in">at</span>&lt;uchar&gt;(row, col) = <span class="number">255</span> - pv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//彩色图像</span></span><br><span class="line"><span class="keyword">if</span> (dims == <span class="number">3</span>) &#123;</span><br><span class="line">Vec3b p1 = image.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line">Vec3b p2 = m.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(p1[<span class="number">0</span>] * p2[<span class="number">0</span>]);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(p1[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line">dst.<span class="built_in">at</span>&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(p1[<span class="number">2</span>] * p2[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;operator&quot;</span>,dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231901960-opencv-notes3-2.png" alt=""></p><h3 id="2-2-图像算术操作API">2.2 图像算术操作API</h3><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>加法</td><td>add(img1, img2, imgout);</td></tr><tr><td>减法</td><td>subtract(img1, img2, imgout);</td></tr><tr><td>乘法</td><td>multiply(img1, img2, imgout);</td></tr><tr><td>除法</td><td>divide(img1, img2, imgout);</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::operators_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat dst = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">Mat m = Mat::<span class="built_in">zeros</span>(image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>());</span><br><span class="line">m = <span class="built_in">Scalar</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add(image, m, dst);</span></span><br><span class="line"><span class="comment">//subtract(image, m, dst);</span></span><br><span class="line"><span class="built_in">multiply</span>(image, m, dst);</span><br><span class="line"><span class="comment">//divide(image, m, dst);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;operator&quot;</span>,dst);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、逻辑操作">三、逻辑操作</h2><h3 id="3-1-基本知识—真值表">3.1 基本知识—真值表</h3><table><thead><tr><th>A</th><th>B</th><th>与</th><th>或</th><th>异或</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h3 id="3-2-画个矩形">3.2 画个矩形</h3><p>  为了更直观的显示像素逻辑运算的结果，我们可以画两个矩形，让两个矩形的相交区域进行逻辑运算。<br>  画矩形方法很简单，只需要先创建一个空白图像，然后调用rectangle函数就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(被处理图像, 左上点坐标, 颜色, 线宽, 线型, 坐标点的小数点位数);</span><br></pre></td></tr></table></figure><p>示例程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::bitWise_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m1 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(m2, <span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-逻辑运算">3.3 逻辑运算</h3><table><thead><tr><th>运算</th><th>函数</th></tr></thead><tbody><tr><td>与</td><td>bitwise_and(m1, m2, dst);</td></tr><tr><td>或</td><td>bitwise_or(m1, m2, dst);</td></tr><tr><td>非</td><td>bitwise_not(m1, dst);</td></tr><tr><td>异或</td><td>bitwise_xor(m1, m2, dst);</td></tr></tbody></table><p>以“与”操作为例，试验代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::bitWise_Demo</span><span class="params">(Mat&amp; image)</span> </span>&#123;</span><br><span class="line">Mat m1 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line">Mat m2 = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">256</span>, <span class="number">256</span>), CV_8UC3);</span><br><span class="line"><span class="built_in">rectangle</span>(m1, <span class="built_in">Rect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">rectangle</span>(m2, <span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">80</span>), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">-1</span>, LINE_8, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m1&quot;</span>, m1);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;m2&quot;</span>, m2);</span><br><span class="line">Mat dst;</span><br><span class="line"><span class="built_in">bitwise_and</span>(m1, m2, dst);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;bitWise&quot;</span>, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>区域</th><th>颜色</th></tr></thead><tbody><tr><td>背景</td><td>Scalar(0, 0, 0)</td></tr><tr><td>矩形1</td><td>Scalar(255, 255, 0)</td></tr><tr><td>矩形2</td><td>Scalar(0, 255, 255)</td></tr><tr><td>相交区域</td><td>Scalar(0, 255, 0)</td></tr><tr><td>其他区域</td><td>Scalar(0, 0, 0)</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/202112231904528-opencv-notes3-3.png" alt=""></p><p>  其他的“或”、“非”、“异或”操作类似，有兴趣的可以自己尝试。</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】图像的基本操作</title>
      <link href="/post/49c93445.html"/>
      <url>/post/49c93445.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、图像色彩空间转换">一、图像色彩空间转换</h2><h3 id="1-1-基本知识">1.1 基本知识</h3><ol><li>色彩空间转换函数：cvtColor</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COLOR_BGR2GRAY = <span class="number">6</span><span class="comment">//6彩色到灰度</span></span><br><span class="line">COLOR_GRAY2BGR = <span class="number">8</span><span class="comment">//8灰度到彩色</span></span><br><span class="line">COLOR_BGR2HSV = <span class="number">40</span><span class="comment">//40BGR到HSV</span></span><br><span class="line">COLOR_HSV2BGR = <span class="number">54</span><span class="comment">//54HSV到BGR</span></span><br></pre></td></tr></table></figure><blockquote><p>GRAY：指灰度，只有一个参数灰度值Channel<br>BGR：指BGR颜色空间，以红绿蓝三基色(0~255)为基础，叠加形成各种颜色<br>HSV：指六角椎体模型，色调Hue用角度度量（0~180），饱和度Saturation（0 ~ 255），亮度Value（0 ~ 255）</p><p><img src="https://img.mahaofei.com/img/202112231855797-opencv-notes2-1.png" alt=""></p></blockquote><ol start="2"><li>图像保存函数：imwrite</li></ol><blockquote><p>第一个参数是图像保存路径<br>第二个参数是图像内存对象</p></blockquote><h3 id="1-2-创建类">1.2 创建类</h3><p>①首先添加一个头文件。</p><p><img src="https://img.mahaofei.com/img/202112231855462-opencv-notes2-2.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231855694-opencv-notes2-3.png" alt=""><br>  </p><p>②头文件内定义一个MyDemo类，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorSpace_Demo</span><span class="params">(Mat &amp;image)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>③添加包含目录。首先在项目名称上<strong>右键-属性</strong>，打开属性页后，编辑<strong>VC++目录-&gt;包含目录</strong>这一项，新建项为头文件所在的目录如图。</p><p><img src="https://img.mahaofei.com/img/202112231856379-opencv-notes2-4.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231856267-opencv-notes2-5.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231856561-opencv-notes2-6.png" alt=""></p><p>  </p><p>④创建一个cpp文件，实现刚才定义的类。</p><p><img src="https://img.mahaofei.com/img/202112231856499-opencv-notes2-7.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::colorSpace_Demo</span><span class="params">(Mat &amp;image)</span> </span>&#123;</span><br><span class="line">Mat gray, hsv;</span><br><span class="line"><span class="built_in">cvtColor</span>(image, hsv, COLOR_BGR2HSV);</span><br><span class="line"><span class="built_in">cvtColor</span>(image, gray, COLOR_BGR2GRAY);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;HSV Image&quot;</span>, hsv);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Gray Image&quot;</span>, gray);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/hsv.png&quot;</span>, hsv);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/gray.png&quot;</span>, gray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-编写主函数">1.3 编写主函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;E:/Program/OpenCV/vcworkspaces/opencv_452/img/opencv.jpg&quot;</span>);<span class="comment">//自己找一张图片</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;opencv.jpg&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">MyDemo demo;</span><br><span class="line">demo.<span class="built_in">colorSpace_Demo</span>(src);</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-测试结果">1.4 测试结果</h3><p><img src="https://img.mahaofei.com/img/202112231857455-opencv-notes2-8.png" alt=""></p><p>  </p><blockquote><p>使用技巧：由于RGB三个参数仅代表颜色，HSV分别代表色调、饱和度、亮度。<br>因此对于一个图片想要调整亮度，可以先转换到HSV色彩空间调节亮度，再返回RGB色彩空间即可。</p></blockquote><h2 id="二、图像对象的创建与复制">二、图像对象的创建与复制</h2><h3 id="2-1-什么是Mat">2.1 什么是Mat</h3><blockquote><p>关于Mat的问题</p><ol><li>如何操作读进来的图像</li><li>如何遍历访问图像的每个像素点</li><li>如何创建一个空图像</li></ol></blockquote><p>在OpenCV中Mat的数据分为两个部分，<strong>头部和数据部分</strong>。头部包括数据类型、通道数量。</p><h3 id="2-2-创建空白图像">2.2 创建空白图像</h3><p><strong>创建图像的过程</strong><br>①所用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat m_new = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br></pre></td></tr></table></figure><p>函数中的参数CV_8UC1，表示8位、unsigned char型、Channel通道数为1。</p><p>②添加头文件</p><p>接下来写demo尝试创建图像，在头文件内添加一行函数的声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">colorSpace_Demo</span><span class="params">(Mat&amp; image)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matCreation_Demo</span><span class="params">()</span></span>;<span class="comment">//这一行是新加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>③实现创建图像的函数</p><p>在mydemo.cpp文件中添加以下代码实现此函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白图像</span></span><br><span class="line">Mat m_new = Mat::<span class="built_in">zeros</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC1);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;width = &quot;</span> &lt;&lt; m_new.cols &lt;&lt; <span class="string">&quot;\theight = &quot;</span> &lt;&lt; m_new.rows &lt;&lt; <span class="string">&quot;\tchannels = &quot;</span> &lt;&lt; m_new.<span class="built_in">channels</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; m_new &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④主函数调用并测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mydemo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyDemo demo;</span><br><span class="line">demo.<span class="built_in">matCreation_Demo</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图所示，是一个8x8的矩阵：<br><img src="https://img.mahaofei.com/img/202112231857465-opencv-notes2-9.png" alt=""></p><p><strong>注意事项：</strong><br>  <br>如果将通道数改为3，也就是<code>Mat m_new = Mat::zeros(Size(8, 8),CV_8UC3);</code>，那么输出结果会变成8x24的矩阵，也就是每个像素点会有三个值：</p><p><img src="https://img.mahaofei.com/img/202112231857776-opencv-notes2-10.png" alt=""><br>  </p><p>如果对三通道使用ones进行初始化，那么只会使每个像素点的第一个通道初始化为1，第二、第三通道仍然初始化为0.</p><p><img src="https://img.mahaofei.com/img/202112231857740-opencv-notes2-11.png" alt=""><br>  </p><p>可以通过使用<code>Scalar</code>函数对图像所有像素点同时进行赋值。<strong>Scalar的三个参数分别为B、G、R</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白图像</span></span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">8</span>, <span class="number">8</span>),CV_8UC3);</span><br><span class="line">m_new = <span class="built_in">Scalar</span>(<span class="number">66</span>, <span class="number">66</span>, <span class="number">66</span>);</span><br><span class="line">std::cout &lt;&lt; m_new &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231858306-opencv-notes2-12.png" alt=""></p><p>  </p><p><strong>图像在哪里</strong><br>刚才我们通过io输出，在控制台将图像的像素点值一个一个打印出来。我们当然也可以将它作为一个图像进行输出。只需要将cout换成imshow即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyDemo::matCreation_Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空白图像</span></span><br><span class="line">Mat m_new = Mat::<span class="built_in">ones</span>(<span class="built_in">Size</span>(<span class="number">800</span>, <span class="number">600</span>),CV_8UC3);</span><br><span class="line">m_new = <span class="built_in">Scalar</span>(<span class="number">66</span>, <span class="number">66</span>, <span class="number">66</span>);</span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;new image&quot;</span>,m_new);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们生成出来的一个图像</p><p><img src="https://img.mahaofei.com/img/202112231858552-opencv-notes2-13.png" alt=""></p><h3 id="2-3-图像的复制">2.3 图像的复制</h3><p>对于Mat对象进行赋值操作时，只是相当于两个指针指向了同一块内存空间，只有进行<strong>克隆和拷贝</strong>操作时，才是真正的复制。</p><p>①克隆：clone</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_clone = image.<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure><p>②拷贝：copyTo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image.<span class="built_in">copyTo</span>(m_copy);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习OpenCV4】Win10下OpenCV4.5+VS2019安装与环境搭建（详细过程）</title>
      <link href="/post/d2828609.html"/>
      <url>/post/d2828609.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、软件准备">一、软件准备</h2><h3 id="1-1-下载并解压OpenCV">1.1 下载并解压OpenCV</h3><p>  建议到<a href="https://opencv.org/">opencv的官网</a>下载windows版本的安装包。</p><blockquote><p>如果觉得下载速度过慢，我也把opencv4.5.2安装包上传了阿里云<br><a href="https://www.aliyundrive.com/s/VGkaM7vyuck">https://www.aliyundrive.com/s/VGkaM7vyuck</a></p></blockquote><p><img src="https://img.mahaofei.com/img/202112231843882-opencv-notes1-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231843681-opencv-notes1-2.png" alt=""></p><p>  下载完之后，双击运行这个文件，<strong>注意解压的路径，一定要是一个英文路径</strong>，等待一段时间解压完成即可。</p><p><img src="https://img.mahaofei.com/img/202112231844664-opencv-notes1-3.png" alt=""></p><h3 id="1-2-下载并安装Visual-Studio">1.2 下载并安装Visual Studio</h3><p>  这里我使用的是Visual Studio 2019 专业版，<a href="https://visualstudio.microsoft.com/zh-hans/vs/">官网</a>就可以下载。使用其他版本的VS也可以，没有特别要求。</p><p>  安装时勾选<strong>使用C++的桌面开发</strong>，然后修改安装位置，其他配置都可以默认。</p><p><img src="https://img.mahaofei.com/img/202112231844878-opencv-notes1-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231844934-opencv-notes1-5.png" alt=""></p><blockquote><p>安装完成后，如果需要VS2019 Pro注册码：<code>NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y</code></p></blockquote><h2 id="二、配置OpenCV环境">二、配置OpenCV环境</h2><h3 id="2-1-创建项目">2.1 创建项目</h3><p>  新建一个<strong>控制台项目</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231845061-opencv-notes1-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231845142-opencv-notes1-7.png" alt=""></p><p>  配置如下图中为<strong>Release</strong>和<strong>x64</strong>版本。</p><p><img src="https://img.mahaofei.com/img/202112231846358-opencv-notes1-8.png" alt=""></p><h3 id="2-2-配置属性">2.2 配置属性</h3><p>  打开<strong>视图-其他窗口-属性管理器</strong>（其他版本的VS可能是视图-属性管理器）。</p><p><img src="https://img.mahaofei.com/img/202112231846533-opencv-notes1-9.png" alt=""></p><p>  在属性管理器内<strong>右键“Microsoft Cpp x64 user”并点击属性</strong>，打开它的属性页。</p><p><img src="https://img.mahaofei.com/img/202112231846979-opencv-notes1-10.png" alt=""></p><p>  ①配置<strong>VC++ 目录-&gt;包含目录</strong></p><p><img src="https://img.mahaofei.com/img/202112231847544-opencv-notes1-11.png" alt=""></p><p>  在编辑页面添加两个新行，第一个是解压的opencv下面的  <strong><code>opencv/build/include</code></strong>  这个目录，第二个是  <strong><code>opencv/build/include/opencv2</code></strong>  这个目录，添加完成后点击确定回到属性页。</p><p><img src="https://img.mahaofei.com/img/202112231847282-opencv-notes1-12.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231847556-opencv-notes1-13.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231848108-opencv-notes1-14.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231848973-opencv-notes1-15.png" alt=""></p><p>  ②继续配置<strong>VC++目录-&gt;库目录</strong></p><p><img src="https://img.mahaofei.com/img/202112231849542-opencv-notes1-16.png" alt=""></p><p>  在编辑页面添加项  <strong><code>opencv/build/x64/vc15</code></strong>  ，添加完成后同样点击确定回到属性页。</p><blockquote><p>这里如果是vs2019，那么用最新的vc15会好一些，如果是之前的版本，可以选择vc14目录</p></blockquote><p><img src="https://img.mahaofei.com/img/202112231849165-opencv-notes1-17.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231850283-opencv-ontes1-18.png" alt=""></p><p>  ③继续配置<strong>链接器-&gt;输入-&gt;附加依赖性</strong></p><p><img src="https://img.mahaofei.com/img/202112231850837-opencv-notes1-19.png" alt=""></p><p>  复制release版本的lib文件名，在编辑项中粘贴即可</p><p><img src="https://img.mahaofei.com/img/202112231851269-opencv-notes1-20.png" alt=""></p><p>  </p><p><img src="https://img.mahaofei.com/img/202112231851586-opencv-notes1-21.png" alt=""></p><p>  完成以上配置之后，点击右下角的<strong>应用-确定</strong>就可以了。</p><p><img src="https://img.mahaofei.com/img/202112231851285-opencv-notes1-22.png" alt=""></p><h3 id="2-3-配置环境变量">2.3 配置环境变量</h3><p>  复制bin文件夹目录。</p><p><img src="https://img.mahaofei.com/img/202112231852406-opencv-notes1-23.png" alt=""></p><p>  回到桌面，<strong>右键计算机-属性-高级系统设置</strong>，打开环境变量。</p><p><img src="https://img.mahaofei.com/img/202112231852254-opencv-notes1-24.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231852926-opencv-notes1-25.png" alt=""></p><p>  找到系统变量中的Path，点击编辑。</p><p><img src="https://img.mahaofei.com/img/202112231853801-opencv-notes1-26.png" alt=""></p><p>  添加一项新项，将刚才复制的bin文件夹目录粘贴过来，然后确定。</p><p><img src="https://img.mahaofei.com/img/202112231853227-opencv-notes1-27.png" alt=""></p><p>  <strong>关掉Visual Studio，再重新打开软件</strong>。</p><h2 id="三、测试程序">三、测试程序</h2><p>  在创建的cpp文件中，添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">Mat src = <span class="built_in">imread</span>(<span class="string">&quot;F:/NutStore/Documents/素材库/Logo/Huffie.jpg&quot;</span>);<span class="comment">//自己找一张图片</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;input&quot;</span>, src);</span><br><span class="line"><span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">destroyAllWindows</span>();;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成解决方案，如果没有报错，那么恭喜你！如果出现错误，那么请自习搜索一下错误原因，或者仔细检查以上的每一步。</p><p><img src="https://img.mahaofei.com/img/202112231854239-opencv-notes1-28.png" alt=""></p><p>测试-&gt;开始执行（不调试）</p><p><img src="https://img.mahaofei.com/img/202112231854619-opencv-notes1-29.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231854767-opencv-notes1-30.png" alt=""></p><p>  </p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proteus8.9 下载与安装教程</title>
      <link href="/post/abdfd22a.html"/>
      <url>/post/abdfd22a.html</url>
      
        <content type="html"><![CDATA[<p>百度网盘链接：<a href="https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA">https://pan.baidu.com/s/1EHGewnvjcnEpPbXnR1qLIA</a><br>提取码: pr89<br>  <br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/29x1H7qy3Hz">https://www.aliyundrive.com/s/29x1H7qy3Hz</a><br>下载后将后缀改为.zip即可正常解压。</p><ol><li><p>右键压缩包，进行解压。进入解压的文件夹，右键<strong>p8.9.sp0.exe</strong>文件，使用管理员身份打开。</p><p><img src="https://img.mahaofei.com/img/202112231758580-proteus89-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231759359-proteus89-2.png" alt=""></p><p>这里可能有些机器会先弹出安装Visual C++的一个界面，一定要安装这些勾选的组件，否则后续安装会出现问题。</p><p><img src="https://img.mahaofei.com/img/202112231759267-proteus89-3.png" alt=""></p></li><li><p>莫得选择，next</p><p><img src="https://img.mahaofei.com/img/202112231759476-proteus89-4.png" alt=""></p></li><li><p>I accept，然后next</p><p><img src="https://img.mahaofei.com/img/202112231800247-proteus89-5.png" alt=""></p></li><li><p>选择使用本地的激活证书license key。</p><p><img src="https://img.mahaofei.com/img/202112231800437-proteus89-6.png" alt=""></p></li><li><p>继续next</p><p><img src="https://img.mahaofei.com/img/202112231801080-proteus89-7.png" alt=""></p></li><li><p>这里会打开一个激活证书管理界面，点击左下角【Browse For Key File】，找到刚才解压出来的文件夹，里面解压后的【Proteus 8.9】文件夹中的【Crack】文件夹下的【Licence.lxk】文件，点击【打开】。</p><p><img src="https://img.mahaofei.com/img/202112231801887-proteus89-8.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231801966-proteus89-9.png" alt=""></p></li><li><p>点击 【<strong>install</strong>】，在弹出的对话框询问是否继续，选择 【<strong>是</strong>】，安装完成后点击【<strong>Close</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231802780-proteus89-10.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231802906-proteus89-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231802103-proteus89-12.png" alt=""></p></li><li><p>都不用勾选，直接【<strong>next</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231803096-proteus89-13.png" alt=""></p></li><li><p>这里选择安装方式，选择【<strong>Custom</strong>】，然后选择要安装的路径，<strong>注意：两个路径一定要一样，否则后期软件使用时会闪退</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231803498-proteus89-14.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231803440-proteus89-15.png" alt=""></p></li><li><p>这里不用管，默认【<strong>Next</strong>】就可以。</p><p><img src="https://img.mahaofei.com/img/202112231804160-proteus89-16.png" alt=""></p></li><li><p>继续【<strong>Next</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231804265-proteus89-17.png" alt=""></p></li><li><p>点击【<strong>Install</strong>】开始安装，安装耗时一分钟左右。</p><p><img src="https://img.mahaofei.com/img/202112231804748-proteus89-18.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231805753-proteus89-19.png" alt=""></p></li><li><p>点击【<strong>Close</strong>】，不要运行Proteus</p><p><img src="https://img.mahaofei.com/img/202112231805229-proteus89-20.png" alt=""></p></li><li><p>再次进入安装包解压后的【<strong>Proteus 8.9</strong>】文件夹中的【<strong>Crack</strong>】文件夹，选择所有文件【<strong>复制</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231805733-proteus89-21.png" alt=""></p></li><li><p>在桌面找到【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231806316-proteus89-22.png" alt=""></p></li><li><p>在空白处【<strong>右键-粘贴</strong>】，将刚才那三个文件复制过来。</p><p><img src="https://img.mahaofei.com/img/202112231806975-proteus89-23.png" alt=""></p></li><li><p>右键<strong>粘贴后</strong>的【<strong>pp8.9</strong>】选择【<strong>以管理员身份运行</strong>】。（运行完成后不会弹出任何对话窗，运行一下就可以），建议关闭各种安全管家之后再运行。</p><p><img src="https://img.mahaofei.com/img/202112231806092-proteus89-24.png" alt=""></p></li><li><p>再次打开解压后的【Proteus 8.9】文件夹，鼠标右击【Translations】选择【复制】。</p><p><img src="https://img.mahaofei.com/img/202112231806438-proteus89-25.png" alt=""></p></li><li><p>再次右键桌面【<strong>Proteus 8.9</strong>】的快捷方式，右键点击【<strong>打开文件所在的位置</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231807721-proteus89-26.png" alt=""></p></li><li><p>点击路径中的【<strong>Proteus</strong>】文件夹，回到上一级。</p><p><img src="https://img.mahaofei.com/img/202112231807086-proteus89-27.png" alt=""></p></li><li><p>在空白处【<strong>右键-粘贴</strong>】，将刚才复制的Translation文件夹粘过来，可能会有27/28个同名文件，点击【<strong>替换目标中的文件</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231807620-proteus89-28.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231808223-proteus89-29.png" alt=""></p></li><li><p>进入【<strong>C:\Program Files (x86)\Labcenter Electronics</strong>】目录下，有一个【<strong>Proteus 8 Professional</strong>】文件夹，进入此文件夹，【<strong>全选-复制这两个文件夹</strong>】。</p><p><img src="https://img.mahaofei.com/img/202112231808875-proteus89-30.png" alt=""></p></li><li><p>回到Proteus的安装路径（同19、20步），【<strong>右键粘贴，替换目标文件</strong>】</p><p><img src="https://img.mahaofei.com/img/202112231808897-proteus89-31.png" alt=""></p></li></ol><p><strong>至此，安装完成！</strong></p><p><img src="https://img.mahaofei.com/img/202112231809916-proteus89-32.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview状态机的介绍与程序示例</title>
      <link href="/post/d55fc503.html"/>
      <url>/post/d55fc503.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、状态机简介">一、状态机简介</h2><p>  状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。<br>  Labview状态机是由<strong>一个While循环、一个条件结构和一个移位寄存器</strong>组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。</p><h2 id="二、状态机的基本框架">二、状态机的基本框架</h2><p>  在程序框图中创建一个while循环，并在while循环上添加移位寄存器，然后再while循环内创建一个条件结构，条件结构的选择端是一个枚举常量。</p><p><img src="https://img.mahaofei.com/img/202112231754270-labview-statemachine-1.png" alt=""></p><h2 id="三、例程">三、例程</h2><h3 id="3-1-运行效果">3.1 运行效果</h3><p>按下开始按钮后，LED开始以输入的时间间隔闪烁，按下停止按钮，程序停止运行。</p><p><img src="https://img.mahaofei.com/img/202112231755605-labview-statemachine-2.png" alt=""></p><h3 id="3-2-程序框图">3.2 程序框图</h3><p><strong>程序框图如下：</strong></p><p><img src="https://img.mahaofei.com/img/202112231755931-labview-statemachine-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231755009-labview-statemachine-4.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231756725-labview-statemachine-5.png" alt=""></p><p><strong>枚举类型的分支情况如下：</strong><br>  设置三项分别为：“开始”、“亮”、灭。然后在条件结构的分支处，<strong>右键-为每个值添加分支</strong><br>  其中左侧初始值与”开始“分支内的都是同一个枚举常量（即通过复制粘贴得到的）。</p><p><img src="https://img.mahaofei.com/img/202112231756475-labview-statemachine-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231757621-labview-statemachine-7.png" alt=""></p><h3 id="3-3-程序逻辑">3.3 程序逻辑</h3><ul><li><p>初始条件的输入值为“开始”，进入“开始”的条件分支进行判断。</p><ul><li>如果按钮按下，输出“亮”，并作为下一次条件的输入；</li><li>如果按钮未按下，输出“开始”，并作为下一次条件的输入，即保持原状态。</li></ul></li><li><p>如果条件的输入为“亮”，此时条件输出“灭”，并作为下一次的输入。</p></li><li><p>如果条件的输入为“灭”，此时条件输出“亮”，并作为下一次的输入。</p></li></ul><p>在“开始”和“灭”分支进行期间，为LED赋值False；在“亮”分支期间，为LED赋值True。</p><p>这样就实现了：启动程序后，程序一直循环执行“开始”分支，LED灯灭。按下按钮后，程序在“亮”分支和”灭“分支交替执行，实现LED灯的亮灭变化。</p><p>可以通过为while循环添加等待延时调整LED闪烁时间。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview子VI的创建与调用</title>
      <link href="/post/adea5358.html"/>
      <url>/post/adea5358.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="一、什么是子VI">一、什么是子VI</h2><p>  程序设计中很重要的一个思想就是模块化思想，也就是将程序划分为若干个区块，这样对程序某个区块进行修改就不会影响到其它区块。在Labview中，我们通过子VI来实现模块化的编程。</p><p>  任何一个VI本身就可以作为子VI被其他VI调用，子VI只是需要在普通VI的基础上定义连接端子和图标即可。当一个VI被其它VI调用，则该VI被称为子VI，子VI相当于程序语言中的子程序。</p><h2 id="二、子VI的创建与调用">二、子VI的创建与调用</h2><p>  这里以角度转弧度的函数为例，说明子VI的创建和调用方法。</p><h3 id="2-1-子VI的创建">2.1 子VI的创建</h3><p>  如下图是一个将角度转为弧度值的简单程序。</p><p><img src="https://img.mahaofei.com/img/202112231751031-labview-subvi-1.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231751951-labview-subvi-2.png" alt=""></p><p><strong>（1）定义接线端</strong><br>  在前面板中右上角的小框框中，点击选择一个接线端的位置，然后再点击这个接线端要对应的输入输出控件，若方块变红，说明这个接线端设置完成了。</p><p><img src="https://img.mahaofei.com/img/202112231752167-labview-subvi-3.png" alt=""></p><p>  例如，先点击小框框左上角的小方块，会发现点击的小方块变黑，然后点击角度控件，会看到小方块变橙色，这就说明子VI左上角的接线端被设定为角度输入。同理可设置右上角的接线端为弧度输出。</p><p><img src="https://img.mahaofei.com/img/202112231752811-labview-subvi-4.png" alt=""></p><p><strong>（2）设置图标</strong><br>  双击右上角的图标，可以打开一个图标编辑器。这里可以使用Labview的模板图标，也可以自己画图标，画图标的方法与windows中的画图工具很类似。</p><p><img src="https://img.mahaofei.com/img/202112231752559-labview-subvi-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231753259-labview-subvi-6.png" alt=""></p><h3 id="2-2-子VI的调用">2.2 子VI的调用</h3><p>  新建一个VI，在程序框图的空白处<strong>右键-选择VI…</strong>，打开刚才保存的子VI程序，可以看到我们刚刚创建的子VI被调用出来了。</p><p><img src="https://img.mahaofei.com/img/202112231753319-labview-subvi-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231753218-labview-subvi-8.png" alt=""></p><p>  可以利用这个子VI创建一个简单的正弦曲线。</p><p><img src="https://img.mahaofei.com/img/202112231754560-labview-subvi-9.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview实现画板</title>
      <link href="/post/eced631e.html"/>
      <url>/post/eced631e.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="一、所用控件介绍">一、所用控件介绍</h2><h3 id="1-1-二维图片">1.1 二维图片</h3><p>  添加方法：前面板右键，图形-控件-二维图片。<br>  二维图片控件可实现像素级控制，能用于创建几乎任何图形对象。如需在二维图片控件中显示图像，必须通过编程向该控件写入一个图像。可使用图片函数VI进行绘制。</p><h3 id="1-2-属性节点">1.2 属性节点</h3><p>  控件的属性节点和控件本身的属性是相同的，在控件上右键单击，选择  创建-属性节点-值，即可创建一个value属性节点</p><h2 id="二、使用二维图片空间画画">二、使用二维图片空间画画</h2><h3 id="2-1-目的">2.1 目的</h3><p><img src="https://img.mahaofei.com/img/202112231745172-labview-drawpad-1.png" alt=""></p><h3 id="2-2-程序设计思路">2.2 程序设计思路</h3><p>（1）使用二维图片的鼠标位置属性节点，获取当前鼠标的位置。<br>（2）使用图片函数中的绘制点函数，对传入的鼠标位置画点。<br>（3）利用移位寄存器将画好点的图片传入下一次循环，作为下一次循环时画点的画布。<br>（4）使用二维图片的鼠标按下属性节点，通过条件结构判断鼠标是否按下，以此控制是否画点。<br>（5）清屏可以使用一个条件结构，清屏按钮按下时，将空白画布传给移位寄存器。</p><h3 id="2-3-程序实现过程">2.3 程序实现过程</h3><p><strong>（1）获取鼠标位置</strong><br>  首先，在前面板创建一个二维图片（右键-图形-控件-二维图片）。然后在<strong>程序框图中</strong>右键二维图片控件，<strong>右键-创建-属性节点-鼠标</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231745410-labview-drawpad-2.png" alt=""></p><p>  将二维图片的属性节点按名称解绑，然后在Mouse Position的输出端点创建显示控件。这样就实现了获取鼠标位置。为整体添加一个while循环，运行看一下效果。</p><p><img src="https://img.mahaofei.com/img/202112231746815-labview-drawpad-3.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231746645-labview-drawpad-4.png" alt=""></p><p><strong>（2）画出当前点</strong><br>  在程序框图中，<strong>右键-图形与声音-图片函数-绘制点</strong>，将解绑出来的鼠标位置作为输入，二维图片空间作为输出。然后在颜色、画笔两个接线端上右键-创建输入控件。</p><p><img src="https://img.mahaofei.com/img/202112231746622-labview-drawpad-5.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231747657-labview-drawpad-6.png" alt=""></p><p><strong>（3）画出连续的点，即保存之前鼠标经过的点</strong><br>  将刚才画好点的二维图片，通过移位寄存器传入下一次循环，作为下一次循环要画点的初始图片。（注意：移位寄存器使用时一定要初始化）</p><p><img src="https://img.mahaofei.com/img/202112231747597-labview-drawpad-7.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231748368-labview-drawpad-8.png" alt=""></p><p><strong>（4）实现鼠标按下时画点</strong><br>  利用二维图片的鼠标属性节点的另一个属性，将鼠标按下这个属性节点拖出来，左键点击，选择<strong>Mouse Modifiers-Button Down</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231748577-labview-drawpad-9.png" alt=""></p><p>  这个属性节点的输出值是一个布尔值，因此我们使用条件结构实现此功能。条件为真，即按键按下时，画当前点；条件为假，即按键未按下时，不做任何操作。</p><p><img src="https://img.mahaofei.com/img/202112231749773-labview-drawpad-10.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231749016-labview-drawpad-11.png" alt=""></p><p><strong>（5）设置清屏按钮</strong><br>  清屏操作十分简单，只需要在前面板添加一个布尔按钮，然后在后面板利用条件结构判断按钮状态，如果按下，就将一个空白图片传给二维图片控件，如果未按下，则不进行任何操作。</p><p><img src="https://img.mahaofei.com/img/202112231749583-labview-drawpad-12.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231750002-labview-drawpad-13.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231750575-labview-drawpad-14.png" alt=""></p><p><strong>（5）调整一下面板布局、颜色和风格</strong></p><p><img src="https://img.mahaofei.com/img/202112231751449-labview-drawpad-15.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview多点正弦运动轨迹</title>
      <link href="/post/cc58d31e.html"/>
      <url>/post/cc58d31e.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="〇、须知">〇、须知</h2><h3 id="0-1-移位寄存器">0.1 移位寄存器</h3><p>  在循环结构的边框上右键，可以创建移位寄存器。</p><p>  移位寄存器用于将上一次循环产生的值传递至下一次循环。移位寄存器以成对接线端的形式出现，分别位于循环两侧的边框上，位置相对。</p><p>  右侧接线端含有一个向上的箭头，用于存储每次循环结束时的数据。LabVIEW会将连接到右侧寄存器的数据传递到下一次循环中。循环执行完毕后，右侧接线端将返回移位寄存器最后一次保存的值。</p><p>  移位寄存器需要初始化，即需要设置移位寄存器传递给第一次循环的值。</p><p><img src="https://img.mahaofei.com/img/202112231741015-labview-sine-1.png" alt=""></p><h3 id="0-2-NaN的使用">0.2 NaN的使用</h3><p>  NaN：Not a Number。使用时直接创建常量输入NaN即可。<br>  在绘制曲线时，NaN不会被显示在波形图上。</p><h3 id="0-3-启用索引与禁用索引">0.3 启用索引与禁用索引</h3><p>  将数组元素传入循环结构时，再循环结构的边框上会出现一个连接端子。<br>  启用索引：指每循环一次，数组的值依次传入一个，此时连接端子为空心。<br>  禁用索引：指无论循环如何，每次循环都会将整个数组传入，此时连接端子为实心。</p><p><img src="https://img.mahaofei.com/img/202112231741147-labview-sine-2.png" alt=""></p><h2 id="一、连续五个点正弦运动">一、连续五个点正弦运动</h2><h3 id="1-1-目标">1.1 目标</h3><p>  在波形图中生成正弦曲线的基础上，实现连续5个点在正弦曲线上跑的效果，如下图所示。</p><p><img src="https://img.mahaofei.com/img/202112231742682-labview-sine-3.png" alt=""></p><h3 id="1-2-实现思路">1.2 实现思路</h3><p>（1）产生一个正弦信号数组，数组的索引代表时间，数组的内容代表正弦信号值。<br>（2）将正弦信号数组，和一个长度相等、元素为NaN的数组同时传入循环结构。<br>（3）依次索引正弦信号数组的当前传入值和前4个值（如果有的话），并将NaN数组的对应位置用这五个数替换。<br>（4）正弦信号数组每传入一个数字，NaN数组就替换一次，同时更新一次波形，这样就实现了连续5个点在正弦曲线上运动的效果。</p><h3 id="1-3-程序框图设计过程">1.3 程序框图设计过程</h3><p><strong>（1）产生正弦信号数组</strong><br>  正弦信号数组的长度为360，相当于每个i对应1°，用正弦角度转弧度的公式即可计算出正弦值，360次循环就输出了一个周期的正弦数组。</p><p><img src="https://img.mahaofei.com/img/202112231742223-labview-sine-4.png" alt=""></p><p><strong>（2）创建一个长度相等、元素为NaN的数组</strong><br>  用到了<strong>数组大小</strong>和<strong>初始化数组</strong>这两个控件。数组大小控件传入一个数组，输出数组中元素的个数。初始化数组传入初始化元素和数组长度，输出一个数组。<br>  这里将正弦信号数组传入，然后初始化一个长度相同，元素全为NaN的数组。</p><p><img src="https://img.mahaofei.com/img/202112231742973-labview-sine-5.png" alt=""></p><p><strong>（3）索引前4个数并于当前值打包成一个数组</strong>（用于接下来按这个数组进行元素替换）<br>  先创建一个for循环，在循环结构的边框上右键-添加移位寄存器，然后拖拉左边的移位寄存器，使左边为4个端子，右边为一个端子，然后为移位寄存器添加初始值。<br>  将正弦数组传入for循环，然后连接到右侧移位寄存器上。（默认是以索引的方式传入数组，即每一次循环传入一个数据）<br>  使用创建数组控件，将当前值和前4个值打包成一个数组。</p><p><img src="https://img.mahaofei.com/img/202112231743979-labview-sine-6.png" alt=""></p><p>  这样实现的功能为：数组每传入一个值，会将传入的值和前4个值打包成一个数组，同时这个值会进入移位寄存器，更新移位寄存器中的四个值。<br><strong>（4）替换NaN数组的元素</strong><br>  这一步的目的是将NaN数组中的对应位置，替换成前5个打包好的值。这样一来，随着每次循环更新，NaN只有的这5个数也随着更新，表现在图上就是5个点在正弦曲线上跑。<br>  这一步的关键在于找到5个数的索引（即在数组中的位置）。由先前的逻辑可知，右侧for循环的 <strong>i</strong> 就是5个数中最后一个数的索引，前四个数是通过移位寄存器获得的，因此前4个数的索引是依次 -1。</p><p><img src="https://img.mahaofei.com/img/202112231743676-labview-sine-7.png" alt=""></p><p>  使用<strong>替换数组子集</strong>这个控件，其输入参数有三个：原数组，替换元素的索引，替换的元素。<br>  其中，原数组就是前面的NaN数组，因为每次循环，都需要传入整个数组，因此要<strong>禁用索引</strong>。并且由于内层for循环单次循环只替换一个数，需要将替换后的数组通过<strong>移位寄存器</strong>传到下一次循环继续进行元素替换。<br>  替换的元素，刚才打包的数组通过索引的方式，依次传入到内层for循环中，作为要替换的元素。同时for循环的次数也由这个数组长度确定了。<br>  替换元素的索引使用外层循环的 i （最后一个数的索引），减内层循环的 i （从0~4五次循环对应五个数）。<br><strong>（5）将原先的正弦数组和替换后的NaN数组打包显示</strong><br>  在前面板创建一个波形图控件。在程序框图使用创建数组控件连接两个数组和波形图控件即可。（注意：正弦数组也是每次循环传入全部数组，禁用索引）<br>  然后为大循环添加一个等待延时，否则一旦运行就直接执行完毕，看不到点的运动过程。</p><p><img src="https://img.mahaofei.com/img/202112231744293-labview-sine-8.png" alt=""></p><p><strong>注：前面板的曲线1（5个点）最好修改成其它线型，否则看不出效果</strong></p><p><img src="https://img.mahaofei.com/img/202112231744517-labview-sine-9.png" alt=""></p><h3 id="1-3-运行结果">1.3 运行结果</h3><p><img src="https://img.mahaofei.com/img/202112231744382-labview-sine-10.png" alt=""></p><h2 id="二、间隔五个点正弦运动">二、间隔五个点正弦运动</h2><h3 id="2-1-目标">2.1 目标</h3><p>  仍然是五个点在正弦曲线上跑，但是这次五个点不是连续的，而是有间隔的。</p><p><img src="https://img.mahaofei.com/img/202112231744824-labview-sine-11.png" alt=""></p><h3 id="2-2-实现思路">2.2 实现思路</h3><p>  因为目标是将NaN数组中的不连续点替换成相应的正弦坐标值。因此只需要将内循环的替换数组的索引乘一个系数，就可以实现不连续点的索引替换。比如系数为5，则之前外i-内i的结果是0-1-2-3-4，现在外i-内i的结果是0-5-15-20-25。<br>  虽然索引变了，但是替换的元素没有变，仍然是上一个元素，这样不是我们要的结果，我们需要将传入的数组也等间隔缩短同样的倍数，再配合移位寄存器找到前4个值，<strong>抽取数组</strong>这个控件可以实现我们的目的。</p><h3 id="2-3-程序框图">2.3 程序框图</h3><p><img src="https://img.mahaofei.com/img/202112231745651-labview-sine-12.png" alt=""></p><h3 id="拓展——香农采样定律">拓展——香农采样定律</h3><p>  为了不失真地恢复模拟信号，采样频率应该不小于模拟信号频谱中最高频率的2倍。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SLAM笔记】如何使用Eigen进行矩阵运算</title>
      <link href="/post/d41b04ed.html"/>
      <url>/post/d41b04ed.html</url>
      
        <content type="html"><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p><hr><h2 id="一、Eigen库的介绍与安装">一、Eigen库的介绍与安装</h2><h3 id="1-1-Eigen是什么">1.1 Eigen是什么</h3><p>  Eigen是一个C++开源的线性代数库，提供了快速的矩阵线性代数运算，解方程等功能。许多上层软件库也使用Eigen进行矩阵运算。<br>  Eigen是一个纯用头文件搭建起来的库，因此使用的时候，只需要引用它的头文件即可，不需要链接库文件。</p><h3 id="1-2-Eigen的安装">1.2 Eigen的安装</h3><p>  如果你的电脑上没有安装Eigen，可以输入下面的命令进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libeigen3-dev</span><br></pre></td></tr></table></figure><h2 id="二、Eigen库的基本使用">二、Eigen库的基本使用</h2><h3 id="2-1-Eigen库的引用">2.1 Eigen库的引用</h3><p>在cpp文件的开头插入如下两个头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure><p>在CMakeLists.txt内指定Eigen的头文件目录（如果把Eigen安装在了不同位址，就必须修改这里的头文件目录）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(<span class="string">&quot;/usr/include/eigen3&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-Eigen的基本语法">2.2 Eigen的基本语法</h3><table><thead><tr><th>功能</th><th>语法</th></tr></thead><tbody><tr><td>声明一个m行n列的 float 矩阵</td><td><code>eigen Eigen::Matrix&lt;float,m,n&gt; matrix_name;</code></td></tr><tr><td>声明一个三维列向量</td><td><code>Eigen::Vector3d vector_name;</code></td></tr><tr><td>声明一个三阶方阵</td><td><code>Eigen::Matrix3d matrix_name;</code></td></tr><tr><td>动态大小矩阵</td><td><code>Eigen::Matrix&lt;double,Eigen::Dynamic,Eigen::Dynamic&gt; matrix_name;</code></td></tr><tr><td>初始化矩阵为零矩阵</td><td><code>Eigen::Matrix3d matrix_name = Eigen::Matrix3d::Zero();</code></td></tr><tr><td>输入数据</td><td><code>matrix_name &lt;&lt; 1,2,3,4,5,6;</code></td></tr><tr><td>输出数据</td><td><code>cout &lt;&lt; matrix_name &lt;&lt; endl;</code></td></tr><tr><td>数据类型转换</td><td><code>matrix_name.cast&lt;double&gt;()</code></td></tr><tr><td>矩阵乘法</td><td><code>matrix_name1 * matrix_name2</code></td></tr><tr><td>转置</td><td><code>matrix_name.transpose();</code></td></tr><tr><td>各元素和</td><td><code>matrix_name.sum()</code></td></tr><tr><td>迹</td><td><code>matrix_name.trace()</code></td></tr><tr><td>逆</td><td><code>matrix_name.inverse()</code></td></tr><tr><td>行列式</td><td><code>matrix_name.determinant()</code></td></tr><tr><td>共轭矩阵</td><td><code>matrix_name.conjugate()</code></td></tr><tr><td>伴随矩阵</td><td><code>matrix_adjoint()</code></td></tr><tr><td>求特征值</td><td><code>Eigen::SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; eigenSolver(matrix3d);</code></td></tr><tr><td>特征值</td><td><code>eigenSolver.eigenvalues()</code></td></tr><tr><td>特征向量</td><td><code>eigenSolver.eigenvectors()</code></td></tr></tbody></table><h3 id="2-3-使用Eigen实现旋转变换">2.3 使用Eigen实现旋转变换</h3><ol><li><strong>三维旋转矩阵</strong>：创建一个三维矩阵即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：创建一个三阶单位矩阵</span></span><br><span class="line">Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>旋转向量</strong>：使用AngleAxis，可以使用这个它乘向量实现旋转操作（因为定义了运算符重载），括号内是旋转向量的角度和旋转轴</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个绕z轴旋转45°的旋转向量</span></span><br><span class="line"><span class="function">Eigen::AngleAxisd <span class="title">rotation_vector</span><span class="params">(M_PI/<span class="number">4</span>,Eigen::Vector3d(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>旋转向量转换为三维旋转矩阵</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将rotation_vector这个旋转向量转换为旋转矩阵并打印出来</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;rotation matrix = \n&quot;</span>&lt;&lt;rotation_vector.<span class="built_in">matrix</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">//或通过toRotationMatrix转换为旋转矩阵</span></span><br><span class="line">rotation_matrix = rotation_vector.<span class="built_in">toRotationMatrix</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>旋转矩阵转换为欧拉角</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将旋转矩阵转换为ZYX顺序的欧拉角，即yaw-pitch-roll</span></span><br><span class="line">Eigen::Vector3d euler_angles = rotation_matrix.<span class="built_in">eulerAngles</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;yaw pitch roll = &quot;</span>&lt;&lt;euler_angles.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>使用旋转向量进行坐标变换</strong>：因为对进行了运算符重载，旋转操作直接乘向量即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个x方向的向量，用前面定义的旋转向量进行旋转，然后输出旋转后的结果。</span></span><br><span class="line"><span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">Eigen::Vector3d v_rotated = rotation_vector * v;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;(1,0,0) after rotation = &quot;</span>&lt;&lt;v_rotated.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>用旋转矩阵进行坐标变换</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v_rotated = rotation_matrix * v;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;(1,0,0) after rotation = &quot;</span>&lt;&lt;v_rotated.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>使用变换矩阵进行坐标变换</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为T的变换矩阵,虽说是3d，但实际是4x4矩阵，Identity说明旋转是0，平移也是0</span></span><br><span class="line">Eigen::Isometry3d T=Eigen::Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line"><span class="comment">//将左上角的旋转矩阵设为按旋转向量rotation_vector旋转</span></span><br><span class="line">T.<span class="built_in">rotate</span>(rotation_vector);</span><br><span class="line"><span class="comment">//设置右上角的平移矩阵为[1,3,4]（旋转前平移）</span></span><br><span class="line">T.<span class="built_in">pretranslate</span>(Eigen::<span class="built_in">Vector3d</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">//因为运算符重载，变换矩阵可以直接乘三维向量</span></span><br><span class="line">Eigen::Vector3d v_transformed = T*v;</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>使用四元数</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个四元数</span></span><br><span class="line">Eigen::Quaterniond q;</span><br><span class="line"><span class="comment">//可以直接把旋转向量赋值给四元数</span></span><br><span class="line">q = Eigen::<span class="built_in">Quaterniond</span>(rotation_vector);</span><br><span class="line"><span class="comment">//也可以把旋转矩阵赋值给它</span></span><br><span class="line">q=Eigen::<span class="built_in">Quaterniond</span>(rotation_matrix);</span><br><span class="line"><span class="comment">//使用四元数旋转一个向量</span></span><br><span class="line">v_rotated = q*v;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SLAM笔记】三维刚体运动</title>
      <link href="/post/98891cce.html"/>
      <url>/post/98891cce.html</url>
      
        <content type="html"><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p><hr><h2 id="一、旋转矩阵">一、旋转矩阵</h2><h3 id="1-1-向量">1.1 向量</h3><p>  向量与坐标是两个不同的概念。向量只是有大小和方向的量。只有当指定了三维空间中某个坐标系的时候，才能谈论向量在此坐标系下的坐标。<strong>因此向量的坐标，既和向量本身有关，也和坐标系的选取有关。</strong><br>  向量的内积描述了向量之间的投影关系。</p><p><img src="https://img.mahaofei.com/img/202112231726158-slam-notes2-1.png" alt=""></p><p>  向量的外积，方向垂直于这两个向量，大小为|a||b|sin&lt;a,b&gt;。</p><p><img src="https://img.mahaofei.com/img/202112231727876-slam-notes2-2.png" alt=""></p><h3 id="1-2-欧氏变换">1.2 欧氏变换</h3><p>  两个坐标系之间的旋转、平移关系，统称为坐标系之间的变换关系。机器人运动过程中，往往会设定一个惯性坐标系（即世界坐标系），可以认为它是固定不动的。机器人则是一个移动坐标系。<br>  如果需要知道某个向量在机器人坐标系中与世界坐标系中如何转换的，就需要先得到该向量对机器人坐标系的坐标值，再根据机器人位姿转换到世界坐标系中，这个转换关系用矩阵T来描述。<br>  机器人移动是一个刚体运动，即同一个向量在各个坐标系下的长度和夹角都不会发生变化，这种变化就是<strong>欧式变换</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231727349-slam-notes2-3.png" alt=""></p><p><strong>（1）旋转矩阵</strong><br>  假设某个单位正交基($\boldsymbol{e_1}$,$\boldsymbol {e_2}$,$\boldsymbol{e_3}$)经过了一次旋转，变成了($\boldsymbol {e_1}‘$,$\boldsymbol{e_2}’$,$\boldsymbol {e_3}'$)，则对于同一个向量$\boldsymbol{a}$（该向量没有随坐标系旋转而运动），则可知</p><p>用矩阵表示如下</p><p><img src="https://img.mahaofei.com/img/202112231727592-slam-notes2-4.png" alt=""></p><p> <img src="https://img.mahaofei.com/img/202112231727422-slam-notes2-5.png" alt=""></p><p> 为了表示两个坐标之间的变换关系，等式两边同乘[$\boldsymbol{e_1}^T$ $\boldsymbol{e_2}^T$ $\boldsymbol{e_3}^T$]T，则左侧矩阵变成了单位矩阵：</p><p><img src="https://img.mahaofei.com/img/202112231728395-slam-notes2-6.png" alt=""></p><p>  中间这个行列式为1的正交矩阵，就是所谓的旋转矩阵。<br>  同时，此旋转矩阵的逆描述了一个相反的旋转。</p><p><img src="https://img.mahaofei.com/img/202112231729153-slam-notes2-7.png" alt=""></p><p><strong>（2)平移矩阵</strong><br>  平移矩阵十分简单，只需要将平移量加到旋转之后的坐标上就可以了。</p><p><img src="https://img.mahaofei.com/img/202112231729229-slam-notes2-8.png" alt=""></p><h3 id="1-3-变换矩阵">1.3 变换矩阵</h3><p>  使用下面这种形式进行变换时，变化多次之后往往会变得过于复杂且不满足线性关系。</p><p><img src="https://img.mahaofei.com/img/202112231729425-slam-notes2-9.png" alt=""></p><p>  因此通常我们会使用如下的齐次坐标和变换矩阵进行变换。即把三维向量末尾加一，变成四维向量，称为齐次坐标$\tilde{a}$。将旋转矩阵和平移矩阵写在同一个矩阵里面，这个矩阵T称为变换矩阵。</p><p><img src="https://img.mahaofei.com/img/202112231730503-slam-notes2-10.png" alt=""></p><p>  引入齐次坐标就可以实现多个变换矩阵的连乘，得到一个总的变换矩阵，实现多次变换的累加。</p><p><img src="https://img.mahaofei.com/img/202112231731355-slam-notes2-11.png" alt=""></p><h2 id="二、角轴和欧拉角">二、角轴和欧拉角</h2><h3 id="2-1-问题提出">2.1 问题提出</h3><p>  旋转矩阵有九个量，但一次旋转只有三个自由度，变换矩阵用十六个量表达六自由度变换，表达方式可能冗余。同时旋转矩阵本身要求必须是正交矩阵，变换矩阵一样都需要约束条件，有些情况下这些约束会使求解变得困难。</p><h3 id="2-2-角轴">2.2 角轴</h3><p><strong>（1）定义</strong><br>  <strong>任意旋转都可以用一个旋转轴和一个旋转角来刻画</strong>。我们可以使用一个向量，其方向与旋转轴一致，长度等于旋转角，这种向量就称为旋转向量或角轴。<br>  使用角轴表示方法只需要一个三维向量即可描述旋转。同样对于变换矩阵，我们使用一个角轴和一个平移向量即可表达。<br><strong>（2）角轴与旋转矩阵的转换</strong><br>  假设有一个旋转轴为$\boldsymbol {n}$，角度为θ的旋转，显然旋转向量为θ$\boldsymbol {n}$。由角轴转化为旋转矩阵，可以使用罗德里格斯公式：</p><p><img src="https://img.mahaofei.com/img/202112231731480-slam-notes2-12.png" alt=""></p><p>  同样也可以计算从旋转矩阵到角轴的转换。（由于旋转轴上的向量旋转后不发生变化，因此旋转轴就是旋转矩阵$\boldsymbol {R}$的特征值1对应的特征向量）。</p><p><img src="https://img.mahaofei.com/img/202112231732000-slam-notes2-13.png" alt=""></p><h3 id="2-3-欧拉角">2.3 欧拉角</h3><p>  旋转矩阵和角轴都不太直观，而欧拉角的表达方式比较利于人的理解。（但是在程序中不常用）<br>  欧拉将将旋转分解为三次不同轴上的转动，例如按Z-Y-X顺序转动，可以得到yaw-pitch-roll角。</p><blockquote><ol><li>绕物体的 Z 轴旋转，得到偏航角 yaw；</li><li>绕旋转之后的 Y 轴旋转，得到俯仰角 pitch；</li><li>绕旋转之后的 X 轴旋转，得到滚转角 roll。</li></ol></blockquote><p><img src="https://img.mahaofei.com/img/202112231732937-slam-notes2-14.png" alt=""></p><p>  欧拉角存在万向锁的问题，例如在ZYX顺序中，第一次绕Z轴旋转，第二次绕Y轴旋转90°，这时候x轴和系统初始时的Z轴重合了，导致第三次旋转和第一次是绕同一个轴旋转，丢失了一个自由度。所以程序中很少用欧拉角表示机器人的位姿。</p><p><img src="https://img.mahaofei.com/img/202112231732880-slam-notes2-15.png" alt=""></p><h2 id="三、四元数">三、四元数</h2><h3 id="3-1-简介">3.1 简介</h3><p>  四元数是一种扩展的复数。我们知道复数可以表示复平面内的旋转，乘i表示复平面内逆时针转90度，单位圆上的复数可以表达二维平面的旋转。<br>  四元数有三个虚部，可以表达三维空间中的旋转。</p><p><img src="https://img.mahaofei.com/img/202112231733226-slam-notes2-16.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231733270-slam-notes2-17.png" alt=""></p><p>  四元数的虚部相乘，类似于虚数i的相乘，也有对应的关系，且其关系很想三维空间中的叉积。</p><p><img src="https://img.mahaofei.com/img/202112231734265-slam-notes2-18.png" alt=""></p><h3 id="3-2-四元数的运算">3.2 四元数的运算</h3><table><thead><tr><th>运算</th><th>公式</th></tr></thead><tbody><tr><td>加减法</td><td><img src="https://img.mahaofei.com/img/202112231734688-slam-notes2-19.png" alt=""></td></tr><tr><td>乘法</td><td><img src="https://img.mahaofei.com/img/202112231734564-slam-notes2-20.png" alt=""></td></tr><tr><td>共轭</td><td><img src="https://img.mahaofei.com/img/202112231735700-slam-notes2-21.png" alt=""></td></tr><tr><td>模长</td><td><img src="https://img.mahaofei.com/img/202112231735117-slam-notes2-22.png" alt=""></td></tr><tr><td>逆</td><td><img src="https://img.mahaofei.com/img/202112231736441-slam-notes2-23.png" alt=""></td></tr><tr><td>数乘</td><td><img src="https://img.mahaofei.com/img/202112231736563-slam-notes2-24.png" alt=""></td></tr><tr><td>点乘</td><td><img src="https://img.mahaofei.com/img/202112231736291-slam-notes2-25.png" alt=""></td></tr></tbody></table><h4 id="3-3-用四元数表示旋转">3.3 用四元数表示旋转</h4><p><strong>（1）四元数与角轴、旋转矩阵的转换</strong></p><table><thead><tr><th>转换</th><th>公式</th></tr></thead><tbody><tr><td>角轴到四元数：</td><td><img src="https://img.mahaofei.com/img/202112231740376-slam-notes2-26.png" alt=""></td></tr><tr><td>四元数到角轴</td><td><img src="https://img.mahaofei.com/img/202112231740724-slam-notes2-27.png" alt=""></td></tr><tr><td>四元数到旋转矩阵</td><td><img src="https://img.mahaofei.com/img/202112231740443-slam-notes2-28.png" alt=""></td></tr></tbody></table><p><strong>（2）使用四元数表示旋转</strong></p><p>  四元数有三个虚部i, j, k，将三个坐标值作为三个虚部的系数，另实部为零，这样就将一个三维空间坐标转换为纯虚四元数表示的坐标。</p><p>  用一个四元数$\boldsymbol{q}$表示旋转。</p><p><img src="https://img.mahaofei.com/img/202112231740466-slam-notes2-29.png" alt=""></p><p>  空间点的旋转可以用四元数的乘法表示，旋转后的点$\boldsymbol{p’}$如下</p><p><img src="https://img.mahaofei.com/img/202112231741907-slam-notes2-30.png" alt=""></p><blockquote><p>参考：<strong>高翔-视觉SLAM十四讲</strong><br>相关Github：<a href="https://github.com/gaoxiang12/slambook">https://github.com/gaoxiang12/slambook</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview生成三维曲面 | 花瓶</title>
      <link href="/post/f3f368c1.html"/>
      <url>/post/f3f368c1.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h2 id="一、程序思路">一、程序思路</h2><p>花瓶这种回转曲面生成的本质是<strong>轮廓沿引导线扫描</strong>。<br><img src="https://img.mahaofei.com/img/202112231723953-labview-vise-1.png" alt=""><br>而对于花瓶来说，其生成方法就是一个圆沿一条曲线进行扫描</p><h3 id="1-1-底面圆轮廓的生成">1.1 底面圆轮廓的生成</h3><p><strong>圆的生成方法如下：</strong><br>循环总数为360，对应360度，i则对应从0~360的每一角度。将i转换为弧度制，即可得到圆上各点的x坐标和y坐标，将两个坐标进行捆绑，得到的就是圆这个曲线。<br><img src="https://img.mahaofei.com/img/202112231723797-labview-vise-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231724316-labview-vise-3.png" alt=""></p><h3 id="1-2-引导线的生成">1.2 引导线的生成</h3><p>花瓶的生成，就是平面曲线圆的基础上，再加一个z轴曲线，作为圆的扫描引导线，这里以正弦曲线作为圆的扫描引导线。<br><img src="https://img.mahaofei.com/img/202112231724512-labview-vise-4.png" alt=""></p><h3 id="1-3-圆沿引导线扫描">1.3 圆沿引导线扫描</h3><p>基本思路为：<br>在刚才生成圆的循环外，再套一个循环。循环的输入是引导线输出的数组。<br>引导线上每一个点位数据进入大循环时，内循环就画一个以此数据为半径的圆。<br>当引导线上所有数据都进入循环，生成了一个一次为半径的圆时，花瓶的侧面就完成了。<br>在前面板插入三维图形中的曲面控件即可看到生成的侧面。<br><img src="https://img.mahaofei.com/img/202112231724504-labview-vise-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231724697-labview-vise-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231725898-labview-vise-7.png" alt=""><br>生成哑铃状图像的原因是，刚才是以z轴正弦曲线的各个数据作为半径画圆，因此根据正弦图像，可以知道在<strong>起始、终止以及中间位置半径为零</strong>，画出来的图形也就是现在所看到的哑铃。<br><img src="https://img.mahaofei.com/img/202112231725038-labview-vise-8.png" alt=""><br>要解决这个问题，只需要将正弦曲线整体向上平移即可。<br><img src="https://img.mahaofei.com/img/202112231725571-labview-vise-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231725803-labview-vise-10.png" alt=""></p><h2 id="二、改进方法">二、改进方法</h2><h3 id="2-1-修复裂缝">2.1 修复裂缝</h3><p>可以看到生成的曲面上有一条裂缝，原因是起始点和终止点没有重合。<br><img src="https://img.mahaofei.com/img/202112231726918-labview-vise-11.png" alt=""><br>**解决方法：**将起始点添加到终止点，手动实现曲面封闭。索引数组中的第一个元素，将其添加到原数组的最后。<br><img src="https://img.mahaofei.com/img/202112231726775-labview-vise-12.png" alt=""></p><h3 id="2-2-添加底面">2.2 添加底面</h3><p>添加底面的方法十分简单，因为labview的三维曲面生成是连接相邻的点组成曲面，因此只需要在底面最中心添加一个点即可。<br><img src="https://img.mahaofei.com/img/202112231726743-labview-vise-13.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Labview绘制圆/椭圆</title>
      <link href="/post/b19eb912.html"/>
      <url>/post/b19eb912.html</url>
      
        <content type="html"><![CDATA[<p><strong>LabVIEW专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">https://blog.csdn.net/weixin_44543463/category_10714833.html</a></p><hr><h3 id="一、介绍-2">一、介绍</h3><p>1.1 for循环<br>for循环是固定次数的循环，其也有条件接线端，可以提前结束while循环，相当于C语言的break语句。for循环与数组操作是密不可分的，for循环最重要的功能就是处理数组数据。<br><img src="https://img.mahaofei.com/img/202112231720495-labview-circles-1.png" alt=""><br>1.2 XY图<br>将x数组和y数组进行捆绑，形成一系列x和y组合的数据，将捆绑后的结果传递给xy图，即可生成一条曲线。<br><img src="https://img.mahaofei.com/img/202112231721452-labview-circles-2.png" alt=""><br>1.3 创建数组<br>创建数组这个控件的作用是将元素添加入数组，或连接多个数组。向下拖动此控件，会自动增加新的输入端和输出端。<br><img src="https://img.mahaofei.com/img/202112231722169-labview-circles-3.png" alt=""><br>1.4 移位寄存器<br>添加移位寄存器后，循环结构的左右两侧的平行位置将各增加一个包含三角形的方框。左侧的方框代表上一次循环的运行结果，右侧的代表本次循环要输入的结果。<br><img src="https://img.mahaofei.com/img/202112231722025-labview-circles-4.png" alt=""></p><h3 id="二、实验目标">二、实验目标</h3><p>显示x坐标随角度的变化曲线，y坐标随角度的变化曲线。同时实时绘制一个椭圆，展示椭圆绘制的全过程。<br><img src="https://img.mahaofei.com/img/202112231722218-labview-circles-5.png" alt=""></p><h3 id="三、实验思路">三、实验思路</h3><p>以循环次数i作为角度变化，每循环一次相当于角度+1，角度从0到360，因此循环总数设置为360。<br>考虑圆的参数方程，x=r·cos(φ)，y=r·sin(φ)，这里以r=1为例。<br>因为循环次数作为角度，故每个循环对应的x和y的值的计算方法为：$\frac{iπ}{180}$<br>将生成的数据添加到移位寄存器传过来的数组中，再将x数据数组和y数据数组捆绑送给xy图即可。<br><img src="https://img.mahaofei.com/img/202112231722087-labview-circles-6.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Proteus仿真】220V转5V向单片机供电</title>
      <link href="/post/706260b4.html"/>
      <url>/post/706260b4.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、所用元器件介绍">一、所用元器件介绍</h3><p>1.1 仿真电源Alternator：用于仿真220v交流电源<br><img src="https://img.mahaofei.com/img/202112231717027-proteus-220to5-1.png" alt=""><br>1.2 变压器Tran-2p2s：对220v交流电源进行降压<br><img src="https://img.mahaofei.com/img/202112231717703-proteus-220to5-2.png" alt=""><br>1.3 桥式整流器2W005G：用于将交流电整流为直流电<br><img src="https://img.mahaofei.com/img/202112231718392-proteus-220to5-3.png" alt=""><br>1.4 无极性电容CAP<br><img src="https://img.mahaofei.com/img/202112231718821-proteus-220to5-4.png" alt=""><br>1.5 电解电容CAP-ELEC<br><img src="https://img.mahaofei.com/img/202112231718469-proteus-220to5-5.png" alt=""><br>1.6 三端稳压芯片7805<br><img src="https://img.mahaofei.com/img/202112231719763-proteus-220to5-6.png" alt=""></p><h3 id="二、接线方法">二、接线方法</h3><p><img src="https://img.mahaofei.com/img/202112231719201-proteus-220to5-7.png" alt=""></p><h3 id="三、仿真结果">三、仿真结果</h3><p><img src="https://img.mahaofei.com/img/202112231719617-proteus-220to5-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SLAM笔记】SLAM概述</title>
      <link href="/post/47f7138e.html"/>
      <url>/post/47f7138e.html</url>
      
        <content type="html"><![CDATA[<p><strong>SLAM笔记专栏：</strong><a href="https://blog.csdn.net/weixin_44543463/category_10925276.html">https://blog.csdn.net/weixin_44543463/category_10925276.html</a></p><h2 id="一、引言">一、引言</h2><p>对于一个移动机器人来说，我们往往需要它知道两件事：</p><ul><li>我在什么地方——定位</li><li>周围环境是什么样——建图</li></ul><h3 id="1-1-定位方法">1.1 定位方法</h3><p>对于定位来说，有许多方法可以使机器人确定自己的位置。主要分为两类：</p><ol><li>携带与机器人本体上的：轮式编码器、相机、激光等</li><li>安装于环境中的：导引线、二维码等</li></ol><p>其中安装于环境中的设备约束了外部环境，对环境要求较高，无法提供通用普遍的解决方案。而携带于机器人本体的传感器则可适用于未知环境。</p><p>在视觉SLAM中，我们更加注重考虑如何用相机解决定位和建图的问题。</p><h3 id="1-2-相机">1.2 相机</h3><p>相机按照工作方式可以分为三类。</p><p>单目相机：只使用一个摄像头进行SLAM。它获取的数据是一张张照片，照片以二维的形式反映了三维的世界，因此在单张图像里，无法确定一个物体的真实大小和物体的距离。如果我们想恢复三维结构，就必须转动相机的视角。</p><p>双目相机：使用两个摄像头测量。这样就消除了单目相机的尺度不确定性，可以测量物体的大小。并且两个摄像头间距（基线）越大，测量范围就越远。其缺点是配置和标定十分复杂，非常消耗计算资源。</p><p>深度相机：通过红外结构光或ToF原理，主动向物体发射并接受返回的光，测出物体离相机的距离。其通过物理手段测量，节省了大量的计算量，但缺点是测量范围窄、噪声大、事业小、易受日光干扰、无法测量投射材料等。</p><h2 id="二、经典SLAM框架">二、经典SLAM框架</h2><p><img src="https://img.mahaofei.com/img/202112231715582-slam-notes1-1.png" alt=""></p><h3 id="2-1-传感数据读取">2.1 传感数据读取</h3><p>传感数据信息读取主要为图像信息的读取和预处理，还可能有马盘、惯性传感器等信息的读取和同步。</p><h3 id="2-2-前端视觉里程计">2.2 前端视觉里程计</h3><p>视觉里程计的任务是估算相邻图像间相机的运动。由于是估计两张图间相机的运动，然后串联起来得到的机器人轨迹，所以仅通过视觉里程计来估算轨迹，不可避免会出现累计误差。为了解决这个问题所以有了后端优化和回环检测。</p><h3 id="2-3-后端优化">2.3 后端优化</h3><p>后端优化的任务是接受视觉里程计测得的相机位姿，接合回环检测的新息，得到全局一致的轨迹和地图。<br>后端优化主要是指处理SLAM过程中噪声的问题，主要是滤波和非线性优化算法等。</p><h3 id="2-4-回环检测">2.4 回环检测</h3><p>目的是判断机器人是否曾到达过先前的位置。主要解决位置随时间漂移的问题。</p><h3 id="2-5-建图">2.5 建图</h3><p>根据估计的轨迹，建立于任务要求对应的地图。地图的形式主要有两种：</p><ul><li>度量地图：用稀疏和稠密对他们分类。稀疏地图进行了一定程度的抽象，可以满足定位的需求。而导航时，我们需要稠密的地图，稠密地图由小方块或小格子表示，每个小块有占据、空闲、未知三种状态，这种地图可以用于各种导航算法。</li><li>拓扑地图：只由节点和边组成，只考虑节点之间的连通性。去掉了细节问题，是一种更紧凑的表达方式，但无法表达具有复杂结构的地图。</li></ul><h2 id="三、SLAM问题的数学表述">三、SLAM问题的数学表述</h2><p>机器人携带传感器在未知环境内运动时，相机会在离散的时刻采集一系列数据。</p><h3 id="3-1-运动方程——定位问题">3.1 运动方程——定位问题</h3><p>在这些离散时刻机器人的位置，用$x$表示机器人的位置。<br>由于传感器的不同，某时刻机器人的位置没有确定的计算方程，但可以知道<strong>每一时刻的位置都取决于上一时刻的位置以及传感器采集的数据</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231715709-slam-notes1-2.png" alt=""></p><p>其中，$u_k$为传感器读数，$w_k$为噪声。</p><h3 id="3-2-观测方程——建图问题">3.2 观测方程——建图问题</h3><p>设地图由多个路标组成，每个时刻传感器会测量到一部分路标点，得到这些点的观测数据。即机器人在$x_k$位置上测量到路标点$y_j$，产生了观测数据$z_{k,j}$。</p><p><img src="https://img.mahaofei.com/img/202112231716217-slam-notes1-3.png" alt=""></p><p>其中$v_{k,j}$为观测时的噪声。</p><h3 id="3-3-方程求解方法">3.3 方程求解方法</h3><p>按照运动和观测方程是否为线性，分为<strong>线性/非线性系统</strong>。<br>按照噪声是否服从高斯分布分类，分为<strong>高斯/非高斯系统</strong>。</p><ol><li>对于线性高斯系统，无偏最优估计可由卡尔曼滤波器给出。</li><li>对于复杂的非线性非高斯系统，使用扩展卡尔曼滤波和非线性优化两类方法解决。</li></ol><h2 id="四、Linux基础">四、Linux基础</h2><h3 id="4-1-编写程序Hello-SLAM">4.1 编写程序Hello SLAM</h3><p>在根目录下创建文件夹<code>/slam/ch01</code><br>使用vim或gedit或nano等编辑器，输入以下代码，保存为<code>helloSLAM.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello SLAM!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用cmake">4.2 使用cmake</h3><p>仍然在此目录下创建一个文件<code>CMakeLists.txt</code>，输入以下内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#声明要求的cmake最低版本</span><br><span class="line">cmake_minimum_required( VERSION <span class="number">2.8</span> )</span><br><span class="line"></span><br><span class="line">#声明一个cmake工程</span><br><span class="line">project( HelloSLAM )</span><br><span class="line"></span><br><span class="line">#添加一个可执行程序语法：add_executable( 可执行程序名 源代码文件名 )</span><br><span class="line">add_executable( helloSLAM helloSLAM.cpp )</span><br></pre></td></tr></table></figure><p>创建一个文件夹<code>mkdir build</code>用于保存变异生成的中间文件<br>进入<code>build</code>文件夹，使用以下代码进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>此时产生了一个名为<code>helloSLAM</code>的可执行文件，使用<code>./helloSLAM</code>即可执行此程序看到正确的输出。</p><h3 id="4-3-使用库">4.3 使用库</h3><p>C++中只有带有main函数的文件才会生成可执行程序，而其他代码，我们只需把它打包成库，供程序调用即可。<br><strong>（1）创建库</strong><br>在刚才的ch01文件夹下，创建一个名为<code>libHelloSLAM.cpp</code>的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello SLAM!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个库文件提供了一个printHello函数，但它没有main函数，因此不会生成可执行文件，我们需要告诉cmake，我想把这个文件编译成叫“hello”的库。在CmakeLists.txt内添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(hello_shared SHARED libHelloSLAM.cpp)</span><br></pre></td></tr></table></figure><blockquote><p>这里创建的是共享库。<br>在Linux中，库文件分成<strong>静态库</strong>和<strong>动态库</strong>两种。<br>静态库以.a后缀，每次被调用都会生成一个副本。<br>共享库以.so后缀，只有一个副本，更省空间。</p></blockquote><p>此时编译的话，可以得到一个libhello_shared.so的库文件</p><p><strong>（2）创建头文件</strong><br>创建一个名为<code>libHelloSLAM.cpp</code>的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBHELLOSLAM_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>（3）创建主程序</strong><br>创建一个名为<code>useHello.cpp</code>的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libHelloSLAM.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printHello</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CMakeLists.txt中添加生成可执行程序的生成命令，链接到刚才我们使用的库上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable( useHello useHello.cpp )</span><br><span class="line">target_link_libraries( useHello hello_shared )</span><br></pre></td></tr></table></figure><p>进行编译，得到<code>useHello</code>这个可执行文件。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> slam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS定位</title>
      <link href="/post/ebe88fe2.html"/>
      <url>/post/ebe88fe2.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、为什么需要定位">一、为什么需要定位</h4><p>某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子。</p><p>当滚动窗口时，某些模块是固定在屏幕中的某个位置。</p><p>以上两个效果通过标准流和浮动都无法快速实现，此时需要定位来实现。</p><h4 id="二、定位组成">二、定位组成</h4><p>定位：将盒子定在某一位置</p><p>定位 = 定位模式 + 边偏移</p><p>（定位模式用于指定元素在文档中的定位方式，边偏移则决定了该元素的最终位置）</p><p><strong>2.1 定位模式</strong></p><p>定位模式决定元素的定位方式，通过CSS的position属性设置</p><table><thead><tr><th>值</th><th>语义</th></tr></thead><tbody><tr><td>static</td><td>静态定位</td></tr><tr><td>relative</td><td>相对定位</td></tr><tr><td>absolute</td><td>绝对定位</td></tr><tr><td>fixed</td><td>固定定位</td></tr></tbody></table><p><strong>2.2 边偏移</strong></p><p>边偏移就是定位盒子移动到最终位置，有top、bottom、left、right四个属性</p><table><thead><tr><th>边偏移属性</th><th>示例</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>top: 80px</td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素上边线的距离</td></tr><tr><td>bottom</td><td>bottom: 80x</td><td><strong>底部</strong>偏移量，定义元素相对于其父元素下边线的距离</td></tr><tr><td>left</td><td>left: 80px</td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素左边线的距离</td></tr><tr><td>right</td><td>right: 80px</td><td>右侧偏移量，定义元素相对于其父元素右边线的距离</td></tr></tbody></table><h4 id="三、静态定位-static">三、静态定位 static</h4><p>静态定位是元素的默认定位方式，无定位的意思。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: static; &#125;</span><br></pre></td></tr></table></figure><ul><li>静态定位按照标准流摆放位置，没有边偏移</li></ul><h4 id="四、相对定位-relative">四、相对定位 relative</h4><p>相对定位是元素在移动位置的时候，是相对于它原来的位置来说的。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; positon: relative; &#125;</span><br></pre></td></tr></table></figure><ul><li>相对定位是相对自己原来的位置进行移动</li><li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。即<strong>相对定位并没有脱标</strong>。</li></ul><h4 id="五、绝对定位-absolute">五、绝对定位 absolute</h4><p>绝对定位是元素在移动位置的时候，相对于它祖先元素来说的。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位</p></li><li><p>父级有定位时（相对、绝对、固定定位），就会以最近一级带有定位的元素为参考点移动位置</p></li><li><p><strong>绝对定位不在占有原先位置</strong>。</p></li></ul><h4 id="六、子绝父相">六、子绝父相</h4><p>子级用绝对定位，父级用相对定位。</p><ol><li>子级绝对位置，不占有位置，可以放到父盒子里面的每一个地方，不会影响到其它的兄弟盒子</li><li>父盒子需要加定位限制子盒子在父盒子内显示</li><li>父盒子布局时，需要占有位置，因此父亲只能是相对定位</li></ol><h4 id="七、固定定位">七、固定定位</h4><p>固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: fixed; &#125;</span><br></pre></td></tr></table></figure><ol><li>以浏览器的可视窗口为参照点移动元素</li></ol><ul><li>跟父元素没有关系</li><li>不随着滚动条的滚动而滚动</li></ul><ol start="2"><li>固定定位不再占有原先的位置，也是脱标的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode中HTML与CSS代码的快速写法</title>
      <link href="/post/f28961f5.html"/>
      <url>/post/f28961f5.html</url>
      
        <content type="html"><![CDATA[<p>Emmet语法的前身是Zen coding，它使用缩写来提高html/css的编写速度，vscode内部已经集成该语法</p><h3 id="1-快速生成Html结构">1. 快速生成Html结构</h3><ul><li><p>生成标签，直接输入标签名，按<code>tab</code>键即可，比如div然后按tab键，就可以生成<code>&lt;div&gt;&lt;/div&gt;</code></p></li><li><p>如果想要生成多个相同标签，加上<code>*</code>就可以了，比如<code>div*3</code>可以快速生成三个div</p></li><li><p>如果有父子级关系的标签，可以用<code>&gt;</code>，比如ul &gt; li</p></li><li><p>如果有兄弟关系的标签，用<code>+</code>，比如div+p</p></li><li><p>如果生成带有类名或者id名的，直接写<code>.demo</code>或者<code>#two</code>，再按tab键即可，例如<code>div.banner</code></p></li><li><p>如果生成的div类名是有顺序的，可以使用自增符号<code>$</code>，例如<code>div.demo$*5</code></p></li><li><p>如果想要在生成的标签内部写内容可以用{}biaoshi</p></li></ul><h3 id="2-快速生成CSS样式">2. 快速生成CSS样式</h3><p>CSS取每个单词得首字母简写即可：</p><p>比如，ti2em，按tab，可以生成text-indent: 2em;</p><p>比如，w200，按tab，可以生成width: 200px;</p><h3 id="3-格式化代码">3. 格式化代码</h3><p>在VSCode中，保存时默认格式化代码，如果没有自动格式化可以按照如下步骤设置：</p><blockquote><p>【新版本】：</p><p>打开文件-首选项-设置，搜索format，勾选保存自动格式化。</p><p>【旧版本】：</p><p>打开：文件-&gt;首选项-&gt;设置</p><p>搜索：emmet.include</p><p>在setting.json下的【用户】中添加以下语句</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;editor.formatOnType&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>设置好以后，保存时都会格式化文档</p></blockquote><p>也可以手动格式化文档：右键-格式化文档，或者<code>Shift+Alt+F</code></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS浮动</title>
      <link href="/post/dfc42a6d.html"/>
      <url>/post/dfc42a6d.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、浮动">一、浮动</h2><h3 id="1-1-传统网页布局的三种方式">1.1 传统网页布局的三种方式</h3><p>CSS提供了三种传统布局方式：</p><ol><li>普通流（标准流）</li><li>浮动</li><li>定位</li></ol><p>三种布局方式都是用来摆放盒子的，盒子摆放到合适的位置，布局自然就完成了。</p><p>实际开发中，一个页面基本都包含了这三种布局方式（移动端有新的布局方式）</p><h3 id="1-2-标准流">1.2 标准流</h3><p>所谓标准流：就是标签按照规定好的默认方式排列</p><ol><li>块级元素独占一行，从上向下顺序排序<ul><li>div、hr、p、h1~h6、ul、ol、dl、form、table</li></ul></li><li>行内元素会按照顺序，从左到右顺序排序，碰到父元素边缘则会自动换行<ul><li>span、a、i、em</li></ul></li></ol><p>标准流是最基本的布局方式</p><h3 id="1-3-为什么需要浮动">1.3 为什么需要浮动</h3><p>有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排序方式。</p><p><strong>浮动的典型应用：块级元素横向排列</strong></p><p>多个块级元素纵向排列用标准流，多个块级元素横向排列找浮动。</p><h3 id="1-4-什么是浮动">1.4 什么是浮动</h3><p><strong>float</strong>属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘及包含块或另一个浮动框的边缘。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">float</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>元素不浮动（默认值）</td></tr><tr><td>left</td><td>元素向左浮动</td></tr><tr><td>right</td><td>元素向右浮动</td></tr></tbody></table><h3 id="1-5-浮动的特性">1.5 浮动的特性</h3><p><strong>（1）浮动元素会脱离标准流</strong></p><ul><li><p>多利标准流的控制，移动到指定位置（浮动）</p></li><li><p>浮动的盒子不再保留原先的位置</p><blockquote><p>如果有两个盒子一个设置浮动，一个没有</p><p><img src="https://img.mahaofei.com/img/202112231713946-html-notes5-1.png" alt=""></p></blockquote></li></ul><p><strong>（2）浮动的元素会在一行内显示并且元素顶部对齐</strong></p><ul><li>要在一行内显示，各个元素都要设置浮动特性</li><li>浮动的元素是互相贴靠在一起的，如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐</li></ul><p><strong>（3）浮动的元素会具有行内块元素的特性</strong></p><ul><li>任何元素都可以浮动，不管原先是什么元素，添加浮动之后都具有行内块元素相似的特性</li></ul><h3 id="1-6-浮动元素经常和标准流父级搭配使用">1.6 浮动元素经常和标准流父级搭配使用</h3><p>为了约束浮动元素位置，网页布局一般采取的策略是：</p><p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。<br><img src="https://img.mahaofei.com/img/202112231713850-html-notes5-2.png" alt=""></p><h2 id="二、常见网页布局">二、常见网页布局</h2><h3 id="2-1-常见网页布局">2.1 常见网页布局</h3><p><img src="https://img.mahaofei.com/img/202112231713951-html-notes5-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231713771-html-notes5-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231714289-html-notes5-5.png" alt=""></p><h3 id="2-2-浮动布局注意点">2.2 浮动布局注意点</h3><p><strong>（1）浮动和标准流父盒子配合使用</strong></p><p>先用标准流的父元素排列上下位置，之后内部子元素用浮动排列左右位置</p><p><strong>（2）一个元素浮动了，理论上其余的兄弟元素也要浮动</strong></p><p>一个盒子里面有多个滋贺子，如果其中一个盒子浮动了，那么其他兄弟元素也应该浮动，以防止引起问题。</p><p>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。</p><h2 id="三、清除浮动">三、清除浮动</h2><h3 id="3-1-为什么需要清除浮动">3.1 为什么需要清除浮动</h3><p>由于父盒子在很多情况下，不方便给高度，但是子盒子浮动又不占有位置，导致父盒子高度为0，进而影响下面的标准流盒子。<br><img src="https://img.mahaofei.com/img/202112231714645-html-notes5-6.png" alt=""></p><ul><li>浮动元素不在占用原标准流位置，所以会对后面元素的排版产生影响</li></ul><h3 id="3-2-清除浮动本质">3.2 清除浮动本质</h3><ul><li><p>清除浮动的本质就是清除浮动元素造成的影响</p></li><li><p>如果父盒子本身有高度，则不需要清除浮动</p></li><li><p>清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了</p></li></ul><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">clear</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table><p>实际工作中，几乎只用<code>clear:both</code></p><p>清除浮动的策略是：闭合浮动</p><h3 id="3-3-清除浮动的方法">3.3 清除浮动的方法</h3><p><strong>（1）额外标签法，也称为隔墙法</strong></p><p>额外标签法会在浮动元素末尾添加一个空标签。如<code>&lt;div style=&quot;&quot;clear:both&gt;&lt;/div&gt;</code>或其它标签<code>&lt;br/&gt;</code>等。</p><ul><li>优点：通俗易懂，书写方便</li><li>缺点：添加许多无意义的钱钱，结构化较差</li><li>注意：新增的空标签必须是一个块级元素。</li></ul><p><strong>（2）父级添加 overflow 属性</strong></p><p>可以给父级添加overflow属性，将其属性设置为hidden、auto或scroll。<code>overflow: hidden;</code></p><p>注意：给父元素添加代码</p><ul><li>优点：代码简洁</li><li>缺点：无法显示溢出的部分</li></ul><p><strong>（3）父级添加 after 伪元素</strong></p><p>:after 方式是额外标签发的升级版。也是给父元素添加。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加如下样式 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123; <span class="comment">/* IE6、7专有 */</span></span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为父元素添加clearfix类 */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;clearfix&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>优点：没有增加标签，结构更简单</li><li>缺点：照顾低版本浏览器</li></ul><p>（4）父级添加双伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加如下样式 */</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 为父元素添加clearfix类 */</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;clearfix&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>优点：代码更简洁</li><li>缺点：照顾低版本浏览器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS盒子模型</title>
      <link href="/post/eb803673.html"/>
      <url>/post/eb803673.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、盒子模型">一、盒子模型</h2><p>网页布局学习有三大核心，盒子模型，浮动和定位，学习盒子模型可以帮助我们很好的布局页面。</p><h3 id="1-1-网页布局的本质">1.1 网页布局的本质</h3><p>网页布局过程：</p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子Box</li><li>利用CSS设置盒子样式，然后摆放到相应位置</li><li>往盒子里面装内容</li></ol><p>因此网页布局的本质：利用CSS摆盒子</p><h3 id="1-2-盒子模型的组成">1.2 盒子模型的组成</h3><p>CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边框、外边距、内边距和实际内容</p><ol><li>border边框</li><li>content内容</li><li>padding内边距</li><li>margin外边距</li></ol><p><img src="https://img.mahaofei.com/img/202112231711309-html-notes4-1.png" alt=""></p><h3 id="1-3-边框border">1.3 边框border</h3><p><strong>boder</strong>可以设置元素的边框。边框有三部分组成：边框粗细、边框样式、边框颜色</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: border-width || border-style || border-color</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>border-width</td><td>定义边框粗细，单位是px</td></tr><tr><td>border-style</td><td>边框的样式（none默认无|solid实线|dashed虚线|dotted点线）</td></tr><tr><td>border-color</td><td>边框颜色（默认黑色）</td></tr></tbody></table><p><strong>（1）边框的复合写法：</strong>（没有顺序）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure><p><strong>（2）边框的分开写法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure><p><strong>（3）表格的细线边框</strong></p><p><strong>border-collapse</strong>属性控制浏览器绘制表格边框的方式。（绘制表格时两个单元格的边框重叠在一起，边框宽度会变粗）</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>-collpse: collapse;</span><br></pre></td></tr></table></figure><ul><li>collpse单词是合并的意思</li><li>border-collapse: collapse;表示相邻边框合并在一起</li></ul><p><strong>（4）边框会影响盒子大小</strong></p><p>边框会额外增加盒子的实际大小，因此我们有两种方案解决：</p><ol><li>测量盒子大小的时候，不量边框</li><li>如果测量的时候包含了边框，则需要width/height减去边框宽度</li></ol><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231711571-html-notes4-2.png" alt=""></p><h3 id="1-4-内边距padding">1.4 内边距padding</h3><p>padding属性用于设置内边距，即边框与内容之间的距离。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>padding-left</td><td>左内边距</td></tr><tr><td>padding-right</td><td>右内边距</td></tr><tr><td>padding-top</td><td>上内边距</td></tr><tr><td>padding-bottom</td><td>下内边距</td></tr></tbody></table><p><strong>padding简写</strong>：</p><table><thead><tr><th>值的个数</th><th>释义</th></tr></thead><tbody><tr><td>padding: 5px;</td><td>1个值，代表上下左右都有5px内边距</td></tr><tr><td>padding: 5px 10px;</td><td>2个值，代表上下内边距是5px，左右内边距是10px</td></tr><tr><td>padding: 5px 10px 20px;</td><td>3个值，代表上内边距5px，左右内边距10px，下内边距20px</td></tr><tr><td>padding: 5px 10px 20px 30px;</td><td>4个值，上是5px，右是10px，下是20px，左是30px（顺时针）</td></tr></tbody></table><p><strong>padding影响了盒子实际大小</strong></p><p>如果盒子已经有了宽度和高度，此时再指定内边框，会增大盒子。即内容不变只能使盒子变大。</p><p>解决方案：width/height减去多出来的内边距大小</p><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231712713-html-notes4-3.png" alt=""></p><h3 id="1-5-外边距margin">1.5 外边距margin</h3><p><strong>margin</strong>属性用于设置外边距，即控制盒子和盒子之间的距离</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>margin-left</td><td>左外边距</td></tr><tr><td>margin-right</td><td>右外边距</td></tr><tr><td>margin-top</td><td>上外边距</td></tr><tr><td>margin-bottom</td><td>下外边距</td></tr></tbody></table><p>margin的简写方式与padding一致。</p><p><strong>（1）外边距的典型应用</strong></p><p>margin可以让<strong>块级盒子水平居中</strong>，但必须满足两个条件：</p><ol><li>盒子必须指定宽度（width）</li><li>盒子左右的外边距都设置为auto。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123; <span class="attribute">width</span>: <span class="number">960px</span>; <span class="attribute">margin</span>: <span class="number">0</span> auto; &#125;</span><br></pre></td></tr></table></figure><p>以下三种写法都可以：</p><ul><li>margin-left:auto; margin-right:auto;</li><li>margin: auto;</li><li>margin: 0 auto;</li></ul><p><strong>行内元素或行内块元素水平居中</strong>：给父元素添加 text: align:center 即可。</p><p><strong>（2）外边距合并</strong></p><p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p><ol><li>相邻块元素垂直外边距的合并</li></ol><p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则它们之间的垂直间距不是两者之和。<strong>取两个值中较大者，这种现象被称为相邻块元素垂直外边距的合并。</strong></p><p>解决方案：尽量只给一个盒子添加margin值。</p><ol start="2"><li>嵌套块元素垂直外边距的塌陷</li></ol><p>对于两个嵌套关系（父子关系）的元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><p><img src="https://img.mahaofei.com/img/202112231712550-html-notes4-4.png" alt=""></p><p>解决方案：</p><ol><li>为父元素定义上边框</li><li>为父元素定义上内边距</li><li>为父元素添加overflow:hidden</li></ol><h3 id="1-6-清除内外边距">1.6 清除内外边距</h3><p>网页元素很多都带有默认的内外编剧，而且不同浏览器默认的值也不一致。因此我们在布局前，首先要清除网页元素的内外边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。</p><h2 id="二、特殊样式">二、特殊样式</h2><h3 id="2-1-圆角边框">2.1 圆角边框</h3><p>CSS3中新增了圆角边框杨适，这样我们的盒子就可以变圆角了。</p><p><strong>border-radius</strong>属性用于设置元素的外边框圆角</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>:length;</span><br></pre></td></tr></table></figure><ul><li><p>参数值可以为数值或百分比</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果是正方形，想要设置为一个圆，把数值修改为高度或宽度的一般即可，或者直接写为50%</p><p>同理如果是个矩形，半径设置为高度的一般就成了圆角矩形</p></li><li><p>该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角。跟两个值，分别代表左上右下、右上左下。</p></li><li><p>圆角边框也可以分开写：如border-top-left-radius</p></li></ul><p><img src="https://img.mahaofei.com/img/202112231712931-html-notes4-5.png" alt=""></p><h3 id="2-2-盒子阴影">2.2 盒子阴影</h3><p>CSS3中新增了盒子阴影，可以使用box-shadown属性为盒子添加阴影。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必须。水平阴影的位置，允许负值。</td></tr><tr><td>v-shadow</td><td>必须。垂直阴影的位置，允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>spread</td><td>可选。阴影的尺寸。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr><tr><td>inset</td><td>可选。将外部阴影outset改为内部阴影</td></tr></tbody></table><ul><li>默认是外阴影outset，但是不可以写outset，否则会使阴影失效</li><li>盒子阴影不占用空间，不影响其他盒子的位置</li></ul><p>例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> -<span class="number">3px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231712448-html-notes4-6.png" alt=""></p><h3 id="2-3-文字阴影">2.3 文字阴影</h3><p><strong>text-shadow</strong>属性可以将阴影应用于文本</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: h-shadow v-show blur color;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>描述</th></tr></thead><tbody><tr><td>h-shadow</td><td>必须。水平阴影的位置，允许负值。</td></tr><tr><td>v-shadow</td><td>必须。垂直阴影的位置，允许负值。</td></tr><tr><td>blur</td><td>可选。模糊距离。</td></tr><tr><td>color</td><td>可选。阴影的颜色。</td></tr></tbody></table><blockquote><p>本文参考了黑马程序员pink老师的视频教程<br><strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS进阶</title>
      <link href="/post/e36aeffb.html"/>
      <url>/post/e36aeffb.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS的复合选择器">一、CSS的复合选择器</h2><h3 id="1-1-复合选择器">1.1 复合选择器</h3><p>CSS中根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合而成的。</p><ul><li><p>复合选择器可以更准确、更高效的选择目标标签</p></li><li><p>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的。</p></li><li><p>常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等等</p></li></ul><h3 id="1-2-后代选择器">1.2 后代选择器</h3><p>后代选择器又称包含选择器，可以选择父元素里面的子元素。其写法就是把<strong>外层元素写在前面</strong>，<strong>内层元素写在后面</strong>，<strong>中间用空格分离</strong>。放标签发生嵌套时，内层标签就成为外层标签的后代。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素1 元素2 &#123;属性1: 属性值1...&#125;</span><br></pre></td></tr></table></figure><p>上述语法表示：<strong>选择元素1里面的所有元素2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例:选择ul里面所有li标签 --&gt;</span></span><br><span class="line">ul li &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><ul><li><p>元素2可以是子元素，也可是子元素的子元素,只要是元素1的后代即可</p></li><li><p>元素1和元素2可以是任意基础选择器，例如<code>.nav li a</code> {}</p></li></ul><h3 id="1-3-子选择器">1.3 子选择器</h3><p>子元素选择器，只能选择某元素的最近一级元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素1&gt;元素2 &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><p>上述语法表示：<strong>选择元素1里面的所有直接后代元素2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例:选择div里面所有最近一级p标签 --&gt;</span></span><br><span class="line">div&gt;p &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-并集选择器">1.4 并集选择器</h3><p>并集选择器可以选择多组标签，通常用于集体声明</p><p>并集选择器是各选择器通过<strong>英文逗号“，”连接而成</strong>，<strong>任何形式的选择器都可以</strong>作为并集选择器的一部分</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素1, 元素2 &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><p>上述语法表示<strong>选择元素1和元素2</strong></p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择u1和div标签元素 --&gt;</span></span><br><span class="line">u1, div &#123; 样式声明 &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-伪类选择器">1.5 伪类选择器</h3><p>伪类选择器用于向某些选择器添加特殊效果，比如给链接添加特殊效果，或者选择第1个，第n个元素</p><p>伪类选择器书写的最大特点是用**冒号“:”表示，比如<code>:first-child</code>，<code>:hover</code></p><p>伪类选择器有很对，如链接伪类、结构伪类等。</p><p><strong>（1）链接伪类选择器</strong></p><p>链接伪类选择器常用于，鼠标经过链接时，链接的颜色或其他样式发生改变。</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>a:link</td><td>选择所有未被访问的链接</td></tr><tr><td>a:visited</td><td>选择所有已被访问的链接</td></tr><tr><td>a:hover</td><td>选择鼠标指针位于其上的链接</td></tr><tr><td>a:active</td><td>选择活动链接（鼠标按下未弹起的链接）</td></tr></tbody></table><p>注意事项：</p><ul><li>为了确保生效，请按照<strong>LVHA</strong>的顺序声明：link - visited - hover active</li><li>因为a链接在浏览器中有默认的样式，因此实际工作中都需要给链接单独指定样式</li></ul><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">color: gray;</span><br><span class="line">text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a:hover &#123;</span><br><span class="line">color: skyblue;</span><br><span class="line">text-decoration: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）:focus伪类选择器</strong></p><p><strong>:focus伪类选择器</strong>用于选取获得焦点的表单元素</p><p>焦点就是光标，一般情况<code>&lt;input&gt;</code>类表单元素才能获取，因此这个选择器也主要针对表单元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input:focus &#123;</span><br><span class="line">background-color: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-复合选择器总结">1.6 复合选择器总结</h3><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择后代元素</td><td>可以是子、孙</td><td>较多</td><td>符号是<strong>空格</strong>，.nav a</td></tr><tr><td>子代选择器</td><td>选择最近一级元素</td><td>只选子</td><td>较少</td><td>符号是<strong>大于</strong>，.nav&gt;p</td></tr><tr><td>并集选择器</td><td>选择某些相同样式的元素</td><td>可以用于集体声明</td><td>较多</td><td>符号是<strong>逗号</strong>，.nav, .header</td></tr><tr><td>链接伪类选择器</td><td>选择不同状态的链接</td><td>跟链接相关</td><td>较多</td><td>重点记住a{}和a:hover实际开发的写法</td></tr><tr><td>:focus选择器</td><td>选择获得光标的表单</td><td>跟表单相关</td><td>较少</td><td>input:focus</td></tr></tbody></table><h2 id="二、CSS的元素显示模式">二、CSS的元素显示模式</h2><h3 id="2-1-什么是元素显示模式">2.1 什么是元素显示模式</h3><p>网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好地布局我们的网页。</p><p>元素显示模式就是元素（标签）以什么形式进行显示，比如<code>&lt;div&gt;</code>自己占一行，而一行可以放多个<code>&lt;span&gt;</code></p><p>HTML元素一般分为<strong>块元素</strong>和<strong>行内元素</strong>两种类型</p><h3 id="2-2-块元素">2.2 块元素</h3><p>常见的块元素有 <code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>等，其中<code>div</code>是最典型的块元素</p><ul><li>块元素子集独占一行</li><li>高度，宽度，外边距，内边距都可以控制</li><li>宽度默认是容器父级的100%</li><li>是一个容器或盒子，里面可以放行内元素或块元素</li></ul><p>注意：文字类的元素内不能使用块级元素，<code>&lt;p&gt;</code>内不能放块级元素<code>&lt;div&gt;</code>等，同理<code>&lt;h1&gt;~&lt;h6&gt;</code>等都是文字类块级标签，里面也不能放其他块级元素。</p><h3 id="2-3-行内元素">2.3 行内元素</h3><p>常见的行内元素有<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;span&gt;</code>等，其中<code>&lt;span&gt;</code>是最典型的行内元素，有些地方也称行内元素为内联元素。</p><ul><li>相邻行内元素在一行上，一行可以放多个行内元素</li><li>高、宽直接设置是无效的</li><li>默认宽度就是本身内容的宽度</li><li>行内元素只能容纳文本或其他行内元素</li></ul><p>注意：链接里面不能再放链接，但特殊情况下a标签内可以放块级元素。</p><h3 id="2-4-行内块元素">2.4 行内块元素</h3><p>在行内元素中有几个特殊的标签：<code>&lt;img&gt;</code>、<code>&lt;imput&gt;</code>、<code>&lt;td&gt;</code>，他们同时具有块元素和行内元素的特点。</p><ul><li>和相邻行内元素或行内块元素在一行上，但是它们之间会有空隙，一行可以显示多个</li><li>默认宽度是本身内容的宽度</li><li>高度、行高、外边距和内边距都可以控制</li></ul><h3 id="2-5-元素显示模式总结">2.5 元素显示模式总结</h3><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置宽度高度</td><td>容器的100%</td><td>可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以直接设置宽度高度</td><td>本身内容的宽度</td><td>只可以包含行内元素</td></tr><tr><td>行内块元素</td><td>一行可以放多个行内块元素</td><td>可以直接设置宽度高度</td><td>本身内容的宽度</td><td></td></tr></tbody></table><h3 id="2-6-元素显示模式的转换">2.6 元素显示模式的转换</h3><p>特殊情况下，我们需要元素模式的转换，简单理解就是，一个模式的元素需要另外一种模式的特性</p><p>例如，想要增大链接<code>&lt;a&gt;</code>的触发范围</p><p><strong>转换为块元素：<code>display:block</code></strong></p><p>转换为行内元素：<code>display:inline</code></p><p><strong>转换为行内块元素：<code>display:inline-block</code></strong></p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">    display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、CSS的背景">三、CSS的背景</h2><p>通过CSS背景属性可以为页面内元素添加背景样式</p><p>背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。</p><h3 id="3-1-背景颜色">3.1 背景颜色</h3><p><strong>background-color</strong> 可以设置背景颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-color: 颜色值</span><br></pre></td></tr></table></figure><p>颜色参数：transparent 透明（默认）或color</p><h3 id="3-2-背景图片">3.2 背景图片</h3><p><strong>background-image</strong> 属性描述了元素的背景图像。实际开发常见于logo或者一些装饰性的小图片或者超大的背景图片，优点是非常便于控制位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: none|url</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>无背景（默认）</td></tr><tr><td>url</td><td>使用绝对或相对地址指定背景图像</td></tr></tbody></table><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-image: url(images/background.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-背景平铺">3.3 背景平铺</h3><p><strong>background-repeat</strong> 使HTML页面上对背景图像进行平铺</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-repeat: repeat | no-repeat | repeat-x | repeat-y</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td>repeat</td><td>背景图像在纵向和横向上平铺（默认）</td></tr><tr><td>no-repeat</td><td>背景图像不平铺</td></tr><tr><td>repeat-x</td><td>背景图像在横向平铺</td></tr><tr><td>repeat-y</td><td>背景图像在纵向平铺</td></tr></tbody></table><p>页面元素既可以添加背景颜色，也可以添加背景图片，背景图片在上层。</p><h3 id="3-4-背景位置">3.4 背景位置</h3><p><strong>background-position</strong> 可以改变图片在背景中的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-position: x y;</span><br></pre></td></tr></table></figure><p>参数是：x坐标和y坐标，可以使用方位名词或者精确单位</p><table><thead><tr><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>百分数|由浮点数字和单位标识符组成的长度值</td></tr><tr><td>position</td><td>top|center|bottom|left|center|right 等方位名词</td></tr></tbody></table><p><strong>（1）参数为方位名词</strong></p><ul><li>如果指定的两个词都是方位名词，则两个值前后顺序无关，比如left top和top left效果一致</li><li>如果只指定了一个方位名词，另一个忽略，则第二个默认居中对齐</li></ul><p><strong>（2）参数为精确单位</strong></p><ul><li>如果参数值是精确坐标，那么第一个一定是x坐标，第二个一定是y坐标</li><li>如果只指定了一个数值，则数值一定指x，y坐标默认垂直居中</li></ul><p><strong>（3）参数为混合单位</strong></p><ul><li>如果指定的两个值是精确单位和方位名词混合使用，第一个值一定是x坐标，第二个是y坐标</li></ul><h3 id="3-5-背景固定">3.5 背景固定</h3><p><strong>background-attachment</strong> 属性设置背景图像是否固定或者随着页面的区域部分滚动，可以制作视差滚动的效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-attachment: scroll | fixed</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>scroll</td><td>背景图像是否随对象内容滚动（默认）</td></tr><tr><td>fixed</td><td>背景图像固定</td></tr></tbody></table><h3 id="3-6-背景属性复合写法">3.6 背景属性复合写法</h3><p>为了简化背景属性的代码，我们可以将这些属性合并简写在同一个background属性中，减少代码量。</p><p>当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：</p><p><strong>background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</strong></p><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: transparent url(image.jpg) repeat-none fixed top center</span><br></pre></td></tr></table></figure><h3 id="3-7-背景色半透明">3.7 背景色半透明</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(0, 0, 0, 0.3);</span><br></pre></td></tr></table></figure><p>四个参数分别为<strong>r，g，b和alpha透明度</strong>，最后一个alpha透明度取值范围为0~1，0代表完全透明。</p><p>此属性只是让背景颜色半透明，里面的内容不受影响。</p><h3 id="3-8-背景总结">3.8 背景总结</h3><table><thead><tr><th>属性</th><th>作用</th><th>值</th></tr></thead><tbody><tr><td>background-color</td><td>背景颜色</td><td>预定义的颜色值/十六进制/RGB代码</td></tr><tr><td>background-image</td><td>背景图片</td><td>url(图片路径)</td></tr><tr><td>background-repeat</td><td>是否平铺</td><td>repeat/no-repeat/repeat-x/repeat-y</td></tr><tr><td>background-position</td><td>背景位置</td><td>length/position 分别是x 和 y坐标</td></tr><tr><td>background-attachment</td><td>背景附着</td><td>scroll背景滚动、fixed背景固定</td></tr><tr><td>背景简写</td><td>减少代码量</td><td>背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置</td></tr><tr><td>背景色半透明</td><td>颜色半透明</td><td>background: rgba(0,0,0,0.3);</td></tr></tbody></table><p>背景图片：实际开发中常用于装饰性的小图片，或者超大的背景图片，优点是非常便于控制位置。</p><h2 id="四、CSS三大特性">四、CSS三大特性</h2><p>CSS由三个非常重要的特性：层叠性、继承性、优先级</p><h3 id="4-1-层叠性">4.1 层叠性</h3><p>相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题。</p><p>层叠的原则是：</p><ul><li>样式冲突，遵循就近原则，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，则不会层叠</li></ul><h3 id="4-2-继承性">4.2 继承性</h3><p>子标签会继承父标签的某些样式，如文本颜色和字号等。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>div内的p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时如果设置div的样式，则p标签也会继承div的样式。</p><p>可继承的样式有：text-，font-，line-这些元素开头的可以继承，以及color属性。</p><p><strong>行高的继承性</strong>：</p><p>行高可以跟单位，也可以不跟单位</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">font: 12px/1.5;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的1.5代表当前元素文字大小的1.5倍。即div中的行高是21px，body中其它标签的行高默认是18px。</p><h3 id="4-3-优先级">4.3 优先级</h3><p>当同一个元素指定多个选择器，就会有优先级的产生。</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，则根据选择器权重执行</li></ul><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承 或 通配符选择器*</td><td>0,0,0,0</td></tr><tr><td>元素选择器</td><td>0,0,0,1</td></tr><tr><td>类选择器，伪类选择器</td><td>0,0,1,0</td></tr><tr><td>ID选择器</td><td>0,1,0,0</td></tr><tr><td>行内样式 style=“”</td><td>1,0,0,0</td></tr><tr><td>!important</td><td>最大</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: skyblue <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.test</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: greenyellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: pink;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总而言之，<strong>作用范围越大，权重越低，作用范围越小，权重越高。</strong></p><p><strong>权重叠加</strong>：</p><p>如果是复合选择器，则会有权重叠加，需要计算权重</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ul内的li权重是0,0,0,1+0,0,0,1=0,0,0,2 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: darkcyan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* li的权重是0,0,0,1 */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* .nav内的li权重是0,0,1,0+0,0,0,1=0,0,1,1 */</span></span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>权重只会叠加，不会进位</li><li>权重比较是从左到右逐位进行比较</li></ul><blockquote><p>本文参考了黑马程序员pink老师的视频教程<br><strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | CSS基础</title>
      <link href="/post/4d1b2e53.html"/>
      <url>/post/4d1b2e53.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS简介">一、CSS简介</h2><p>CSS的主要使用目的就是美化网页，布局页面</p><h3 id="1-1-HTML的局限性">1.1 HTML的局限性</h3><p>HTML只关注内容的语义，比如<code>&lt;h1&gt; </code>只表明这是一个标题，<code>&lt;p&gt; </code>只表明这是一个段落等。</p><p>只用HTML时，网页显示效果很不好看。因为HTML可以做简单的样式，但是十分繁琐和臃肿。</p><p><strong>即，HTML主要做结构，显示元素内容。</strong></p><h3 id="1-2-CSS的作用">1.2 CSS的作用</h3><p>CSS是层叠样式表的简称，也成为CSS样式表或级联样式表。</p><p>CSS也是一种标记语言，主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p><p><strong>简单来说，CSS可以美化HTML，让页面布局更简单。</strong></p><h3 id="1-3-CSS语法规范">1.3 CSS语法规范</h3><p>CSS规则有两个主要部分组成：选择器以及一条或多条声明。</p><p><code>选择器 &#123;属性:值 属性:值&#125;</code></p><p>选择器是用于指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式。</p><p>属性和属性值以“键值对”的形式出现</p><h3 id="1-4-CSS代码风格">1.4 CSS代码风格</h3><p>代码风格推荐</p><ol><li><p>样式格式书写</p><ul><li><p>展开格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h3 &#123;</span><br><span class="line">color: blue;</span><br><span class="line">font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>样式大小写</p><ul><li>样式选择器，属性名，属性值关键字全部使用小写字母，特殊情况除外。</li></ul></li><li><p>空格规范</p><ul><li>在属性值前面，冒号后面，保留一个空格；</li><li>选择器和大括号中间保留空格</li></ul></li></ol><h2 id="二、CSS基础选择器">二、CSS基础选择器</h2><h3 id="2-1-CSS选择器的作用">2.1 CSS选择器的作用</h3><p>选择器就是根据不同需求把不同的标签选出来，这就是选择器的作用，简单来说，<strong>就是选择标签用的</strong>。</p><h3 id="2-2-选择器的分类">2.2 选择器的分类</h3><p>选择器分为<strong>基础选择器和复合选择器</strong></p><p>其中，基础选择器是由单个选择器组成的</p><p>基础选择器又包括：标签选择器、类选择器、id选择器和通配符选择器</p><h3 id="2-3-标签选择器">2.3 标签选择器</h3><p>使用<strong>HTML标签名</strong>作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标签名 &#123;</span><br><span class="line">属性1: 属性值1;</span><br><span class="line">属性2: 属性值2;</span><br><span class="line">属性3: 属性值3;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：把某一类标签全部选择出来，例如所有的<code>&lt;div&gt;</code>标签，所有的<code>&lt;p&gt;</code>标签。</p><p><strong>优点</strong></p><p>能快速为页面中同类型的标签统一设置样式。</p><p><strong>缺点</strong></p><p>不能差异化设置，只能选择全部的当前标签。</p><h3 id="2-4-类选择器">2.4 类选择器</h3><p>如果想要差异化选择不同的标签，单独选一个或者选几个标签，可以使用类选择器。</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">属性1: 属性值1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.red &#123;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=`<span class="attr">red</span>`&gt;</span> 红色 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>类选择器口诀</strong>：样式点定义，结构类调用，一个或多个，开发最常用。</p></blockquote><p><strong>注意事项</strong></p><ol><li>长名称或词组可以使用短横线来表示。</li><li>不要使用纯数字、中文等命名，尽量使用英文字母来表示。</li><li>命名要有意义，尽量使别人一眼就知道这个类名的目的。</li></ol><p><strong>多类名</strong></p><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，简单理解就是一个标签有多个名字。</p><ol><li><p>多类名使用方式</p><p><code>&lt;div class=&quot;red fong35&quot;&gt;Huffie&lt;/div&gt;</code></p><ul><li>在标签class属性中写多个类名</li><li>多个类名中间必须用空格分开</li><li>这个标签就可以分别具有这些类名的样式</li></ul></li><li><p>多类名的优点</p><ul><li>节省CSS代码，统一修改也非常方便</li><li>多类名选择器在后期布局比较复杂的情况下，使用比较多</li></ul></li></ol><h3 id="2-5-id选择器">2.5 id选择器</h3><p>id选择器可以为标有特定id的HTML元素指定特定的样式</p><p>HTML元素以<strong>id属性</strong>来设置id选择器，CSS中id选择器以&quot;<strong>#</strong>&quot;来定义</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#id名&#123;</span><br><span class="line">属性: 属性值1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>口诀：样式#定义，结构id调用，只能调用一次，别人切勿使用</p></blockquote><h3 id="2-6-通配符选择器">2.6 通配符选择器</h3><p>在CSS中，通配符选择器使用&quot;*&quot;定义，他表示选取页面中的所有元素</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">属性1: 属性值1;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通配符选择器不需要调用，自动就给所有的元素使用样式</li><li>特殊情况下才使用</li></ol><h3 id="2-7-基础选择器总结">2.7 基础选择器总结</h3><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签</td><td>不能差异化选择</td><td>较多</td><td>p {color: red;}</td></tr><tr><td>类选择器</td><td>可以选出1个或多个标签</td><td>可以根据需求选择</td><td>非常多</td><td>.nav{color: red;}</td></tr><tr><td>id选择器</td><td>一次只能选择1个标签</td><td>ID属性只能在每个HTML文档中出现一次</td><td>一般和js搭配</td><td>#nav{color: red;}</td></tr><tr><td>通配符选择器</td><td>选择所有标签</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td>* {color: red;}</td></tr></tbody></table><h2 id="三、CSS字体属性">三、CSS字体属性</h2><p>CSS Fonts字体属性用于定义字体系列、大小、粗细和文字样式。</p><h3 id="3-1-字体系列">3.1 字体系列</h3><p>CSS使用<strong>font-family</strong>属性定义文本的字体系列。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h2 &#123;font-family: &quot;Microsoft Yahei&quot;;&#125;</span><br><span class="line">p &#123;font-family: Arial, &quot;Times New Roman&quot;;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以写多个字体，字体之间用英文逗号分隔</p><p>浏览器会优先使用第一个字体，如果用户电脑上没有安装第一个字体，则会按顺序检索。</p></li><li><p>如果字体名由多个单词组成，用引号包含</p></li><li><p>尽量使用系统默认的字体，保证任何用户的浏览器都能正确显示</p><p>常用字体：“Microsoft Yahei”, tahoma, arial, “Hiragino Sans GB”</p></li></ul><h3 id="3-2-字体大小">3.2 字体大小</h3><p>CSS使用font-size属性定义字体大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;font-size 20px;&#125;</span><br></pre></td></tr></table></figure><ul><li>谷歌浏览器默认文字大小为16px</li><li>不同浏览器可能默认现实的字号大小不一致，我们尽量给字体大小一个明确值</li><li>可以给body指定整个页面文字的大小</li></ul><h3 id="3-3-字体粗细">3.3 字体粗细</h3><p>CSS使用font-weight属性设置文本字体的粗细</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.bold &#123;font-weight: bold;&#125;</span><br><span class="line">.bold &#123;font-weight: 700;&#125;</span><br></pre></td></tr></table></figure><p>参数：normal正常，bold加粗，数字100-900也可表示字体粗细</p><p>实际开发中我们提倡使用数字：<strong>400 正常，700 加粗</strong></p><h3 id="3-4-文字样式">3.4 文字样式</h3><p>CSS使用font-style属性设置文本的风格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>normal</td><td>默认值，浏览器会显示标准的字体样式</td></tr><tr><td>italic</td><td>浏览器会显示斜体的字体样式</td></tr></tbody></table><p>注意：我们很少给文字加斜体，反而要给斜体标签(em, i)改为正常</p><h3 id="3-5-字体复合属性">3.5 字体复合属性</h3><p>字体属性可以把文字样式综合起来写，这样可以更节约代码</p><p><strong>语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;font: font-style font-weight font-size/line-height font-family;&#125;</span><br></pre></td></tr></table></figure><p><strong>例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font: italic 700 16px &quot;Microsoft Yahei&quot;</span><br></pre></td></tr></table></figure><ul><li>使用font属性时，必须按照上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开</li><li>不需要设置属性可以省略，但必须保留font-size和font-family属性，否则font属性不起作用</li></ul><h3 id="3-6-字体属性总结">3.6 字体属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>font-size</td><td>字号</td><td>通常的单位是px像素，一定要加单位</td></tr><tr><td>font-family</td><td>字体</td><td>“Microsoft Yahei”, tahoma, arial, “Hiragino Sans GB”</td></tr><tr><td>font-weight</td><td>粗细</td><td>加粗是700/bold，不加粗是400/normal，数字没有单位</td></tr><tr><td>font-style</td><td>样式</td><td>倾斜是italic，正常是normal，常用normal</td></tr><tr><td>font</td><td>复合属性</td><td>符合属性是有顺序的，不能随意换位置，字号和字体必须有</td></tr></tbody></table><h2 id="四、CSS文本属性">四、CSS文本属性</h2><p>CSS Text文本属性可以定义文本的外观，别如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。</p><h3 id="4-1-文本颜色">4.1 文本颜色</h3><p><strong>color属性</strong>用于定义文本的颜色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;color: red;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表示形式</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色值</td><td>red, green, blue, pink</td></tr><tr><td>十六进制</td><td>#FF0000, #123456, #666666</td></tr><tr><td>RGB代码</td><td>rgb(255,0,0)或rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="4-2-对齐文本">4.2 对齐文本</h3><p><strong>text-align属性</strong>用于设置元素内文本内容的水平对齐方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;text-align: center;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中</td></tr></tbody></table><h3 id="4-3-装饰文本">4.3 装饰文本</h3><p><strong>text-decoration属性</strong>规定添加到文本的装饰，可以给文本添加下划线、删除线、上划线等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123;text-decoration: underline;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>无（最常用，超链接去下划线）</td></tr><tr><td>underline</td><td>下划线（常用）</td></tr><tr><td>overline</td><td>上划线（几乎不用）</td></tr><tr><td>line-through</td><td>删除线（几乎不用）</td></tr></tbody></table><h3 id="4-4-文本缩进">4.4 文本缩进</h3><p><strong>text-indent属性</strong>用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;text-indent: 2em;&#125;</span><br></pre></td></tr></table></figure><p>通过设置该属性，该元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p><p>em是一个相对单位，是当前元素的文字大小。</p><h3 id="4-5-行间距">4.5 行间距</h3><p><strong>line-height属性</strong>用于设置行间的距离（行高），可以控制文字行与行之间的距离</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;line-height: 26px;&#125;</span><br></pre></td></tr></table></figure><p>行间距=上间距+文本高度+下间距，行高改变的是上下两个间距。</p><h3 id="4-6-文本属性总结">4.6 文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>通常使用16进制</td></tr><tr><td>text-align</td><td>文本对齐</td><td>可以设定文字水平的对齐方式</td></tr><tr><td>text-indent</td><td>文本缩进</td><td>用于设定段落首行缩进两字符 text-indent: 2em</td></tr><tr><td>text-decoration</td><td>文本修饰</td><td>添加下划线underline，取消下划线none</td></tr><tr><td>line-height</td><td>行高</td><td>控制行与行的距离</td></tr></tbody></table><h2 id="五、CSS的引入方式">五、CSS的引入方式</h2><h3 id="5-1-CSS的三种样式表">5.1 CSS的三种样式表</h3><p>按照CSS样式书写的位置（或者引入的样式），CSS样式表可以分为三大类：</p><ol><li>行内样式表（行内式）</li><li>内部样式表（嵌入式）</li><li>外部样式表（链接式）</li></ol><h3 id="5-2-内部样式表">5.2 内部样式表</h3><p>内部样式表是写到html页面内部，将所有的CSS代码抽取出来，单独放到一个<code>&lt;style&gt;</code>标签中。内部样式表设定CSS，也被称为嵌入式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>理论上<code>&lt;style&gt;</code>标签可以放到任何位置，但一般放在<code>&lt;head&gt;</code>标签。</li><li>这种方式可以控制整个页面的元素样式</li><li>代码结构清晰，但并没有实现结构和样式的完全分离</li></ul><h3 id="5-3-行内样式表">5.3 行内样式表</h3><p>行内样式表是在元素标签内部的style属性中设定CSS杨适。适合于修改简单样式。通常也称为行内式引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>Hello world.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>style其实就是标签的属性</li><li>在双引号中间，写法要符合CSS规范</li><li>只可以控制当前标签样式</li><li>书写过于繁琐，不推荐大量使用，只有对当前元素添加简单样式的时候考虑使用。</li></ul><h3 id="5-4-外部样式表">5.4 外部样式表</h3><p>实际开发都是外部样式表，适合样式比较多的情况，核心是：样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。</p><p>引入外部样式表分为两步：</p><ol><li>新建一个后缀名为.css的样式文件，把所有CSS代码都放入此文件中。</li><li>在HTML页面中，使用<code>&lt;link&gt;</code>标签引入这个文件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>rel</td><td>定义当前文档与被链接文档之间的关系，这里需要指定为&quot;stylesheet&quot;，即被链接的文档是一个样式表文件</td></tr><tr><td>href</td><td>定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径</td></tr></tbody></table><h3 id="5-5-CSS引入方式总结">5.5 CSS引入方式总结</h3><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>结构样式混写</td><td>较少</td><td>控制一个标签</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多</td><td>控制多个页面</td></tr></tbody></table><h2 id="六、Chrome调试工具">六、Chrome调试工具</h2><p>Chrome浏览器提供了一个非常好用的调试工具，可以用来调试我们的HTML结构和CSS样式。</p><h3 id="6-1-打开调试工具">6.1 打开调试工具</h3><p>在页面右键点击审查元素，或者按F12</p><h3 id="6-2-使用调试工具">6.2 使用调试工具</h3><ol><li>左边是HTML，右边是CSS杨适</li><li>使用<code>Ctrl+滚轮</code>可以放大代码字体大小</li><li>右边CSS样式可以改动数值和查看颜色</li><li><code>Ctrl+0</code>复原浏览器大小</li><li>如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误</li><li>如果有样式，但是样式前面有黄色感叹号提示，则是样式属性书写错误</li></ol><blockquote><p>本文参考了黑马程序员pink老师的视频教程<br><strong>黑马程序员pink老师前端入门视频教程：</strong> <a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端笔记 | HTML基础</title>
      <link href="/post/8861e96a.html"/>
      <url>/post/8861e96a.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、HTML的介绍">一、HTML的介绍</h3><h4 id="1-1-什么是HTML">1.1 什么是HTML</h4><p>HTML是用来描述网页的一种语言</p><p>HTML指超文本标记语言</p><p>HTML不是编程语言，是一种标记语言</p><h4 id="1-2-HTML5的新特性">1.2 HTML5的新特性</h4><p>用于绘画的canvas标签</p><p>用于媒介回放的video和audio元素</p><p>对本地离线存储的更好支持</p><p>新的特殊内容：article、footer、header、nav、section</p><p>新的表单控件：calendar、date、time、email、url、search</p><p>浏览器的支持：Safari、Chrome、Firefox以及Opera包括IE9以上</p><h3 id="二、HTML基础">二、HTML基础</h3><h4 id="2-1-声明">2.1 声明</h4><p><strong>声明：</strong><code>&lt;!DOCTYPE html&gt;</code></p><p>HTML有多个不同的版本，只有明白页面使用的确切的HTML版本，浏览器才能完全正确的显示出HTML页面。</p><blockquote><p>HTML5：<code>&lt;!DOCTYPE html&gt;</code></p><p>HTML4.01:<code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;  &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></p></blockquote><h4 id="2-2-基础标签">2.2 基础标签</h4><p><strong>基础标签：</strong><code>&lt;head&gt; &amp; &lt;body&gt;</code></p><ol><li>head：定义头部。如编码格式(UTF-8)、标题(title)、文字的显示形式，</li><li>body：页面的内容，其他的标签等</li></ol><h4 id="2-3-HTML标题">2.3 HTML标题</h4><p><strong>标题：</strong><code>&lt;h1&gt; &lt;h2&gt;……&lt;h6&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题h4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>标题h5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>标题h6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231706893-html-notes1-1.png" alt=""></p><h4 id="2-4-HTML段落">2.4 HTML段落</h4><p><strong>段落：</strong><code>&lt;p&gt;</code></p><p>定义一个段落</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello World</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231706461-html-notes1-2.png" alt=""></p><h4 id="2-5-HTML链接">2.5 HTML链接</h4><p><strong>链接：</strong><code>&lt;a&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/weixin_44543463&quot;</span>&gt;</span>Half_A的CSDN主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231706044-html-notes1-3.png" alt=""></p><h4 id="2-6-HTML图像">2.6 HTML图像</h4><p><strong>图像：</strong><code>&lt;img&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/Huffie.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231707957-html-notes1-4.png" alt=""></p><h3 id="三、HTML元素、属性和格式化">三、HTML元素、属性和格式化</h3><h4 id="3-1-元素">3.1 元素</h4><p>元素是指从开始标签到结束标签的所有内容</p><table><thead><tr><th>开始标签</th><th>元素内容</th><th>结束标签</th></tr></thead><tbody><tr><td><code>&lt;p&gt;</code></td><td>this is my page</td><td><code>&lt;/p&gt;</code></td></tr></tbody></table><blockquote><p><code>&lt;p&gt;&lt;/p&gt;</code>是段落标记，<code>&lt;br/&gt;</code>是换行符</p><p>二者虽然都可以实现换行，但其行间距不一样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is my webpage<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> Hello,world<span class="tag">&lt;<span class="name">br</span>/&gt;</span>Huffie</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231707062-html-notes1-5.png" alt=""></p></blockquote><ul><li>元素内容是指从开始标签到结束标签之间的内容</li><li>空元素在开始标签中进行关闭（如<code>&lt;br/&gt;</code>）</li><li>大多数HTML元素可拥有属性</li><li>大多数HTML元素都是可以嵌套的</li></ul><h4 id="3-2-HTML属性">3.2 HTML属性</h4><ol><li><p>标签可以拥有属性为元素提供更多的信息</p></li><li><p>属性以键/值对的形式出现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">href=&quot;www.huffie.top&quot;</span><br></pre></td></tr></table></figure></li><li><p>常用标签属性</p><p><code>&lt;h1&gt;:align</code> ：对齐方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><body>:bgcolor`  背景颜色  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#ebebeb&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：bgcolor设置背景颜色，background设置背景图片</p><p><code>&lt;a&gt;:target</code>  规定在何处打开链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通用属性</p><table><thead><tr><th>通用属性</th><th>作用</th></tr></thead><tbody><tr><td>class</td><td>规定元素的类名</td></tr><tr><td>id</td><td>规定元素唯一ID</td></tr><tr><td>style</td><td>规定元素样式</td></tr><tr><td>title</td><td>规定元素的额外信息</td></tr></tbody></table></li></ol><h4 id="3-3-格式化">3.3 格式化</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;b&gt;</code></td><td>定义粗体文本</td></tr><tr><td><code>&lt;big&gt;</code></td><td>定义大号字</td></tr><tr><td><code>&lt;em&gt;</code></td><td>定义着重文字</td></tr><tr><td><code>&lt;i&gt;</code></td><td>定义斜体字</td></tr><tr><td><code>&lt;small&gt;</code></td><td>定义小号字</td></tr><tr><td><code>&lt;strong&gt;</code></td><td>定义加重语气</td></tr><tr><td><code>&lt;sub&gt;</code></td><td>定义下标字</td></tr><tr><td><code>&lt;sup&gt;</code></td><td>定义上标字</td></tr><tr><td><code>&lt;ins&gt;</code></td><td>定义插入字</td></tr><tr><td><code>&lt;del&gt;</code></td><td>定义删除字</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello, I&#x27;m huffie!<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>标签 b：欢迎来到我的博客<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">big</span>&gt;</span>标签 big: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">big</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>标签 em: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>标签 i: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>标签 small: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>标签 strong: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 标签 sub: 欢迎来到<span class="tag">&lt;<span class="name">sub</span>&gt;</span>这是上标<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>我的博客</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 标签 sup: 欢迎来到<span class="tag">&lt;<span class="name">sup</span>&gt;</span>这是下标<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>我的博客</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ins</span>&gt;</span>标签 ins: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">del</span>&gt;</span>标签 del: 欢迎来到我的博客<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231707703-html-notes1-6.png" alt=""></p><h3 id="四、样式、链接和表格">四、样式、链接和表格</h3><h4 id="4-1-样式">4.1 样式</h4><ol><li><p>标签：</p><ul><li><code>&lt;style&gt;</code>：样式定义</li><li><code>&lt;link&gt;</code>：资源引用</li></ul></li><li><p>属性：</p><ul><li>rel=“stylesheet”：外部样式表</li><li>type=“text/css”：引入文档的类型</li><li>margin-left：边距</li></ul></li><li><p>样式的插入方式</p><ul><li><p>外部样式表</p><p><strong>语法：</strong><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</code></p><p>即指定外部引用资源，文档类型为css，具体位置为mystyle.css</p><p>**例：**index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题h1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mystyle.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231707135-html-notes1-7.png" alt=""></p><ul><li><p>内部样式表</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: aquamarine;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>欢迎来到我的博客<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://img.mahaofei.com/img/202112231708041-html-notes1-8.png" alt=""></p><ul><li><p>内联样式表</p><p><strong>语法：</strong><code>    &lt;p style=&quot;color: blueviolet;&quot;&gt;点击我跳转到CSDN&lt;/a&gt;</code></p><p><strong>例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blueviolet;&quot;</span>&gt;</span>点击我跳转到CSDN<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-链接">4.2 链接</h4><ol><li><p>链接数据包括 文本链接、图片链接</p></li><li><p>属性：</p><ul><li>href属性：指向另一个文档的链接</li><li>name属性：创建文档内的链接</li></ul></li><li><p>img标签属性：</p><ul><li>alt：替换文本属性</li><li>width：宽</li><li>height：高</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.huffie.top&quot;</span>&gt;</span>点击我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.huffie.top&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./images/Huffie.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;huffie.jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;tips&quot;</span>&gt;</span>页内锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#tip&quot;</span>&gt;</span>跳转到页内锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231708036-html-notes1-9.png" alt=""></p><h4 id="4-3-表格">4.3 表格</h4><p><strong>（1）表格标签：</strong></p><table><thead><tr><th>表格</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;table&gt;</code></td><td>定义表格</td></tr><tr><td><code>&lt;caption&gt;</code></td><td>定义表格标题</td></tr><tr><td><code>&lt;th&gt;</code></td><td>定义表格的表头</td></tr><tr><td><code>&lt;tr&gt;</code></td><td>定义表格的行</td></tr><tr><td><code>&lt;td&gt;</code></td><td>定义表格单元</td></tr><tr><td><code>&lt;thead&gt;</code></td><td>定义表格的页眉</td></tr><tr><td><code>&lt;tbody&gt;</code></td><td>定义表格的主体</td></tr><tr><td><code>&lt;tfoot&gt;</code></td><td>定义表格的页脚</td></tr><tr><td><code>&lt;col&gt;</code></td><td>定义表格的列属性</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231708632-html-notes1-10.png" alt=""></p><p><strong>（2）表格属性</strong></p><ol><li><p>边框属性：border例：<code>&lt;table border=&quot;1&quot;&gt;</code></p></li><li><p>表格中的列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>单元格大小：cellpadding    例：<code>&lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt;</code></p></li></ol><p><img src="https://img.mahaofei.com/img/202112231708556-html-notes1-11.png" alt=""></p><ol start="4"><li>单元格间距：cellspacing    例：<code>&lt;table border=&quot;1&quot; cellspacing=&quot;10&quot;&gt;</code></li></ol><p><img src="https://img.mahaofei.com/img/202112231708504-html-notes1-12.png" alt=""></p><ol start="5"><li>单元格背景颜色：bgcolor    例：<code>&lt;table border=&quot;1&quot; bgcolor=&quot;#cccccc&quot;&gt;</code></li><li>单元格背景图片：background    例：<code>&lt;table border=&quot;1&quot; background=&quot;huffie.jpg&quot;&gt;</code></li></ol><h3 id="五、HTML列表、块和布局">五、HTML列表、块和布局</h3><h4 id="5-1-列表">5.1 列表</h4><p><strong>（1）标签</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;ol&gt;</code></td><td>有序列表</td></tr><tr><td><code>&lt;ul&gt;</code></td><td>无序列表</td></tr><tr><td><code>&lt;li&gt;</code></td><td>列表项</td></tr><tr><td><code>&lt;dl&gt;</code></td><td>列表</td></tr><tr><td><code>&lt;dt&gt;</code></td><td>列表项</td></tr><tr><td><code>&lt;dd&gt;</code></td><td>描述</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231709158-html-notes1-13.png" alt=""></p><p><strong>（2）属性</strong></p><ol><li><p>无序列表</p><ul><li><p>标签：<code>&lt;ul&gt;</code>、<code>&lt;li&gt;</code></p></li><li><p>属性：实心圆disc、空心圆circle、方块square（默认是实心圆）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;square&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231709341-html-notes1-15.png" alt=""></p><ol start="2"><li><p>有序列表</p><ul><li><p>标签：<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></p></li><li><p>属性：A、a、l、i（序号：默认是数字），start（开始位置：默认从1开始）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231709077-html-notes1-16.png" alt=""></p><ol start="3"><li><p>嵌套列表</p><ul><li>标签：<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code></li></ul></li><li><p>自定义列表</p><ul><li><p>标签：<code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Huffie<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><img src="https://img.mahaofei.com/img/202112231710198-html-notes1-17.png" alt=""></p><h4 id="5-2-块">5.2 块</h4><ol><li><p>块元素</p><p>块元素在显示时，通常会以新行开始。如<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code></p></li><li><p>内联元素</p><p>内联元素通常不会以新行开始。如<code>&lt;b&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code></p></li><li><p><code>&lt;div&gt;</code>元素</p><p><code>&lt;div&gt;</code>元素也被称为块元素，其主要是组合HTML元素的容器</p></li><li><p><code>&lt;span&gt;</code>元素</p><p><code>&lt;spac&gt;</code>元素是内联元素，可作为文本的容器</p></li></ol><h4 id="5-3-布局">5.3 布局</h4><ol><li>使用<code>&lt;div&gt;</code>布局</li><li>使用<code>&lt;table&gt;</code>布局</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: cornsilk;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#heading</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: cyan;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#content_menu</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: gold;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#content_body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: darkgray;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#footing</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: darkslateblue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content_menu&quot;</span>&gt;</span>内容菜单<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content_body&quot;</span>&gt;</span>内容主体<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footing&quot;</span>&gt;</span>内容底部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231710586-html-notes1-18.png" alt=""></p><h3 id="六、HTML表单">六、HTML表单</h3><ol><li><p>表单用于获取不同类型的用户输入</p></li><li><p>常用表单标签</p><table><thead><tr><th>标签</th><th>解释</th></tr></thead><tbody><tr><td><code>&lt;form&gt;</code></td><td>表单</td></tr><tr><td><code>&lt;input&gt;</code></td><td>输入域</td></tr><tr><td><code>&lt;textarea&gt;</code></td><td>文本域</td></tr><tr><td><code>&lt;label&gt;</code></td><td>控制标签</td></tr><tr><td><code>&lt;fieldset&gt;</code></td><td>定义域</td></tr><tr><td><code>&lt;legend&gt;</code></td><td>域的标题</td></tr><tr><td><code>&lt;select&gt;</code></td><td>选择列表</td></tr><tr><td><code>&lt;optgroup&gt;</code></td><td>选项组</td></tr><tr><td><code>&lt;option&gt;</code></td><td>下拉列表中的选项</td></tr><tr><td><code>&lt;button&gt;</code></td><td>按钮</td></tr></tbody></table></li><li><p>常见表单</p><ul><li><p>复选框：<code>&lt;input type=&quot;checkbox&quot;&gt;</code></p></li><li><p>单选框：</p><p><code>&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;</code></p><p>单选框的几个选项需要有相同的name</p><p>默认勾选要添加属性<code>checked=&quot;checked&quot;</code></p></li><li><p>下拉列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文本域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>文本内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建按钮：<code>&lt;input type=&quot;button&quot; value=&quot;按钮内容&quot;&gt;</code></p></li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line">        账号:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span> 密码:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 复选框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>已阅读并同意《用户使用须知》</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line">        请选择您的性别： 男 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span> 女 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下拉列表 --&gt;</span></span><br><span class="line">        请选择居住地区</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;人机验证&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 提交按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文本域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span>请填写个人简介<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    &lt;b/r&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231710839-html-notes1-19.png" alt=""><br>ps.如果利用表格搭配表单，可以写出更规范的注册页面</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】文件操作</title>
      <link href="/post/751a9034.html"/>
      <url>/post/751a9034.html</url>
      
        <content type="html"><![CDATA[<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件<code>#include&lt;fstream&gt;</code></p><p>文件类型分为两种：</p><ul><li>文本文件：文件以文本的ASCII码形式存储在计算机中</li><li>二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂</li></ul><p>文件的操作：</p><ol><li>ofstream：写操作</li><li>ifstream：读操作</li><li>fstream：读写操作</li></ol><h3 id="一、文本文件">一、文本文件</h3><h4 id="1-1-写文件">1.1 写文件</h4><p>写文件步骤如下</p><ol><li><p>包含头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>创建流对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br></pre></td></tr></table></figure></li><li><p>打开文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 打开方式)</span><br></pre></td></tr></table></figure><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p>文件打开方式可以配合使用，利用|操作符<br>例如：<code>ios::binary | ios::out</code></p></li><li><p>写数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs &lt;&lt; <span class="string">&quot;写入的数据&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ofs.close</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-2-读文件">1.2 读文件</h4><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>创建流对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br></pre></td></tr></table></figure></li><li><p>打开文件并判断文件是否打开成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>, 打开方式)</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, buf))&#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs, buf))&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、二进制文件">二、二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为<code>ios::binary</code></p><h4 id="2-1-写文件">2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数<code>write</code></p><p>函数原型：<code>ostream&amp; write(const char * buffer, int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：将Person类中的数据写入文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>,ios::out | ios::binary)</span></span>;</span><br><span class="line">Person p = &#123;<span class="string">&quot;Huffie&quot;</span>, <span class="number">21</span>&#125;;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-读文件">2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数<code>read</code></p><p>函数原型：<code>istream&amp; read(const char * buffer, int len);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：读取文件中的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in | ios::binary);</span><br><span class="line"><span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error: File open failed.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p.m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】继承</title>
      <link href="/post/f22ba72b.html"/>
      <url>/post/f22ba72b.html</url>
      
        <content type="html"><![CDATA[<p><strong>继承是面向对象的三大特性之一</strong></p><p>定义类时，下级别的成员除了拥有上一级的共性，还有自己的特性</p><h4 id="6-1-继承的基本语法">6.1 继承的基本语法</h4><p>作用：减少代码重复量</p><p>语法：<code>class 子类 : 继承方式 父类</code></p><p>例：<code>class MyPage : public BasePage </code></p><blockquote><p>子类也称为派生类、父类也称为基类</p><p>派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过来的表现其共性，新增的表现其个性</p></blockquote><h4 id="6-2-继承方式">6.2 继承方式</h4><p>继承方式一共有三种：</p><ul><li>公共继承<ul><li>父类中的公共权限成员，子类中也是公共权限</li><li>父类中的保护权限成员，子类中也是保护权限</li><li>父类的私有权限成员，子类无法访问</li></ul></li><li>保护继承<ul><li>父类中的公共权限成员，子类中也是保护权限</li><li>父类中的保护权限成员，子类中也是保护权限</li><li>父类的私有权限成员，子类无法访问</li></ul></li><li>私有继承<ul><li>父类中的公共权限成员，子类中是私有权限</li><li>父类中的保护权限成员，子类中是私有权限</li><li>父类的私有权限成员，子类无法访问<br><img src="https://img.mahaofei.com/img/202112231705496-cpp-notes7-1.png" alt=""></li></ul></li></ul><h4 id="6-3-继承中的对象模型">6.3 继承中的对象模型</h4><p>父类中所有非静态成员属性都会被子类继承下去。父类中私有成员属性，是被编译器隐藏了，因此是访问不到，但是确实被继承下去了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果：16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-继承中构造和析构顺序">6.4 继承中构造和析构顺序</h4><p>子类继承父类后，创建子类对象，也会调用父类的构造函数</p><p>继承中的构造和析构顺序如下：</p><ul><li>构造：先构造父类，在构造子类</li><li>析构：顺序与构造相反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Base</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Son</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Base的构造函数</span><br><span class="line">Son的构造函数</span><br><span class="line">Son的析构函数</span><br><span class="line">Base的析构函数</span><br></pre></td></tr></table></figure><h4 id="6-5-继承同名成员处理方式">6.5 继承同名成员处理方式</h4><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><p>例：<code>s.Base::m_A</code>或<code>s.Base::func()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base func 函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son func 函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son : m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base : m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>如果子类中出现和父类同名的成员函数，子类中的同名成员会隐藏掉父类中所有同名成员函数（包括重载）。如果先要访问父类同名成员，需要加作用域</p></blockquote><h4 id="6-6-继承同名静态成员处理方式">6.6 继承同名静态成员处理方式</h4><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - m_A =  &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第一个::代表通过类名方式访问第二个::代表访问父类作用域下的成员</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-7-多继承语法">6.7 多继承语法</h4><p>C++允许一个类继承多个类</p><p>语法：<code>class 子类 : 继承方式 父类1, 继承方式 父类2...</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br></pre></td></tr></table></figure><p>如果多继承中父类出现了同名情况，子类使用时要加作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base1 - m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base2 - m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="6-8-菱形继承">6.8 菱形继承</h4><p><strong>概念</strong>：</p><ol><li>两个派生类继承同一个类</li><li>又有某个类同时继承这两个类</li><li>这种继承称为菱形继承</li></ol><p><strong>菱形继承的问题</strong>：</p><ol><li><p>Son1继承了Base的数据，Son2也继承了Base的数据，当GrandSon使用数据时，就会产生二义性</p><blockquote><p>解决方法：两个父类因为相同的数据，需要加以作用域区分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g.Son1::m_A = <span class="number">100</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>GrandSon继承来自Base的数据有两份，但实际上有一份就可以</p><blockquote><p>利用虚继承，解决菱形继承数据重复的问题。发生虚继承之后，数据只有一个，且可以不加作用域直接访问。</p><p>在继承前加上关键字virtual。此时的Base称为虚基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】运算符重载</title>
      <link href="/post/65592f98.html"/>
      <url>/post/65592f98.html</url>
      
        <content type="html"><![CDATA[<p>运算符重载的目的是对已有的运算符重新定义，赋予其另一种功能，以适应不同的数据类型。</p><h3 id="一、加号运算符重载">一、加号运算符重载</h3><p>作用：实现两个自定义数据类型的加法运算</p><p><strong>1.1 通过成员函数重载+号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    Person <span class="keyword">operator</span>+(Person &amp;p)&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用方法：</p><ol><li>本质调用：<code>Person p3 = p1.operator+(p2);</code></li><li>简化调用：<code>Person p3 = p1 + p2;</code></li></ol><p><strong>1.2 通过全局函数重载+号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, Person &amp;p2)&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, <span class="type">int</span> num)&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p1.m_A + num;</span><br><span class="line">temp.m_B = p1.m_B + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：</p><ol><li>本质调用：<code>Person p3 = operator+(p1, p2);</code></li><li>简化调用：<code>Person p3 = p1 + p2;</code></li></ol><p>运算符重载也可以发生函数重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p3 = p1 + p2;</span><br><span class="line">Person p4 = p1 + <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>1.3 注意事项</strong>：</p><ul><li>对于内置的数据类型的表达式的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul><h3 id="二、左移运算符重载">二、左移运算符重载</h3><p><strong>通过全局函数重载&lt;&lt;左移运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p.m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p.m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>选中cout，右键转到声明，可以看到cout属于ostream这个类</li><li>返回cout是为了实现链式编程，使得可以无限追加&lt;&lt;</li><li>不通过成员函数重载是因为，成员函数重载只能实现p.operator&lt;&lt;(cout)，即p&lt;&lt;cout，与预期不符。</li></ul><p>调用方法：</p><p><code>cout &lt;&lt; p &lt;&lt; endl;</code></p><h3 id="三、递增运算符重载">三、递增运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>()&#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载前置++运算符</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">++m_Num;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载后置++运算符此处的int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前置++：</p><ul><li>返回值是引用，是因为需要实现++(++a)，保证自增的都是同一个数据</li></ul><p>后置++：</p><ul><li>因为后置++要先返回当前值，再递增。因此先把当前值记录下来，递增之后，再返回记录值。</li><li>返回值以值传递形式，是因为返回的是局部对象temp，局部对象不能通过引用返回。</li></ul><h3 id="四、赋值运算符重载">四、赋值运算符重载</h3><p>c++编译器至少给一个类添加四个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。</p><p>解决方法：利用深拷贝，解决浅拷贝带来的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line"><span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)&#123;</span><br><span class="line"><span class="comment">//先判断是否有属性在堆区，如果有，先释放干净，再深拷贝</span></span><br><span class="line"><span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行深拷贝</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_Age = &quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_Age = &quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3.m_Age = &quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>重载=的逻辑是，如p2=p1，先释放p2内的属性（因为浅拷贝p2和p1内的m_Age指向同一块内存），然后再重新开辟内存空间进行深拷贝。</li><li>返回值是Person&amp;，是为了连续赋值操作</li></ul><h3 id="五、关系运算符重载">五、关系运算符重载</h3><p>**作用：**重载关系运算符时，可以让两个自定义类型对象进行对比操作。（如==、!=）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：重载==运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp;p)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、函数调用运算符重载">六、函数调用运算符重载</h3><ul><li>函数调用运算符是()</li><li>由于重载后使用方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：重载()实现自定义打印</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">---------</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">MyPrint myprint;</span><br><span class="line"><span class="built_in">myprint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>重载()很像函数调用，比如上面的功能也可以用函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(string test)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">---------</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】友元</title>
      <link href="/post/803a8532.html"/>
      <url>/post/803a8532.html</url>
      
        <content type="html"><![CDATA[<p>有些私有属性，可需要让类外特殊的一些函数或类进行访问，就需要利用友元。</p><p>友元的关键字为fiend</p><p>友元的三种实现方法</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h3 id="一、全局函数作友元">一、全局函数作友元</h3><p>将全局函数的声明写在类的定义内，并在前面添加关键字friend。</p><p>例：<code>friend void func(Person *person);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">//goodFriend全局函数可以访问Person中的私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodFriend</span><span class="params">(Person *person)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">m_Money = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend</span><span class="params">(Person *person)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Friends is getting:&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Friends is getting:&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、类作友元">二、类作友元</h3><p>语法：<code>friend class className;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodFriend</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>()&#123;</span><br><span class="line">m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">m_Money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//goodFriend类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">goodFriend</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>;<span class="comment">//获取函数，获取Person中的属性</span></span><br><span class="line"></span><br><span class="line">Person * person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">goodFriend::<span class="built_in">goodFriend</span>()&#123;</span><br><span class="line">person = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend::get</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;goodFriend类正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;goodFriend类正在访问：&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">goodFriend gf;</span><br><span class="line">gf.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、成员函数作友元">三、成员函数作友元</h3><p>例：<code>friend void className::func();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">goodFriend</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get1</span><span class="params">()</span></span>;<span class="comment">//让get函数可以访问Person中私有成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get2</span><span class="params">()</span></span>;<span class="comment">//让get函数不可以访问Person中私有成员</span></span><br><span class="line"></span><br><span class="line">Person * person;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodFriend::get1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>();</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> m_Money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::<span class="built_in">Person</span>()&#123;</span><br><span class="line">m_Name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">m_Money = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodFriend::<span class="built_in">goodFriend</span>()&#123;</span><br><span class="line">person = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend::get1</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodFriend::get2</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get函数正在访问：&quot;</span> &lt;&lt; person-&gt;m_Name &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;get函数正在访问：&quot; &lt;&lt; person-&gt;m_Money &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">goodFriend gf;</span><br><span class="line">gf.<span class="built_in">get1</span>();</span><br><span class="line">gf.<span class="built_in">get2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】对象模型和this指针</title>
      <link href="/post/5388c9e9.html"/>
      <url>/post/5388c9e9.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、成员变量和成员函数分开存储">一、成员变量和成员函数分开存储</h3><p>C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象</p><ol><li><p>空对象也会占用内存</p><p>C++编译器会给每个空对象也分配一个字节空间，是为了标志此对象占内存的位置。每个空对象也应该有一个独一无二的内存地址</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>空对象占用1个字节内存</p></blockquote></li><li><p><strong>只有</strong>类的非静态成员变量，属于类的对象</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>只含一个int非静态成员变量的对象占用4个字节内存</p></blockquote></li><li><p>类的静态成员变量，不属于类的对象</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>对象还是占用4个字节内存</p></blockquote></li><li><p>成员变量和成员函数是分开存储的</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>对象还是占用4个字节内存</p></blockquote></li></ol><h3 id="二、this指针">二、this指针</h3><p>有上述可知，C++中成员变量和成员函数是分开存储的。</p><p>每一个非静态成员函数只会产生一份函数实例，也就是多个同类型的对象会共用一块代码，而代码如何区分哪个对象调用自己。</p><p>这里就用到了this指针，<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li><p>形参和成员变量同名时，可以用this指针来区分</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用return *this</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> money)&#123;</span><br><span class="line"><span class="comment">//this指针指向被调用的成员函数所属的对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;money = money;<span class="comment">//如果不加this，则赋值两侧会认为是同一个money</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddMoney</span><span class="params">(Person &amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;money += p.money;<span class="comment">//将传入的p对象的money加到此对象上</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//this是指向对象的指针，*this就是指向对象本体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的财产为：&quot;</span> &lt;&lt; p1.money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddMoney</span>(p1).<span class="built_in">PersonAddMoney</span>(p1).<span class="built_in">PersonAddMoney</span>(p1);<span class="comment">//链式编程</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的财产为：&quot;</span> &lt;&lt; p2.money &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、空指针访问成员函数">三、空指针访问成员函数</h3><p>C++中空指针也可以调用成员函数，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加判断保证代码的健壮性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is Person class.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;<span class="comment">//报错原因是传入的指针为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">showClassName</span>();<span class="comment">//空指针也可以正常执行</span></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge</span>();<span class="comment">//如果不加if语句会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、const修饰成员函数">四、const修饰成员函数</h3><p><strong>常函数：</strong></p><ul><li><p>成员函数后加const后我们称为这个函数为常函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>常函数不可以修改成员属性</p><blockquote><p>常函数也存在this指针，而<strong>this指针的本质是指针常量</strong>，指针的指向是不可修改的。</p><p>在成员函数后面加this，修饰的是this指向，让指针指向的值也不可以修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = <span class="number">100</span>;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>成员属性声明时加关键字mutable，在常函数中依然可以修改</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;</span><br></pre></td></tr></table></figure><p>创建了一个特殊的变量，即使在常函数中也可以修改，常对象也可以修改</p></blockquote></li></ul><p><strong>常对象</strong></p><ul><li><p>对象前加const，创建的是常对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Person p;</span><br></pre></td></tr></table></figure></li><li><p>常对象无法修改成员变量，值可以修改加mutable的变量</p></li><li><p>常对象只能调用常函数，不能调用普通成员函数，因为普通成员函数可以修改属性</p><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】构造函数与析构函数相关知识</title>
      <link href="/post/cf29751c.html"/>
      <url>/post/cf29751c.html</url>
      
        <content type="html"><![CDATA[<p>每个对象需要有初始设置以及对象销毁前的清理数据的设置。</p><h3 id="一、构造函数和析构函数">一、构造函数和析构函数</h3><p>对象的<strong>初始化和清理</strong>是两个非常重要的安全问题。</p><ul><li>一个对象或变量没有初始状态，对其使用后果未知</li><li>使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li></ul><p>C++使用<strong>构造函数和析构函数</strong>解决这两个问题，这<strong>两个函数会被编译器自动调用</strong>，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此<strong>如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现</strong>。</p><ul><li>构造函数：创建对象时为对象的成员属性赋值</li><li>析构函数：对象销毁前执行清理工作</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次。</li></ol><p><strong>析构函数语法：</strong><code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同，在名称前加上~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数，进行初始化操作</span></span><br><span class="line"><span class="comment">//构造函数没有返回值 不用写void</span></span><br><span class="line"><span class="comment">//函数名与类名相同</span></span><br><span class="line"><span class="comment">//构造函数可以有参数，可以发生重载</span></span><br><span class="line"><span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数，执行清理操作</span></span><br><span class="line"><span class="comment">//没有返回值，不写void</span></span><br><span class="line"><span class="comment">//函数名和类名相同，前面加~</span></span><br><span class="line"><span class="comment">//不可以有参数，不可以发生重载</span></span><br><span class="line"><span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line">Person p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、构造函数的分类及调用">二、构造函数的分类及调用</h3><p>分类方式：</p><ul><li>按参数分：有参构造和无参构造</li><li>按类型分：普通构造和拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通构造、无参构造（默认构造）</span></span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通构造、有参构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line"><span class="comment">//将传入的类中所有的属性传到此对象上</span></span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><ul><li>括号法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//调用有参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p>注：调用默认构造函数的时候，不要加()</p><p>因为 <code>Person p1();</code> ，编译器会认为是一个函数的声明</p></blockquote><ul><li>显示法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//调用无参构造函数</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//调用有参构造函数</span></span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Person(10)</code> 是匿名对象。</p><p>特点：当前行执行结束后，系统会立即回收掉匿名对象。</p></blockquote><blockquote><p>不要用拷贝构造函数初始化匿名对象</p><p><code>Person(p3);//报错重定义</code></p><p>编译器会认为 Person (p3) 等价于 Person p3;</p></blockquote><ul><li>隐式转换法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//调用无参构造函数</span></span><br><span class="line">Person p2 = <span class="number">10</span>;<span class="comment">//调用有参构造函数</span></span><br><span class="line">Person p3 = p2;<span class="comment">//调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Person p2 = 10;</code> 相当于 <code>Person p2 = Person(10);</code></p></blockquote><h3 id="三、拷贝构造函数调用时机">三、拷贝构造函数调用时机</h3><p>C++中拷贝构造函数的调用时机通常有以下情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>以值传递的方式给函数参数传值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">m_Age = age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">m_Age = p.m_Age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用已经创建完毕的对象初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p)</span></span>&#123;&#125;<span class="comment">//值传递相当于 Person p = p 的隐式写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line"><span class="built_in">doWork</span>(p);<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line">test03;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、构造函数调用规则">四、构造函数调用规则</h3><p>默认情况下，c++中类至少有三个函数</p><ul><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性值进行拷贝</li></ul><p>构造函数调用规则：</p><ul><li>如果用户定义了有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><h3 id="五、深拷贝与浅拷贝">五、深拷贝与浅拷贝</h3><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>：浅拷贝的问题，此程序的问题是，m_Height指向的区域，经过两次析构函数的调用，被重复释放了。</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)&#123;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line"><span class="comment">//析构函数，将堆区开辟的数据做释放操作</span></span><br><span class="line"><span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Height;</span><br><span class="line">m_Height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"><span class="type">int</span> *m_Height;<span class="comment">//身高数据开辟到堆区</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">21</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot;\t身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot;\t身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">解决方法：自己实现拷贝构造函数，解决浅拷贝带来的问题</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)&#123;</span><br><span class="line">m_Age = p.m_Age;</span><br><span class="line"><span class="comment">//m_Height = p.m_Height;//编译器默认实现的是这行代码</span></span><br><span class="line">m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="六、初始化列表">六、初始化列表</h3><p>**作用：**为类中的属性进行初始化操作</p><p><strong>语法：</strong><code>构造函数(): 属性1(值1),属性2(值2)...&#123;&#125;</code></p><p>**优点：**类成员存在常量时，只能初始化而不能赋值；类成员存在引用时，只能初始化不能赋值；提高效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传统的初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c)&#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表进行初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c):<span class="built_in">m_A</span>(a),<span class="built_in">m_B</span>(b),<span class="built_in">m_C</span>(c)&#123;&#125;</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、类对象作为类成员">七、类对象作为类成员</h3><p>C++中类的成员可以是另一个类的对象，<strong>一般称该成员为对象成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当其它类的对象作为本类成员</p><p>构造时：先构造类对象，再构造自身。</p><p>析构时：顺序与构造相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string brand)&#123;</span><br><span class="line">m_Brand = brand;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Brand;<span class="comment">//品牌</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//这里的m_Phone(brand)相当于使用括号法Phone m_Phone(brand)创建对象</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string brand):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(brand)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Huffie&quot;</span>,<span class="string">&quot;Huawei&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; with &quot;</span> &lt;&lt; p.m_Phone.m_Brand &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、静态成员">八、静态成员</h3><p>静态成员就是在成员变量和成员函数前加上static</p><ul><li>静态成员变量：<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存（全局区）</li><li>类内声明，类外初始化</li></ul></li></ul><blockquote><p>静态成员变量有两种访问方式（若为私有权限，类外无法访问）：</p><ol><li><p>通过对象访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>通过类名访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//类内声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; p1.m_A &lt;&lt; endl;<span class="comment">//输出100</span></span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; p1.m_A &lt;&lt; endl;<span class="comment">//输出200，说明数据共享</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象，所有对象都共享同一份数据，因此静态成员变量有两种访问方式</span></span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; Person::m_B &lt;&lt; endl;错误，私有权限类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><blockquote><p>静态成员函数有两种访问方式（若为私有权限，类外同样无法访问）：</p><ol><li><p>通过对象访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li><li><p>通过类名访问</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 200;静态成员函数不可以访问非静态成员变量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="comment">//非静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func2的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2();类外无法访问私有的静态成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】封装的意义，结构体和类的区别</title>
      <link href="/post/16d89721.html"/>
      <url>/post/16d89721.html</url>
      
        <content type="html"><![CDATA[<h4 id="一、封装的意义">一、封装的意义</h4><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>1.1 设计类时，属性和行为写在一起，表现事物</strong></p><p><strong>语法：</strong><code>class 类名&#123; 访问权限: 属性/行为 &#125;;</code></p><p>类中的属性和行为统一称为成员，属性也称为成员属性或成员变量，行为也成为成员函数或成员方法；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class代表设计一个类，类后面紧跟着类名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="comment">//行为</span></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">calcuPerimeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过圆类，创建具体的圆对象</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//给圆对象的属性赋值</span></span><br><span class="line">    c1.r = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Perimeter is &quot;</span> &lt;&lt; c1.<span class="built_in">calcuPerimeter</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1.2 类在设计时，可以把属性和行为放在不同的权限下加以控制</strong></p><p>访问权限有三种</p><ol><li>public：公共权限，类内可以访问，类外可以访问</li><li>protected：保护权限，类内可以访问，类外不可以访问</li><li>private：私有权限，类内可以访问，类外不可以访问</li></ol><blockquote><p>保护权限和私有权限区别主要在继承方面，子类可以访问父类的保护权限，而私有权限不可访问</p></blockquote><h4 id="二、struct和class的区别">二、struct和class的区别</h4><p>在C++种struct和class的唯一区别在于默认的访问权限不同</p><ul><li>struct：默认权限为公有</li><li>class：默认权限为私有</li></ul><p>尽管结构体可以包含成员函数，但它们很少这样做。所以，通常情况下，结构体声明只会声明成员变量。结构体声明通常不包括public或private的访问修饰符。</p><h4 id="三、成员属性设置为私有">三、成员属性设置为私有</h4><ul><li>将所有成员属性设置为私有，可以自己控制读写权限</li><li>对于写权限，我们可以检测数据的有效性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置性别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setGender</span><span class="params">(string gender)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gender == <span class="string">&quot;Male&quot;</span> <span class="keyword">or</span> gender == <span class="string">&quot;Female&quot;</span>)&#123;</span><br><span class="line">            m_Gender = gender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Wrong Gender!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_Gender = <span class="string">&quot;Male&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取性别</span></span><br><span class="line">    <span class="function">string <span class="title">getGender</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置年龄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>&#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名  可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//性别  可读可写 修改选项只能是 &quot;Male&quot; &quot;Female&quot;</span></span><br><span class="line">    string m_Gender;</span><br><span class="line">    <span class="comment">//年龄  只写</span></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;Huffie&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:\t&quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setGender</span>(<span class="string">&quot;Male&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Gender:\t&quot;</span> &lt;&lt; p.<span class="built_in">getGender</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">21</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.getAge() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;Pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++笔记】函数的用法：函数的默认参数、占位参数、函数重载</title>
      <link href="/post/1845ba15.html"/>
      <url>/post/1845ba15.html</url>
      
        <content type="html"><![CDATA[<h3 id="函数的默认参数">函数的默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code>返回值类型 函数名 (参数=默认值)&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给形参传入了数据，就用自己的数据；如果没有，就用默认值</p><p><strong>注意事项：</strong></p><ul><li><p>如果某个位置已经有了默认参数，那么从这个位置往后，必须都有默认值。（即有默认参数的形参必须放在最后）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果函数的声明有了默认参数，函数实现就不能有默认参数。（即声明和实现只能有一个有默认参数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">error C2572: <span class="string">&quot;func2&quot;</span>：重定义默认参数</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数占位参数">函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p>语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);<span class="comment">//这里必须要传两个数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>占位参数还可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a function.&quot;</span> &lt;&lt;endl</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载">函数重载</h3><h4 id="1-函数重载概述">1. 函数重载概述</h4><p>**作用：**函数名可以相同，提高复用性</p><p><strong>函数重载满足条件</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同、个数不同、顺序不同</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//func函数都在全局作用域下</span></span><br><span class="line"><span class="comment">//func函数名称相同</span></span><br><span class="line"><span class="comment">//func函数参数类型不同、或个数不同、或顺序不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func().&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a, double b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-函数重载注意事项">2. 函数重载注意事项</h4><ul><li><p>函数的返回值不可以作为函数重载的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="comment">//无法重载仅按返回类型区分的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(double a, int b).&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用作为重载条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数类型不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int &amp;a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(const int &amp;a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);<span class="comment">//调用func(int &amp;a)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用func(const int &amp;a)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数重载碰到默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is func(int a, int b).&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//X 当函数重载碰到默认参数，出现二义性报错，尽量避免重载时使用默认参数</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);<span class="comment">//√</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考</strong>：黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难<br><strong>链接</strong>：<a href="https://www.bilibili.com/video/BV1et411b73Z">https://www.bilibili.com/video/BV1et411b73Z</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（十二）常用可视化工具</title>
      <link href="/post/bc15620d.html"/>
      <url>/post/bc15620d.html</url>
      
        <content type="html"><![CDATA[<h3 id="Qt工具箱">Qt工具箱</h3><h4 id="1-rqt-console">1. rqt_console</h4><p>（1）回到系统内，首先启动海龟例程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rqt_console</span><br></pre></td></tr></table></figure><p>上面的窗口显示日志的输出信息，info信息、warning警告、error错误等<br><img src="https://img.mahaofei.com/img/202112231703320-ros-notes12-1.png" alt=""></p><p>（2）运行键盘控制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>当小海龟碰到边界时，可以看到控制台会输出warning<br><img src="https://img.mahaofei.com/img/202112231703366-ros-notes12-2.png" alt=""></p><h4 id="2-rqt-plot">2. rqt_plot</h4><p>关闭rot_console控制台，再在终端输入<code>rqt_plot</code></p><p>在Topic栏输入<code>/turtle1/pose</code></p><p>可以看到小海龟的位姿信息都会被输出出来<br><img src="https://img.mahaofei.com/img/202112231704699-ros-notes12-3.png" alt=""></p><blockquote><p>如果打不开的可以在终端输入rqt，进入后选择plugin-visualization-plot打开</p><p>如果出现核心已转：运行<code>sudo apt-get install python-pip</code>和<code>python -m pip install -U matplotlib</code></p></blockquote><h4 id="3-rqt-image-view">3. rqt_image_view</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_image_view</span><br></pre></td></tr></table></figure><p>需要驱动摄像头，在这里显示镜头的图像，选择图像的信息后会渲染出来。<br><img src="https://img.mahaofei.com/img/202112231704369-ros-notes12-4.png" alt=""></p><h4 id="4-rqt">4. rqt</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt</span><br></pre></td></tr></table></figure><p>集成了所有rqt工具，在plugins可以看到所有插件。<br><img src="https://img.mahaofei.com/img/202112231704839-ros-notes12-5.png" alt=""></p><h3 id="Rviz">Rviz</h3><p>在命令行输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun rviz rviz</span><br></pre></td></tr></table></figure><p>Rviz是一款三维可视化工具，可以很好的兼容基域ROS软件框架的机器人平台。</p><ul><li>在Rviz中，可以使用扩展标记语言XML对机器人、周围物体等任何实物进行尺寸、质量、位置、材质等属性的描述，并在界面中显示出来。</li><li>Rviz可以通过图形化的方式显示机器人传感器信息、机器人运动状态、环境信息等。</li></ul><p>Rviz界面主要包括：3D视图区，视角设置区，工具栏，显示项列表，时间显示区</p><p>Rviz是数据显示平台，所以显示数据时，需要选择Topic。<br><img src="https://img.mahaofei.com/img/202112231704368-ros-notes12-6.png" alt=""></p><h3 id="Gazebo">Gazebo</h3><p>Gazebo是一款功能强大的三位物理仿真平台，用来仿真机器人、传感器、环境的平台。</p><p>在Gazebo也包括：0-3D视图区，1-工具栏，2-模型列表，3-模型属性，4-时间显示区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch gazebo_ros willow</span><br></pre></td></tr></table></figure><p>可能运行不成功，Gazebo对计算机性能要求较高，而且第一次加载会从远程服务器下载一些材质包、环境等。</p><p><img src="https://img.mahaofei.com/img/20220410103348.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（十一）launch启动文件的使用方法</title>
      <link href="/post/cfdda38f.html"/>
      <url>/post/cfdda38f.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Launch文件作用">一、Launch文件作用</h3><ul><li>通过XML文件实现多节点的配置和启动。</li><li>同时可以自动启动ROS Master（不需要单独<code>roscore</code>）。</li></ul><h3 id="二、Launch文件语法">二、Launch文件语法</h3><h4 id="1-launch">1. <code>&lt;launch&gt;</code></h4><p>launch文件中的根元素采用<code>&lt;launch&gt;</code>标签定义</p><h4 id="2-node">2. <code>&lt;node&gt;</code></h4><p>启动节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package-name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;executable-name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node-name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>pkg：节点所在功能包名称</li><li>type：节点的可执行文件名称</li><li>name：节点运行时的名称</li><li>其他可选属性：<ul><li>output（是否打印日志信息）</li><li>respawn（是否在出现错误时重启）</li><li>require（是否要求某个节点必须启动）</li><li>ns（namespace定义命名空间，避免命名冲突）</li><li>args（给每个节点输入参数）</li></ul></li></ul><h4 id="3-参数设置">3. 参数设置</h4><ul><li><p><code>&lt;param&gt;</code>或<code>&lt;param&gt;</code></p><p>设置系统中的参数，存储在参数服务器中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abcd&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>加载参数文件中的多个参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;params&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;arg&gt;</code></p><p>launch文件内部的局部变量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;arg-name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;arg-value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-重映射-remap">4. 重映射<code>&lt;remap&gt;</code></h4><p>重映射ROS计算图资源的命名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/turtlebot/cmd_vel&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/cmd_vel&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-嵌套-include">5. 嵌套<code>&lt;include&gt;</code></h4><p>包含其他launch文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、Launch示例">三、Launch示例</h3><h4 id="1-新建一个功能包">1. 新建一个功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_launch</span><br></pre></td></tr></table></figure><h4 id="2-创建launch文件夹">2. 创建launch文件夹</h4><p>在learning_launch文件夹下新建一个名为<code>launch</code>的文件夹。</p><h4 id="3-创建launch文件">3. 创建launch文件</h4><p>在刚才创建的文件夹内新建一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchs simple.launch</span><br></pre></td></tr></table></figure><p>其内容为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_subscriber&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231702958-ros-notes11-1.png" alt=""></p><h4 id="4-运行launch文件">4. 运行launch文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch learning_launch simple.launch</span><br></pre></td></tr></table></figure><p>可以看到两个节点都运行起来了。<br><img src="https://img.mahaofei.com/img/202112231702374-ros-notes11-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（十）ROS中的坐标系管理系统</title>
      <link href="/post/6c3b819e.html"/>
      <url>/post/6c3b819e.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、机器人中的坐标变换">一、机器人中的坐标变换</h3><p>TF功能包用来管理所有的坐标系。它可以记录十秒钟之内所有坐标系之间的关系，可以展示夹取的物体相对于机器人中心坐标系的位置在哪里。</p><h3 id="二、举例：小海龟跟随实验">二、举例：小海龟跟随实验</h3><h4 id="1-小海龟跟随">1. 小海龟跟随</h4><p>两只海龟出现之后，一只海龟在中心点，另一只海龟出现在下方，可以控制中心的海龟进行运动，下方的海龟会自动跟随我们控制的海龟进行运动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-turtle-tf</span><br><span class="line">roslaunch turtle_tf turtle_tf_demo.launch</span><br><span class="line"><span class="comment">#rosrun turtlesim turtle_teleop_key</span></span><br></pre></td></tr></table></figure><p>其中roslaunch用来启动脚本文件，启动其中的很多节点<br>其中的noetic为ROS版本号</p><p>在terminal中按方向键即可控制被跟随的乌龟。<br><img src="https://img.mahaofei.com/img/202112231659245-ros-notes10-1.png" alt=""></p><blockquote><p>如果ubuntu20.04 noetic版本出现报错可以参考下面的方法解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">sudo rm -r python# 有的可能没有这个文件，就省略这一步</span><br><span class="line">sudo cp python3 python</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-查看tf关系">2. 查看tf关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf view_frames</span><br></pre></td></tr></table></figure><p>等待5秒，生成一个pdf文件，打开可以看到当前系统中tf坐标的位置关系。<br><img src="https://img.mahaofei.com/img/202112231659486-ros-notes10-2.png" alt=""></p><p>其中world是全局坐标系，另外的turtle1和turtle2是两只海龟上的坐标系。例程的目的是使两个坐标系在坐标上是重叠的。</p><blockquote><p>此步如果出错则需要执行修改报错的文件<br><code>sudo gedit /opt/ros/noetic/lib/tf/view_frames </code><br>在第88行<code>print(vstr)</code>上方添加一句<code>vstr=str(vstr)</code>就可以了</p></blockquote><h4 id="3-tf-echo坐标关系">3. tf_echo坐标关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf tf_echo turtle1 turtle2</span><br></pre></td></tr></table></figure><p>输出两个坐标系之间的关系，描述turtle2坐标系如何变换到turtle1坐标系。包括Translation平移和Rotation旋转（四元数、弧度、角度三种方式描述旋转）。<br><img src="https://img.mahaofei.com/img/202112231659014-ros-notes10-3.png" alt=""></p><h4 id="4-rviz三维可视化显示平台">4. rviz三维可视化显示平台</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun rviz rviz -d <span class="string">&#x27;rospack find turtle_tf&#x27;</span> /rviz/turtle_rviz.rviz</span><br></pre></td></tr></table></figure><p>首先将左侧Fixed Frame改成world</p><p>点击左下方Add，添加一个TF，用来显示TF位置关系<br><img src="https://img.mahaofei.com/img/202112231659046-ros-notes10-4.png" alt=""></p><p>控制海龟运动，可以看到图中两个坐标系在运动<br><img src="https://img.mahaofei.com/img/202112231701272-ros-notes10-5.png" alt=""></p><h3 id="三、TF坐标系广播与监听的编程实现">三、TF坐标系广播与监听的编程实现</h3><h4 id="1-创建功能包-3">1. 创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_tf roscpp rospy tf turtlesim</span><br></pre></td></tr></table></figure><h4 id="2-创建tf广播器代码">2. 创建tf广播器代码</h4><p>打开<code>learning_tf/src/</code>目录，在其中创建一个<code>turtle_tf_broadcaster.cpp</code></p><p>其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> * REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建tf的广播器</span></span><br><span class="line"><span class="type">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化tf数据</span></span><br><span class="line">tf::Transform transform;</span><br><span class="line">transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">tf::Quaternion q;</span><br><span class="line">q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-创建监听器listener代码">3. 创建监听器listener代码</h4><p>同样的，再创建一个<code>turtle_tf_listener.cpp</code>，其内容为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> * REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求产生turtle2</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">ros::Publisher turtle_vel = node.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tf的监听器</span></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">tf::StampedTransform transform;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (tf::TransformException &amp;ex) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-配置tf广播器与监听器代码编译规则">4. 配置tf广播器与监听器代码编译规则</h4><p>配置<code>learning_tf</code>中的<code>CMakeLists.txt</code>，在图示位置添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(turtle_tf_listener src/turtle_tf_listener.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_tf_listener $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231701891-ros-notes10-6.png" alt=""></p><p>即分别把两个cpp文件编译成两个可执行文件，然后对库进行链接。</p><h4 id="5-编译">5. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h4 id="6-运行程序">6. 运行程序</h4><p>以下程序每一行均需要一个单独的terminal运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2</span><br><span class="line">rosrun learning_tf turtle_tf_listener</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231701727-ros-notes10-7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（九）参数的使用与编程方法</title>
      <link href="/post/b8ca2ffd.html"/>
      <url>/post/b8ca2ffd.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、参数模型">一、参数模型</h3><p>在ROS Master中有一个Parameter Server参数服务器，它是一个全局字典，用来保存各种配置参数，配置参数是各个节点都可以全局访问的。</p><h3 id="二、使用方法">二、使用方法</h3><h4 id="1-列出当前所有参数">1. 列出当前所有参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><h4 id="2-显示某个参数值">2. 显示某个参数值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam get param_key</span><br></pre></td></tr></table></figure><h4 id="3-设置某个参数值">3. 设置某个参数值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span> param_key param_value</span><br></pre></td></tr></table></figure><h4 id="4-保存参数到文件">4. 保存参数到文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam dump file_name</span><br></pre></td></tr></table></figure><h4 id="5-从文件读取参数">5. 从文件读取参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam load file_name</span><br></pre></td></tr></table></figure><h4 id="6-删除参数">6. 删除参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam delete param_key</span><br></pre></td></tr></table></figure><h3 id="三、举例">三、举例</h3><h4 id="1-创建功能包-2">1. 创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_parameter roscpp rospy std_srvs</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656763-ros-notes9-1.png" alt=""></p><h4 id="2-打开小海龟仿真器">2. 打开小海龟仿真器</h4><p>打开一个终端，启动roscore：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>再打开一个终端，运行小海龟仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656152-ros-notes9-2.png" alt=""></p><h4 id="3-rosparam命令行的使用">3. rosparam命令行的使用</h4><p>（1）查看参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><p>（2）得到变量的值：背景颜色RGB的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosparam get /turtlesim/background_r</span><br><span class="line">rosparam get /turtlesim/background_g</span><br><span class="line">rosparam get /turtlesim/background_b</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656272-ros-notes9-3.png" alt=""></p><p>（3）修改变量的值：更改背景颜色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam <span class="built_in">set</span> /turtlesim/background_b 100</span><br></pre></td></tr></table></figure><p>重新发送请求，刷新背景颜色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231656088-ros-notes9-4.png" alt=""></p><p>（4）保存参数到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam dump param.yaml</span><br></pre></td></tr></table></figure><p>参数默认保存到当前目录<br><img src="https://img.mahaofei.com/img/202112231657663-ros-notes9-5.png" alt=""></p><p>（5）加载参数文件</p><p>打开刚刚保存的参数文件，对其中的参数值进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam load param.yaml</span><br></pre></td></tr></table></figure><p>即可将文件里面的参数内容修改系统内的参数。<br><img src="https://img.mahaofei.com/img/202112231657124-ros-notes9-6.png" alt=""></p><p>（6）删除参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam delete /turtlesim/background_g</span><br></pre></td></tr></table></figure><p>查看参数列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam list</span><br></pre></td></tr></table></figure><p>刷新小海龟仿真器背景颜色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /clear <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231657366-ros-notes9-7.png" alt=""></p><h3 id="四、通过程序获取、设置参数的值">四、通过程序获取、设置参数的值</h3><h4 id="1-编写cpp程序">1. 编写cpp程序</h4><p>在learning_parameter/src/目录下创建一个<code>parameter_config.cpp</code>的文件</p><p>其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> * REFERENCE：www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">ros::ServiceClient clear_background = node.<span class="built_in">serviceClient</span>&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">std_srvs::Empty srv;</span><br><span class="line">clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231658670-ros-notes9-8.png" alt=""></p><h4 id="2-编译程序">2. 编译程序</h4><p>打开<code>learning_parameter/</code>下的<code>CMakeList.txt</code>文件，在其中添加编译规则。(install上方)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(parameter_config src/parameter_config.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(parameter_config $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231658934-ros-notes9-9.png" alt=""></p><p>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h4 id="3-运行程序">3. 运行程序</h4><p>运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>运行小海龟仿真程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>运行刚才编写的节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_parameter parameter_config</span><br></pre></td></tr></table></figure><p>发现小海龟的颜色被改变了，说明程序执行成功<br><img src="https://img.mahaofei.com/img/202112231658716-ros-notes9-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（八）服务数据的定义与使用</title>
      <link href="/post/65ca30a6.html"/>
      <url>/post/65ca30a6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的-4">一、目的</h3><p>Client每Request一次数据请求，Server发送一次数据。数据格式为个人信息，如姓名、性别等。</p><h3 id="二、自定义服务数据">二、自定义服务数据</h3><p>此步骤与<a href="https://blog.csdn.net/weixin_44543463/article/details/114108345">话题消息的定义与使用</a>过程类似</p><h4 id="1-定义srv文件">1. 定义srv文件</h4><p>再<code>learning_service</code>文件夹下新建一个文件夹<code>srv</code>，再在<code>srv</code>文件夹内新建一个<code>Person.srv</code>文件，内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8  age</span><br><span class="line">uint8  sex</span><br><span class="line"></span><br><span class="line">uint8 unknown = <span class="number">0</span></span><br><span class="line">uint8 male    = <span class="number">1</span></span><br><span class="line">uint8 female  = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">string result</span><br></pre></td></tr></table></figure><p>—以上是request的数据，—以下是response的数据<br><img src="https://img.mahaofei.com/img/202112231654771-ros-notes8-1.png" alt=""></p><h4 id="2-在package-xml中添加功能包依赖">2. 在package.xml中添加功能包依赖</h4><p>打开<code>learning_service/package.xml</code>，在文件最后部分添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231654282-ros-notes8-2.png" alt=""></p><h4 id="3-在CMakeLists-txt中添加编译选项">3. 在CMakeLists.txt中添加编译选项</h4><p>首先在<code>find_package</code>最后一行添加一条语句<code>message_generation</code>，用以添加依赖的功能包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231654047-ros-notes8-3.png" alt=""></p><p>在此函数下面再添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_service_files</span>(</span><br><span class="line">  FILES</span><br><span class="line">  Person.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">generate_messages</span>(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>add_message_files，将Person.srv作为定义的接口</p><p>generate_messages，在编译Person.srv文件时需要依赖的功能包<br><img src="https://img.mahaofei.com/img/202112231654750-ros-notes8-4.png" alt=""></p><p>然后在下方<code>catkin specific configuration</code>内的<code>catkin_packages</code>中，添加依赖<code>message_runtime</code>，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catkin_package</span>(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES learning_topic</span><br><span class="line">   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231655676-ros-notes8-5.png" alt=""></p><h4 id="4-编译生成相关文件-2">4. 编译生成相关文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="三、创建服务器代码">三、创建服务器代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个person_server.cpp`的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment">REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置反馈数据</span></span><br><span class="line">res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、创建客户端代码">四、创建客户端代码</h3><p>同样在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>person_client.cpp</code>的文件，其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment">REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">ros::ServiceClient person_client = node.<span class="built_in">serviceClient</span>&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">learning_service::Person srv;</span><br><span class="line">srv.request.name = <span class="string">&quot;Huffie&quot;</span>;</span><br><span class="line">srv.request.age  = <span class="number">21</span>;</span><br><span class="line">srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line"> srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231655990-ros-notes8-6.png" alt=""></p><h3 id="五、配置服务器-客户端代码编译规则">五、配置服务器/客户端代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_client $&#123;PROJECT_NAME&#125;_gencpp)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231655263-ros-notes8-7.png" alt=""></p><h3 id="六、编译并运行发布者和订阅者">六、编译并运行发布者和订阅者</h3><p>首先进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行发布者和订阅者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun learning_service person_server</span><br><span class="line">rosrun learning_service person_client</span><br></pre></td></tr></table></figure><p>client每请求一次，会接受到一次数据<br><img src="https://img.mahaofei.com/img/202112231655403-ros-notes8-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（七）服务端Server的实现</title>
      <link href="/post/a31f0ac2.html"/>
      <url>/post/a31f0ac2.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的-3">一、目的</h3><p>Server端等待信号，每次接收到Client端的信号，海龟的运动状态就切换一次（运动→停止、停止→运动）</p><h3 id="二、创建服务器代码">二、创建服务器代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>turtle_command_server.cpp</code>的文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span></span><br><span class="line"><span class="comment"> REFERENCE:www.guyuehome.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_srvs/Trigger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="type">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         std_srvs::Trigger::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置反馈数据</span></span><br><span class="line">res.success = <span class="literal">true</span>;</span><br><span class="line">res.message = <span class="string">&quot;Change turtle command state!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">turtle_vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line"><span class="keyword">if</span>(pubCommand)</span><br><span class="line">&#123;</span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照循环频率延时</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现过程：</p><ol><li>初始化ROS节点</li><li>创建Server实例</li><li>循环等待服务请求，进入回调函数</li><li>在回调函数中完成服务功能的处理，并反馈应答数据<br><img src="https://img.mahaofei.com/img/202112231653779-ros-notes7-1.png" alt=""></li></ol><h3 id="三、配置服务器代码编译规则">三、配置服务器代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(turtle_command_server src/turtle_command_server.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(turtle_command_server $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure><p>把turtle_command_server.cpp编译成turtle_command_server文件，同时去链接需要依赖的库文件。<br><img src="https://img.mahaofei.com/img/202112231653176-ros-notes7-2.png" alt=""></p><h3 id="四、编译并运行">四、编译并运行</h3><p>编译服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">cadkin_make</span><br></pre></td></tr></table></figure><p>生效环境变量（如果已经在<code>.bashrc</code>中<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">添加了环境变量</a>则不需要再执行此步）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><p>再运行以下代码（以下三行需要各自启动一个终端）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_command_server</span><br></pre></td></tr></table></figure><p>再启动一个终端，输入代码<code>rosservice call /turtle_command+空格+两次Tab</code>发送信号，海龟开始运动，<strong>再次发送同样的信号</strong>，小海龟停止。</p><p><img src="https://img.mahaofei.com/img/202112231653462-ros-notes7-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（六）客户端Client的编程实现</title>
      <link href="/post/9b3f197.html"/>
      <url>/post/9b3f197.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的">一、目的</h3><p>通过程序，发布服务请求。</p><p>即通过客户端的请求，发给服务端产生一个海龟，反馈回客户端。</p><h3 id="二、创建功能包-3">二、创建功能包</h3><p>回到<code>catkin_ws/src</code>文件夹下，创建一个名为<code>learning_service</code>的功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231651523-ros-notes6-1.png" alt=""></p><h3 id="三、创建客户端代码">三、创建客户端代码</h3><p>在<code>~/catkin_ws/src/learning_service/src</code>目录下创建一个<code>turtle_spawn.cpp</code>的文件，其内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spawn turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spawn turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码👆的实现过程如下：</p><ol><li>初始化ROS节点</li><li>创建一个Client实例</li><li>发布服务请求数据</li><li>等待Server处理之后的应答结果<br><img src="https://img.mahaofei.com/img/202112231652508-ros-notes6-2.png" alt=""></li></ol><h3 id="四、配置客户端代码编译规则">四、配置客户端代码编译规则</h3><p>打开<code>learning_service</code>中的<code>CMakeLists.txt</code>，在图示区域添加代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(turtle_spawn src/turtle_spawn.cpp)</span><br><span class="line">target_link_libraries(turtle_spawn <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><p>add_executable添加编译规则，target_link_libraries链接一些需要的库<br><img src="https://img.mahaofei.com/img/202112231652255-ros-notes6-3.png" alt=""></p><h3 id="五、编译与运行">五、编译与运行</h3><p>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231652845-ros-notes6-4.png" alt=""></p><p>运行客户端，可以看到产生了第二个小海龟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_spawn</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231652468-ros-notes6-5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（五）话题消息的定义与使用</title>
      <link href="/post/28bcb558.html"/>
      <url>/post/28bcb558.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目的-2">一、目的</h3><p>在ROS Master中，可以发布与订阅已经定义好的消息，比如海龟的运动、位姿等信息。但有时我们需要自己定义消息的类型。</p><p>本节主要目的为定义一个Person个人信息，Publisher发布个人信息，Subscriber订阅个人信息。</p><h3 id="二、自定义话题消息">二、自定义话题消息</h3><h4 id="1-定义msg文件">1. 定义msg文件</h4><p>在功能包<code>learning_topic</code>文件夹中新建一个文件夹<code>msg</code>，在此文件夹内创建一个<code>Person.msg</code>文件，在其中添加以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br><span class="line"></span><br><span class="line">uint8 unknown=<span class="number">0</span></span><br><span class="line">uint8 male=<span class="number">1</span></span><br><span class="line">uint8 female=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>注：<code>uint8</code>和<code>string</code>，在不同程序里面需要扩展成对应的格式，因此需要先进行一些配置。<br><img src="https://img.mahaofei.com/img/202112231649673-ros-notes5-1.png" alt=""></p><h4 id="2-在package-xml文件中添加功能包依赖">2. 在package.xml文件中添加功能包依赖</h4><p>在文件末尾部分，添加如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>build_depend，编译依赖，依赖一个动态产生message的功能包</p><p>exec_depend，执行依赖， 依赖message运行时间的功能包<br><img src="https://img.mahaofei.com/img/202112231650056-ros-notes5-2.png" alt=""></p><h4 id="3-在CMakeLists-txt添加编译选项">3. 在CMakeLists.txt添加编译选项</h4><p>首先在<code>find_package</code>内添加一条语句，用以添加依赖的功能包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231650566-ros-notes5-3.png" alt=""></p><p>在此函数下面再添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_message_files</span>(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">generate_messages</span>(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>add_message_files，将Person.msg作为定义的接口</p><p>generate_messages，在编译Person.msg文件时需要依赖的功能包<br><img src="https://img.mahaofei.com/img/202112231650214-ros-notes5-4.png" alt=""></p><p>然后在下方<code>catkin specific configuration</code>内的<code>catkin_packages</code>中，添加依赖<code>message_runtime</code>，修改后的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catkin_package</span>(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES learning_topic</span><br><span class="line">   CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231650548-ros-notes5-5.png" alt=""></p><h4 id="4-编译生成相关文件">4. 编译生成相关文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><h3 id="三、创建发布者">三、创建发布者</h3><p>在<code>~/catkin_ws/src/learning_topic/src</code>文件夹下创建<code>person_publisher.cpp</code>文件，内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.<span class="built_in">advertise</span>&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    learning_topic::Person person_msg;</span><br><span class="line">person_msg.name = <span class="string">&quot;huffie&quot;</span>;</span><br><span class="line">person_msg.age  = <span class="number">21</span>;</span><br><span class="line">person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、创建订阅者">四、创建订阅者</h3><p>在<code>~/catkin_ws/src/learning_topic/src</code>文件夹下创建<code>person_subscriber.cpp</code>文件，内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> REFERENC:www.guyuehome.com.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="type">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line"> msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231651965-ros-notes5-6.png" alt=""></p><h3 id="五、配置发布者-订阅者代码编译规则">五、配置发布者/订阅者代码编译规则</h3><p>在<code>CMakeLists.txt</code>文件的<code>build</code>区域内添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_publisher $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(person_subscriber $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line"><span class="built_in">add_dependencies</span>(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp)</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231651308-ros-notes5-7.png" alt=""></p><h3 id="六、编译与运行">六、编译与运行</h3><p>首先进行编译，回到主目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>运行roscore</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>运行订阅者Subscriber</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_topic person_subscriber</span><br></pre></td></tr></table></figure><p>运行发布者Publisher</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_topic person_Publisher</span><br></pre></td></tr></table></figure><p>可以看到发布者在发布个人信息，订阅者在接受信息。<br><img src="https://img.mahaofei.com/img/202112231651808-ros-notes5-8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（四）订阅者Subscriber的实现</title>
      <link href="/post/57898ee9.html"/>
      <url>/post/57898ee9.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目标功能">一、目标功能</h3><p>订阅者订阅海龟的位姿信息。</p><h3 id="二、创建功能包">二、创建功能包</h3><p>首先创建工作空间，参考<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">【ROS学习笔记】（二）工作空间与功能包的创建</a></p><p>然后创建一个功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_creat_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><h3 id="三、创建订阅者代码">三、创建订阅者代码</h3><p>进入功能包的src文件夹下，创建一个cpp文件（也可以在图形界面直接创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/src</span><br><span class="line">touch pose_subscriber.cpp</span><br><span class="line">sudo gedit pose_subscriber.cpp</span><br></pre></td></tr></table></figure><p>输入以下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">Copyright 2020 GuYueHome (www.guyuehome.com).</span><br><span class="line">***********************************************************************/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"><span class="comment">#include &lt;ros/ros.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;turtlesim/Pose.h&quot;</span></span><br><span class="line"></span><br><span class="line">// 接收到订阅的消息后，会进入消息回调函数</span><br><span class="line">void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)</span><br><span class="line">&#123;</span><br><span class="line">    // 将接收到的消息打印出来</span><br><span class="line">    ROS_INFO(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化ROS节点</span><br><span class="line">    ros::init(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    // 创建节点句柄</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span><br><span class="line">    ros::Subscriber pose_sub = n.subscribe(<span class="string">&quot;/turtle1/pose&quot;</span>, 10, poseCallback);</span><br><span class="line"></span><br><span class="line">    // 循环等待回调函数</span><br><span class="line">    ros::spin();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码思路：</p><ol><li>初始化ROS节点</li><li>订阅需要的话题</li><li>循环等待话题消息，接收到消息后进入回调函数</li><li>在回调函数中完成消息处理<br><img src="https://img.mahaofei.com/img/202112231649178-ros-notes4-1.png" alt=""></li></ol><h3 id="四、配置订阅者代码编译规则">四、配置订阅者代码编译规则</h3><ol><li><p>设置需要编译的代码和生成的可执行文件</p></li><li><p>设置链接库</p></li></ol><p>在<code>Learning_topic/CMakeList.txt</code>文件的Build下方（Install上方），添加代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(pose_subscriber src/pose_subscriber.cpp)<span class="comment">#描述要把哪个程序文件编译成哪个可执行文件</span></span><br><span class="line">target_link_libraries(pose_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#把可执行文件和库做链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231649732-ros-notes4-2.png" alt=""></p><h3 id="五、编译并运行订阅者SubScriber">五、编译并运行订阅者SubScriber</h3><h4 id="1-编译">1. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><blockquote><p>可以在[.bash]文件最后添加source语句，这样就不用每次再在终端输入source命令</p><p>sudo vim ~/catkin_ws<br>source /home/huffie/catkin_ws/devel/setup.bash</p></blockquote><h4 id="2-运行">2. 运行</h4><p>打开小海龟的仿真程序，运行subscriber，同时让小海龟动起来，可以看到姿态坐标在实时改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic pose_subscriber</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231649325-ros-notes4-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（三）发布者Publisher的实现</title>
      <link href="/post/5bbac892.html"/>
      <url>/post/5bbac892.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、目标功能-2">一、目标功能</h3><p>ROS Master内有两个节点，一个是Subscriber(turtlesim)，一个是Publisher，发布者通过程序实现发布Message，Message的内容包括线速度、角度，通过Topic管道，传递给Subscriber，从而控制小海龟的运动。</p><h3 id="二、创建功能包-2">二、创建功能包</h3><p>首先先创建一个工作空间，具体参考上一节<a href="https://blog.csdn.net/weixin_44543463/article/details/113985223">【ROS学习笔记】（二）工作空间与功能包的创建</a></p><p>然后创建一个功能包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647709-ros-notes3-1.png" alt=""></p><h3 id="三、创建发布者代码">三、创建发布者代码</h3><p>进入功能包的src文件夹下，创建一个cpp文件（也可以在图形界面直接创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/src</span><br><span class="line">touch velocity_publisher.cpp</span><br><span class="line">sudo gedit velocity_publisher.cpp</span><br></pre></td></tr></table></figure><p>输入以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ROS节点初始化</span></span><br><span class="line">ros::init(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率</span></span><br><span class="line">ros::Rate <span class="title function_">loop_rate</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ros::ok())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">turtle_vel_pub.publish(vel_msg);</span><br><span class="line">ROS_INFO(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">    loop_rate.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647723-ros-notes3-2.png" alt=""></p><h3 id="四、配置发布者代码编译规则">四、配置发布者代码编译规则</h3><ol><li><p>设置需要编译的代码和生成的可执行文件</p></li><li><p>设置链接库</p></li></ol><p>在<code>Learning_topic/CMakeList.txt</code>文件的Build下方（Install上方），添加代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(velocity_publisher src/velocity_publisher.cpp)<span class="comment">#描述要把哪个程序文件编译成哪个可执行文件</span></span><br><span class="line">target_link_libraries(velocity_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#把可执行文件和库做链接</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231648236-ros-notes3-3.png" alt=""></p><h3 id="五、编译并运行发布者Publisher">五、编译并运行发布者Publisher</h3><h4 id="1-编译-2">1. 编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><blockquote><p>可以在<code>~/.bashrc</code>文件最后添加source语句，这样就不用每次再在终端输入source命令创建环境变量（路径中替换成自己的用户名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/【Username】/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://img.mahaofei.com/img/202112231648682-ros-notes3-4.png" alt=""></p><h4 id="2-运行-2">2. 运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231648643-ros-notes3-5.png" alt=""></p><blockquote><p>参考教程：<strong>古月ROS入门21讲</strong><br>GitHub：<a href="https://github.com/guyuehome/ros_21_tutorials">https://github.com/guyuehome/ros_21_tutorials</a><br>Bilibili：<a href="https://www.bilibili.com/video/BV1zt411G7Vn">https://www.bilibili.com/video/BV1zt411G7Vn</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（二）工作空间与功能包的创建</title>
      <link href="/post/bf2fd3f4.html"/>
      <url>/post/bf2fd3f4.html</url>
      
        <content type="html"><![CDATA[<h3 id="工作空间的概念">工作空间的概念</h3><p>工作空间是存放工程开发相关文件的文件夹，类似windows中使用ide时创建的工程。</p><h3 id="工作空间包括的文件夹">工作空间包括的文件夹</h3><ol><li>src：代码空间</li><li>build：编译空间，编译过程中的中间文件，一般用不到</li><li>devel：开发空间，放置开发过程中的可执行文件、库等</li><li>install：安装空间</li></ol><h3 id="创建工作空间">创建工作空间</h3><h4 id="1-创建工作空间">1. 创建工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><h4 id="2-编译工作空间">2. 编译工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">catkin_make install <span class="comment">#产生install文件夹</span></span><br></pre></td></tr></table></figure><h4 id="3-设置环境变量">3. 设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure><h4 id="4-检查环境变量">4. 检查环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647957-ros-notes2-1.png" alt=""></p><h3 id="创建功能包">创建功能包</h3><p><code>catkin_creat_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</code></p><h4 id="1-创建功能包">1. 创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pkg std_msgs rospy roscpp</span><br></pre></td></tr></table></figure><p><em>注：功能包要放在src文件夹下，同一个工作空间不能有同名的功能包</em></p><p>创建功能包后，在功能包test_pkg文件夹下有<strong>src、include</strong>文件夹和<strong>package.xml、CMakeLists.txt</strong>文件</p><p>(1)src文件夹：放置代码文件<br>(2)include文件夹：放置头文件<br>(3)package.xml：与功能包相关的信息<br>（如名字、版本号、许可证、作者信息、功能包的依赖信息等）<br>(4)CMakeLists.txt：描述功能包的编译规则</p><h4 id="2-编译功能包">2. 编译功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231647602-ros-notes2-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ROS学习笔记】（一）常用命令的解释与举例</title>
      <link href="/post/208ac25a.html"/>
      <url>/post/208ac25a.html</url>
      
        <content type="html"><![CDATA[<h5 id="1-roscore">1. roscore</h5><p>roscore是用来启动ros master，是运行ros系统前首先运行的命令<br><img src="https://img.mahaofei.com/img/202112231644191-ros-notes1-1.png" alt=""></p><h5 id="2-rosrun">2. rosrun</h5><p>rosrun是用来运行某个功能包内的某个节点的指令，有两个参数，第一个参数是功能包名，第二个参数是节点名</p><blockquote><p><strong>例：仿真小海龟</strong><br>在一个终端中输入<code>rosrun turtlesim turtlesim_node</code><br>在另一个终端中输入<code>rosrun turtlesim turtle_teleop_key</code><br><img src="https://img.mahaofei.com/img/202112231644184-ros-notes1-2.png" alt=""></p></blockquote><h5 id="3-rosnode">3. rosnode</h5><p>rosnode，用来显示节点相关信息的指令</p><ul><li>rosnode list用来把系统中所有节点都列出来<br><img src="https://img.mahaofei.com/img/202112231645569-ros-notes1-3.png" alt=""></li><li>rosnode info *，查看节点的具体信息，如正在发布哪些话题、提供的服务、等其他信息<br><img src="https://img.mahaofei.com/img/202112231645955-ros-notes1-4.png" alt=""></li></ul><h5 id="4-rostopic">4. rostopic</h5><ul><li>rostopic list，输出当前系统中所有话题的列表<br><img src="https://img.mahaofei.com/img/202112231645086-ros-notes1-5.png" alt=""></li><li>rostopic pub 【话题名+tab补全】，显示发布的内容<br><img src="https://img.mahaofei.com/img/202112231645993-ros-notes1-6.png" alt=""></li></ul><blockquote><p><strong>例：通过发布话题(rostopic pub)控制小海龟运动</strong><br>输入代码：<code>rostopic pub -r 10 /turtle1/cmd_vel+两次tab补全</code><br>通过修改linear速度和angular角度，可以控制小海龟的运动。其中 -r 10 是话题发布的频率，每秒发布十次。<br><img src="https://img.mahaofei.com/img/202112231646567-ros-notes1-7.png" alt=""></p></blockquote><h5 id="5-rosservice">5. rosservice</h5><ul><li>roservice list 可以显示ros系统内所有服务的列表（所有服务端都是上面的海龟仿真器）</li><li>rosservice call 【服务名称+tab补全】发布请求</li></ul><blockquote><p>例：产生两只海龟（服务列表中/spawn是产生海龟的请求）<br>输入代码：<code>rosservice call /spawn+两次tab补全</code><br>其中x，y是新海龟的坐标（仿真器左下角为原点）<br><img src="https://img.mahaofei.com/img/202112231646126-ros-notes1-8.png" alt=""></p></blockquote><h5 id="6-rosbag">6. rosbag</h5><p>记录当前系统内所有话题数据，并在下次复现出来。</p><blockquote><p><strong>例：保存小海龟的运动</strong></p><ol><li>输入命令：<code>rosbag record -a -O cmd_record</code><br>其中record指做记录，-a指记录所有数据，-o指将数据保存成压缩包，最后是保存文件的名字</li><li>回到key终端，用键盘方向键控制小海龟进行运动</li><li>运动完成后使用<code>ctrl+C</code>中断rosbag record<br><img src="https://img.mahaofei.com/img/202112231646263-ros-notes1-9.png" alt=""></li></ol></blockquote><blockquote><p><strong>例：复现小海龟的运动</strong></p><ol><li>关掉之前打开的终端，重新打开一个终端，运行<code>roscore</code></li><li>再新开一个终端，启动小海龟的仿真：<code>rosrun turtlesim turtlesim_node</code>（这里不需要启动键盘输入）</li><li>再新开一个终端，实现小海龟的动作复现：<code>rosbag play cmd_record.bag</code><br><img src="https://img.mahaofei.com/img/202112231646907-ros-notes1-10.png" alt=""></li></ol></blockquote><p><strong>本文学习内容来自古月居</strong><br>官方论坛：<a href="https://www.guyuehome.com/">https://www.guyuehome.com/</a><br>学习视频：<a href="https://www.bilibili.com/video/BV1zt411G7Vn">https://www.bilibili.com/video/BV1zt411G7Vn</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS安装时rosdep_init与rosdep_update问题解决方法（2021.2.20亲测）</title>
      <link href="/post/6e920e4a.html"/>
      <url>/post/6e920e4a.html</url>
      
        <content type="html"><![CDATA[<p><strong>2022.4.8更新：</strong><br>运行下面的指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo pip3 install rosdepc</span><br><span class="line">sudo rosdepc init</span><br><span class="line">rosdepc update</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/20220408213139.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220408213126.png" alt=""></p><hr><p>==以下都是过时方法：==</p><p><strong>2021.9.19更新：</strong></p><p>最稳妥的解决方法还是找一个机场、节点，然后下载electron或者clash等“加速”软件。<br>如果终端还是报错，却发现浏览器可以访问相应的资源网址，说明终端没有配置好代理，在终端窗口输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:12333&quot;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;https://127.0.0.1:12333&quot;</span></span><br></pre></td></tr></table></figure><p>再次<code>rosdep update</code>就可以了。</p><p><strong>原文：</strong></p><p>ROS安装过程可见我的上一篇博客<a href="https://blog.csdn.net/weixin_44543463/article/details/113862391">Ubuntu20.04安装ROS Noetic</a></p><p>安装过程中<strong>rosdep init</strong>出现【<strong>ERROR: cannot download default sources list from:…Website may be down.</strong>】<br><strong>rosdep update</strong>，总是出现<strong>超时</strong>问题无法更新。<br>最终找到了一种靠谱可用的方法。</p><p>这两个问题都是网络连接相关的问题，<strong>解决方法相同，都是修改host主机</strong>。</p><p>只是修改完成后rosdep init可以直接成功。而rosdep update还需要可靠的网络才行，如果update仍然失败，建议多试几次，或者试着更换手机热点网络</p><h5 id="1-打开ip查询网址">1. 打开ip查询网址</h5><blockquote><p><a href="https://site.ip138.com">https://site.ip138.com</a></p></blockquote><h5 id="2-输入raw-githubusercontent-com查询ip">2. 输入raw.githubusercontent.com查询ip</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231643086-rosdep-bug-1.png" alt=""></p><h5 id="3-将解析出来的IP地址全部添加到-etc-hosts文件最后，格式：185-199-109-133-raw-githubusercontent-com">3. 将解析出来的IP地址全部添加到/etc/hosts文件最后，格式：185.199.109.133 <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/hosts</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231643217-rosdep-bug-2.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">  </span><br><span class="line"><span class="comment"># The following lines are desirable for IPv6 capable hosts</span></span><br><span class="line">::1 ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">ff02::3 ip6-allhosts</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>保存回到命令行</p><h5 id="5-重新进行rosdep-update">5. 重新进行rosdep update</h5><p><img src="https://img.mahaofei.com/img/202112231643953-rosdep-bug-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04安装ROS Noetic</title>
      <link href="/post/b278544f.html"/>
      <url>/post/b278544f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考ros官网<a href="http://wiki.ros.org/">http://wiki.ros.org/</a>的有关<a href="http://wiki.ros.org/noetic/Installation/Ubuntu">安装教程</a></p></blockquote><h3 id="一、准备工作">一、准备工作</h3><h4 id="1-添加ROS软件源">1. 添加ROS软件源</h4><p>打开软件与更新，将下载选项前四个都选上。<br><strong>一定要确保都勾选上，不然后续安装时会出现依赖关系问题</strong><br><img src="https://img.mahaofei.com/img/202112231642871-ubuntu-ros-1.png" alt=""><br>然后执行以下命令添加软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb https://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-添加公钥">2. 添加公钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h4 id="3-更新索引">3. 更新索引</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="二、安装ROS">二、安装ROS</h3><h4 id="1-安装ROS">1. 安装ROS</h4><p>建议安装桌面完整版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-desktop-full</span><br></pre></td></tr></table></figure><h4 id="2-设置环境变量">2. 设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/noetic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="3-初始化rosdep">3. 初始化rosdep</h4><p>在使用许多ROS工具之前，需要初始化rosdep。rosdep是运行ROS中某些核心组件所必需的，首先安装rosdep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep</span><br></pre></td></tr></table></figure><p>然后进行初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><blockquote><p>rosdep init如果出现【ERROR: cannot download default sources list from:…<br>Website may be down.】<br>rosdep update如果出现超时问题<br><strong>解决方法：</strong><br>1.<code>sudo apt-get install python3-pip</code><br>2.<code>sudo pip3 install rosdepc</code><br>3.<code>sudo rosdepc init</code><br>4.<code>rosdepc update</code></p></blockquote><h4 id="4-安装其它工具和依赖包">4. 安装其它工具和依赖包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br></pre></td></tr></table></figure><h3 id="三、测试-2">三、测试</h3><p><strong>打开</strong>终端，输入<code>roscore</code>，运行ros<br><strong>再打开</strong>一个新终端，输入：<code>rosrun turtlesim turtlesim_node</code>，可以看到小乌龟的仿真界面已经打开了。<strong>再打开</strong>一个新终端输入指令：<code>rosrun turtlesim turtle_teleop_key</code>，可以在这个key终端内，通过键盘的方向键控制小乌龟在界面中移动<br><img src="https://img.mahaofei.com/img/202112231643691-ubuntu-ros-2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu使用VNC实现远程桌面</title>
      <link href="/post/c1d87973.html"/>
      <url>/post/c1d87973.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>我是在树莓派4B上安装的Ubuntu20.10，想通过VNC实现远程桌面连接，进行接下来的试验。<br>但是在网上搜索了许多关于VNC连接的博客，也尝试了各种方法，但总是出现各种问题，要么连接不上，要么连接上了就黑屏灰屏，总之出现了各种问题，重装了n次系统，最终找到了一种实现的方法。<br><strong>注：已经试验过Ubunt18.04、Ubuntu20.04与Ubuntu20.10，均正常实现</strong></p><h3 id="Windows端">Windows端</h3><p>安装VNC Viewer，进入其<a href="https://www.realvnc.com/en/connect/download/viewer/">VNC Viewer官网</a>下载安装。<br><img src="https://img.mahaofei.com/img/202112231640381-ubuntu-vnc-1.png" alt=""></p><h3 id="Ubuntu端">Ubuntu端</h3><p><strong>进行VNC设置之前，需要有图形界面，没有的可以执行以下代码安装图形界面</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br><span class="line">apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br><span class="line">sudo reboot <span class="comment">#重启即可看到图形界面</span></span><br></pre></td></tr></table></figure><h4 id="1-安装x11vnc程序">1. 安装x11vnc程序</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install x11vnc</span><br></pre></td></tr></table></figure><h4 id="2-安装lightdm">2. 安装lightdm</h4><p>因为使用的是gnome图形界面，为了保证x11vnc与图形界面的兼容性，这里需要安装lightdm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lightdm</span><br></pre></td></tr></table></figure><p>安装过程中会跳出一个界面，<strong>选择lightdm</strong>即可<br><img src="https://img.mahaofei.com/img/202112231640773-ubuntu-vnc-2.png" alt=""></p><h4 id="3-创建配置目录">3. 创建配置目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -pv /home/【USERNAME】/.vnc</span><br></pre></td></tr></table></figure><p>其中的**【USERNAME】**替换成你的用户名</p><h4 id="4-生成当前用户的VNC连接密码">4. 生成当前用户的VNC连接密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo x11vnc -storepasswd 【Password】 /home/【USERNAME】/.vnc/passwd</span><br></pre></td></tr></table></figure><p>其中的**【Password】<strong>处设置连接VNC时的密码，</strong>【USERNAME】**替换成你的用户名<br><img src="https://img.mahaofei.com/img/202112231641706-ubuntu-vnc-3.png" alt=""></p><h4 id="5-生成VNC配置文件">5. 生成VNC配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>&gt;x11vnc.service&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit] </span></span><br><span class="line"><span class="string">Description=Start x11vnc at startup. </span></span><br><span class="line"><span class="string">After=multi-user.target </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[Service] </span></span><br><span class="line"><span class="string">Type=simple </span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/【USERNAME】/.vnc/passwd -rfbport 5900 -shared </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[Install] </span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>配置文件生成后将其移动到<code>/lib/systemd/sydtem/</code>目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mv</span> x11vnc.service /lib/systemd/system/x11vnc.service</span><br></pre></td></tr></table></figure><p>修改权限为root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> root:root /lib/systemd/system/x11vnc.service</span><br></pre></td></tr></table></figure><h4 id="6-重新加载服务配置文件">6. 重新加载服务配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>执行以下命令可以查看服务开启情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl list-unit-files | grep x11vnc</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231641384-ubuntu-vnc-4.png" alt=""></p><h4 id="7-开机启动VNC服务">7. 开机启动VNC服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> x11vnc.service</span><br></pre></td></tr></table></figure><h4 id="8-重启系统">8. 重启系统</h4><p>因为之前安装了lightdm图形管理程序，所以需要重启一下系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h4 id="9-查看一下监听端口">9. 查看一下监听端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ss -tunlp</span><br></pre></td></tr></table></figure><p>可以看到x11vnc的监听端口已经打开了<br><img src="https://img.mahaofei.com/img/202112231641133-ubuntu-vnc-5.png" alt=""></p><h3 id="远程连接">远程连接</h3><p>打开windows端的VNC Viewer，输入IP地址:5900即<code>192.168.6.6:5900</code>进行远程连接，密码是之前设置的密码。<br><img src="https://img.mahaofei.com/img/202112231641205-ubuntu-vnc-6.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231642992-ubuntu-vnc-7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs安装方法</title>
      <link href="/post/7349121e.html"/>
      <url>/post/7349121e.html</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><p>未正确安装nodejs，导致安装之后node -v有输出，npm -v无反应。</p><p>重新安装nodejs</p><h1>解决方法</h1><h2 id="卸载nodejs">卸载nodejs</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove nodejs</span><br><span class="line">sudo apt-get remove --purge npm</span><br><span class="line">sudo apt-get remove --purge nodejs</span><br></pre></td></tr></table></figure><p>进入 /usr/local/lib 删除所有 node 和 node_modules文件夹 <br>进入 /usr/local/include 删除所有 node 和 node_modules 文件夹<br>（这里我删除的是nodejs文件夹）</p><h2 id="安装nodejs">安装nodejs</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">node -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装最新的 node v10.x</span></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派4B安装Ubuntu20.04</title>
      <link href="/post/8bd23e63.html"/>
      <url>/post/8bd23e63.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、树莓派的准备">一、树莓派的准备</h2><ol><li>进入<a href="http://cdimage.ubuntu.com/ubuntu/releases/20.04/release/">Ubuntu官网</a>下载支持树莓派的Ubuntu版本安装包。<br><img src="https://img.mahaofei.com/img/202112231639061-raspberrypi-ubuntu20-1.png" alt=""></li><li>使用DiskGenius格式化SD卡，将所有扇区删除，然后格式化。<br><img src="https://img.mahaofei.com/img/202112231639964-raspberrypi-ubuntu20-2.png" alt=""></li><li><a href="https://downloads.raspberrypi.org/imager/imager.exe">下载官方烧录工具</a>，镜像选择刚才下载的.xz文件，SD卡选择自己的卡，写入即可。<br><img src="https://img.mahaofei.com/img/202112231639079-raspberrypi-ubuntu20-3.png" alt=""></li></ol><h2 id="二、Ubuntu系统配置">二、Ubuntu系统配置</h2><h3 id="2-1-进入Ubuntu系统">2.1 进入Ubuntu系统</h3><p>将TF卡插到树莓派上。可以通过显示器进行系统初始化配置，也可以用网线将树莓派和电脑连接起来，再进行远程配置。建议使用一个外接显示器，操作会简单许多。<strong>以使用外接屏幕+键盘为例</strong>（这些设备只使用一次就够了）</p><ol><li>将之前制作好的SD卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</li><li>开机，等待一段时间后进入系统，首先需要登录，<strong>初始用户名和密码都是ubuntu</strong>，登陆后会要求重新设置密码。</li></ol><h3 id="2-2-wifi设置">2.2 wifi设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/netplan</span><br></pre></td></tr></table></figure><p>在该目录下，如果是服务器，则会有一个50-cloud-init.yaml的文件，如果是桌面环境，会有一个01-network-manager-all.yaml<br>这里以50-cloud-init.yaml为例，编辑文件:<br>注意文件的缩进格式，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  wifis:</span><br><span class="line">    wlan0:</span><br><span class="line">      dhcp4: <span class="literal">true</span></span><br><span class="line">      optional: <span class="literal">true</span></span><br><span class="line">      access-points:</span><br><span class="line">        <span class="string">&quot;你的wifi名称&quot;</span>:</span><br><span class="line">          password: <span class="string">&quot;wifi密码&quot;</span></span><br></pre></td></tr></table></figure><p>然后执行命令使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan generate</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure><p>输入命令<code>ifconfig</code>即可查看ip地址，使用远程访问工具进行访问。</p><h3 id="2-3-更新源">2.3 更新源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>source.list内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="2-4-安装桌面环境">2.4 安装桌面环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br><span class="line">sudo apt install xrdp</span><br></pre></td></tr></table></figure><h3 id="2-5-安装中文环境">2.5 安装中文环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install language-pack-zh-hans language-pack-zh-hans-base language-pack-gnome-zh-hans language-pack-gnome-zh-hans-base</span><br><span class="line">sudo apt install `check-language-support -l zh`</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h3 id="2-7-允许root登录">2.7 允许root登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root <span class="comment">#设置root密码</span></span><br><span class="line">sudo vim /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf <span class="comment">#编辑此文件</span></span><br></pre></td></tr></table></figure><p>添加下列两行到50-ubuntu.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line">allow-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-8-远程桌面连接">2.8 远程桌面连接</h3><p>在windows搜索框输入<code>远程桌面连接</code>，选择Xorg模式，输入用户名密码即可连接。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由于没有公钥，无法验证下列签名 :NO_PUBKEY 的解决方法</title>
      <link href="/post/1e538308.html"/>
      <url>/post/1e538308.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>今天运行apt-get update时突然出现了由于没有公钥，无法验证下列签名的问题，尝试了网上许多方法，最终找到了一种亲测有效的解决方法：</p><h3 id="解决方法">解决方法</h3><p><strong>在终端输入：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 76F1A20FF987672F</span><br></pre></td></tr></table></figure><p>其中最后的代码为报错语句中的最后一部分：由于没有公钥，无法验证下列签名： NO_PUBKEY <strong>76F1A20FF987672F</strong></p><h3 id="解决结果">解决结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executing: /tmp/apt-key-gpghome.uBwlOPqFFF/gpg.1.sh --keyserver hkp://keyserver.ubuntu.com:80 --recv 76F1A20FF987672F</span><br><span class="line">gpg: key 76F1A20FF987672F: 1 signature not checked due to a missing key</span><br><span class="line">gpg: 密钥 76F1A20FF987672F：公钥“WineHQ packages &lt;wine-devel@winehq.org&gt;”已导入</span><br><span class="line">gpg: 合计被处理的数量：1</span><br><span class="line">gpg:               已导入：1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【个人网站搭建教程】阿里云服务器+宝塔+wordpress</title>
      <link href="/post/bd8011a0.html"/>
      <url>/post/bd8011a0.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、服务器和域名的申请">一、服务器和域名的申请</h2><h3 id="1-1-服务器的购买">1.1 服务器的购买</h3><ol><li>进入阿里云官网，购买ECS云服务器（可以看看<a href="https://developer.aliyun.com/plan/promotion/1?spm=a2c6h.13813017.1364563.d100010001.5ab41d3cmWpHDS&amp;utm_content=g_1000199894">开发者成长计划</a>，虽然我当时是在618这里买的学生ECS）。服务器的系统选择CentOS或Ubuntu。<br><img src="https://img.mahaofei.com/img/202112231629303-ali-bt-wp-1.png" alt=""><br>购买完成后会进入<a href="https://ecs.console.aliyun.com/">控制台</a>，在这里可以看到自己刚才购买的服务器。<br><img src="https://img.mahaofei.com/img/202112231630259-ali-bt-wp-2.png" alt=""></li><li>服务器使用之前，我们需要先重置root用户密码。<br><img src="https://img.mahaofei.com/img/202112231630681-ali-bt-wp-3.png" alt=""></li><li>重置密码完成后就可以通过<strong>公网IP</strong>，使用xshell或者PuTTy或者阿里平台的远程连接工具登陆服务器了。</li></ol><h3 id="1-2-域名申请与备案">1.2 域名申请与备案</h3><ol><li>进入<a href="https://wanwang.aliyun.com/domain?utm_content=se_1008301712">域名注册平台</a>，选一个合适的域名，点击结算。（如果之前没有申请过域名的话，在结算时需要创建个人的信息模板，按要求填写信息即可）。<br><img src="https://img.mahaofei.com/img/202112231631536-ali-bt-wp-4.png" alt=""></li><li>购买后域名的注册就完成了，然后需要网站备案。进入阿里<a href="https://beian.aliyun.com/">备案首页</a>，开始备案。<br><img src="https://img.mahaofei.com/img/202112231631757-ali-bt-wp-5.png" alt=""></li><li>填写完成个人信息，点击信息校验（<strong>注意：要求域名注册后两到三天再来备案</strong>）<br><img src="https://img.mahaofei.com/img/202112231631006-ali-bt-wp-6.png" alt=""><br>然后按要求填写自己的信息，网站的信息，进行身份验证，提交审核。<strong>注意各项信息都要填写准确，不符合要求的后续还要打电话修改</strong>。</li><li>提交审核后，在一个工作日之内，阿里云的客服会打电话确认身份，同时告知备案信息需要修改的地方，这期间需要保持电话畅通。</li><li>阿里云初审完成后，会将备案信息提交管局，大概一天之内你会收到一条工信部的验证短信，根据短信上的验证码，进入<a href="https://beian.miit.gov.cn/#/Integrated/ComplaintA">工信部官网</a>验证。<br><img src="https://img.mahaofei.com/img/202112231631498-ali-bt-wp-7.png" alt=""></li><li>等待7-20天，管局审核完成后，备案也就ok了。<br><img src="https://img.mahaofei.com/img/202112231631767-ali-bt-wp-8.png" alt=""></li></ol><h2 id="二、宝塔面板的安装">二、宝塔面板的安装</h2><h3 id="2-1-准备工作">2.1 准备工作</h3><p>进入<a href="https://www.bt.cn/">宝塔官网</a>注册一个宝塔账号，后续需要使用。</p><h3 id="2-2-安装宝塔面板">2.2 安装宝塔面板</h3><blockquote><p>以下安装过程参考官网：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p></blockquote><ol><li><strong>开放服务器端口</strong><br>进入控制台，点击实例名称，进入安全组-安全组列表页面，点击配置规则。<br><img src="https://img.mahaofei.com/img/202112231632152-ali-bt-wp-9.png" alt=""><br>如下图所示，放行8888端口，并开放所有ip访问，点击保存即可<br><img src="https://img.mahaofei.com/img/202112231632312-ali-bt-wp-10.png" alt=""><br>另外在这里同时开启其他端口，点击快速添加，选择SSH、HTTP、HTTPS、MySQL添加，方便后续网站的访问。<br><img src="https://img.mahaofei.com/img/202112231632208-ali-bt-wp-11.png" alt=""></li><li><strong>安装面板</strong></li></ol><ul><li>CentOS 安装命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><ul><li>Ubuntu 安装命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure><blockquote><p>安装成功后可以看到显示宝塔后台的地址，以及用户名和密码。打开浏览器登录宝塔后台。</p></blockquote><ol start="3"><li><strong>宝塔面板设置</strong><br>为了安全考虑，进入面板后先修改宝塔面板用户和面板密码。（这里的面板用户和密码不是官网账户，而是每个云服务器访问宝塔面板需要用到的账户面板）<br><img src="https://img.mahaofei.com/img/202112231633585-ali-bt-wp-12.png" alt=""></li><li><strong>安装LNMP环境</strong><br>LNMP网站环境就是指Linux+Nginx+MySQL+PHP的组合，用来快速搭建各种开源的网站程序如Wordpress、Typecho等。<br><img src="https://img.mahaofei.com/img/202112231633033-ali-bt-wp-13.png" alt=""><br>安装需要10~20分钟，安装过程是自动完成的。稍等一段时间即可。<br><img src="https://img.mahaofei.com/img/202112231633644-ali-bt-wp-14.png" alt=""></li><li><strong>宝塔账号实名认证</strong><br>进入<a href="https://www.bt.cn/">宝塔官网</a>，点击右上角会员后台，或者点此链接进入后台<a href="https://www.bt.cn/admin/userinfo">https://www.bt.cn/admin/userinfo</a>。<br><img src="https://img.mahaofei.com/img/202112231633993-ali-bt-wp-15.png" alt=""><br>左侧选择账户管理，进行实名认证。<br><img src="https://img.mahaofei.com/img/202112231634655-ali-bt-wp-16.png" alt=""><br>6.<strong>添加站点</strong><br>点击左侧网站-添加站点<br><img src="https://img.mahaofei.com/img/202112231634375-ali-bt-wp-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231634033-ali-bt-wp-18.png" alt=""><br>网站站点添加成功后，就可以进入网站的根目录了。后面搭建网站都会在这个网站的根目录下进行。<br><img src="https://img.mahaofei.com/img/202112231635182-ali-bt-wp-19.png" alt=""></li></ol><h2 id="三、安装WordPress">三、安装WordPress</h2><h3 id="3-1-上传WordPress安装包">3.1 上传WordPress安装包</h3><ol><li>前往<a href="https://cn.wordpress.org/download/">WordPress中国官网</a>下载zip安装包</li></ol><blockquote><p>下载链接：<a href="https://cn.wordpress.org/latest-zh_CN.zip">https://cn.wordpress.org/latest-zh_CN.zip</a></p></blockquote><ol start="2"><li>回到宝塔，点击文件，进入域名的根目录，点击左上角上传文件，上传刚才下载的wordpress安装包。<br><img src="https://img.mahaofei.com/img/202112231635535-ali-bt-wp-20.png" alt=""></li><li>上传成功后，解压zip格式的安装包<br><img src="https://img.mahaofei.com/img/202112231635231-ali-bt-wp-21.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231635899-ali-bt-wp-22.png" alt=""></li></ol><h3 id="3-2-修改站点配置文件">3.2 修改站点配置文件</h3><p><img src="https://img.mahaofei.com/img/202112231636769-ali-bt-wp-23.png" alt=""></p><p>由于安装包解压到站点目录/wordpress下，因此配置文件中的root需要改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /www/wwwroot/huffie.top/wordpress;</span><br></pre></td></tr></table></figure><p>修改完成后，点击保存。</p><h3 id="3-3-域名解析绑定">3.3 域名解析绑定</h3><ol><li>进入阿里云的域名控制台<br><img src="https://img.mahaofei.com/img/202112231636690-ali-bt-wp-24.png" alt=""></li><li>添加记录<br><img src="https://img.mahaofei.com/img/202112231636345-ali-bt-wp-25.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231637130-ali-bt-wp-26.png" alt=""><br>ps.这里遇到了一个小问题，总是显示<strong>您的请求在Web服务器中没有找到对应的站点！</strong>，尝试了许多方法，最后是将PHP版本从7.4更改为5.6，然后成功的，不知道是不是因为这个原因，后来版本改回7.4后也可以继续访问了。</li></ol><h3 id="3-4-WordPress的在线安装">3.4 WordPress的在线安装</h3><p>在浏览器地址栏输入自己的域名，即可看到wordpress的欢迎页面。接下来的步骤就是进行wordpress的配置了。<br><img src="https://img.mahaofei.com/img/202112231637983-ali-bt-wp-27.png" alt=""></p><ol><li><strong>填写数据库信息</strong><br>数据库名、用户名、密码可以到宝塔控制台的数据库栏查到。<br><img src="https://img.mahaofei.com/img/202112231637649-ali-bt-wp-28.png" alt=""><br>按要求填写，填写完成后点击提交。<br><img src="https://img.mahaofei.com/img/202112231637587-ali-bt-wp-29.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231637349-ali-bt-wp-30.png" alt=""></li><li><strong>填写网站信息</strong><br><img src="https://img.mahaofei.com/img/202112231638637-ali-bt-wp-31.png" alt=""></li><li><strong>安装成功</strong><br>登陆后台，可以看到熟悉的wordpress管理界面。<br><img src="https://img.mahaofei.com/img/202112231638272-ali-bt-wp-32.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231638796-ali-bt-wp-33.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> WordPress </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABB RobotStudio6.08安装</title>
      <link href="/post/559e6eff.html"/>
      <url>/post/559e6eff.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>网盘链接<br>链接：<a href="https://pan.baidu.com/s/1yUpRG146dUXC9Gj1D94AHw">https://pan.baidu.com/s/1yUpRG146dUXC9Gj1D94AHw</a><br>提取码：rsaz</p></blockquote><h3 id="安装方法">安装方法</h3><ol><li>解压安装包，运行<code>ABB RobotStudio 6.08.msi</code>程序，按流程一步步安装<br><img src="https://img.mahaofei.com/img/202112231618492-robotstudio608-1.png" alt=""></li><li>安装完成后再根据自己电脑，解压<code>RobotStudio注册文件-64位系统</code>或者<code>RobotStudio注册文件-32位系统</code>压缩包，双击其中的注册表文件<code>RobotStudio注册.reg</code>。这样就完成了ABB RobotStudio的安装与破解了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio码垛机器人创建过程</title>
      <link href="/post/a3d18e39.html"/>
      <url>/post/a3d18e39.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、安装夹具">一、安装夹具</h3><ol><li>导入一个IRB2600机器人<br><img src="https://img.mahaofei.com/img/202112231608015-robotstudio-plie-1.png" alt=""></li><li>移动夹具的本地坐标原点，使原点位置为顶面中心（与法兰盘连接的部位）<br><img src="https://img.mahaofei.com/img/202112231608361-robotstudio-pile-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231609484-robotstudio-pile-3.png" alt=""></li><li>对齐夹爪Smart组件的本地坐标和机器人末端法兰盘的坐标，使夹具的本地坐标与法兰盘的本地坐标重合，为下一步安装夹具做准备。<br><img src="https://img.mahaofei.com/img/202112231609408-robotstudio-pile-4.png" alt=""></li><li>在布局菜单内，将夹具拖动到IRB2600机器人上，完成夹具的安装<br><img src="https://img.mahaofei.com/img/202112231609685-robotstudio-pile-5.png" alt=""></li></ol><h3 id="二、创建传送带">二、创建传送带</h3><ol><li>导入传送带并设定传送带的位置<br><img src="https://img.mahaofei.com/img/202112231610899-robotstudio-pile-6.png" alt=""></li><li>创建码垛用的物体，并将其移动到传送带的起点。<br><img src="https://img.mahaofei.com/img/202112231610645-robotstudio-pile-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231610831-robotstudio-pile-8.png" alt=""></li><li>创建一个Smart组件，用于传送带物体的运动。添加如下组件<br><img src="https://img.mahaofei.com/img/202112231610947-robotstudio-pile-9.png" alt=""></li><li>对各个组件进行设置<br><img src="https://img.mahaofei.com/img/202112231611124-robotstudio-pile-10.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112231611916-robotstudio-pile-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231611919-robotstudio-pile-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231612829-robotstudio-pile-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231612841-robotstudio-pile-14.png" alt=""></p><h3 id="三、创建码垛底盘">三、创建码垛底盘</h3><p><img src="https://img.mahaofei.com/img/202112231612709-robotstudio-pile-15.png" alt=""></p><h3 id="四、创建机器人系统">四、创建机器人系统</h3><p><img src="https://img.mahaofei.com/img/202112231613609-robotstudio-pile-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231613209-robotstudio-pile-17.png" alt=""><br>选项内选择如下选项<br><img src="https://img.mahaofei.com/img/202112231613116-robotstudio-pile-18.png" alt=""></p><h3 id="五、仿真系统设置">五、仿真系统设置</h3><ol><li><p>在仿真设定中，将机器人系统后面的框选去除。<br><img src="https://img.mahaofei.com/img/202112231613549-robotstudio-pile-19.png" alt=""></p></li><li><p>运行仿真，使物块到达面传感器处，然后停止仿真，捕捉几个目标点。（后面两个目标点是为了码垛时，物块会有两种拜访姿态，所以使用两个目标点）<br><img src="https://img.mahaofei.com/img/202112231614390-robotstudio-pile-20.png" alt=""></p></li><li><p>旋转第三个目标点，使其绕Z轴旋转-90度。<br><img src="https://img.mahaofei.com/img/202112231614934-robotstudio-pile-21.png" alt=""></p></li><li><p>为目标点配置参数<br><img src="https://img.mahaofei.com/img/202112231614719-robotstudio-pile-22.png" alt=""></p></li><li><p>使机器人回到机械原点，然后创建一个空路径，将三个目标点依次拖动到路径中。<br><img src="https://img.mahaofei.com/img/202112231615329-robotstudio-pile-23.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231615980-robotstudio-pile-24.png" alt=""></p></li><li><p>同步到工作站<br><img src="https://img.mahaofei.com/img/202112231615993-robotstudio-pile-25.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231616848-robotstudio-pile-26.png" alt=""></p></li><li><p>删除之前仿真出来的物块的copy物体。</p></li><li><p>添加两个信号，一个是到位信号，用于传送带的等待，另一个是夹具信号。添加完成后重启控制器。<br><img src="https://img.mahaofei.com/img/202112231616755-robotstudio-pile-27.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231616351-robotstudio-pile-28.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231617959-robostudio-pile-29.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231617558-robotstudio-pile-30.png" alt=""></p></li><li><p>打开控制器，可以看到RAPID/T_ROB1下的程序模块，接下来就可以进行程序编写了。</p></li></ol><h3 id="程序编写">程序编写</h3><p>main程序代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">MODULE Module1</span><br><span class="line">CONST robtarget Target_10:=[[<span class="number">347.037</span>,<span class="number">682.5</span>,<span class="number">875.06</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">CONST robtarget Target_20:=[[<span class="number">500</span>,<span class="number">-300</span>,<span class="number">100</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">CONST robtarget Target_30:=[[<span class="number">500</span>,<span class="number">-300</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>,<span class="number">9E9</span>]];</span><br><span class="line">VAR num layer:=<span class="number">1</span>;</span><br><span class="line">    VAR num x:=<span class="number">0</span>;</span><br><span class="line">    VAR num z:=<span class="number">0</span>;</span><br><span class="line">    PROC <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">        FOR i FROM 0 TO 20 DO</span><br><span class="line">            SetDO JiaJu0,0;</span><br><span class="line">            MoveJ <span class="title function_">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>)</span>,v500,fine,Tool1;</span><br><span class="line">            WaitDI DaoWei0,<span class="number">1</span>; </span><br><span class="line">            MoveL <span class="title function_">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span>,v500,fine,Tool1;</span><br><span class="line">            SetDO JiaJu0,<span class="number">1</span>;</span><br><span class="line">            WaitTime <span class="number">1</span>;</span><br><span class="line">            MoveL <span class="title function_">Offs</span><span class="params">(Target_10,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>)</span>,v500,fine,Tool1;</span><br><span class="line"></span><br><span class="line">            IF layer MOD <span class="number">2</span> = <span class="number">1</span> THEN</span><br><span class="line">                IF i MOD <span class="number">5</span> &lt; <span class="number">4</span> and i MOD <span class="number">5</span> &lt;&gt; <span class="number">0</span> THEN</span><br><span class="line">                    MoveL Offs(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">300</span>+z),v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">90</span>+x,<span class="number">-150</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">210</span>;</span><br><span class="line">                    IF i MOD <span class="number">5</span> = <span class="number">3</span> THEN</span><br><span class="line">                        x:=<span class="number">0</span>;</span><br><span class="line">                    ENDIF</span><br><span class="line">                ELSE</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-410</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">300</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                IF i MOD <span class="number">5</span> = <span class="number">0</span> THEN</span><br><span class="line">                    layer:=<span class="number">2</span>;</span><br><span class="line">                    x:=<span class="number">0</span>;</span><br><span class="line">                    z:=z+<span class="number">100</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                </span><br><span class="line">            ELSE</span><br><span class="line">                IF i MOD <span class="number">5</span> &lt; <span class="number">3</span> THEN</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_20,<span class="number">150</span>+x,<span class="number">-100</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">300</span>;</span><br><span class="line">                    IF i MOD <span class="number">5</span> = <span class="number">2</span> THEN</span><br><span class="line">                        x:=<span class="number">0</span>;</span><br><span class="line">                    ENDIF</span><br><span class="line">                ELSE</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">100</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    SetDO JiaJu0,<span class="number">0</span>;</span><br><span class="line">                    WaitTime <span class="number">1</span>;</span><br><span class="line">                    MoveL <span class="title function_">Offs</span><span class="params">(Target_30,<span class="number">100</span>+x,<span class="number">-350</span>,<span class="number">300</span>+z)</span>,v500,fine,Tool1;</span><br><span class="line">                    x:=x+<span class="number">210</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">                IF i MOD <span class="number">5</span> = <span class="number">0</span> THEN</span><br><span class="line">                    layer:=<span class="number">1</span>;</span><br><span class="line">                    x:=<span class="number">0</span>;</span><br><span class="line">                    z:=z+<span class="number">100</span>;</span><br><span class="line">                ENDIF</span><br><span class="line">            ENDIF</span><br><span class="line">                </span><br><span class="line">        ENDFOR</span><br><span class="line">        z:=<span class="number">0</span>;</span><br><span class="line">    ENDPROC</span><br><span class="line">ENDMODULE</span><br></pre></td></tr></table></figure><h3 id="仿真测试">仿真测试</h3><ol><li>将代码同步到工作站<br><img src="https://img.mahaofei.com/img/202112231617535-robotstudio-pile-31.png" alt=""></li><li>删除Path_10路径，只保留main路径<br><img src="https://img.mahaofei.com/img/202112231617120-robotstudio-pile-32.png" alt=""></li><li>设置工作站逻辑<br><img src="https://img.mahaofei.com/img/202112231618997-robotstudio-pile-33.png" alt=""></li><li>进行仿真</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio动态夹具的创建</title>
      <link href="/post/5278881.html"/>
      <url>/post/5278881.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建夹具的几何模型">创建夹具的几何模型</h2><p>如果你有其它建模软件如Solidworks等做的夹具模型，可以导入到RobotStudio中。<br>这里简单建模，主要展示动态夹具的创建流程。</p><ol><li>创建夹具的本体<br><img src="https://img.mahaofei.com/img/202112231601044-robotstudio-clamp-1.png" alt=""></li><li>将其移动到其他位置，准备创建夹具的其他部分<br><img src="https://img.mahaofei.com/img/202112231601381-robotstudio-clamp-2.png" alt=""></li><li>创建一个圆柱，作为夹具的法兰盘，与机器人的关节末端相连<br><img src="https://img.mahaofei.com/img/202112231602589-robotstudio-clamp-3.png" alt=""></li><li>移动长方体的位置。<br><img src="https://img.mahaofei.com/img/202112231602622-robotstudio-clamp-4.png" alt=""></li><li>将部件2的物体拖动到部件1上，将两个物体组合成一个部件。<br><img src="https://img.mahaofei.com/img/202112231602868-robotstudio-clamp-5.png" alt=""></li><li>创建夹爪<br><img src="https://img.mahaofei.com/img/202112231603355-robotstudio-clamp-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231603512-robotstudio-clamp-7.png" alt=""></li></ol><h2 id="创建机械装置">创建机械装置</h2><ol><li>点击创建机械装置，装置名称写“夹具”，装置类型选“工具”<br><img src="https://img.mahaofei.com/img/202112231603327-robotstudio-clamp-8.png" alt=""></li><li>添加链接，为刚才创建的三个部件分别添加链接。如果是导入的模型，也需要为各个部件添加链接。其中基座部分需要勾选BaseLink，其它部分不需要。<br><img src="https://img.mahaofei.com/img/202112231603495-robotstudio-clamp-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231604636-robotstudio-clamp-10.png" alt=""></li></ol><p><img src="https://img.mahaofei.com/img/202112231604182-robotstudio-clamp-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231604040-robotstudio-clamp-12.png" alt=""></p><ol start="3"><li><p>创建接点<br><img src="https://img.mahaofei.com/img/202112231604329-robotstudio-clamp-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231605794-robotstudio-clamp-14.png" alt=""></p></li><li><p>创建工具数据<br><img src="https://img.mahaofei.com/img/202112231605742-robotstudio-clamp-15.png" alt=""></p></li><li><p>添加一个新姿态<br><img src="https://img.mahaofei.com/img/202112231605535-robotstudio-clamp-16.png" alt=""></p></li></ol><h2 id="Smart组件设置">Smart组件设置</h2><ol><li>创建Smart组件，将夹具拖动到Smart组件下，并将夹具设置为Smart组件的角色Role<br><img src="https://img.mahaofei.com/img/202112231605493-robotstudio-clamp-17.png" alt=""></li><li>添加以下组件<br><img src="https://img.mahaofei.com/img/202112231606527-robotstudio-clamp-18.png" alt=""></li><li>添加信号<br><img src="https://img.mahaofei.com/img/202112231606441-robotstudio-clamp-19.png" alt=""></li><li>对各个组件进行设置，首先先设置夹具不可由传感器检测<br><img src="https://img.mahaofei.com/img/202112231606430-robotstudio-clamp-20.png" alt=""></li><li>设置直线传感器，设置为图示圆柱状，用于检测夹具下方是否有物体<br><img src="https://img.mahaofei.com/img/202112231606894-robotstudio-clamp-21.png" alt=""></li><li>设置Attacher安装对象组件<br><img src="https://img.mahaofei.com/img/202112231607965-robotstudio-clamp-22.png" alt=""></li><li>设置PoseMover，机械装置运动的属性<br><img src="https://img.mahaofei.com/img/202112231607238-robotstudio-clamp-23.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231607713-robotstudio-clamp-24.png" alt=""></li><li>按图示设计程序框图<br><img src="https://img.mahaofei.com/img/202112231607859-robotstudio-clamp-25.png" alt=""></li></ol><blockquote><p>链接：<a href="https://pan.baidu.com/s/1pVwEuCmvoiwFlHMjRqEjLQ">https://pan.baidu.com/s/1pVwEuCmvoiwFlHMjRqEjLQ</a><br>提取码：rs04</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio碰撞检测的设定</title>
      <link href="/post/67c8f55a.html"/>
      <url>/post/67c8f55a.html</url>
      
        <content type="html"><![CDATA[<h4 id="碰撞检测的创建">碰撞检测的创建</h4><p>单击<strong>创建碰撞检测</strong>进行创建，创建完成后，<strong>ObjectA</strong>与<strong>ObjectB</strong>为进行检测的两个组，如果两个组的物体发生碰撞，则会发生颜色变化。<br><img src="https://img.mahaofei.com/img/202112231600684-robotstudio-crash-1.png" alt=""></p><h4 id="碰撞检测的设定">碰撞检测的设定</h4><p>可以在右键菜单中设置<strong>接近距离</strong>和<strong>变化颜色</strong><br><img src="https://img.mahaofei.com/img/202112231600582-robotstudio-crash-2.png" alt=""></p><h4 id="仿真演示">仿真演示</h4><ol><li>正常状态，焊枪与盒子未碰撞，颜色未改变。<br><img src="https://img.mahaofei.com/img/202112231600008-robotstudio-crash-3.png" alt=""></li><li>焊枪与盒子碰撞时，两物体颜色均改变成设定的颜色<br><img src="https://img.mahaofei.com/img/202112231601016-robotstudio-crash-4.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio机器人运行路径的创建与仿真</title>
      <link href="/post/c192e333.html"/>
      <url>/post/c192e333.html</url>
      
        <content type="html"><![CDATA[<p>本文在一个已经<strong>搭建好机械模型</strong>，同时<strong>完成机器人系统的创建</strong>后的机器人运行路径的创建过程。初始时的界面如下：<br><img src="https://img.mahaofei.com/img/202112231556681-robotstudio-path-1.png" alt=""></p><blockquote><p><strong>工程文件已上传到网盘</strong><br>包括：初始工程文件（03Practice_init.rspag）、完成后的工程文件（03Practice.rspag）、模型文件<br>链接：<a href="https://pan.baidu.com/s/1f0RL-iLBm2Kxd0NbLduv0Q">https://pan.baidu.com/s/1f0RL-iLBm2Kxd0NbLduv0Q</a><br>提取码：rs03</p></blockquote><h4 id="工件坐标的创建">工件坐标的创建</h4><p><img src="https://img.mahaofei.com/img/202112231557192-robotstudio-path-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231557471-robotstudio-path-3.png" alt=""></p><h4 id="运行路径的创建">运行路径的创建</h4><ol><li>首先创建一个空路径<br><img src="https://img.mahaofei.com/img/202112231557137-robotstudio-path-4.png" alt=""></li><li>改变机器人的姿态，使工具移动到目标点进行示教。<br><img src="https://img.mahaofei.com/img/202112231557648-robotstudio-path-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231558239-robotstudio-path-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231558386-robotstudio-path-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231558971-robotstudio-path-8.png" alt=""></li></ol><ul><li>动作类型<ul><li>Joint：机器人以点到点的形式到此点（不走直线，各轴自由运动）</li><li>Linear：机器人以直线运行方式从上一点运行到下一点</li></ul></li><li>Conc<ul><li>禁用：机器人会精确到达此点</li><li>启用：机器人会依据Zone的参数，略过此点</li></ul></li><li>Speed：机器人的运动速度</li><li>Zone：启用Conc时，机器人掠过目标点所经过圆弧轨迹的半径</li></ul><ol start="3"><li>测试到达能力并进行模拟运行<br><img src="https://img.mahaofei.com/img/202112231559740-robotstudio-path-9.png" alt=""></li></ol><h4 id="仿真与录像">仿真与录像</h4><ol><li>将工作站同步到Rapid代码<br><img src="https://img.mahaofei.com/img/202112231559244-robotstudio-path-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231559665-robotstudio-path-11.png" alt=""></li><li>进行仿真设定<br><img src="https://img.mahaofei.com/img/202112231559104-robotstudio-path-12.png" alt=""></li><li>播放并录制保存仿真视频。（录制的视频默认保存在 <strong>我的电脑/视频</strong> 目录下）<br><img src="https://img.mahaofei.com/img/202112231600619-robotstudio-path-13.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio双传送带系统的搭建</title>
      <link href="/post/f8aff6ba.html"/>
      <url>/post/f8aff6ba.html</url>
      
        <content type="html"><![CDATA[<h3 id="机械结构的搭建">机械结构的搭建</h3><ol><li>导入两个传送带，将第二个传送带以z轴旋转90°，再沿y轴偏移-3200mm。<br><img src="https://img.mahaofei.com/img/202112231547151-robotstudio-doubleconveyer-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231547014-robotstudio-doubleconveyer-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231548275-robotstudio-doubleconveyer-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231548997-robotstudio-doubleconveyer-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231549817-robotstudio-doubleconveyer-5.png" alt=""></li><li>导入机器人IRB120，将其移动到合适的位置上。<br><img src="https://img.mahaofei.com/img/202112231549242-robotstudio-doubleconveyer-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231550395-robotstudio-doubleconveyer-7.png" alt=""></li><li>创建工件的模型，将工件的第二部分内的物体拖动到第一部分中，形成一个部件<br><img src="https://img.mahaofei.com/img/202112231550097-robotstudio-doubleconveyer-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231551500-robotstudio-doubleconveyer-9.png" alt=""></li><li>将工件移动到合适的位置<br><img src="https://img.mahaofei.com/img/202112231552087-robotstudio-doubleconveyer-10.png" alt=""></li><li>导入夹具，将夹具旋转至与大地坐标系平行<br><img src="https://img.mahaofei.com/img/202112231552216-robotstudio-doubleconveyer-11.png" alt=""></li><li>设置夹具的本地坐标<br><img src="https://img.mahaofei.com/img/202112231554863-robotstudio-doubleconveyer-12.png" alt=""></li><li>在左侧布局栏中，将夹具拖动到机器人上，更新夹具的位置<br><img src="https://img.mahaofei.com/img/202112231554899-robotstudio-doubleconveyer-13.png" alt=""></li></ol><h3 id="创建机器人系统">创建机器人系统</h3><p><img src="https://img.mahaofei.com/img/202112231554707-robotstudio-doubleconveyer-14.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231554597-robotstudio-doubleconveyer-15.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231555421-robotstudio-doubleconveyer-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231555822-robotstudio-doubleconveyer-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231555519-robotstudio-doubleconveyer-18.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231556585-robotstudio-doubleconveyer-19.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231556315-robotstudio-doubleconveyer-20.png" alt=""></p><p>等待一段时间，等待系统创建完成即可进行传送带的试验。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio创建目标点时出现未找到有效配置的问题</title>
      <link href="/post/53fb1c42.html"/>
      <url>/post/53fb1c42.html</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述：">问题描述：</h4><p>RobotStudio在使用路径和目标点的创建目标点时，有时会出现<strong>无法跳转到目标点</strong>的问题，错误为<strong>未找到有效配置</strong>。<br><img src="https://img.mahaofei.com/img/202112231544276-robotstudio-noconfig-1.png" alt=""></p><h4 id="原因分析：">原因分析：</h4><ol><li><strong>未使用正确的工具坐标</strong></li><li>目标点的坐标与工具坐标无法对应，<strong>机器人不能实现运动</strong>到指定位置使两坐标系重合。</li></ol><h4 id="解决方法：">解决方法：</h4><ol><li>解决方法1：在基本-设置选择正确的工具坐标，例如夹具的工具坐标。</li><li>解决方法2：右键目标点-修改目标-旋转，将坐标系旋转至<strong>工具运动到此位置时的工具坐标系重合</strong>。如果仍然有问题可以多试几个方向，一般不止一个方向可以实现跳转到目标点。<br><img src="https://img.mahaofei.com/img/202112231545842-robotstudio-noconfig-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231546698-robotstudio-noconfig-3.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio传送带设计</title>
      <link href="/post/235f7d9b.html"/>
      <url>/post/235f7d9b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>工作站文件：<br>链接：<a href="https://pan.baidu.com/s/1kikAGbj-vVAH-IR9AWY1sg">https://pan.baidu.com/s/1kikAGbj-vVAH-IR9AWY1sg</a><br>提取码：robo</p></blockquote><h3 id="传送带模型的创建">传送带模型的创建</h3><ol><li>新建一个工作站，从设备中导入一个传送带<br><img src="https://img.mahaofei.com/img/202112231529116-robotstudio-conveyer-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231529421-robotstudio-conveyer-2.png" alt=""></li><li>创建一个正方体，作为传送带的传送对象<br><img src="https://img.mahaofei.com/img/202112231530401-robotstudio-conveyer-3.png" alt=""></li><li>将小方块拖动带传送带上我们要的位置处<br><img src="https://img.mahaofei.com/img/202112231530756-robotstudio-conveyer-4.png" alt=""></li><li>可以借助<strong>捕捉</strong>与<strong>设定位置</strong>精确定位小方块的位置<br><img src="https://img.mahaofei.com/img/202112231537698-robotstudio-conveyer-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231537983-robotstudio-conveyer-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231538014-robotstudio-conveyer-7.png" alt=""></li></ol><h3 id="简单传送带设计">简单传送带设计</h3><ol><li>建立一个Smart组件，先实现小方块的直线移动<br><img src="https://img.mahaofei.com/img/202112231538464-robotstudio-conveyer-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231538216-robotstudio-conveyer-9.png" alt=""></li><li>点击仿真-播放，然后点击Smart组件的Execute按钮，即可观察到小方块的直线运动。但是小方块无法自行停止，需要点击停止按钮，然后重置，才能回到初始状态。<br><img src="https://img.mahaofei.com/img/202112231539253-robotstudio-conveyer-10.png" alt=""></li><li>添加一个<strong>面传感器</strong>用于检测小方块的位置<br><img src="https://img.mahaofei.com/img/202112231539927-robotstudio-conveyer-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231539811-robotstudio-conveyer-12.png" alt=""></li><li>回到Smart组件的设计页面，设计逻辑程序，因为<strong>传送带的逻辑是输入端有高电平就运行，传感器的逻辑是有物体触碰就输出高电平，其他时间输出低电平</strong>。因此要实现传送带的要求，只需要将<strong>传感器的输出取非后传给传动带</strong>即可。<br><img src="https://img.mahaofei.com/img/202112231540286-robotstudio-conveyer-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231540964-robotstudio-conveyer-14.png" alt=""></li><li>进行仿真，发现传送带与小方块的运行效果符合预期。如果发现小方块不停止的话，将传送带的<strong>可由传感器检测</strong>取消掉就可以了<br><img src="https://img.mahaofei.com/img/202112231540116-robotstudio-conveyer-15.png" alt=""></li></ol><h3 id="多个物体的连续传送">多个物体的连续传送</h3><ol><li>添加一个Source组件用于实现小方块的复制，编辑它的属性<br><img src="https://img.mahaofei.com/img/202112231540663-robotstudio-conveyer-16.png" alt=""><br>复制源Source选择小方块，位置通过捕捉本地原点选择小方块的原点，点击应用。</li><li>然后进行复制小方块的程序设计由于<strong>Source组件的触发条件是上升沿</strong>，即低脉冲跃变到高脉冲时，才会触发复制效果。<br><img src="https://img.mahaofei.com/img/202112231541684-robotstudio-conveyer-17.png" alt=""><br>因此考虑添加一个脉冲信号的发生组件Timber，信号间隔暂定为5s。<br><img src="https://img.mahaofei.com/img/202112231541304-robotstudio-conveyer-18.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231541885-robotstudio-conveyer-19.png" alt=""></li><li>但是这样带来的问题是，在第一个小方块还未到终点时，因为时间已经到了5s，因此传送带会开始运送下一个小方块，仿真表现是所有小方块运动5s后会自动停止。因此选择使用队列这个组件来解决问题。<br><img src="https://img.mahaofei.com/img/202112231542233-robotstudio-conveyer-20.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231542450-robotstudio-conveyer-21.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231542707-robotstudio-conveyer-22.png" alt=""></li></ol><ul><li>back：将复制出来的小方块添加到队列后面</li><li>delete：删除队列中最前面的物体</li><li>enqueue：接收到复制完成的信号后开始将对象添加到队列中</li><li>传送带的传送对象需要改为整个队列</li></ul><p>仿真效果如下（可将原始方块部件_1取消可见，显示效果更好）<br><img src="https://img.mahaofei.com/img/202112231543116-robotstudio-conveyer-23.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotStudio关于Ctrl+鼠标左键拖动速度慢的解决方法</title>
      <link href="/post/75ac34b3.html"/>
      <url>/post/75ac34b3.html</url>
      
        <content type="html"><![CDATA[<p>使用ABB RobotStudio的过程中，有时会遇到鼠标拖动平移视角的速度突然变慢的问题，不知道问题出在什么地方，但是发现了解决方法：<br><strong>工作站空白处右键，点击查看全部或查看中心</strong><br><img src="https://img.mahaofei.com/img/202112231528441-robotstudio-mouse-1.png" alt=""><br>然后就恢复正常了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（十）模块化程序</title>
      <link href="/post/fd5caa9a.html"/>
      <url>/post/fd5caa9a.html</url>
      
        <content type="html"><![CDATA[<p>当程序比较复杂，或者程序内存在重复的部分时，模块化程序设计往往是比较可行的办法。在RobotStudio中可以通过在主程序中调用不同的例行程序，达到使代码逻辑清晰的目的。</p><h3 id="将搬运工件的动作保存为例行程序">将搬运工件的动作保存为例行程序</h3><ol><li>进入例行程序，新建一个例行程序<br><img src="https://img.mahaofei.com/img/202112231523040-robotstudio-notes10-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231524731-robotstudio-notes10-2.png" alt=""></li><li>回到main程序，鼠标选中第一行，点击编辑-编辑，将main函数内的代码复制到新建的例行程序中<br><img src="https://img.mahaofei.com/img/202112231524737-robotstudio-notes10-3.png" alt=""></li><li>回到刚才新建的例行程序中，将main函数代码粘贴过来。<br><img src="https://img.mahaofei.com/img/202112231524541-robotstudio-notes10-4.png" alt=""></li><li>利用调试-pp移至例行程序，测试例行程序是否正确，没有问题的话，就将main函数的内容，用指令procall代替。<br><img src="https://img.mahaofei.com/img/202112231525965-robotstudio-notes10-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231525916-robotstudio-notes10-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231526799-robotstudio-notes10-7.png" alt=""></li></ol><h3 id="快速实现搬运第二个工件">快速实现搬运第二个工件</h3><ol><li>首先将搬运工件的例行程序复制一份<br><img src="https://img.mahaofei.com/img/202112231526330-robotstudio-notes10-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231527924-robotstudio-notes10-9.png" alt=""></li><li>因为工件的位置是利用仓库的工件坐标系通过偏倚确定的，因此只需要修改Offs函数的参数即可确定第二个工件的夹取位置。<br><img src="https://img.mahaofei.com/img/202112231527246-robotstudio-notes10-10.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（九）坐标偏移设置</title>
      <link href="/post/fa5adfbf.html"/>
      <url>/post/fa5adfbf.html</url>
      
        <content type="html"><![CDATA[<h3 id="Offs指令">Offs指令</h3><p><strong>功能</strong>：根据当前所选工件坐标以及基准点进行坐标偏移<br><strong>使用</strong>：Offs(变量, Δx, Δy, Δz)</p><h3 id="坐标偏移设置方法">坐标偏移设置方法</h3><ol><li>点击要偏移的robtarget数据，选择<strong>功能-Offs</strong><br><img src="https://img.mahaofei.com/img/202112231521620-robotstudio-notes9-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231522496-robotstudio-notes9-2.png" alt=""></li><li>例如让夹爪夹取工件后竖直上升50mm，则可按如下设置<br><img src="https://img.mahaofei.com/img/202112231522604-robotstudio-notes9-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231523048-robotstudio-notes9-4.png" alt=""><br>同理，其它坐标的偏移方式也可按相同的方法进行设置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（八）速度设置</title>
      <link href="/post/cd6881c8.html"/>
      <url>/post/cd6881c8.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、速度的直接设置">一、速度的直接设置</h3><p>在手动模式下，最大速度受到限制，最大时250mm/s。而程序中v1000在仿真和实际中是十分快的，因此修改工件拿起和放下时的速度，轻拿轻放。<br><img src="https://img.mahaofei.com/img/202112231512893-robotstudio-notes8-1.png" alt=""><br>实际操作时，手动调试完成后要先如下图，从25%速度开始测试，如果实物机器人运动没有问题，在逐步增大速度，直到100%。如果中间出现任何问题，就将程序中的速度参数修改成适合的值。<br><img src="https://img.mahaofei.com/img/202112231512860-robotstudio-notes8-2.png" alt=""></p><h3 id="二、速度数据的创建与替换">二、速度数据的创建与替换</h3><ol><li>点击<strong>菜单【三V】—&gt;数据类型—&gt;全部数据类型—speeddata—&gt;显示数据—&gt;新建</strong><br><img src="https://img.mahaofei.com/img/202112231513906-robotstudio-notes8-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231513221-robotstudio-notes8-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231513746-robotstudio-notes8-5.png" alt=""></li><li>设置变量的名字，然后修改初始值，其中v_tcp是直线运动速度（主要用这个），v_ori是重定位速度。<br><img src="https://img.mahaofei.com/img/202112231514409-robotstudio-notes8-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231515775-robotstudio-notes8-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231515368-robotstudio-notes8-8.png" alt=""></li><li>回到程序设计页面，点击速度值，选择需要替换的速度变量，确定。<br><img src="https://img.mahaofei.com/img/202112231516107-robotstudio-notes8-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231517754-robotstudio-notes8-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231517162-robotstudio-notes8-11.png" alt=""></li></ol><h3 id="三、速度延时设置">三、速度延时设置</h3><p>夹爪的加紧动作需要时间，如果不延时的话，夹爪会在加进的同时运动，可能导致一些问题。设置的方法如下：</p><ol><li>点击夹爪夹紧的指令（Set语句），添加指令WaitTime，这里以1s延时为例。<br><img src="https://img.mahaofei.com/img/202112231518649-robotstudio-notes8-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231518798-robotstudio-notes8-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231520453-robotstudio-notes8-14.png" alt=""></li><li>同理在夹爪松开时，同样需要进行延时设置。<br><img src="https://img.mahaofei.com/img/202112231521870-robotstudio-notes8-15.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（七）工件坐标</title>
      <link href="/post/c31c5b0.html"/>
      <url>/post/c31c5b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、工件坐标简介">一、工件坐标简介</h3><p>在目标工作台的任意位置，任意角度创建一个直角坐标系，把这个坐标系叫做工件坐标。<br>在不同的位置创建工件坐标系，就可以实现，相同的程序在不同的位置实现相同的加工。</p><h3 id="二、3点法设置工件坐标">二、3点法设置工件坐标</h3><ol><li>进入手动操作-工件坐标=新建，创建一个工件坐标<br><img src="https://img.mahaofei.com/img/202112231458020-robotstudio-notes7-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231458085-robotstudio-notes7-2.png" alt=""></li><li>选中新建的工件坐标，编辑-定义，用户方法选择3点<br><img src="https://img.mahaofei.com/img/202112231458270-robotstudio-notes7-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231459866-robotstudio-notes7-4.png" alt=""></li><li>如果想建立一个如下图所示的坐标系<br><img src="https://img.mahaofei.com/img/202112231500037-robotstudio-notes7-5.png" alt=""></li><li>在仿真内选择基本-其它-创建工件坐标，用户坐标框架-取点创建框架，选择三个点即可创建坐标系。<br><img src="https://img.mahaofei.com/img/202112231500874-robotstudio-notes7-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231500815-robotstudio-notes7-7.png" alt=""></li></ol><h3 id="三、实际系统工件坐标的确定">三、实际系统工件坐标的确定</h3><p>在操作实际机器人系统时，可以选择一个具有尖端的工件，手动操作对齐要确定的三个点，记录下来设置工件坐标。</p><ol><li><p>添加一个具有尖端的工具，用于确定目标点坐标。将工具添加到机器人系统中，并隐藏此前的夹爪工具。<br><img src="https://img.mahaofei.com/img/202112231501574-robotstudio-notes7-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231501192-robotstudio-notes7-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231501383-robotstudio-notes7-10.png" alt=""></p></li><li><p>按照上文<strong>三点法设置工件坐标</strong>的前两步。选择仓库的三个点位分别设置为X1、X2、Y1，以此来确定工件坐标系。完成后点击确定。<br><img src="https://img.mahaofei.com/img/202112231503509-robotstudio-notes7-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231504258-robotstudio-notes7-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231504772-robotstudio-notes7-13.png" alt=""></p></li><li><p>同理在操作台也可以创建一个工件坐标<br><img src="https://img.mahaofei.com/img/202112231505134-robotstudio-notes7-14.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231508294-robotstudio-notes7-15.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231508626-robotstudio-notes7-16.png" alt=""></p></li><li><p>删除刚才添加用于确定点位的工具（Pen），令夹爪可见</p></li></ol><h3 id="四、程序中工件坐标的修改方法">四、程序中工件坐标的修改方法</h3><p>修改程序中的工件坐标，使在仓库夹取工件的部分动作使用仓库工件坐标系，在操作台的放置部分动作使用操作台工件坐标系，其余动作使用默认工件坐标系。</p><ol><li>以pPickUP位置处的动作为例。单步运行程序，运行至pPickUP位置时，点击整条指令，<strong>可选变量—[\WObj]—使用</strong><br><img src="https://img.mahaofei.com/img/202112231509087-robotstudio-notes7-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231509106-robotstudio-notes7-18.png" alt=""></li><li>点击wobj0，选择wobj_CK确定<br><img src="https://img.mahaofei.com/img/202112231510351-robotstudio-notes7-19.png" alt=""></li><li>选择回到手动操作面板，点击工件坐标，选择wobj_CK<br><img src="https://img.mahaofei.com/img/202112231511473-robotstudio-notes7-20.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231511778-robotstudio-notes7-21.png" alt=""></li><li>再回到程序编辑器，选择刚才编辑的那一条语句，修改位置即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（六）有效载荷</title>
      <link href="/post/61ec45b2.html"/>
      <url>/post/61ec45b2.html</url>
      
        <content type="html"><![CDATA[<p>从夹爪夹住工件后，系统的载荷就发生了变化，对于仿真程序中效果区别可能不明显，但在实际系统中，必须要考虑载荷的区别。</p><ol><li>打开手动操作-有效载荷<br><img src="https://img.mahaofei.com/img/202112231453205-robotstudio-notes6-1.png" alt=""></li><li>新建一个有效载荷<br><img src="https://img.mahaofei.com/img/202112231454418-robotstudio-notes6-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231455004-robotstudio-notes6-3.png" alt=""></li><li>修改程序，在程序开始处，添加指令-settings-gripload<br><img src="https://img.mahaofei.com/img/202112231456893-robotstudio-notes6-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231456248-robotstudio-notes6-5.png" alt=""></li><li>添加到上方，负载为load0<br><img src="https://img.mahaofei.com/img/202112231456033-robotstudio-notes6-6.png" alt=""></li><li>在夹爪夹取工件后，即set dol0_1语句下，再次添加一条gripload语句，负载为load_Box。同理，在夹爪松开后，再次添加一条gripload语句，负载为load0.<br><img src="https://img.mahaofei.com/img/202112231456481-robotstudio-notes6-7.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（五）工具数据</title>
      <link href="/post/96d699f6.html"/>
      <url>/post/96d699f6.html</url>
      
        <content type="html"><![CDATA[<ol><li>拆除夹爪，测量夹爪末端坐标<br><img src="https://img.mahaofei.com/img/202112231451524-robotstudio-notes5-1.png" alt=""></li><li>点击建模-测量-点到点，选择夹爪底面和末端面，记录得到的z坐标值<br><img src="https://img.mahaofei.com/img/202112231451216-robotstudio-notes5-2.png" alt=""></li><li>将夹爪安装回机器人末端<br><img src="https://img.mahaofei.com/img/202112231451089-robotstudio-notes5-3.png" alt=""></li><li>打开虚拟示教器，进入手动操纵-工具坐标-新建，修改名称，点击左下角初始值<br><img src="https://img.mahaofei.com/img/202112231452933-robotstudio-notes5-4.png" alt=""></li><li>修改第一个z（坐标位置）为刚才测得得值215.30，mass（质量）为1，第二个z（重心位置）初估一个数<br><img src="https://img.mahaofei.com/img/202112231452295-robotstudio-notes5-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231452825-robotstudio-notes5-6.png" alt=""></li><li>验证坐标，选择动作模式为重定位，工具坐标为刚才新建坐标。操纵摇杆可看到机器人绕夹爪两末端中心点转动。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（四）夹取工件程序设计</title>
      <link href="/post/c3082f61.html"/>
      <url>/post/c3082f61.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、指令">一、指令</h3><ol><li>MoveJ：移动到某位置</li><li>Set/Reset：控制外部设备</li></ol><h3 id="二、实现过程">二、实现过程</h3><ol><li>在初始位置添加一句MoveJ指令<br><img src="https://img.mahaofei.com/img/202112231156121-robotstudio-notes4-1.png" alt=""></li><li>将机器人爪调至工件的正上方，再添加一条MoveJ指令（在工件上方添加一个位置点，是为了防止机器人直接夹取，可能会从侧面撞到工件）<br><img src="https://img.mahaofei.com/img/202112231158132-robotstudio-notes4-2.png" alt=""></li><li>将机器人爪子向下移动到夹取工件的位置，添加一条MoveJ指令<br><img src="https://img.mahaofei.com/img/202112231200758-robotstudio-notes4-3.png" alt=""></li><li>使用Set指令，使机器人爪子夹紧工件。<br><img src="https://img.mahaofei.com/img/202112231202140-robotstudio-notes4-4.png" alt=""></li><li>将机器人竖直向上移动，使工件脱离工作台，添加一条MoveJ指令。<br><img src="https://img.mahaofei.com/img/202112231435382-robotstudio-notes4-5.png" alt=""></li><li>将工件移动到夹具台上方，再次添加一条MoveJ指令。<br><img src="https://img.mahaofei.com/img/202112231435336-robotstudio-notes4-6.png" alt=""></li><li>将工具放到工作台上，添加一条MoveJ指令，再使用Reset指令松开夹爪。<br><img src="https://img.mahaofei.com/img/202112231437607-robotstudio-notes4-7.png" alt=""></li><li>使用MoveJ指令将机器人先竖直向上移动，再回到初始位置，即可完成一个动作周期。</li></ol><h3 id="三、增强代码可读性-创建robtarget数据">三、增强代码可读性-创建robtarget数据</h3><p>点击MoveJ指令后的*，点击ToPoint，点击新建，即可创建一个robotarget数据，代替*所在位置，增强程序的可读性。<br>（注意，新建robtarget数据时，是记录机器人<strong>现在位置</strong>，而非原指位置）<br><img src="https://img.mahaofei.com/img/202112231438945-robotstudio-notes4-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231439891-robotstudio-notes4-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231440095-robotstudio-notes4-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231444607-robotstudio-notes4-11.png" alt=""></p><h3 id="四、修改程序中的工具数据">四、修改程序中的工具数据</h3><p>为了输出负载等其它参数的正常与机器人的稳定运行，需要将指令后的工具坐标修改为正确的工具坐标。</p><ol><li>当机器人系统处于此行程序对应位置时，点击tool0修改为tGrip<br><img src="https://img.mahaofei.com/img/202112231448325-robotstudio-notes4-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231450261-robotstudio-notes4-13.png" alt=""></li><li>因工具坐标发生变化，所以对应的位置坐标也需要改变，点击修改位置即可将更改正确位置<br><img src="https://img.mahaofei.com/img/202112231450760-robotstudio-notes4-14.png" alt=""></li><li>将机器人移动到下一个位置，然后再修改工具坐标，再更正位置。<br><img src="https://img.mahaofei.com/img/202112231450222-robotstudio-notes4-15.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（三）程序创建</title>
      <link href="/post/1210b010.html"/>
      <url>/post/1210b010.html</url>
      
        <content type="html"><![CDATA[<p><strong>1. 层级结构</strong><br>打开主菜单-程序 可以看到最上面一行是程序名称，T_ROB1/MainModule/main。<br><img src="https://img.mahaofei.com/img/202112231153517-robotstudio-notes3-1.png" alt=""><br>其中T_ROB1是任务，有几个机械单元就有几个任务可以选择。比如两个机械臂协同工作，就会出现ROB2等。<br><img src="https://img.mahaofei.com/img/202112231153668-robotstudio-notes3-2.png" alt=""><br>第二层是模块，分成系统模块和程序模块。模块就是将机器人需要实现的各个功能分成不同模块。可以理解成文件夹。<br><img src="https://img.mahaofei.com/img/202112231153002-robotstudio-notes3-3.png" alt=""><br>第三层是例行程序，是机器人系统真正执行的一些程序。<br><img src="https://img.mahaofei.com/img/202112231154696-robotstudio-notes3-4.png" alt=""><br><strong>2. 新建程序</strong><br>新建模块：点击文件-新建模块。<br><img src="https://img.mahaofei.com/img/202112231154598-robotstudio-notes3-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231154343-robotstudio-notes3-6.png" alt=""><br>进入新建的模块，可以看到现在的模块只是相当于一个文件夹，并没有创建程序的地方。所以我们需要先创建一个例行程序。点击右上方例行程序，文件-新建例行程序。<br><img src="https://img.mahaofei.com/img/202112231154969-robotstudio-notes3-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231155859-robotstudio-notes3-8.png" alt=""><br>点击显示例行程序，就可以进入到程序编辑页面了。<br>把当前位置记录下来，使用添加指令-MoveJ指令。<br>将机器人移动至另一个位置，再次添加MoveJ指令。点击调试-pp移至Main，点击右边的单步执行，可以看到机器人进行了一步移动。<br><img src="https://img.mahaofei.com/img/202112231155034-robotstudio-notes3-9.png" alt=""><br>同时，程序可以切换单周执行与连续执行。<br><img src="https://img.mahaofei.com/img/202112231156889-robotstudio-notes3-10.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（二）手动操作</title>
      <link href="/post/8e5621e4.html"/>
      <url>/post/8e5621e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="手动单轴操作">手动单轴操作</h2><ol><li>打开一个机器人系统，打开虚拟示教器</li><li>点击<strong>菜单-手动操纵-动作模式</strong>，可以看到下方有四个动作模型，其中轴1-3和轴4-6为单轴操作，后面是线性操作，和重定位操作，这里<strong>选择轴1-3</strong>，点击确定。<br><img src="https://img.mahaofei.com/img/202112231146716-robotstudio-notes2-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231147272-robotstudio-notes2-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231147945-robotstudio-notes2-3.png" alt=""></li><li>可以看到在手动操作界面右方有机器人的位置信息和操纵杆方向。 操纵杆方向处的箭头对应示教器控制器的箭头，数字代表轴的序号。 如第一个代表上下箭头控制二轴的运动，下箭头为正方向第二个代表左右箭头控制1轴的运动，第三个代表顺时针，逆时针按钮控制3轴的运动。如果想要控制4-6，点击动作模式选择轴4-6即可。<br><img src="https://img.mahaofei.com/img/202112231147709-robotstudio-notes2-4.png" alt=""></li></ol><h2 id="手动线性操作">手动线性操作</h2><ol><li>进入手动操纵的菜单栏，可以看到现在的动作模式是单轴动作，坐标系不可选。<br><img src="https://img.mahaofei.com/img/202112231148535-robotstudio-notes2-5.png" alt=""></li><li>点击动作模式，将<strong>动作模式更改为线性</strong>，确定后，可以看到此时的坐标系可以选择了。<br><img src="https://img.mahaofei.com/img/202112231148461-robotstudio-notes2-6.png" alt=""></li><li>进入坐标系菜单，可以看到有四种坐标系，分别是大地坐标、基坐标、工具、工件坐标。<br><img src="https://img.mahaofei.com/img/202112231148166-robotstudio-notes2-7.png" alt=""></li><li>首先看大地坐标，选择大地坐标确定后，可以看到控制器右侧的位置信息变成了xyz坐标值。操纵杆方向也变成了xyz，大地坐标系就是以机器人视图左下角的坐标系为基准进行运动。<br><img src="https://img.mahaofei.com/img/202112231149507-robotstudio-notes2-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231149493-robotstudio-notes2-9.png" alt=""></li><li>基坐标系，选中机器人底座，可以看到有一个坐标系，此时xyz就是沿着这个坐标系确定的。<br><img src="https://img.mahaofei.com/img/202112231150330-robotstudio-notes2-10.png" alt=""></li><li>工具坐标，可以看到菜单栏有一项为工具坐标tool0，这个坐标系就是以机器人末端第六关节的坐标运动。<br><img src="https://img.mahaofei.com/img/202112231150929-robotstudio-notes2-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231150345-robotstudio-notes2-12.png" alt=""></li><li>工件坐标，可以看到菜单栏有一项为工件坐标tool0，这个坐标系是以工件的坐标系运动。</li></ol><h2 id="重定位操作">重定位操作</h2><ol><li>打开虚拟示教器，<strong>手动操纵-动作模式</strong>，切换动作模式为重定位。<br><img src="https://img.mahaofei.com/img/202112231151019-robotstudio-notes2-13.png" alt=""></li><li>回到手动操纵的菜单栏，可以看到此时的坐标系为工具，工具坐标为tool0<br><img src="https://img.mahaofei.com/img/202112231151642-robotstudio-notes2-14.png" alt=""></li><li>按下示教器的箭头，手动操作进行观察，可以发现位置坐标XYZ始终不发生变化。<br><img src="https://img.mahaofei.com/img/202112231151849-robotstudio-notes2-15.png" alt=""></li><li>将爪子隐藏，可以看出系统运动过程中，第6关节末端中心点位置保持不变。<br><img src="https://img.mahaofei.com/img/202112231152444-robotstudio-notes2-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231152706-robotstudio-notes2-17.png" alt=""></li></ol><h2 id="动作模式的切换">动作模式的切换</h2><ol><li>在摇杆的左侧切换操作模式，第二个按钮是切换重定位和线性，第三个按钮切换轴1-3和轴4-6。面板右下角显示当前操作模式。<br><img src="https://img.mahaofei.com/img/202112231152614-robotstudio-notes2-18.png" alt=""></li><li>点击示教器右下角图标，可以看到机器人系统的详细信息，在这里同样可以对手动操纵菜单栏里所有的选项进行更改。<br><img src="https://img.mahaofei.com/img/202112231152848-robotstudio-notes2-19.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RobotStudio学习笔记】（一）软件的安装与初步测试</title>
      <link href="/post/f1b544b4.html"/>
      <url>/post/f1b544b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="RobotStudio-6-03-02-的安装">RobotStudio 6.03.02 的安装</h2><blockquote><p>链接：<a href="https://pan.baidu.com/s/1NyDTu_OCcPJLbfaQLtCHCw">https://pan.baidu.com/s/1NyDTu_OCcPJLbfaQLtCHCw</a><br>提取码：robo</p></blockquote><h3 id="1-安装注意事项">1. 安装注意事项</h3><p>（1）PC用户名为英文<br>（2）安装路径为英文<br>（3）安装过程全程联网</p><h3 id="2-安装方法">2. 安装方法</h3><p>（1）将安装包解压，运行安装包内的setup.exe程序，按照提示安装即可，比较简单。<br>（2）安装完成后双击<code>RobotStudio_5.61.02注册补丁.reg</code>。<br>（3）打开RobotStudio即可完成安装。</p><h2 id="初次测试">初次测试</h2><ol><li>打开RobotStudio软件，新建一个空工作站解决方案。<br><img src="https://img.mahaofei.com/img/202112231142274-robotstudio-notes1-1.png" alt=""></li><li>点击左上角ABB模型库，导入一个IRB 120确定<br><img src="https://img.mahaofei.com/img/202112231142220-robotstudio-notes1-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231142041-robotstudio-notes1-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231143834-robotstudio-notes1-4.png" alt=""></li><li>然后点击机器人系统-从布局创建系统，选择一个6.03的软件版本<br><img src="https://img.mahaofei.com/img/202112231143475-robotstudio-notes1-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231143090-robotstudio-notes1-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231143933-robotstudio-notes1-7.png" alt=""><br>点击选项，将其中的默认语言改为中文，点击完成即可，稍等一段时间等待系统创建完成。<br><img src="https://img.mahaofei.com/img/202112231144142-robotstudio-notes1-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231144741-robotstudio-notes1-9.png" alt=""></li><li>当下方控制器状态变成绿色的时候说明系统已经创建完成了。<br><img src="https://img.mahaofei.com/img/202112231144001-robotstudio-notes1-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231144900-robotstudio-notes1-11.png" alt=""></li><li>点击上方 控制器-示教器-虚拟示教器<br><img src="https://img.mahaofei.com/img/202112231145793-robotstudio-notes1-12.png" alt=""><br>在弹出的示教器窗口，打开控制面板切换为手动并使能。<br><img src="https://img.mahaofei.com/img/202112231145491-robotstudio-notes1-13.png" alt=""></li><li>在机器人视图内，Ctrl+左键为平移，Ctrl+Shift+左键为旋转，调整视图，使虚拟示教器和机器人能够同时看到。</li><li>点击菜单-程序编辑器，新建一个程序。<br><img src="https://img.mahaofei.com/img/202112231145202-robotstudio-notes1-14.png" alt=""><br>添加一条MoveJ指令<br><img src="https://img.mahaofei.com/img/202112231145407-robotstudio-notes1-15.png" alt=""><br>长按示教器右边的箭头，使机器人转动一个角度，然后在下方再添加一条MoveJ指令。（一定要看示教器上访的状态，保证机器人是手动控制模式、电机开启)<br><img src="https://img.mahaofei.com/img/202112231146603-robotstudio-notes1-16.png" alt=""><br>然后点击调试-PP移至Main，再点击右下方的运行按钮，即可看到机器人在起始位置和刚才转动的位置进行往复运动。<br><img src="https://img.mahaofei.com/img/202112231146967-robotstudio-notes1-17.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器人 </category>
          
          <category> RobotStudio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> RobotStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WordPress网站设计】小白网站设计流程（使用Elementor可视化编辑网站）</title>
      <link href="/post/ab6dd331.html"/>
      <url>/post/ab6dd331.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、准备工作-2">一、准备工作</h2><h3 id="1-安装Elementor插件">1. 安装Elementor插件</h3><p>进入wordpress后台，搜索插件Elementor进行安装。</p><blockquote><p>如果安装失败，可以在官网下载安装包，手动上传安装，安装方法参考<a href="https://blog.csdn.net/weixin_44543463/article/details/112839933">此篇文章</a><br>下载地址：<a href="https://cn.wordpress.org/plugins/elementor/">https://cn.wordpress.org/plugins/elementor/</a></p></blockquote><h3 id="2-安装主题">2. 安装主题</h3><p>这里以Astra主题为例，进入wordpress后台，搜索主题Astra进行安装。<br><img src="https://img.mahaofei.com/img/202112231129572-wordpress-elementor-2.png" alt=""></p><h3 id="3-安装辅助插件">3. 安装辅助插件</h3><p>根据不同主题的要求，可能需要安装不同的辅助插件，才能导入网站模板。Astra主题需要的插件是Starter Templates。<br><img src="https://img-blog.csdnimg.cn/20210125142716805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70" width="60%"></p><h2 id="二、导入模板">二、导入模板</h2><p>点击<strong>外观-Starter Templates</strong>，可以看到Astra的一些网站模板。在这里我们可以选择一个符合自己网站主题的模板（点击详情可以预览网页），导入到我们的网站中。<br><img src="https://img.mahaofei.com/img/202112231134720-wordpress-elementor-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231135722-wordpress-elementor-4.png" alt=""></p><h2 id="三、可视化编辑">三、可视化编辑</h2><h3 id="1-修改网站logo和标识">1. 修改网站logo和标识</h3><p>（1）进入自己的网站界面，点击上方的使用Elementor编辑，进入Elementor的编辑界面。<br><img src="https://img.mahaofei.com/img/202112231135491-wordpress-elementor-5.png" alt=""><br>（2)点击左上角进入<strong>站点设置-网站标识</strong>，可以修改网站的Logo和标识。<br><img src="https://img.mahaofei.com/img/202112231135732-wordpress-elementor-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231136081-wordpress-elementor-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231136994-wordpress-elementor-8.png" alt=""></p><h3 id="2-修改内容">2. 修改内容</h3><p>Elementor是模块化的编辑器，它将网站从上到下按不同段进行拼接，每个段内部分成一个或多个栏，可以填加不同的功能模块。<br>（1）修改文字：将鼠标放在要求改的文字上，单击可以直接修改，或者在左侧编辑菜单中修改。<br><img src="https://img.mahaofei.com/img/202112231136545-wordpress-elementor-9.png" alt=""><br>（2）更换图片：点击要修改的图片，可以看到左侧编辑菜单出现了相应的选项，此处可以更换图像，图像可以选择媒体库中已存在的图像，也可以上传图像。同时下方能够修改图像的尺寸和对齐方式。此外还可以在高级设置中进行更多的设置。<br><img src="https://img.mahaofei.com/img/202112231136332-wordpress-elementor-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231137596-wordpress-elementor-11.png" alt=""><br>（3)更改图标：还是点击要求改的图标，以Read More→的→为例，在左侧可以选择图标库中已经有的图标，也可以自己上传图标。<br><img src="https://img.mahaofei.com/img/202112231137045-wordpress-elementor-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231138675-wordpress-elementor-13.png" alt=""></p><h3 id="3-修改布局">3. 修改布局</h3><p>（1）点击段上方中间的按钮，在左侧可以更改此段的布局（边距、对齐）、结构（分栏数）等。<br><img src="https://img.mahaofei.com/img/202112231138481-wordpress-elementor-14.png" alt=""><br>（2）点击段内部各个栏的左上方的小窗子，可以修改内部各栏的布局。<br><img src="https://img.mahaofei.com/img/202112231138081-wordpress-elementor-15.png" alt=""><br>（3)修改段的位置，点击Elementor编辑菜单下方的导航器。可看到右侧出现了网站的大纲列表，直接拖动对应的段即可直接排序。<br><img src="https://img.mahaofei.com/img/202112231138476-wordpress-elementor-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231139125-wordpress-elementor-17.png" alt=""></p><h3 id="4-添加段">4. 添加段</h3><p>（1）翻到页面最下端或者点击某段上方的+，可以添加段<br><img src="https://img.mahaofei.com/img/202112231139207-wordpress-elementor-18.png" alt=""><br>（2）添加新段：选择分栏的方式数目，然后从左侧Elementor的编辑菜单直接拖动需要的功能模块至各栏即可。<br><img src="https://img.mahaofei.com/img/202112231140673-wordpress-elementor-19.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231140366-wordpress-elementor-20.png" alt=""><br>（3）使用Elementor的模板，这里可以在左上角选择模板的分类，比如我要添加About的相关模块。选好后直接插入即可。<br><img src="https://img.mahaofei.com/img/202112231140428-wordpress-elementor-21.png" alt=""><br>（4)有些主题也有自己内置的模块，添加方法类似。<br><img src="https://img.mahaofei.com/img/202112231140591-wordpress-elementor-22.png" alt=""></p><h2 id="四、修改网页导航">四、修改网页导航</h2><p>网页导航就是网站最上方的一排导航按钮，在wordpress后台的外观-菜单中可以修改。可以选择不同的页面添加到导航菜单中，也可以修改导航菜单的顺序，或者修改页面之间的从属关系，实现下拉菜单的效果。<br><img src="https://img.mahaofei.com/img/202112231141181-wordpress-elementor-23.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231141438-wordpress-elementor-24.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站搭建 </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress学习笔记（三）其他功能</title>
      <link href="/post/1bc25693.html"/>
      <url>/post/1bc25693.html</url>
      
        <content type="html"><![CDATA[<hr><p>title: WordPress学习笔记（三）其他功能<br>date: 2021-01-24 14:32:36<br>description: 媒体库是主要用来管理，你使用wordpress上传的附件的，比如图片、视频等其他文件。 点击左上角可以切换视图（列表/缩略图）。在评论内容处可以管理评论，更换不同的主题，网站的视觉效果会发生改变。用户看到的网站内容也会发生改变。站点的功能也会发生变化。<br>categories:</p><ul><li>程序设计</li><li>网站<br>tags:</li><li>笔记</li><li>WordPress</li></ul><hr><h2 id="一、媒体库">一、媒体库</h2><p>媒体库是主要用来管理，你使用wordpress上传的附件的，比如图片、视频等其他文件。 点击左上角可以切换视图（列表/缩略图）</p><h3 id="媒体文件的管理">媒体文件的管理</h3><ol><li>编辑：可以修改图片的的标题，说明文字，替代文本。替代文本是当图片没有办法正常显示的时候，会用文本代替图片。</li><li>永久删除：在媒体库中删除媒体，已经在文章中添加过的不受影响</li><li>查看：以网页的形式查看图片<br><img src="https://img.mahaofei.com/img/202112231124625-wordpress-notes3-1.png" alt=""></li></ol><h3 id="媒体文件添加">媒体文件添加</h3><ol><li>在此处可以上传到上传文件最大允许尺寸为2M</li><li>常用的图片格式、文档格式、压缩格式都可以上传。可以利用这里上传文件供用户下载。<br><img src="https://img.mahaofei.com/img/202112231124661-wordpress-notes3-2.png" alt=""></li></ol><h2 id="二、评论管理">二、评论管理</h2><ol><li>列表从左到右依次是：评论的用户，评论内容，用户评论的文章，评论时间。</li><li>在评论内容处可以管理评论，具体操作有<br>（1）驳回/批准：wordpress默认设置用户发表评论，批准后才会在网页显示<br>（2）回复：就是回复用户的评论<br>（3）编辑：可以修改用户的评论<br>（4）垃圾评论和移至回收站操作后，评论都不会在网页中显示。<br><img src="https://img.mahaofei.com/img/202112231125996-wordpress-notes3-3.png" alt=""></li></ol><h2 id="三、用户管理">三、用户管理</h2><h3 id="添加用户">添加用户</h3><p>可以在此给网站添加用户，一般是不会手动添加用户的，手动添加用户一般只用来添加管理员，普通用户通常是会有注册渠道。<br>填写用户名，电子邮件，名字，姓氏，密码，选择用户角色后即可完成用户的添加。<br><img src="https://img.mahaofei.com/img/202112231125420-wordpress-notes3-4.png" alt=""></p><h3 id="用户资料">用户资料</h3><p>点击个人资料即可看到自己的资料<br><img src="https://img.mahaofei.com/img/202112231125017-wordpress-notes3-5.png" alt=""></p><ol><li>可视化编辑器<br>不使用可视化编辑器：<br><img src="https://img.mahaofei.com/img/202112231125549-wordpress-notes3-6.png" alt=""><br>使用可视化编辑器<br><img src="https://img.mahaofei.com/img/202112231126322-wordpress-notes3-7.png" alt=""></li><li>管理界面的配色：后台左侧和上侧的颜色</li><li>工具栏：在登录之后，打开自己的网站，会看到最上面有一条工具条。<br><img src="https://img.mahaofei.com/img/202112231126870-wordpress-notes3-8.png" alt=""></li><li>资料图片：需要到gravatar网站上注册账户，并设置头像。当在wordpress的网站中使用相同的邮件账户注册会员，那么wordpress就会根据邮件账户信息，从gravatar网站中获取头像</li></ol><h3 id="管理用户">管理用户</h3><p>在所有用户页面内可以管理此网站的所有用户<br>在这里插入图片描述<br><img src="https://img.mahaofei.com/img/202112231126221-wordpress-notes3-9.png" alt=""></p><h2 id="四、工具">四、工具</h2><h3 id="快速发布">快速发布</h3><p>将按钮拖动到收藏夹栏即可添加这个工具。再打开别人的网站时，点击快速发布按钮，可以将该网页的标题，内容，图片等copy下来形成一个文章。</p><h3 id="直接链接">直接链接</h3><p>类似快速发布，点击直接连接按钮，可以看到最上方有一栏可以输入url，找到想要剪辑的网页，将url复制到此栏即可生成一篇文章。</p><h3 id="导入和导出">导入和导出</h3><p>导入可以从其它博客平台等网站，将自己的文章和评论等导入到此网站。到处则是创建一个xml文件，保存网站的内容。</p><h2 id="五、外观">五、外观</h2><h3 id="主题">主题</h3><ol><li>主题的作用<br>更换不同的主题，网站的视觉效果会发生改变。用户看到的网站内容也会发生改变。站点的功能也会发生变化。</li><li>主题的安装方法<br>点击添加主题即可进入安装页面，可以在此页面安装主题<br>（1）在线安装：在wordpress的特色、热门、最新等栏目中选择主题，也可以搜索主题安装。安装后点击实时预览可以看到网站更换主题的效果。点击启用即可更换主题。<br><img src="https://img.mahaofei.com/img/202112231126493-wordpress-notes3-10.png" alt=""><br>（2）手动安装：将主题下载到本地，点击上传主题，选择下载好的主题zip文件，点击现在安装即可。<br><img src="https://img.mahaofei.com/img/202112231127787-wordpress-notes3-11.png" alt=""><br>（3)直接安装：直接将解压后的主题文件夹，放置在wp-content/themes/文件夹内。回到主提页面，刷新一下即可看到刚才安装的主题。</li><li>自定义主题<br>点击自定义按钮后，可以看到左侧是自定义的栏目（不同的主题栏目会不一样），右侧是实时效果预览<br><img src="https://img.mahaofei.com/img/202112231127605-wordpress-notes3-12.png" alt=""></li></ol><h3 id="小工具">小工具</h3><p>有的主题没有提供这个功能，有没有这个功能是由主题决定的。</p><ol><li>小工具右侧可以看到一些容器，修改这些容器可以更改网页的效果。</li><li>小工具左侧可用的选项，可以拖动到右面的容器中使用。<br><img src="https://img.mahaofei.com/img/202112231127711-wordpress-notes3-13.png" alt=""></li></ol><h2 id="六、设置">六、设置</h2><h3 id="常规设置">常规设置</h3><ol><li>站点标题：网站的名称</li><li>副标题：一般情况下，显示在网站的标题旁边</li><li>wordpress地址和站点地址一般使用默认</li><li>电子邮件地址：用于接收站点相关通知的邮</li><li>成员资格：网站是否允许其他人注册</li><li>新用户默认角色：考虑权限以及安全问题，订阅者权限即可。</li><li>ICP备案号：可以填写网站的备案号，是否会在网站显示取决于主题。<br><img src="https://img.mahaofei.com/img/202112231127549-wordpress-notes3-14.png" alt=""></li></ol><h3 id="撰写设置">撰写设置</h3><ol><li>默认文章分类：发布文章时没有勾选分类目录时，wordpress会自动将这篇文章放到此处设置的分类目录里面</li><li>更新服务：在更新服务里面填写的网址，当发布新的内容的时候，wordpress会自动通知此处的链接地址。（主要用于搜索优化）<br><img src="https://img.mahaofei.com/img/202112231128293-wordpress-notes3-15.png" alt=""></li></ol><h3 id="阅读设置">阅读设置</h3><ol><li>首页显示：默认显示最新文章，选择静态页面时可以设置站点首页为后台发布的某张页面</li><li>Feed中显示最近：用户订阅我们网站内容时，每页显示多少内容<br><img src="https://img.mahaofei.com/img/202112231128640-wordpress-notes3-16.png" alt=""></li></ol><h3 id="讨论设置">讨论设置</h3><p>尝试通知文章链接的博客：在发布文章时，如果文章内容发布链接时，如果勾选此选项，则会通知对方我们的链接指向了他们（一般不使用）。<br><img src="https://img.mahaofei.com/img/202112231128717-wordpress-notes3-17.png" alt=""></p><h3 id="多媒体设置">多媒体设置</h3><p>上传图片后，wordpress会自动在此图片基础上转换出不同像素大小的图片。</p><h3 id="固定链接">固定链接</h3><p>通过切换不同的链接结构，可以改变网页网址。更改的主要原因是为了搜索引擎检索的优化。一般使用文章名较好。<br><img src="https://img.mahaofei.com/img/202112231128743-wordpress-notes3-18.png" alt=""><br>自定义结构</p><table><thead><tr><th>代码</th><th>作用</th></tr></thead><tbody><tr><td>%post_id%</td><td>内容的编号</td></tr><tr><td>%postname%</td><td>内容的名称</td></tr><tr><td>%year%</td><td>发布的年份</td></tr><tr><td>%monthnum%</td><td>发布的月份</td></tr><tr><td>%day%</td><td>具体哪一天</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress学习笔记（二）插件安装</title>
      <link href="/post/552816bb.html"/>
      <url>/post/552816bb.html</url>
      
        <content type="html"><![CDATA[<p>插件可以实现为wordpress站点增加、修改、删除功能。<br>WordPress有许多安装插件的安装方法，可以在线安装，可以手动上传插件包，也可以直接配置文件视线插件的安装。</p><p><img src="https://img.mahaofei.com/img/202112231123056-wordpress-notes2-1.png" alt=""></p><ol><li>在线安装插件，可以在wordpress的特色、热门、推荐菜单中寻找插件，也可以搜索插件。找到合适的插件后点击安装即可。</li></ol><p><img src="https://img.mahaofei.com/img/202112231124432-wordpress-notes2-2.png" alt=""><br>2. 手动安装插件：当在线安装插件失败或者需要安装wordpress插件库中没有的插件时，从对应网站下载插件包，点击上传插件，选择手动下载下来的插件包即可。</p><p><img src="https://img.mahaofei.com/img/202112231124287-wordpress-notes2-3.png" alt=""></p><ol start="3"><li>解压安装插件：如果手动安装插件仍然出错而且无法解决时，可以将下载的zip压缩包解压，将整个文件夹放到wp-content/plugins/文件夹内</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress学习笔记（一）文章操作</title>
      <link href="/post/9a45b6f9.html"/>
      <url>/post/9a45b6f9.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述">一、简述</h2><h3 id="1-网站的内容">1. 网站的内容</h3><p>对于一个网站来说，内容是最重要的一部分，用户之所以访问你的网站，也是因为你的内容。在WordPress中，内容主要分成两个部分：文章和页面。</p><ul><li>文章：用于发布网站的主要内容（如博客类网站，文章处发布博文）</li><li>页面：用于发布网站的其他内容（如博客类网站，页面处发布博主/网站信息）<br><img src="https://img.mahaofei.com/img/202112231122275-wordpress-notes1-1.png" alt=""></li></ul><h3 id="2-网站的规划">2. 网站的规划</h3><p>（1）划分出网站的主要内容和其他内容<br>（2）对主要内容进行分门别类，划分出分类目录<br>（3）不需要事先划分标签</p><blockquote><p><strong>分类目录</strong>：对文章按内容进行分类<br><strong>标签</strong>：可以理解为是一种标记，通过给文章添加一个标记，如果需要查看带有某个标记的文章的时候，wordpress就能快速筛选出来。</p></blockquote><p><img src="https://img.mahaofei.com/img/202112231123221-wordpress-notes1-2.png" alt=""></p><h2 id="二、文章">二、文章</h2><ul><li>右边可以看到文章的发布信息、状态、分类目录、标签、特色图片等信息<br><img src="https://img.mahaofei.com/img/202112231123743-wordpress-notes1-3.png" alt=""></li><li>点击右上角显示选项可以看到更多信息，这里可以先把所有复选框都选上，后面一个一个看他们的作用。（我们的选项可能不一样，这是因为安装的插件不同导致的，这个不用在意）<br><img src="https://img.mahaofei.com/img/202112231123157-wordpress-notes1-4.png" alt=""></li></ul><ol><li><strong>标题</strong>：从上到下，第一个就是文章内容的标题，这里就不多说。</li><li><strong>添加媒体</strong>：可以上传图片等文件，插入进文章中光标所在位置</li><li><strong>文章摘要</strong>：在文章内容下面，可以看到文章摘要的填写框，文章摘要就是文章主要内容的概述，作用为在网站的文章列表中显示摘要，让用户快速的了解文章的主要内容，如果用户感兴趣的话可以进一步查看内容。</li><li><strong>发送Trackback</strong>：如果应用或借鉴了其他人的文章，可以在此处填写ulr通知对方，这个功能目前很少使用。</li><li><strong>自定义栏目</strong>：在正文内无法添加，需要添加更多的内容，可以在自定义栏目中实现。</li><li><strong>讨论</strong>：允许评论勾选则允许评论，不勾选则不允许用户评论</li><li><strong>评论</strong>：可以添加，或者管理评论</li><li><strong>别名</strong>：修改链接网址，使网址更符合搜索引擎的索引要求</li><li><strong>标签</strong>：可以给文章打上标记，将来如果想查看文章，只需要使用标签即可。</li><li><strong>特色图像</strong>：相当于文章的缩略图</li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress后台加载慢的解决方法</title>
      <link href="/post/7755eae.html"/>
      <url>/post/7755eae.html</url>
      
        <content type="html"><![CDATA[<hr><p>title: wordpress后台加载慢的解决方法<br>date: 2021-01-21 22:59:30<br>description: 进入后台/在后台操作时，会发现页面加载很慢，原因之一是wordpress使用了google字体，解决方法：安装disable google fonts插件（2021.1亲测有效）（查资料还有一个原因是用户头像无法正常加载，但是这个在最新版的wordpress中已经解决了）<br>categories:</p><ul><li>程序设计</li><li>网站<br>tags:</li><li>WordPress</li><li>bugs</li></ul><hr><p>进入后台/在后台操作时，会发现页面加载很慢，原因之一是wordpress使用了google字体<br>解决方法：安装disable google fonts插件（2021.1亲测有效）<br>（查资料还有一个原因是用户头像无法正常加载，但是这个在最新版的wordpress中已经解决了）</p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wordpress上传文件报错的解决方法（413 Request Entity Too Large、超过upload_max_filesize文件中定义的php.ini值）</title>
      <link href="/post/3357eac0.html"/>
      <url>/post/3357eac0.html</url>
      
        <content type="html"><![CDATA[<h1>报错：413 Request Entity Too Large</h1><p>问题nginx是限制上传大小，解决方法如下:</p><ol><li><p>打开nginx配置文件 nginx.conf, 路径一般是：/etc/nginx/nginx.conf。</p></li><li><p>在http{}段中加入 client_max_body_size 64m; 64m为允许最大上传的大小。</p></li><li><p>保存后重启nginx，service nginx restart</p></li></ol><h1>报错：上传的文件尺寸超过upload_max_filesize文件中定义的php.ini值</h1><p>解决方法：修改/etc/php/7.3/apache2/php.ini文件中的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post_max_size = 64M</span><br><span class="line">upload_max_filesize = 64M</span><br></pre></td></tr></table></figure><p>（这两条都在比较靠后的位置，不太好找）</p><p><img src="https://img.mahaofei.com/img/202112231121053-wp-bugfix-1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bugs </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派搭建个人网站】花生壳内网穿透</title>
      <link href="/post/e8738dca.html"/>
      <url>/post/e8738dca.html</url>
      
        <content type="html"><![CDATA[<p>如果wordpress已经安装设置完成后，浏览器输入<code>localhost</code>或者 <code>树莓派的ip地址</code>，就可以访问到网站了，但是外网（不在一个路由器内）仍然无法访问，而内网穿透的目的就是使外网的计算机能够访问你的网站。为了减少配置的难度和复杂度，我使用了花生壳进行配置。<br>（虽然说是免费内网穿透，但是过程中是花费了6元）</p><h2 id="一、-安装花生壳">一、 安装花生壳</h2><ol><li>进入<a href="https://hsk.oray.com/download/">官网下载页面</a>，下载<strong>树莓派32位系统</strong>。</li><li>通过cd命令进入对应下载目录，输入下面的命令进行安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i phtunnel_5_0_rapi_armhf.deb</span><br></pre></td></tr></table></figure><ol start="3"><li>安装成功后，将显示此树莓派的SN码、默认密码以及远程管理地址。记住这里的SN码。<br><img src="https://img.mahaofei.com/img/202112231121334-raspberry-site3-1.png" alt=""></li></ol><h2 id="二、配置花生壳">二、配置花生壳</h2><ol><li>浏览器输入远程管理地址<a href="b.oray.com">b.oray.com</a>进入花生壳远程管理页面，输入安装花生壳时生成的SN码及默认密码admin进入。</li><li>首次登录，需要通过扫码或者密码进行激活操作，两种方法任选一种。</li><li>激活成功后，即可免费开通内网穿透。</li></ol><h2 id="三、配置内网穿透">三、配置内网穿透</h2><ol><li>点击控制台左侧的花生壳-账号列表，点击自己的账号名，即可进入内网穿透的配置页面</li><li>添加映射，映射类型选择http，这里就需要支付6元了。</li><li>其它配置按下图配置即可，域名只能选择固定的域名，外网端口只能选择动态端口，内网主机为树莓派的ip地址，端口一般是80。<br><img src="https://img.mahaofei.com/img/202112231121558-raspberrypi-site3-2.png" alt=""></li></ol><p>这样就已经实现外网访问自己用wordpress搭建的个人网站了。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派搭建个人网站】WordPress安装</title>
      <link href="/post/ed65ee52.html"/>
      <url>/post/ed65ee52.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、下载wordpress">一、下载wordpress</h2><p>在<a href="https://cn.wordpress.org/download/">wordpress官网</a>下载安装包，解压后把worpress文件夹内容放在html文件夹内。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://cn.wordpress.org/latest-zh_CN.tar.gz</span><br><span class="line">tar -xzvf latest-zh_CN.tar.gz</span><br><span class="line"><span class="built_in">mv</span> wordpress/* /var/www/html/</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231118531-raspberrypi-site2-1.png" alt=""></p><h2 id="二、在phpmyadmin内新建一个数据库">二、在phpmyadmin内新建一个数据库</h2><ol><li>浏览器输入localhost/phpmyadmin进入phpmyadmin，输入自己的phpmyadmin用户名和密码</li><li>点击数据库栏，新建数据库，输入一个数据库的名字，点击创建即可，暂时不需要数据表<br><img src="https://img.mahaofei.com/img/202112231119643-raspberrypi-site2-2.png" alt=""></li><li>在地址栏输入localhost，即可进入wordpress，按下图进行wordpress的配置<br>(我是在wordpress官网下载的安装包，没有下载中文官网的，所以显示英文，不过内容一样，按网页提示填写网站的信息即可)。<br><img src="https://img.mahaofei.com/img/202112231119494-raspberrypi-site2-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231119388-raspberrypi-site2-4.png" alt=""></li><li>设置完成后，接下来就可以用刚刚设置的用户名和密码进行wordpress的登陆了<br><img src="https://img.mahaofei.com/img/202112231119135-raspberrypi-site2-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231120445-raspberrypi-site2-6.png" alt=""></li></ol><ul><li>ps.如果要从英文修改成中文，就在如果需要修改中文就在<a href="https://cn.wordpress.org/download/">https://cn.wordpress.org/download/</a>下载中文官网的安装包，解压后将<code>wordpress/wp_content</code>内的language文件夹复制到<code>/var/www/html/wpcontent</code>内即可</li></ul><h2 id="三、wordpress修改网站主题">三、wordpress修改网站主题</h2><p>点击左上角的网站title即可查看当前网站<br><img src="https://img.mahaofei.com/img/202112231120192-raspberrypi-site2-7.png" alt=""><br>如果想更改主题，可以点击左侧W标志，进入外观-主题菜单栏，选择主题安装。<br><strong>主机名填写树莓派的ip地址，用户名为pi，密码为raspberry</strong>，若出现下列要求FTP的对话框<br><img src="https://img.mahaofei.com/img/202112231120759-raspberrypi-site2-8.png" alt=""><br>则在命令栏输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br><span class="line">sudo passwd root<span class="comment">#自己设置一个root账户密码</span></span><br><span class="line">sudo passwd --unlock root</span><br><span class="line">su<span class="comment">#这里会提示输入刚才设置的密码</span></span><br><span class="line">vi /etc/vsftpd.conf</span><br><span class="line"><span class="comment">#去掉write_enable=YES前面的#</span></span><br><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure><p>此时再重新安装主题即可成功安装。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 网站搭建 </tag>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派搭建个人网站】环境配置</title>
      <link href="/post/db9ee778.html"/>
      <url>/post/db9ee778.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建LAMP服务器">搭建LAMP服务器</h2><p><strong>即Linux+Apache+MySQL+PHP</strong></p><p><strong>1. 安装apache</strong><br>打开控制台，输入命令，确保软件安装是最新的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>安装apache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure><p>安装完成后给apache文件赋予权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R pi:www-data /var/www/html/</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 770 /var/www/html/</span><br></pre></td></tr></table></figure><p>在浏览器输入<code>127.0.0.1</code>可以看到apache的页面，说明apache已经顺利安装成功。<br><img src="https://img.mahaofei.com/img/202112231115154-raspberrypi-site1-1.png" alt=""><br><strong>2. 安装Nginx</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p><strong>2. 安装php及部分插件</strong><br>在控制台输入以下命令安装php7.3（2021年1月为7.3版本，安装最新版即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0</span><br></pre></td></tr></table></figure><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0-fpm</span><br><span class="line">sudo apt-get install php7.0-mysql</span><br><span class="line">sudo apt-get install php7.0-common</span><br></pre></td></tr></table></figure><p><strong>3. 安装MySQL</strong><br>由于MySQL闭源了，我们安装mariadb.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br><span class="line">sudo apt-get install mariadb-client</span><br></pre></td></tr></table></figure><p><strong>4. 配置Nginx</strong><br>在控制台输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure><p>找到其中的location，将location修改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">index index.html index.htm index.php default.html default.htm default.php</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~\.php<span class="variable">$&#123;</span></span><br><span class="line"><span class="variable">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>5. 重新启动服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nginx restart</span><br><span class="line">sudo /etc/init.d/php7.3-fpm restart</span><br><span class="line">sudo service mysql restart</span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><p><strong>6. 测试Nginx与PHP</strong><br>所有关于网站的东西都在var内，对其授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var/www</span><br><span class="line">sudo <span class="built_in">chmod</span> -R 777 /var/www/html</span><br></pre></td></tr></table></figure><p>在/var/www/html中新建index.php文件，并输入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>PHP Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;?php echo &#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后删除/var/www/html文件夹内的index.html和index.nginx-debian.html两个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /var/www/html/index.html</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /var/www/html/index.nginx-debian.html</span><br></pre></td></tr></table></figure><p>完成后，打开浏览器，输入树莓派的ip地址，或者localhost，即可看到网页Helloworld，说明以上步骤顺利完成了。<br><img src="https://img.mahaofei.com/img/202112231115939-raspberrypi-site1-2.png" alt=""></p><h2 id="创建数据库用户">创建数据库用户</h2><p>这一步需要安装PhpMyAdmin，并使用SQL语句添加mariaDB数据库用户。PHPMYADMIN是一个以PHP为基础，以Web-Base防止架构运行在网站主机上的MySQL的数据库管理工具，让管理者可以直接使用Web接口管理MySQL数据库。<br><strong>1.安装phpmyadmin</strong><br>使用以下命令进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure><p>安装过程中会遇到一些选项，按下图设置即可<br><img src="https://img.mahaofei.com/img/202112231116569-raspberrypi-site1-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231117712-raspberrypi-site1-4.png" alt=""><br>这里的密码要记住，一会登录phpmyadmin时要用到。<br><img src="https://img.mahaofei.com/img/202112231117624-raspberrypi-site1-5.png" alt=""><br><strong>2. 设置PHPMYADMIN软连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/phpmyadmin /var/www/html</span><br></pre></td></tr></table></figure><p><strong>3. 登录phpmyadmin</strong><br>在浏览器输入<code>localhost/phpmyadmin</code>进入登陆界面，初始用户名为<code>phpmyadmin</code>初始密码为之前安装过程中设置的密码。<br><img src="https://img.mahaofei.com/img/202112231117327-raspberrypi-site1-6.png" alt=""><br><strong>4. 使用SQL语句添加mariaDB数据库用户</strong><br>输入以下命令进入mariadb环境，这里没有密码，直接回车或者随便输入即可进入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure><p>在mariadb中添加用户并赋予权限<br>（1）添加用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;名字&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）赋予用户权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to 名字@localhost;</span><br></pre></td></tr></table></figure><p>（3）刷新权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>（4）退出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure><p>再次打开浏览器进入phpmyadmin中（<code>localhost/phpmyadmin</code>），使用刚刚创建的用户登录。<br><img src="https://img.mahaofei.com/img/202112231118898-raspberrypi-site1-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231118685-raspberrypi-site1-8.png" alt=""><br>可以看到我们有了很高的权限（甚至可以删库[doge])<br>到此为止就基本完成了网站环境的搭建，之后就是使用wordpress等工具搭建个人网站了。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派系统的安装、初步配置与远程访问</title>
      <link href="/post/ed0c7859.html"/>
      <url>/post/ed0c7859.html</url>
      
        <content type="html"><![CDATA[<h5 id="一、准备TF卡">一、准备TF卡</h5><ol><li>将TF卡通过读卡器连接到电脑上。</li><li>如果原来使用过的话，用Diskgenius将TF卡内所有分区都删除，新建一个分区为FAT32格式，然后格式化当前分区。</li></ol><h5 id="二、镜像的下载和写入">二、镜像的下载和写入</h5><ol><li>进入RaspberryPi官网下载最新的<a href="https://www.raspberrypi.org/software/operating-systems/#raspberry-pi-os-32-bit">系统镜像</a>。这里有三种版本，轻量版、标准版和完全版，大家可以根据需要下载，一般标准版就可以了。<br><img src="https://img.mahaofei.com/img/202112231111825-raspberrypi-install-1.png" alt=""><br>如果大家觉得下载太慢，也可以使用一些方法从百度网盘下载，链接放在下面了。<br>链接：<a href="https://pan.baidu.com/s/1FhSZkqXggTO-spSZxLwLcQ">https://pan.baidu.com/s/1FhSZkqXggTO-spSZxLwLcQ</a><br>提取码：qhcm</li><li>使用Win32Diskimager安装镜像。镜像安装完成后可能会弹出格式化的对话框，一定不要格式化，否则相当于前功尽弃。<br>（ps：使用过程中可能会报错，因为可能打开了TF卡的某个文件夹，不用理会直接确认即可。）<br><img src="https://img.mahaofei.com/img/202112231112696-raspberrypi-install-2.png" alt=""></li><li>打开SSH服务：在制作好的boot分区内，新建一个文件名为ssh，无任何后缀的文件。（可以在文件资源管理器上方点击查看选项卡，选择显示扩展名）<br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223111234812.png" alt="image-20211223111234812"></li></ol><h5 id="三、IP地址的确定和访问">三、IP地址的确定和访问</h5><p>以下操作需要【屏幕+外接键盘】或者【一根网线】，二者选一个即可。使用前者的在需要的时候将屏幕和键盘连接至树莓派即可，使用后者的需要将路由器或者电脑通过网线连接至树莓派。<br><strong>使用网线的：</strong></p><ol><li><p>将之前制作好的TF卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</p></li><li><p>开机，等待一段时间后进入系统，如果有显示器可以看到进入系统的界面，没有显示器的直接进行下一步即可。</p></li><li><p>使用Advanced scanner搜索此局域网内的树莓派的IP地址。<br><img src="https://img.mahaofei.com/img/202112231112675-raspberrypi-install-4.png" alt=""></p></li><li><p>使用PuTTy软件，默认SSH连接方式，输入IP地址，进入系统后如果出现login，则说明连接成功，用户名为pi，密码为raspberry，则可以成功进入系统。如果PuTTy连接超时，则说明IP地址有问题或者树莓派没有连接到网络。<br><img src="https://img.mahaofei.com/img/202112231112880-raspberrypi-install-5.png" alt=""></p></li><li><p>设置wifi<br>(1)命令行执行</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>(2)内容改为</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line">network=&#123;</span><br><span class="line">ssid=<span class="string">&quot;这里写wifi名称&quot;</span></span><br><span class="line">psk=<span class="string">&quot;这里写密码&quot;</span></span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://img-blog.csdnimg.cn/20210103164816336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDU0MzQ2Mw==,size_16,color_FFFFFF,t_70" width="60%"><p>其中priority是连接优先级，数字越大，优先级越高。<br>(3)保存后reboot重启，没有问题的话就可以连接上WiFi了，如果出现no wireless interfaces found，那么一定要检查上面这个文件/etc/wpa_supplicant/wpa_supplicant.conf的内容，key_mgmt和priority两行是可以不写的，所有拼写都不能错。（本人就曾因为把ssid打成ssod导致连接不上wifi排查了好久）</p></li><li><p>查看IP地址，使用Advanced scanner搜索，或者用更简单的方法，在命令行里输入<code>raspberrypi.local</code>即可查看树莓派的地址，再使用PuTTy访问即可。<br><strong>使用外接屏幕键盘数表的</strong>（这些设备只使用一次就够了）</p></li><li><p>将之前制作好的TF卡插入树莓派中，为树莓派连接电源（电源可以是2.5mm圆头电源线，也可以是microUSB或者TypeC接口的线，但要求充电头能够达到5V 3A，最低5V 2.5A）</p></li><li><p>开机，等待一段时间后进入系统，如果有显示器可以看到进入系统的界面，按照提示进行初始化设置，提示需要大量更新的时候跳过即可，后续换源后再手动更新。</p></li></ol><h5 id="四、数据源的更新和配置">四、数据源的更新和配置</h5><p>如果使用默认的源，下载速度可能会很慢，因此推荐换成国内的源，这里以清华源为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">打开sources.list文件</span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">注释里面的所有内容，输入以下地址</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line">（ctrl+o回车保存，ctrl+x退出编辑器）</span><br><span class="line"></span><br><span class="line">打开raspi.list文件</span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">注释里面的所有内容，输入以下地址</span><br><span class="line">deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line">deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line"></span><br><span class="line">更新源</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h5 id="五、windowns远程访问的实现">五、windowns远程访问的实现</h5><ol><li>在PuTTy命令行窗口输入<code>sudo raspi-config</code>，选中进入Interfacing Options，选中VNC选项，回车，选择Enable，即可打开VNC。</li><li>下载安装<a href="https://www.realvnc.com/en/connect/download/viewer/windows/">VNC软件</a><br><img src="https://img.mahaofei.com/img/202112231113661-raspberrypi-install-6.png" alt=""><br>注意：如果出现cannot currently show the desktop，则需要在刚才的位置修改分辨率，在PuTTy中输入<code>sudo raspi-config</code>，选中进入Advanced Options-Resolutions，选择除了第一个default的任意一个，保存重启后，再打开VNC即可。</li><li>即可进入图形界面。<br>至此，初步完成了系统的安装。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（十）：条件结构</title>
      <link href="/post/71a94f2b.html"/>
      <url>/post/71a94f2b.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="条件结构">条件结构</h2><ol><li>条件结构类似C语言中的if…else…和switch结构，主要用于分支选择程序逻辑。</li><li>条件结构包括两个及以上子程序框图或分支。每次仅执行一个条件分支</li><li>右键单击条件结构边框添加、复制、删除、重排及选择默认分支。</li></ol><h2 id="输入和输出隧道">输入和输出隧道</h2><ol><li>可创建多个输入/输出隧道</li><li>输入数据可供全部条件分支使用</li><li>必须为每个条件分支定义各自的输出隧道</li><li>默认分支选择器是布尔型的，当为真的时候，执行真框图内的内容，当为假的时候执行假框图内的内容。同时分支选择器也可以是数组、枚举等控件输入。</li></ol><h2 id="实验">实验</h2><p><strong>任务要求</strong></p><ol><li>产生频率、波形类型均可设置的信号</li><li>已足够的采样率产生和显示波形，并生成采样率可调的波形，并进行比较</li><li>显示波形和信号频谱</li></ol><p><strong>实现过程</strong></p><ol><li>信号的产生和显示是一个连续的过程，所以考虑使用循环。</li><li>由于信号的波形类型是可以设置的，所以在前面板中插入一个枚举型变量用于进行设置，对于枚举型变量采用不同的值，要产生不同的波形，因此使用条件结构进行判断。<br><img src="https://img.mahaofei.com/img/202112231107751-labview-notes10-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231108679-labview-notes10-2.png" alt=""></li><li>首先对第一种波形（正弦波）进行设置，程序框图中添加一个正弦波形生成控件。<br>（1）设置波形：在前面板插入一个旋钮用于调节频率，回到程序框图将其连到正弦波形生成控件的频率接口上。<br><img src="https://img.mahaofei.com/img/202112231108399-labview-notes10-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231108041-labview-notes10-4.png" alt=""><br>（2)设置采样信息：在对应接口处添加常量，增大采样率，产生采样率足够大的正弦信号。<br><img src="https://img.mahaofei.com/img/202112231108259-labview-notes10-5.png" alt=""></li><li>产生采样信号 添加一个正弦波形生成控件用于产生采样信号，在前面板添加一个文本下拉列表控件用于设置采样率（数据类型为DBL，采样率如下图），利用捆绑，将采样率和采样点数捆绑后传递给正弦波形生成控件的采样信息接口。其它接口与上面正弦波形的部分一致。<br><img src="https://img.mahaofei.com/img/202112231109348-labview-notes10-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231109263-labview-notes10-7.png" alt=""></li><li>显示信号：因涉及到两个信号的显示，因此使用创建数组，将两个信号合成为数组传递到波形图中。<br><img src="https://img.mahaofei.com/img/202112231109353-labview-notes10-8.png" alt=""></li><li>信号测量：添加一个FFT功率谱和PSD（在信号处理-波形测量中）。将采样信号连接至时间信号接口，平均参数接口创建一个常量并选择RMS平均方式。然后在前面板添加一个波形图控件用于显示频谱图。<br><img src="https://img.mahaofei.com/img/202112231109525-labview-notes10-9.png" alt=""></li><li>配置其他波形：先在条件结构中删除方波分支，然后选择复制正弦波分支，并将条件结构内的正弦波形生成控件替换为方波生成控件。（其他波形也是类似的操作流程）<br><img src="https://img.mahaofei.com/img/202112231110894-labview-notes10-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231110577-labview-notes10-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231110944-labview-notes10-12.png" alt=""></li><li>添加停止按钮，修改波形图的横坐标显示范围，最后修饰一下界面，程序就成功完成了<br><img src="https://img.mahaofei.com/img/202112231110027-labview-notes10-13.png" alt=""><br>采样率足够高时，波形信号与采样率几乎重合。<br><img src="https://img.mahaofei.com/img/202112231110120-labview-notes10-14.png" alt=""><br>采样率较低时，会出现明显的失真<br><img src="https://img.mahaofei.com/img/202112231111768-labview-notes10-15.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（九）：数组与簇</title>
      <link href="/post/2d7ac11f.html"/>
      <url>/post/2d7ac11f.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h3 id="数组">数组</h3><ol><li>数组：处理一系列相似的数据和执行重复计算操作时，可考虑使用数组。数据将相同类型的数据元素归为一组。</li><li>创建方法：在前面板放置一个数组的外框，拖放一个数据对象或元素至外框内即可创建数组。</li><li>数组组成：<br>（1） 元素：组成数组的数据<br>（2）b. 维度：数组的长度、高度、深度 （数组可以是一维或多维的，内存允许的情况下，每一维度可有多达(2^31)-1个元素）</li><li>数组初始化<br>（1）直接在前面板输入元素进行初始化。<br>（2）利用循环，如for循环索引输出的是一个数组<br>（3）c. 数组的初始化函数<br>（注：未初始化的元素只具有维数，不包含任何元素）</li><li>数组函数：包括数组大小、索引数组、创建数组、数组最大值最小值、排序、拆分数组等操作均可以通过数组函数实现。<br><img src="https://img.mahaofei.com/img/202112231106676-labview-notes9-1.png" alt=""></li></ol><h3 id="簇">簇</h3><ol><li>簇与数组：簇将不同类型数据元素归为一组，簇不同于数组的地方在于簇的大小是固定的，簇可以包含不同的数据类型，数组仅可包含一种数据类型。</li><li>簇的创建方法<br>（1）在前面板上放置一个簇的外框<br>（2）推拽数据对象或元素至簇的外框内，拖拽对象可分为数值、布尔值、字符串、路径、引用句柄、数组、簇输入控件和簇显示控件</li><li>簇的顺序：簇元素的逻辑顺序与其在簇内的位置无关，右键单击簇外框，从快捷菜单中选择重新排序簇中控件<br><img src="https://img.mahaofei.com/img/202112231107285-labview-notes9-2.png" alt=""></li><li>簇函数：簇函数中最重要的就是构造打包生成簇的捆绑函数和从簇中解包提取簇中元素的接触捆绑函数<br><img src="https://img.mahaofei.com/img/202112231107463-labview-notes9-3.png" alt=""></li><li>错误簇：<br>（1）可以控制控件执行的先后顺序<br>（2）也可以通过错误簇控制循环的终止</li><li>波形簇的簇元素<br>（1）t0：时间戳<br>（2）dt：Y数据的时间间隔<br>（3）Y：随时间变化的一组数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（八）：属性节点</title>
      <link href="/post/d8947a19.html"/>
      <url>/post/d8947a19.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="一、属性节点的介绍">一、属性节点的介绍</h2><ol><li>属性节点：可用于访问对象的属性。当某些应用中可能需要通过编程改变前面板对象外观，以响应特定输入时，通过编辑属性节点进行设置。</li><li>创建方法：在程序框图的控件上右键，创建属性节点。需要设置多个属性时可以在边框上下拖动添加属性，属性节点按照由上而下的顺序执行。</li><li>严格属性节点：右键控件创建属性节点的方法为隐含属性节点；通过控件引用创建严格属性节点（右键创建属性节点，控件右键创建引用，二者相连即可创建严格属性节点）。在多个VI涉及同一个控件的属性时，会使用严格属性节点传递。</li></ol><h2 id="二、实验">二、实验</h2><ol><li>任务要求：通过滑动杆对波形图任意一段进行显示。<br><img src="https://img.mahaofei.com/img/202112231105333-labview-notes8-1.png" alt=""></li><li>实现过程：<br>（1）用for循环产生1000个随机数，通过波形图将1000个点显示出来<br><img src="https://img.mahaofei.com/img/202112231105730-labview-notes8-2.png" alt=""><br>（2）在前面板添加一个水平滑动杆作为拖动的滚动条。<br><img src="https://img.mahaofei.com/img/202112231105264-labview-notes8-3.png" alt=""><br>（3）因需要实时调整波形图，所以用一个while循环，在while循环中创建属性节点（波形图的最大值和最小值），并将其转换为写入。将滑动杆的输出连接至波形图最小值，滑动杆的输出+100连接至波形图最大值。<br><img src="https://img.mahaofei.com/img/202112231105825-labview-notes8-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231105330-labview-notes8-5.png" alt=""><br>（4）设置滑动杆的属性（最大值和最小值）为0和900，初始值为0。<br><img src="https://img.mahaofei.com/img/202112231106970-labview-notes8-6.png" alt=""><br>（5）连接错误簇确定程序执行顺序。<br><img src="https://img.mahaofei.com/img/202112231106405-labview-notes8-7.png" alt=""><br>（6)程序设计完成</li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（七）：变量与移位寄存器</title>
      <link href="/post/20f87532.html"/>
      <url>/post/20f87532.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="变量">变量</h2><ol><li>变量的作用：在并行循环间传递数据</li><li>变量类型</li></ol><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>局部变量</td><td>将数据存储在前面板输入控件和显示控件中</td></tr><tr><td>全局变量</td><td>将数据存储在多个VI可访问的特殊数据库中</td></tr><tr><td>功能全局变量</td><td>将数据存储在While循环移位寄存器中</td></tr><tr><td>共享变量</td><td>在通过网络连接的分布式任务间传递数据</td></tr></tbody></table><ol start="3"><li>布尔控件的局部变量</li></ol><ul><li>具有关联局部变量的布尔控件必须使用开关机械动作</li><li>布尔触发动作与局部变量不兼容</li></ul><h2 id="移位寄存器">移位寄存器</h2><ol><li>应用：移位寄存器可以将前一循环产生的数据传递至下一循环</li><li>添加方法：右键单击循环边框，添加移位寄存器</li><li>右侧的移位寄存器存储每次循环结束后的数据，左侧的移位寄存器为下一循环提供所存储的数据</li><li>移位寄存器的初始化</li></ol><table><thead><tr><th>初始化</th><th>程序执行结果</th></tr></thead><tbody><tr><td>初始化的移位寄存器</td><td>无论程序运行多少次结果都一样</td></tr><tr><td>未初始化的移位寄存器</td><td>输入为上一次程序运行的结果，因此输出结果会随着程序运行次数而改变</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（六）：while循环与for循环</title>
      <link href="/post/f5eddc6a.html"/>
      <url>/post/f5eddc6a.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="while循环（图片循环播放程序）">while循环（图片循环播放程序）</h2><p>实验：完成三张图片的循环放映</p><ol><li>插入一个图片下拉列表，并导入n张图片<br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223110219783.png" alt="image-20211223110219783"><br><img src="https://img.mahaofei.com/img/202112231102463-labview-notes6-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231102640-labview-notes6-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231103974-labview-notes6-4.png" alt=""></li><li>打开程序框图，利用While循环实现图片的循环播放，首先将图片下拉列表转换为显示控件<br><img src="https://img.mahaofei.com/img/202112231103789-labview-notes6-5.png" alt=""></li><li>创建一个While循环<br><img src="https://img.mahaofei.com/img/202112231103002-labview-notes6-6.png" alt=""></li><li>因下拉图片列表中各个图片的值为0，1，2……n，利用循环次数与n的余数作为图片的选择依据（n为图片个数），插入数值中的商与余树控件并连线<br><img src="https://img.mahaofei.com/img/202112231103372-labview-notes6-7.png" alt=""><br>在我的程序中图片数是3所以除数为3</li><li>创建停止条件<br><img src="https://img.mahaofei.com/img/202112231103976-labview-notes6-8.png" alt=""></li><li>回到前面板中添加一个旋钮，用于调整图片切换速度<br><img src="https://img.mahaofei.com/img/202112231104493-labview-notes6-9.png" alt=""></li><li>在while循环中插入一个等待时间，等待时间的输入端以毫秒作为单位，同时考虑旋钮越大图片切换速度应该越快，因此将旋钮的数值取倒数再乘1000作为while循环的等待时间<br><img src="https://img.mahaofei.com/img/202112231104454-labview-notes6-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231104777-labview-notes6-11.png" alt=""></li><li>运行程序，即可观察到图片循环播放，拖动旋钮可以看到图片切换速度也会随之变化。</li></ol><h2 id="for循环">for循环</h2><ol><li>for循环的创建</li></ol><ul><li>创建for循环的方法和while循环类似</li><li>可以右键单击while循环的边框，在右键菜单中将while循环转换为for循环</li></ul><ol start="2"><li>for循环的接线端</li></ol><ul><li>N为循环次数，循环次数必须指定为非负整数（如果将双精度浮点数值连接至总线接线端，LabView将把较长的数值转换为32位有符号整数）</li><li>为了避免强制转换，以增强程序性能，选择匹配的数据类型，或者通过编程进行数据类型的转换</li></ul><ol start="3"><li>与while循环的区别</li></ol><ul><li>while循环至少执行一次，for循环可以执行0次</li><li>while循环自动输出最后一次执行的值，for循环自动输出一个数组</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（五）：数据类型综合实验</title>
      <link href="/post/3bed1cad.html"/>
      <url>/post/3bed1cad.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="任务要求">任务要求</h2><ol><li>输出正弦波信号，频率0-50M</li><li>采样率10M、50M、100M可选</li><li>检测信号频率</li><li>输出采样信号的功率谱，如果频率或采样率发生变化，重新开始平均过程</li></ol><h2 id="实现过程">实现过程</h2><ol><li>在程序框图中创建基本函数发生器，按下Ctrl+H查看即时帮助中的接口说明<br><img src="https://img.mahaofei.com/img/202112231056843-labview-notes5-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231056869-labview-notes5-2.png" alt=""></li><li>按照任务要求配置各个接口，首先在信号类型处右键，创建常量（正弦波）<br><img src="https://img.mahaofei.com/img/202112231057916-labview-notes5-3.png" alt=""></li><li>在频率、采样信息处右键创建输入控件<br><img src="https://img.mahaofei.com/img/202112231057344-labview-notes5-4.png" alt=""></li><li>添加两个波形测量的Express VI，分别是提取单频信息、FFT功率谱和PSD<br><img src="https://img.mahaofei.com/img/202112231057877-labview-notes5-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231057962-labview-notes5-6.png" alt=""></li><li>在 提取单频信息 的Express VI的<strong>检测到的功率</strong>的接口，FFT功率谱和PSD 的Express VI<strong>功率谱/PSD</strong>接口创建显示控件<br><img src="https://img.mahaofei.com/img/202112231058600-labview-notes5-7.png" alt=""></li><li>在FFT功率谱和PSD的Express VI的<strong>显示为DB</strong>接口创建常量并设置为<strong>True</strong><br><img src="https://img.mahaofei.com/img/202112231058453-labview-notes5-8.png" alt=""></li><li>在FFT功率谱和PSD的Express VI的<strong>平均参数</strong>接口创建常量并设置为<strong>RMS均方根平均方式</strong><br><img src="https://img.mahaofei.com/img/202112231058660-labview-notes5-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231058145-labview-notes5-10.png" alt=""></li><li>因需要重新开始平均所以在<strong>重新开始平均</strong>接口处创建常量并选择为<strong>真</strong><br><img src="https://img.mahaofei.com/img/202112231059510-labview-notes5-11.png" alt=""></li><li>切换回前面板，将功率谱的显示方式替换为波形图，并将频率的显示方式替换为旋钮<br><img src="https://img.mahaofei.com/img/202112231059800-labview-notes5-12.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231059373-labview-notes5-13.png" alt=""></li><li>修改旋钮周围的刻度<br><img src="https://img.mahaofei.com/img/202112231059667-labview-notes5-14.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231100465-labview-notes5-15.png" alt=""></li><li>将采样信息替换为文本下拉列表，然后右键-编辑项，修改下拉列表的菜单，并设置默认值为50M<br><img src="https://img.mahaofei.com/img/202112231100878-labview-notes5-16.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231100461-labview-notes5-17.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231101223-labview-notes5-18.png" alt=""></li><li>修改检测到的频率的显示格式<br><img src="https://img.mahaofei.com/img/202112231101135-labview-notes5-19.png" alt=""></li><li>进行简单外观修饰后运行程序<br><img src="https://img.mahaofei.com/img/202112231101949-labview-notes5-20.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（四）：动态数据类型</title>
      <link href="/post/8038e45b.html"/>
      <url>/post/8038e45b.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="动态数据类型介绍">动态数据类型介绍</h2><ol><li>在LabView中，动态数据类型表示为深蓝色</li><li>只有Express VI才能产生和接收ExpressVI （如要使用内置VI或函数处理动态数据类型，必须先进行数据类型转换，连线时一般会自动转换动态数据）</li><li>动态数据类型转换</li></ol><ul><li>从动态数据类型转换：在程序框图上放置“从动态数据转换”Express VI，配置转换的数据类型</li><li>转换至动态数据：在程序框图上放置“转换至动态数据”ExpressVI</li></ul><ol start="4"><li>获取和设置动态数据</li></ol><ul><li>使用获取动态数据ExpressVI获取动态数据的属性</li><li>使用设置动态数据属性ExpressVI设置动态数据的属性，如信号名、时间标识、时间模式等</li></ul><h2 id="实验：波形显示和数据获取">实验：波形显示和数据获取</h2><ol><li>主要目的：模拟信号输入，在波形图上显示波形，获取采样数据，采样时间和信号名称</li><li>实验过程<br>（1）添加并配置仿真信号<br><img src="https://img.mahaofei.com/img/202112231053478-labview-notes4-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231053836-labview-notes4-2.png" alt=""><br>（2）创建图形显示控件（示波器），用来显示输出波形<br><img src="https://img.mahaofei.com/img/202112231053597-labview-notes4-3.png" alt=""><br>（3）获得信号数据，并进行显示<br><img src="https://img.mahaofei.com/img/202112231054721-labview-notes4-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231054013-labview-notes4-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231054727-labview-notes4-6.png" alt=""><br>（4）获得信号属性并显示<br><img src="https://img.mahaofei.com/img/202112231055401-labview-notes4-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231055694-labview-notes4-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231055409-labview-notes4-9.png" alt=""><br>（5)运行程序查看结果<br><img src="https://img.mahaofei.com/img/202112231056441-labview-notes4-10.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（三）：基本控件</title>
      <link href="/post/2641b5ca.html"/>
      <url>/post/2641b5ca.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h2 id="1-数值型控件">1. 数值型控件</h2><ul><li>数值型控件可表示不同类型的数值</li><li>程序框图或前面板中，右键单击输入控件、显示控件或常量，从快捷菜单中选择表示法，可以改变数值型数据的表示法<br><img src="https://img.mahaofei.com/img/202112231050733-labview-notes3-1.png" alt=""></li></ul><h2 id="2-布尔型控件">2. 布尔型控件</h2><ul><li>布尔型控件最关键的就是机械动作的选择。</li></ul><table><thead><tr><th>机械动作</th><th>作用</th></tr></thead><tbody><tr><td>单击时转换</td><td>按下按钮时改变状态。保持改状态直至其他按钮按下</td></tr><tr><td>释放时转换</td><td>释放按钮时改变状态。释放其他按钮之前保持当前状态</td></tr><tr><td>保持转换直到释放</td><td>按下按钮时改变状态。松开按钮后恢复原来的状态</td></tr><tr><td>单击时触发</td><td>按下按钮时改变状态。LabView读取控件值后恢复原来的状态</td></tr><tr><td>释放时触发</td><td>释放按钮时改变状态。LabView读取控件值后返回原状态</td></tr><tr><td>保持触发直到释放</td><td>按下按钮时改变状态。松开按钮且LabView读取控件值后恢复原来的状态</td></tr></tbody></table><p><img src="https://img.mahaofei.com/img/202112231050980-labview-notes3-2.png" alt=""></p><h2 id="3-字符型控件">3. 字符型控件</h2><ul><li>可以通过快捷菜单更改显示类型：正常显示、''显示、密码显示、十六进制显示</li><li>在LabView中字符串颜色为粉红色</li><li>字符串的数据/控件可以通过数值/字符串转换函数实现字符串与各种类型数值数据之间的转换，字符串数据也可以与路径、数组之间进行转换</li><li>字符串型控件可以通过函数面板的连接字符串以及制表符、回车/换行符将多个字符串数据转换成指定格式的字符串，用于报表的制作<br><img src="https://img.mahaofei.com/img/202112231051354-labview-notes3-3.png" alt=""></li></ul><h2 id="4-枚举和下拉控件">4. 枚举和下拉控件</h2><ul><li>下拉列表：右键单击下拉列表控件，并从快捷菜单中选择编辑项，或者在属性对话框中点击编辑项的选项卡，即可向控件的下拉列表中添加内容，并更改项的顺序<br><img src="https://img.mahaofei.com/img/202112231051221-labview-notes3-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231052453-labview-notes3-5.png" alt=""></li><li>枚举型控件：将枚举型控件连接至条件结构的选择器接线端时，LabView将控件中的字符串与分支条件相比较，而不是控件的数值<br><img src="https://img.mahaofei.com/img/202112231052099-labview-notes3-6.png" alt=""></li><li>如果数据过大时，枚举类型可以较好的显示，而下拉列表有时需要更改数据类型以实现存储较大数据。<br><img src="https://img.mahaofei.com/img/202112231052110-labview-notes3-7.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（二）：滤波器实验</title>
      <link href="/post/7442f1dd.html"/>
      <url>/post/7442f1dd.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h3 id="滤波器实验">滤波器实验</h3><p><strong>1. 主要目的</strong>：学习VI的创建方法<br><strong>2. 操作步骤</strong>：<br>（1）放置Express VI至程序框图<br>（2）配置弹出的对话框<br>（3）连线Express VI<br>（4）保存并运行VI<br><strong>3. 实验过程</strong><br>（1）添加正弦仿真信号，并对正弦信号进行配置，设置频率为100Hz<br><img src="https://img.mahaofei.com/img/202112231047458-labview-notes2-1.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231048500-labview-notes2-2.png" alt=""><br>（2）添加滤波器，设置截止频率为100Hz，频率低于100Hz就可以进行波形显示<br><img src="https://img.mahaofei.com/img/202112231048435-labview-notes2-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231048260-labview-notes2-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231048631-labview-notes2-5.png" alt=""><br>（3）将正弦信号和滤波后的信号进行合并<br><img src="https://img.mahaofei.com/img/202112231049922-labview-notes2-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231049124-labview-notes2-7.png" alt=""><br>（4）添加图形显示控件<br><img src="https://img.mahaofei.com/img/202112231049374-labview-notes2-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231049966-labview-notes2-9.png" alt=""><br>（5）双击生成的图形显示控件，进入前面板，运行程序<br><img src="https://img.mahaofei.com/img/202112231050285-labview-notes2-10.png" alt=""><br>（6)可以尝试修改正弦信号源和滤波器的配置，观察曲线变化</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView学习笔记（一）：基础介绍</title>
      <link href="/post/840cf816.html"/>
      <url>/post/840cf816.html</url>
      
        <content type="html"><![CDATA[<p><strong>Labview学习笔记</strong>：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/112325523">LabView学习笔记（一）：基础介绍</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112329185">LabView学习笔记（二）：滤波器实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112364388">LabView学习笔记（三）：基本控件</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112366358">LabView学习笔记（四）：动态数据类型</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112392799">LabView学习笔记（五）：数据类型综合实验</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112393383">LabView学习笔记（六）：while循环与for循环</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112431393">LabView学习笔记（七）：变量与移位寄存器</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112470713">LabView学习笔记（八）：属性节点</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112529983">LabView学习笔记（九）：数组与簇</a><br><a href="https://blog.csdn.net/weixin_44543463/article/details/112571924">LabView学习笔记（十）：条件结构</a><br><a href="https://blog.csdn.net/weixin_44543463/category_10714833.html">其它实验过程记录</a></p><hr><h1>一、前面板</h1><h2 id="1-控件选板">1. 控件选板</h2><p>（1） 控件来源于控件选板，右键可以打开控件选板，控件可以点击后添加到前面板，也可以通过拖拽添加控件。<br><img src="https://img.mahaofei.com/img/202112231047048-labview-notes1-1.png" alt=""><br>（2) 分类</p><ul><li>数值控件：输入和显示数值数据</li><li>布尔控件：创建按钮、开关和指示灯</li><li>路径控件：输入或返回文件或目录的地址</li><li>数组、矩阵、簇控件：创建数组、矩阵、簇</li><li>列表框、树形和表格等控件：提供选项列表</li><li>图形控件：图形和图表的形式绘制数值数据</li><li>枚举控件：提供一个可供选择的项列表</li><li>容器控件：用于组合各种控件</li></ul><h2 id="2-工具选板">2. 工具选板</h2><p><img src="https://img.mahaofei.com/img/202112231047795-labview-notes1-2.png" alt=""></p><p><img src="https://img.mahaofei.com/img/20220410101018.png" alt=""></p><h1>二、程序框图</h1><h2 id="1-组成">1. 组成</h2><p>接线端（前面板）、子VI、函数、常量、结构、连线</p><h2 id="2-函数选板">2. 函数选板</h2><p>依然是右键打开</p><h2 id="3-程序框图">3. 程序框图</h2><p>（1） 接线端：包括前面板对象程序框图外观，可以右键不选显示为图标，使程序框图界面更简洁。<br>（2） 节点：带有输入和输出端，是用来进行运算的，比如函数节点、子VI节点（双击即可查看子VI的前面板和程序框图，ExpressVI是特殊的子VI所需连线数量最少，通过对话框配置）。<br>（3） 连线</p><ul><li>程序框图对象之间通过连线传输数据</li><li>不同数据类型的连线颜色、粗细和样式均有差异</li><li>断开的连线显示为中间带有红叉的黑色虚线</li><li>按下Ctrl+B删除所有断线</li><li>右键连线可以整理连线</li><li>框选程序框图的一部分，使用整理程序框图可以使程序框图更易读</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView2018的安装</title>
      <link href="/post/9b2c6c92.html"/>
      <url>/post/9b2c6c92.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>百度网盘链接：<a href="https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA">https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA</a><br>提取码：labv<br>  <br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/vBKNYBdLsXV">https://www.aliyundrive.com/s/vBKNYBdLsXV</a><br>阿里云盘无法分享压缩包，因此改了文件格式，下载完后缀名改回.zip即可</p></blockquote><p>安装前请新建一个文件夹作为labview的安装路径，最好不要安装在盘符根目录下。</p><ol><li>下载LabView2018安装包解压，运行安装程序。<br><img src="https://img.mahaofei.com/img/202112231042371-labview2018-1.png" alt=""></li><li>选择安装程序的解压路径，点击Unzip<br><img src="https://img.mahaofei.com/img/202112231043655-labview2018-2.png" alt=""></li><li>开始安装，点击下一步<br><img src="https://img.mahaofei.com/img/202112231043950-labview2018-3.png" alt=""></li><li>输入用户信息，可以随意输入<br><img src="https://img.mahaofei.com/img/202112231043887-labview2018-4.png" alt=""></li><li>不用输入序列号，直接跳过，点击下一步<br><img src="https://img.mahaofei.com/img/202112231043425-labview2018-5.png" alt=""></li><li>选择安装目录，点击下一步<br><img src="https://img.mahaofei.com/img/202112231044650-labview2018-6.png" alt=""></li><li>选择需要安装的组件，一般情况默认下一步即可<br><img src="https://img.mahaofei.com/img/202112231044511-labview2018-7.png" alt=""></li><li>接受许可，一直下一步即可<br><img src="https://img.mahaofei.com/img/202112231044061-labview2018-8.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231045566-labview2018-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231045211-labview2018-10.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231045881-labview2018-11.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231045928-labview2018-12.png" alt=""><br>如果出现需要安装支持，如果不用NI的采集卡，是不需要安装这个驱动的，直接点击不需要支持就可以，如果后续需要驱动的话可以另行安装。<br><img src="https://img.mahaofei.com/img/202112231046513-labview2018-13.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231046586-labview2018-14.png" alt=""></li><li>进行软件的注册破解<br>打开破解工具<br><img src="https://img.mahaofei.com/img/202112231046976-labview2018-15.png" alt=""><br>鼠标右键激活，将所有都变成绿色<br><img src="https://img.mahaofei.com/img/202112231046569-labview2018-16.png" alt=""><br>至此完成了LabView的安装和破解，接下来就可以正常使用了。<br>在开始菜单中所有应用中可以找到新安装的LabView2019<br><img src="https://img.mahaofei.com/img/202112231046828-labview2018-17.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabView2019的安装与卸载</title>
      <link href="/post/3e37433.html"/>
      <url>/post/3e37433.html</url>
      
        <content type="html"><![CDATA[<h1>LabView2019的安装</h1><p><strong>注：此版本为英文版，如需要要中文版的请参考<a href="https://blog.csdn.net/weixin_44543463/article/details/112323169">LabView2018的安装<br></a></strong><br><strong>1. 下载网盘里面的LabView2019.zip压缩包</strong></p><blockquote><p>百度网盘链接：<a href="https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA">https://pan.baidu.com/s/1gyiFn5nOdPkLdp-1kRwwHA </a><br>提取码：labv<br>  <br>阿里云盘链接：<a href="https://www.aliyundrive.com/s/fgfRMQYBBuu">https://www.aliyundrive.com/s/fgfRMQYBBuu</a><br>阿里云盘无法分享压缩包，因此改了文件格式，下载完后缀名改回.zip即可</p></blockquote><p><strong>2. 解压进入对应64位或32位文件夹，再解压文件夹内的的ISO文件，进入打开的文件夹，双击install.exe</strong><br><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223103914607.png" alt="image-20211223103914607"><br><strong>3. 按照下列步骤进行安装</strong><br><img src="https://img.mahaofei.com/img/202112231039411-labview2019-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231039570-labview2019-3.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231039014-labview2019-4.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231040434-labview2019-5.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231040848-labview2019-6.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231040160-labview2019-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231040293-labview2019-8.png" alt=""><br>等待一段时间的安装<br><img src="https://img.mahaofei.com/img/202112231040948-labview2019-9.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231041218-labview2019-10.png" alt=""><br>这里不要登陆账号，直接关闭所有窗口，然后点击立即重启。<br><img src="https://img.mahaofei.com/img/202112231041957-labview2019-11.png" alt=""><br><strong>3. 进行软件的破解</strong><br>打开Crack文件夹下面的破解工具<br><img src="https://img.mahaofei.com/img/202112231041200-labview2019-12.png" alt=""><br>鼠标右键激活，将所有都变成绿色<br><img src="https://img.mahaofei.com/img/202112231041456-labview2019-13.png" alt=""><br>至此完成了LabView的安装和破解，接下来就可以正常使用了。<br>在开始菜单中所有应用中可以找到新安装的LabView2019<br><img src="https://img.mahaofei.com/img/202112231042809-labview2019-14.png" alt=""></p><h1>LabView2019的卸载</h1><p>打开控制面板，按照安装时间排序，找到图示的程序，双击卸载<br><img src="https://img.mahaofei.com/img/202112231042194-labview2019-15.png" alt=""><br>选择删除全部<br><img src="https://img.mahaofei.com/img/202112231042213-labview2019-16.png" alt=""><br>再在控制面板中删除其它有关LabView的程序</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> LabVIEW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> LabVIEW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用38译码器扩展单片机接口</title>
      <link href="/post/d455f071.html"/>
      <url>/post/d455f071.html</url>
      
        <content type="html"><![CDATA[<h2 id="74HC138译码器">74HC138译码器</h2><p><strong>1. 介绍</strong><br>在设计单片机电路的时候，单片机的IO口数量是有限的，有时并满足不了我们的设计需求，因此为了控制更多的器件，就需要使用一些外围的数字芯片进行引脚扩展。常用的是74HC138，也叫38译码器。<br><img src="https://img.mahaofei.com/img/202112231037711-74hc138-1.png" alt=""><br><strong>2. 工作原理</strong><br>38译码器，从名字来分析就是把3种输入状态翻译成8种输出状态。对于数字器件的引脚，如果一个引脚输入的时候，有 0 和 1 两种状态；对于两个引脚输入的时候，就会有 00、01、10、11 这四种状态了，那么对于 3 个输入的时候，就会出现 8 种状态了，真值表如下图所示。<br><img src="https://img.mahaofei.com/img/202112231037943-74hc138-2.png" alt=""><br>可以看出，左面三位相当于从0~8，右面则是8种输出状态。在任意输入状态时，只有一个输出引脚是低电平，这一点需要注意，也可以通过连接反相器实现高电平输出。<br>使用时，E2、E3接地，E1用来控制译码器的选通1为开启，0为关闭。A、B、C分别对应A0、A1、A2。E1、A、B、C连接单片机的4个引脚，就可以实现共输出状态的控制。</p><h2 id="Protues仿真实验">Protues仿真实验</h2><p><strong>1. 实验目的</strong><br>使用51单片机控制12个电机的选择启动<br><strong>2. 实验过程</strong><br><img src="https://img.mahaofei.com/img/202112231037894-74hc138-3.png" alt=""></p><ul><li>L298N作为步进电机的驱动</li><li>CD4066作为步进电机的选通开关，控制端收到高电平则导通</li><li>74HC138译码器+74HC240反相器用于扩展引脚，将单片机的信号经翻译后发送给给CD4066选择电机<br><strong>3. 实验结果</strong><br>电机按照预期要求以此选通启动。<br><img src="https://img.mahaofei.com/img/202112231038889-74hc138-4.png" alt=""><br><strong>4. 代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">enable</span> <span class="operator">=</span> P3^<span class="number">0</span>;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">key</span> <span class="operator">=</span> P3^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="type">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;<span class="comment">//顺时针转动</span></span><br><span class="line"><span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line">unsigned <span class="type">char</span> table[] = &#123;<span class="number">0x80</span>,<span class="number">0x90</span>,<span class="number">0xa0</span>,<span class="number">0xb0</span>,<span class="number">0xc0</span>,<span class="number">0xd0</span>,<span class="number">0xe0</span>,<span class="number">0xf0</span>,<span class="number">0x08</span>,<span class="number">0x09</span>,<span class="number">0x0a</span>,<span class="number">0x0b</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line">P1=<span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>);</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num&gt;=<span class="number">12</span>)</span><br><span class="line">num=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(num==-1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">P1=0x00;</span></span><br><span class="line"><span class="comment">P0=0x00;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else if(num&lt;8)</span></span><br><span class="line"><span class="comment">P1=table1[num];</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">P0=table2[num-8];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span>(num==-<span class="number">1</span>)</span><br><span class="line">P1=<span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P1 = table[num];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P2 = step[i];</span><br><span class="line">delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驱动多个二相四线制步进电机的Proteus仿真</title>
      <link href="/post/6f10ef99.html"/>
      <url>/post/6f10ef99.html</url>
      
        <content type="html"><![CDATA[<h2 id="CD4066介绍">CD4066介绍</h2><p><strong>1. 功能简介</strong><br>CD4066是四双向模拟开关，主要用作模拟或数字信号的多路传输。CD4066 的每个封装内部有4 个独立的模拟开关，每个模拟开关有输入、输出、控制三个端子，其中输入端和输出端可互换。<br><img src="https://img.mahaofei.com/img/202112231034164-mulity-step-motor-1.png" alt=""><br><strong>2. 引脚说明</strong></p><ul><li>CONTROL：开关控制端 [1]</li><li>IN/OUT：输入/输出端</li><li>OUT/IN：输出/输入端</li><li>VDD：电源正</li><li>VSS：电源负</li></ul><p><strong>3. 控制方法</strong><br>将CD4066的四个输入端接在L298N的输出口，CD4066的输出端接在步进电机的A+、A-、B+、B-端口，四个控制口同时接在单片机的某一引脚上，实现单片机的一个引脚控制一个CD4066上四个开关的同时开断，进而实现步进电机的选择。</p><h2 id="Proteus仿真">Proteus仿真</h2><p>Proteus接线图如下图所示。<br><img src="https://img.mahaofei.com/img/202112231035730-mulity-step-motor-2.png" alt=""><br>由于Proteus内没有CD4066，只有4066，因此考虑将4个4066组合视为一个整体。<br><img src="https://img.mahaofei.com/img/202112231036221-mulity-step-motor-3.png" alt=""><br>仿真结果：<br><img src="https://img.mahaofei.com/img/202112231036870-mulity-step-motor-4.png" alt=""><br>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">enable</span> <span class="operator">=</span> P3^<span class="number">0</span>;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">key</span> <span class="operator">=</span> P3^<span class="number">1</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="type">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;<span class="comment">//顺时针转动</span></span><br><span class="line"><span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line">unsigned <span class="type">char</span> table1[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line">unsigned <span class="type">char</span> table2[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P0 = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>);</span><br><span class="line">&#123;</span><br><span class="line">delay(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num&gt;=<span class="number">12</span>)</span><br><span class="line">num=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num==-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P1=<span class="number">0x00</span>;</span><br><span class="line">P0=<span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num&lt;<span class="number">8</span>)</span><br><span class="line">P1=table1[num];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">P0=table2[num-<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P2 = step[i];</span><br><span class="line">delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proteus仿真错误解决方法：No power supply specified for net 5V in Power Rail Configuration.</title>
      <link href="/post/1204e2b0.html"/>
      <url>/post/1204e2b0.html</url>
      
        <content type="html"><![CDATA[<p><strong>错误原因</strong><br>设置的5V电源没有添加到电网，如下图红圈中的电源。<br><img src="https://img.mahaofei.com/img/202112231033794-no-power-1.png" alt=""><br><strong>解决方法</strong><br>设计—配置供电网—在电源供应中，并将未连接电网的电源增加到网络连接即可。<br><img src="https://img.mahaofei.com/img/202112231033971-no-power-2.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231034901-no-power-3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
            <tag> bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二相四线制步进电机驱动原理与Proteus仿真</title>
      <link href="/post/cacaac0f.html"/>
      <url>/post/cacaac0f.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、L298N">一、L298N</h2><p><img src="https://img.mahaofei.com/img/202112231031103-step-motor-1.png" alt=""><br>单片机无法直接驱动步进电机，需要L298N进行驱动。L298N的最大功耗为20W，驱动部分端子供电范围+5~+30V，控制信号输入电压范围5V/0V，驱动部分峰值电流2A。</p><h2 id="二、两相四线制步进电机">二、两相四线制步进电机</h2><p><strong>1. 技术指标</strong><br>（1）相数：电机内部的线圈组数。<br>（2）拍数：完成一个磁场周期性变化所需要脉冲数或导电状态。两相四线电机可以使用单四拍、双四拍和八拍的方式驱动。<br>（3）步距角：磁场变化一次电机转过的角度，两相四线电机步距角为0.9°/1.8°。<br><strong>2. 工作原理</strong><br><img src="https://img.mahaofei.com/img/202112231032895-step-motor-2.png" alt=""><br>如图所示，电机有四条控制信号A+、A-、B+、B-，通过控制这四条引线上的励磁脉冲，就可以控制步进电机的转动。以四拍驱动方式为例，顺时针转动时</p><table><thead><tr><th>STEP</th><th>A+</th><th>A-</th><th>B+</th><th>B-</th><th></th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td></td></tr><tr><td>2</td><td>0</td><td>1</td><td>0</td><td>0</td><td></td></tr><tr><td>3</td><td>0</td><td>0</td><td>1</td><td>0</td><td></td></tr><tr><td>4</td><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr><tr><td>**ps：**电动机的旋转方向由脉冲顺序决定，转动速度和脉冲频率有关。</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="三、接线方法">三、接线方法</h2><ul><li>控制端：IN1、IN2、IN3、IN4接单片机的四个管脚，用于给出脉冲</li><li>输入端：5V输入接板载5V，12V输入外接电源</li><li>使能端：ENA、ENB接板载5V，默认使能</li><li>输出端：OUT1、OUT2、OUT3、OUT4分别接步进电机的四条线红绿黄蓝。</li></ul><h2 id="三、Proteus仿真">三、Proteus仿真</h2><p>在Proteus中的接线情况如下图所示：<br><img src="https://img.mahaofei.com/img/202112231032155-step-motor-3.png" alt=""><br>参考程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"><span class="type">sbit</span> <span class="variable">enable</span> <span class="operator">=</span> P3^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">114</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">unsigned <span class="type">char</span> step[] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>&#125;;<span class="comment">//顺时针转动</span></span><br><span class="line"><span class="comment">//unsigned char istep[] = &#123;0x01,0x02,0x04,0x08&#125;; //逆时针转动</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">P2 = step[i];</span><br><span class="line">delay(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿真结果：<br><img src="https://img.mahaofei.com/img/202112231033161-step-motor-4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Proteus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP8266_APP连接试验</title>
      <link href="/post/4d218ae.html"/>
      <url>/post/4d218ae.html</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p>本次试验使用的是ESP8266 NodeMCU</p><h1>硬件部分</h1><h2 id="8266固件烧录">8266固件烧录</h2><p>固件烧录的是nodemcu官方固件，打开官方提供的ESP8266Flasher，在配置一栏选择nodemcu固件，烧录地址为0x00000。<br><img src="https://img.mahaofei.com/img/202112231028978-esp8266-app-1.png" alt=""></p><h2 id="Arduino-IDE-8266版型下载">Arduino IDE 8266版型下载</h2><p>打开Arduino IDE，在文件-首选项-附加开发板管理器网址中输入：<br><code>http://arduino.esp8266.com/stable/package_esp8266com_index.json</code><br><img src="https://img.mahaofei.com/img/202112231029730-esp8266-app-2.png" alt=""><br>然后打开工具-开发板-开发板管理器，在搜索框输入esp8266，在下方弹出的搜索结果中选中要下载的版型，点击安装即可。（下载速度较慢，可挂梯子）<br><img src="https://img.mahaofei.com/img/202112231029664-esp8266-app-3.png" alt=""><br>到此为止，硬件部分的准备工作就完成了，接下来就可以使用Arduino IDE进行ESP8266的编程。</p><h2 id="安装MQTT库">安装MQTT库</h2><p>因本程序设计MQTT部分，因此还需要安装MQTT库才能正常编译程序，打开项目-加载库-管理库，有许多mqtt库可以选择，我使用的是PubSubClient。<br><img src="https://img.mahaofei.com/img/202112231029797-esp8266-app-4.png" alt=""></p><h2 id="ESP8266程序设计">ESP8266程序设计</h2><p>代码不长，贴在下方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;<span class="title class_">ESP8266WiFi</span>.<span class="property">h</span>&gt;</span><br><span class="line">#include &lt;<span class="title class_">PubSubClient</span>.<span class="property">h</span>&gt;</span><br><span class="line"><span class="title class_">WiFiClient</span> espClient;</span><br><span class="line"><span class="title class_">PubSubClient</span> <span class="title function_">client</span>(espClient);</span><br><span class="line"><span class="keyword">const</span> char* wifissid = <span class="string">&quot;Wifi_SSID&quot;</span>; <span class="comment">//自己家WIFI</span></span><br><span class="line"><span class="keyword">const</span> char* password = <span class="string">&quot;Wifi_Password&quot;</span>; <span class="comment">//自己家WIFI密码</span></span><br><span class="line"><span class="keyword">const</span> char* mqtt_server = <span class="string">&quot;***,***,***,***&quot;</span>;<span class="comment">//MQTT服务器地址</span></span><br><span class="line"><span class="keyword">const</span> char* mqtt_id = <span class="string">&quot;827855942_ESP&quot;</span>;<span class="comment">//MQTT ID需要唯一，这里我设置成自己的QQ号+_ESP</span></span><br><span class="line"><span class="keyword">const</span> char* <span class="title class_">Mqtt</span>_sub_topic = <span class="string">&quot;827855942_ESP&quot;</span>;   <span class="comment">//ESP8266订阅的topic，其他客户端向此topic发送信息时ESP8266会收到，设成自己的QQ号+_ESP</span></span><br><span class="line"><span class="keyword">const</span> char* <span class="title class_">Mqtt</span>_pub_topic = <span class="string">&quot;827855942&quot;</span>;  <span class="comment">//ESP8266发布消息的topic，上报消息给手机APP的TOPIC，设成自己的QQ号</span></span><br><span class="line">long lastMsg = <span class="number">0</span>; <span class="comment">//定时用的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">pinMode</span>(<span class="number">2</span>, <span class="variable constant_">OUTPUT</span>);     </span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">begin</span>(<span class="number">115200</span>);<span class="comment">//设置波特率</span></span><br><span class="line">  <span class="title function_">setup_wifi</span>();<span class="comment">//初始化wifi</span></span><br><span class="line">  client.<span class="title function_">setServer</span>(mqtt_server, <span class="number">1883</span>);<span class="comment">//设定MQTT服务器与使用的端口，1883是默认的MQTT端口</span></span><br><span class="line">  client.<span class="title function_">setCallback</span>(callback); <span class="comment">//设定回调方式，当ESP8266收到订阅消息时会调用此方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Wifi</span></span><br><span class="line"><span class="comment">//连接成功后可在串口监视器看到ESP8266的IP地址</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setup_wifi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>();</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;Connecting to &quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(wifissid);</span><br><span class="line">  <span class="title class_">WiFi</span>.<span class="title function_">begin</span>(wifissid, password);</span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">WiFi</span>.<span class="title function_">status</span>() != <span class="variable constant_">WL_CONNECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">delay</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;WiFi connected&quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;IP address: &quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="title class_">WiFi</span>.<span class="title function_">localIP</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，参数固定不能改</span></span><br><span class="line"><span class="comment">//payload内容可以是任意的，此程序中传递的是JSON数据</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">callback</span>(<span class="params">char* topic, byte* payload, unsigned int length</span>) &#123;</span><br><span class="line">  <span class="title class_">String</span> msg=<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title class_">String</span> LED_set = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;Message arrived [&quot;</span>);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(topic);</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;] &quot;</span>);</span><br><span class="line">  <span class="comment">//msg中存放的就是传递过来的json数据，此处为&#123;&quot;set_led&quot;:1&#125;格式</span></span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    msg+= (char)payload[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Serial</span>.<span class="title function_">println</span>(msg);</span><br><span class="line">  <span class="keyword">if</span>(msg.<span class="title function_">indexOf</span>(<span class="string">&quot;led&quot;</span>))  <span class="comment">//判断是否是要设置LED灯</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//取出LED_set数据 并执行</span></span><br><span class="line">    LED_set = msg.<span class="title function_">substring</span>(msg.<span class="title function_">indexOf</span>(<span class="string">&quot;led\&quot;:&quot;</span>)+<span class="number">5</span>,msg.<span class="title function_">indexOf</span>(<span class="string">&quot;&#125;&quot;</span>)); </span><br><span class="line">    <span class="title function_">digitalWrite</span>(<span class="number">2</span>,!LED_set.<span class="title function_">toInt</span>()); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断线重连</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!client.<span class="title function_">connected</span>()) &#123;</span><br><span class="line">    <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;Attempting MQTT connection...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (client.<span class="title function_">connect</span>(mqtt_id)) &#123;</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot;connected&quot;</span>);</span><br><span class="line">      <span class="comment">//连接成功以后就开始订阅</span></span><br><span class="line">      client.<span class="title function_">subscribe</span>(<span class="title class_">Mqtt</span>_sub_topic,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">print</span>(<span class="string">&quot;failed, rc=&quot;</span>);</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">print</span>(client.<span class="title function_">state</span>());</span><br><span class="line">      <span class="title class_">Serial</span>.<span class="title function_">println</span>(<span class="string">&quot; try again in 5 seconds&quot;</span>);</span><br><span class="line">      <span class="title function_">delay</span>(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//MQTT是否连接，若未连接则重连</span></span><br><span class="line">  <span class="keyword">if</span> (!client.<span class="title function_">connected</span>()) &#123;</span><br><span class="line">    <span class="title function_">reconnect</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  client.<span class="title function_">loop</span>();</span><br><span class="line">  long now = <span class="title function_">millis</span>();<span class="comment">//运行时间</span></span><br><span class="line">  <span class="keyword">if</span> (now - lastMsg &gt; <span class="number">2000</span>) &#123;</span><br><span class="line">    lastMsg = now;</span><br><span class="line">    <span class="comment">//打包发送数据给pubtopic    </span></span><br><span class="line">    <span class="title class_">String</span> json = <span class="string">&quot;&#123;\&quot;temperature\&quot;:&quot;</span>+<span class="title class_">String</span>(<span class="title function_">analogRead</span>(<span class="variable constant_">A0</span>))+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    client.<span class="title function_">publish</span>(<span class="title class_">Mqtt</span>_pub_topic,json.<span class="title function_">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>APP部分</h1><h2 id="创建项目">创建项目</h2><p>Start a new Android project，我选择Empty Activity，name随意，language java，Android版本要小于等于手机安卓版本。（尽量用真机调试，虚拟机bug太多）<br><img src="https://img.mahaofei.com/img/202112231030854-esp8266-app-5.png" alt=""></p><h2 id="UI设计">UI设计</h2><p>打开app-res-layout下的activity_main.xml文件，设计UI<br>常用的代码列下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android:orientation=<span class="string">&quot;vertical&quot;</span><span class="comment">//设置线性布局方向</span></span><br><span class="line">android:background=<span class="string">&quot;#FFFFFF&quot;</span><span class="comment">//设置背景色</span></span><br><span class="line">android:src=<span class="string">&quot;@drawable/pic&quot;</span><span class="comment">//ImageView下添加图片</span></span><br><span class="line">android:layout_margin=<span class="string">&quot;10dp&quot;</span><span class="comment">//设置距离父空间边缘距离</span></span><br><span class="line">android:id=<span class="string">&quot;@+id/image_1//设置id</span></span><br><span class="line"><span class="string">android:layout_weight=&quot;</span><span class="number">1</span><span class="string">&quot;//布局内设置权重</span></span><br><span class="line"><span class="string">android:gravity=&quot;</span>center_vertical<span class="string">&quot;//布局内设置垂直居中</span></span><br></pre></td></tr></table></figure></p><h2 id="主程序设计">主程序设计</h2><p>打开MainActivity.java编写程序<br>1. OnCreate函数是程序打开后最先运行的地方</p><pre><code>![](https://img.mahaofei.com/img/202112231030143-esp8266-app-6.png)4. 移植Mqtt_init()函数5. 移植startReconnect()函数6. 移植publishmessageplus()函数7. 在OnCreate中加入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mqtt_init();</span><br><span class="line">startReconnect();</span><br><span class="line">handler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br></pre></td></tr></table></figure>注：每完成一小步都要刷入真机调试，以免调bug之痛2. 按钮单击事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button_1 = findViewById(R.id.button_1); <span class="comment">//寻找XML里面真正的ID，与自己初始化的变量绑定</span></span><br><span class="line">button_1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"><span class="comment">//这里是单击之后执行的地方</span></span><br><span class="line"><span class="comment">//在当前ativity 显示内容为hello的短时间弹窗</span></span><br><span class="line">Toast.makeText(MainActivity.<span class="built_in">this</span>,<span class="string">&quot;hello&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>3. 导入JAR包将mqtt的JAR包复制到app下的libs文件夹中右键JAR包Add as Lib确定</code></pre><p>以上就完成了基本的app与ESP8266的通信。<br><img src="https://img.mahaofei.com/img/202112231031740-esp8266-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231031908-esp8266-app-8.png" alt=""><br>感谢正哥，B站up<a href="https://space.bilibili.com/265908761/">阿正啷个哩个啷</a>，大佬的教程</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础_常用函数</title>
      <link href="/post/ee422c9c.html"/>
      <url>/post/ee422c9c.html</url>
      
        <content type="html"><![CDATA[<hr><p>title: 数字化方法基础_常用函数<br>date: 2019-10-29 21:12:14<br>description: 数字化方法基础_常用函数1.叉乘2.单位化矢量3.矩阵乘法4.矩阵乘法。<br>categories:</p><ul><li>程序设计</li><li>OpenGL<br>tags:</li><li>笔记</li><li>数字化方法</li></ul><hr><h2 id="1-叉乘">1. 叉乘</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">crossproject</span><span class="params">(<span class="type">float</span> vec1[<span class="number">3</span>],<span class="type">float</span> vec2[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-单位化矢量">2. 单位化矢量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Normalize</span><span class="params">(<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> length;</span><br><span class="line">length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">n[i] /= length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-矩阵乘法4×4-×-4×1">3. 矩阵乘法4×4  ×  4×1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ApplyMatrix</span><span class="params">(<span class="type">float</span> *P0,<span class="type">float</span> *translation,<span class="type">float</span> *P1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-矩阵乘法-4×4-×-4×4">4. 矩阵乘法 4×4  ×  4×4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">float</span> *rotation,<span class="type">float</span> *translation,<span class="type">float</span> *tran)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础（四）_矩阵操作</title>
      <link href="/post/abc4fa16.html"/>
      <url>/post/abc4fa16.html</url>
      
        <content type="html"><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第四部分</p><h1>Chapter 7 矩阵操作</h1><h2 id="利用矩阵实现向量平移-2">利用矩阵实现向量平移</h2><p>1、基本原理:如图，任意给定一个点的坐标（列向量）x,y,z。设置一个矩阵，利用矩阵的乘法运算即可将三个坐标进行平移<br>注意：过程中所设置的矩阵为单位阵的最后一列加上偏移量Tx，Ty，Tz。如下图，大家自己试一下矩阵乘法即可验证。<br><img src="https://img.mahaofei.com/img/202112231011567-numerical-recipe-38.png" alt=""></p><p>2、在了解了如何将一个列向量进行平移之后，我们就可以编写程序进行向量的平移操作了，我们打开生成螺旋线的程序，注意到螺旋线是由许许多多点组成的，下面这个for循环就是每次生成一个点，我们只需要吧每个点的坐标向量进行平移即可使整个螺旋线平移。<br><img src="https://img.mahaofei.com/img/202112231012895-numerical-recipe-39.png" alt=""><br>3、现在就开始写程序了，首先明确一下程序执行过程</p><p>**1. 获得一个点的坐标存入P0数组内</p><ol start="2"><li>设置一个矩阵Translation用来将坐标平移</li><li>将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标**</li></ol><p>4、第一步，获得一个点的坐标存入P0数组内，这一步十分简单（注：除函数定义外，其余代码均在for循环内）<code>float P0[3] = &#123;x,y,z&#125;;</code><br>5、第二步，设置一个矩阵Translation用来将坐标平移，我们需要一个下面这样的矩阵<br><img src="https://img.mahaofei.com/img/202112231012723-numerical-recipe-40.png" alt=""><br>如何操作呢，首先先初始化一个单位矩阵，然后将单位矩阵的最后一列赋值为需要偏移的量（我的代码十分简单粗暴，当然也可单独另写一个函数用于初始化一个单位矩阵)<br>注意：在OpenGL中，矩阵是按列数的，就是说我定义的I[16]中的前四个元素I[1]、I[2]、I[3]、I[4]实际上是矩阵的第一列，最后的I[12]、I[13]、I[14]、I[15]是矩阵的最后一列，而非上学期C语言中理解的最后一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Translate</span><span class="params">(<span class="type">float</span> fx,<span class="type">float</span> fy,<span class="type">float</span> fz,<span class="type">float</span> Translation[<span class="number">16</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> I[<span class="number">16</span>] = &#123;<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;<span class="comment">//定义一个四阶单位阵</span></span><br><span class="line">I[<span class="number">12</span>] = fx;<span class="comment">//将第四列第一行的元素赋fx</span></span><br><span class="line">I[<span class="number">13</span>] = fy;<span class="comment">//第四列第二行赋fy</span></span><br><span class="line">I[<span class="number">14</span>] = fz;<span class="comment">//第四列第三行赋fz</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)</span><br><span class="line">Translation[i] = I[i];<span class="comment">//将I数组的值循环赋给Translation数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作之后就获得了如上面图片中的数组了。<br>6、第三步，将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标，So我们要做的就是定义一个P1数组<code>float P1[3];</code>这十分简单，然后就是写一个矩阵乘法的运算，用Translation*P0，结果存入P1中。<br>实现代码如下，注意translation为4*4矩阵，P0为3*1矩阵，P1为4*1矩阵，<br>（为什么要四阶矩阵是因为我们需要矩阵运算平移，只有多加一行一列才能实现，而P0和P1我们实际只用前3个元素，）<br>故我们让P0的“第四个”元素默认为1，即下面代码中最后一项为1*translation[i+12]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ApplyMatrix</span><span class="params">(<span class="type">float</span> *P0,<span class="type">float</span> *translation,<span class="type">float</span> *P1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)</span><br><span class="line">P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、有了设置操作矩阵的函数Translate，和矩阵相乘的函数ApplyMatrix，我们就可以平移点了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;<span class="comment">//定义P0存放平移之前的点</span></span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];<span class="comment">//定义P1存放平移之后的点</span></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];<span class="comment">//存放一个4*4的操作矩阵</span></span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">30.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//设置操作矩阵为我们想要的格式（单位阵-&gt;最后一列赋值）</span></span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//操作矩阵和P0点相乘，结果放在P1内</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示平移之后的点</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为螺旋线平移步骤</p><h2 id="使用矩阵实现向量旋转-2">使用矩阵实现向量旋转</h2><p>1、如何进行向量旋转<br>首先了解一下二维坐标的旋转，设一个向量a的坐标是（x,y），长度为r，与x轴正向夹角为α，则：<br>xa = r cos α,<br>ya = r sin α.<br>如果把向量旋转一个角度φ，则新的向量b的坐标是<br>xb = r cos(α + φ) = r cos α cos φ - r sin α sin φ,<br>yb = r sin(α + φ) = r sin α cos φ + r cos α sin φ.<br><img src="https://img.mahaofei.com/img/202112231012454-numerical-recipe-41.png" alt=""><br>又因为xa = r cos α，ya = r sin α.所以容易看出来<br>xb = xa cos φ - ya sin φ,<br>yb = ya cos φ + xa sin φ.<br>而等式右边，又可写成两个矩阵的乘积<br><img src="https://img.mahaofei.com/img/202112231013633-numerical-recipe-42.png" alt=""><br>由此可知，等式中<strong>由sin和cos组成的二阶方阵</strong>，就<strong>可以实现将向量(xa ya,)旋转为(xb,yb,)</strong>，暂且叫做二阶的旋转操作矩阵<br>由此推导至三阶，<strong>三阶的旋转操作矩阵为以下三种</strong>（分别为绕x，y，z轴旋转），大家带入检验一下即可知道，<br><img src="https://img.mahaofei.com/img/202112231013952-numerical-recipe-43.png" alt=""><br>而为了与之前的平移操作统一，因此我们也把这个三阶旋转操作矩阵扩展为四阶的，如下<br><img src="https://img.mahaofei.com/img/202112231013016-numerical-recipe-44.png" alt=""><br>2、如何编写函数实现向量旋转呢<br>由刚才的推导我们知道，用旋转操作矩阵左乘一个列向量即可实现向量的旋转操作<br>现在我们来编写函数，以绕x轴为例，我们先来看一下“主函数”，这是生成螺旋线的那个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个数组（用于存放旋转操作矩阵）</span></span><br><span class="line"><span class="comment">//这里也可生成一个单位阵，那样就不用初始化为0了</span></span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//给定一个角度（-90°），生成旋转操作矩阵</span></span><br><span class="line">ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用旋转操作矩阵左乘P0，得到的结果P1即为旋转完成的向量坐标</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示旋转后的坐标对应的点</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们需要做的就是<strong>写一个函数</strong>，<strong>由参数（角度）生成一个旋转操作矩阵</strong>，这里需要注意的是，math.h头文件中有sin和cos的函数，直接sin（angle）即可调用，其中angle为弧度值，代码如下<br>（注意，函数里用到的PI是在开头宏定义的<code>#define PI 3.14159</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Rotate_x</span><span class="params">(<span class="type">float</span> angle,<span class="type">float</span> *rotation)</span></span><br><span class="line">&#123;</span><br><span class="line">angle = angle/<span class="number">180.0</span>*PI;</span><br><span class="line"><span class="comment">//将角度值转换为弧度值</span></span><br><span class="line">rotation[<span class="number">5</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">rotation[<span class="number">6</span>] = <span class="built_in">sin</span>(angle);</span><br><span class="line">rotation[<span class="number">9</span>] = -<span class="built_in">sin</span>(angle);</span><br><span class="line">rotation[<span class="number">10</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">rotation[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//配置各个位置的数值，注意矩阵下标是竖着数的，第一行位置为0、4、8、12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们得到了旋转操作矩阵，经“主函数”调用即可实现向量的旋转</p><h2 id="如何让图形既平移又旋转-2">如何让图形既平移又旋转</h2><p>一个很简单的思路就是<strong>先后调用平移和旋转操作的函数</strong>，像下面这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> P2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//进行平移操作，P0平移后为P1</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line">ApplyMatrix(P1,Rotation,P2);</span><br><span class="line"><span class="comment">//进行旋转操作，P1旋转后为P2</span></span><br><span class="line"></span><br><span class="line">glVertex3f(P2[<span class="number">0</span>], P2[<span class="number">1</span>], P2[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//最后输出P2的点即可</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这显然不是我们想要的，我们想一步就完成平移操作，不需要中间P1的出现，那么就需要<strong>将平移操作矩阵和旋转操作矩阵相乘，得到的仍为一个四阶矩阵，再拿这个新的四阶矩阵左乘列向量xy，即可将列向量既平移又旋转</strong>。<br><strong>如何理解？</strong><br>我们知道平移操作矩阵和旋转操作矩阵都是可逆矩阵（det Rx ≠ 0，det T ≠ 0）<br><img src="https://img.mahaofei.com/img/202112231014359-numerical-recipe-45.png" alt=""><br>那么这两个矩阵都可以写成许多个初等矩阵的乘积，即<br>Rx = R1*R2*R3*……Rn * I<br>T = R1’*R2’*R3’……Rn’ * I<br>（其中R1，R1’……Rn，Rn’都为初等矩阵，初等矩阵还记得吧，刚学过的线代，只进行一次初等变换的矩阵；初等矩阵左乘一个矩阵即对他行变换）<br>那么我们知道平移操作为<br><img src="https://img.mahaofei.com/img/202112231014908-numerical-recipe-46.png" alt=""><br>同理旋转操作也可以写成<br><img src="https://img.mahaofei.com/img/202112231015626-numerical-recipe-47.png" alt=""><br>那么先平移，然后把平移得到的矩阵旋转就可以写成如下的形式<br><img src="https://img.mahaofei.com/img/202112231015778-numerical-recipe-48.png" alt=""><br>又因为Rx = R1<em>R2</em>R3*……Rn，T = R1’<em>R2’<em>R3’……Rn’<br>所以 Rx</em>T</em>列向量 就代表把列向量平移又旋转<br>那么我们现在要做的就是写一个四阶矩阵的乘法函数，以获取Rx*T的结果，拿这结果左乘列向量即一步实现平移旋转。<br>四阶矩阵的乘法代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">float</span> *rotation,<span class="type">float</span> *translation,<span class="type">float</span> *tran)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个是用16个元素的变量代表一个矩阵，下标表示比较麻烦，大家可以在纸上写一下<br>代码写法不唯一，也可以把它拆成四个循环单独写，当然也可以直接把每个元素赋值，赋值16次就完了<br>然后按照刚才的逻辑在“主函数”里调用一下就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//获得平移操作矩阵</span></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//获得旋转操作矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> multi[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">mul(Rotation,Translation,multi);</span><br><span class="line"><span class="comment">//两矩阵相乘获得平移+旋转操作矩阵</span></span><br><span class="line">ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用平移+旋转操作矩阵左乘P0即可得到被平移且旋转之后的矩阵P1</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即利用矩阵实现向量的平移与旋转操作</p><h2 id="坐标系的旋转-2">坐标系的旋转</h2><p><strong>1、目标</strong>：<br>给定一个向量（如(1,1,1)），将原坐标系旋转为以此向量为Z轴的坐标系。<br><strong>2、基本概念</strong>：<br>如图，左面的三阶方阵内每一列为新坐标轴的三个单位向量，用这个<strong>三阶方阵左乘一个原坐标系的点</strong>，即可<strong>将这个点坐标旋转为新坐标系的对应坐标</strong><br>由此，我们只需要生成一个左面的旋转坐标系的矩阵即可。<br><img src="https://img.mahaofei.com/img/202112231015231-numerical-recipe-49.png" alt=""><br><strong>3、如何生成Ruvw矩阵</strong><br>法一：<br>（1）先单位化已知矢量z<br>（2）然后把已知矢量z中的其中一个坐标变为1，这样就获得了两个在同一平面的向量<br>（3）然后用这两个向量叉乘，得到的结果就是和已知矢量z垂直的矢量y<br>（4）然后再用已知矢量z叉乘刚获得的向量y，得到与这两个向量都垂直的向量x。<br>（5）如此，将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br><img src="https://img.mahaofei.com/img/202112231016083-numerical-recipe-50.png" alt=""><br>法二：知道给定矢量的三个坐标(Zx,Zy,Zz),则和这个矢量垂直的向量之一的坐标是(Zy,-Zx,0)，这样同样可以获得两个相互垂直的矢量，然后这俩矢量叉乘得到第三个矢量，即为三坐标轴。将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br>（注：代表新坐标轴的三个矢量均需要单位化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此为法二的代码，其中Rotation+4等地方用到了指针的技巧</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RotateCoor</span><span class="params">(<span class="type">float</span> *z,<span class="type">float</span> *Rotation)</span></span><br><span class="line">&#123;</span><br><span class="line">Rotation[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">Rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">Normalize(z);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">Rotation[<span class="number">8</span>+i] = z[i];</span><br><span class="line">Rotation[<span class="number">4</span>] = -z[<span class="number">1</span>];</span><br><span class="line">Rotation[<span class="number">5</span>] = z[<span class="number">0</span>];</span><br><span class="line">Normalize(Rotation+<span class="number">4</span>);</span><br><span class="line">crossproject(z,Rotation+<span class="number">4</span>,Rotation);</span><br><span class="line">Normalize(Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231016916-numerical-recipe-51.png" alt=""><br>上图矩阵即为坐标系旋转操作矩阵，<strong>和之前平移与旋转一样</strong>，用<strong>这个矩阵×P0点</strong>，即可得到<strong>坐标轴旋转后的点P1</strong></p><h2 id="让图形显示在屏幕中心且绕中心转动-2">让图形显示在屏幕中心且绕中心转动</h2><p>1.首先我们要知道，OpenGL生成的对话框的长和宽是可以设置的，我们需要让对话框的宽高比与我们要生成的图像的宽高比相同，并且对话框要比图像稍大一些。<br>2、具体如下思路：<br>设模型的高为ModelHeight，宽为ModelWidth，生成的空间高为h，宽为w<br><strong>如果ModelHeight/h &gt; ModelWidth/w，说明对话框比较高（模型比较宽），因此要尽可能满足模型的宽</strong>，比如让<strong>对话框的宽为模型宽的2.5倍</strong>（让对话框稍大一些），则<strong>对话框的高就为 对话框的高/模型的高 * 模型的宽</strong>。<br>同理对话框比较扁也可以得到对称的结论，因此，用计算得到的对话框的宽和高就可生成一个合适的对话框。<br>3、如何编程更改对话框大小：<br>打开之前加载泵体的那个文件(chapt05\shinyjet)更改ChangeSize函数为以下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ChangeSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span><br><span class="line">    &#123;</span><br><span class="line">    GLfloat fAspect;</span><br><span class="line">    GLfloat lightPos[] = &#123; <span class="number">-50.f</span>, <span class="number">50.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a divide by zero</span></span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span>)</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Viewport to window dimensions</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset coordinate system</span></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fAspect = (GLfloat) w / (GLfloat) h;</span><br><span class="line"><span class="comment">// Establish clipping volume (left, right, bottom, top, near, far)</span></span><br><span class="line"><span class="comment">//aspectRatio = (GLfloat)w / (GLfloat)h;</span></span><br><span class="line"><span class="comment">//这之上都不用动</span></span><br><span class="line"><span class="type">float</span> scale = <span class="number">2.5</span>;</span><br><span class="line"><span class="comment">//对话框与模型大小比例为2.5倍</span></span><br><span class="line"><span class="type">float</span> ScaleHeight,ScaleWidth,ModelWidth,ModelHeight;</span><br><span class="line"><span class="comment">//定义对话框的宽高，模型的宽高</span></span><br><span class="line">ModelWidth = PointMax[<span class="number">0</span>]-PointMin[<span class="number">0</span>];</span><br><span class="line">ModelHeight = PointMax[<span class="number">1</span>]-PointMin[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//模型宽的计算可由模型上最右的点坐标减最左点的坐标</span></span><br><span class="line"><span class="keyword">if</span>(w*ModelHeight &gt; h*ModelWidth)</span><br><span class="line">&#123;<span class="comment">//当ModelHeight/h &gt; ModelWidth/w时，模型比较宽，对话框比较高</span></span><br><span class="line">ScaleHeight = scale * ModelHeight;</span><br><span class="line"><span class="comment">//设置对话框的宽为模型宽的2.5倍</span></span><br><span class="line">ScaleWidth =  scale * ModelHeight * w / h;</span><br><span class="line"><span class="comment">//对话框的高为 对话框的高/模型的高 * 模型的宽</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ScaleWidth =  scale * ModelWidth;</span><br><span class="line">ScaleHeight = scale * ModelWidth * h / w;</span><br><span class="line">&#125;</span><br><span class="line">glOrtho(<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">-2.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//定出模型的中心坐标，下面代码就根据中心坐标生成一个与模型中心位置相同的对话框</span></span><br><span class="line"><span class="comment">//这之下都不用动</span></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    </span><br><span class="line">    glLightfv(GL_LIGHT0,GL_POSITION,lightPos);</span><br><span class="line">    <span class="comment">//glTranslatef(0.0f, 0.0f, -150.0f);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、如何编程找出模型上对角线的两个点<br>将之前写过的读取文件里点的坐标的那个while循环中添加一部分内容，改成如下形式，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//以下为新加内容，作用为找到对角线上的两个点，存到PointMin和PointMax里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMin[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMax[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上为新加内容</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>,n);</span><br><span class="line">glEnd();</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line">（注意，因为PointMin和PointMax既在SetupRC函数里使用又在Changesize函数里使用，故需要定义为全局变量，如下<span class="type">float</span> PointMin[<span class="number">3</span>] = &#123;<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f&#125;;<span class="type">float</span> PointMax[<span class="number">3</span>] = &#123;<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f&#125;;）</span><br></pre></td></tr></table></figure><p>5、现在看起来可以了，我们把对话框设置成了和模型等比例，对称中心重合，但还需要更改一个地方就是，我们生成的<strong>模型中心和我们旋转轴的中心不是重合的</strong>，我们如何实现按下键盘时，让模型绕原点转动，而不是绕其他轴运动。<br>具体思路就是，我们<strong>要让模型绕自己中心旋转，可以先把模型平移到坐标轴原点处（原点与模型中心重合），进行旋转，然后在平移回原来位置，这样看上去就是模型绕自己中心旋转了</strong>，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">glPushMatrix();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glCallList(DrawList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the matrix state</span></span><br><span class="line">glPopMatrix();</span><br><span class="line"><span class="comment">// Display the results</span></span><br><span class="line">glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改这三个地方就实现了让模型能够正常的显示在屏幕中心且绕模型自己的中心转动</p><h1>Chapter 8 造小车</h1><h2 id="装配一个小车-2">装配一个小车</h2><p>组装小车开始了<br>在学习本节内容之前，<strong>请先掌握装载泵体模型的相关操作</strong><br>1.原理部分：我们知道了如何将一个模型文件装载进来同时显示出来，主要步骤是<strong>先新建一个列表DrawList</strong>，然后<strong>将模型存入此列表中</strong>，最后在<strong>通过glCallList()函数召唤列表即可生成一个模型</strong>。现在我们要做的就是同时生成许多个模型，那么<strong>如何同时生成许多模型呢，只要新建许多列表，然后把它们一个一个召唤出来（glCallList）就可以了</strong>。<br>2.既然我们需要新建好多个列表，那么我们最好定义一个函数用于生成列表，不然一大段代码赋值五六遍可不是一般的长。把之前在SetupRC函数里的新建列表的代码移出来，稍加修改封装成一个函数。新建列表的代码如下说明一下，函数第一个参数是文件名，也就是”&quot;F:\Works\Practice\数字化方法\Shove\Shovel.STL&quot;像这样的字符串，后面三个参数是RGB颜色，用于设置生成的模型的颜色，毕竟你也不想让整个小车变成一个颜色吧。最后一个参数是定义的列表变量的地址，或者说列表变量的指针<br>（注：为什么要用指针呢，我jo得这个可以参考上学期C++课上的内容，函数的形参只在函数体内有效，比如在主函数里定义了一个变量，把它传给一个函数并在函数内部改变它的值，主函数内的变量的值不会发生改变，因此只有把地址传过去才可以正常新建列表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatGLList</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> R,<span class="type">int</span> G,<span class="type">int</span> B,GLuint *listname)</span></span><br><span class="line">&#123;</span><br><span class="line">ifstream <span class="title function_">in</span><span class="params">(filename)</span>;</span><br><span class="line"><span class="comment">//要读取的文件是filename，例如如果参数是</span></span><br><span class="line"><span class="comment">//&quot;F:\\Works\\Practice\\数字化方法\\Shove\\Shovel.STL&quot;，</span></span><br><span class="line"><span class="comment">//那么会读取F:\\Works\\Practice\\数字化方法\\Shove这个目录下的Shove1.STL文件。</span></span><br><span class="line"><span class="keyword">if</span> (!in)</span><br><span class="line">_ASSERT(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> String0[<span class="number">30</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line"></span><br><span class="line">*listname = glGenLists(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//参数listname是一个指针，*listname才是列表变量</span></span><br><span class="line"><span class="type">float</span> Points[<span class="number">12</span>];</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">glNewList(*listname,GL_COMPILE);</span><br><span class="line">glPolygonMode(GL_BACK,GL_LINE);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMin[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMax[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glColor3ub(R,G,B);</span><br><span class="line"><span class="comment">//根据函数的参数设置模型颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line">glEnd();</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glEndList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们有了新建列表的函数之后，然后就可以加载文件了……吗？注意，<strong>在使用函数之前先在文件开头定义几个列表变量（GLuint类型变量）</strong>，这个几个变量是用来存放各个模型的，没有这些变量就调用函数，软件会在参数上划红线，也就是它不知道把模型读取进来之后存到哪里去。<br><img src="https://img.mahaofei.com/img/202112231016256-numerical-recipe-52.png" alt=""><br>做好了这两个准备工作之后就可以开始新建模型列表and召唤模型列表了。在SetupRC函数原来加载文件的那个地方就可以用一句简单的CreatGLList(“F:\Works\Practice\数字化方法\Shove\Shovel.STL”,255,255,0,&amp;Shove);代替了。<strong>新建六个模型列表就用六次这个函数就可以了</strong>，比直接复制一大段读取模型的文件简化了不少。就像下面这样<br><img src="https://img.mahaofei.com/img/202112231017247-numerical-recipe-53.png" alt=""><br>建好了这六个模型列表，那我们就可以直接召唤它们了，在RenderScene函数里直接调用六个glCallList就可以把这六个模型召唤出来了<br><img src="https://img.mahaofei.com/img/202112231017471-numerical-recipe-54.png" alt=""><br>这么召唤神龙，sorry召唤模型，出来就直接是装配好的小车的样子，（虽然我也不知是为什么<br>这一节到此为止。</p><h2 id="让小车动起来-2">让小车动起来</h2><p>本节的目的是让小车动起来！难度稍大，各位仔细听我娓娓道来<br>1、理论部分，我们想让这个模型通过按键盘上不同的按键让他动起来，肯定要有<strong>函数用来读取按键</strong>，<strong>读取之后利用平移旋转之类的矩阵各个部分运动起来</strong>。<br>2、键盘部分：在写函数之前先在文件开头定义一些全局变量（各部分的转动角度），用于以后的旋转矩阵。<br><img src="https://img.mahaofei.com/img/202112231018223-numerical-recipe-55.png" alt=""><br>然后我们先写一下读取按键的函数。请大家先在最下方main函数里添加如下的一行代码，这个是库函数，用于读取按键的。<br><img src="https://img.mahaofei.com/img/202112231018145-numerical-recipe-56.png" alt=""><br>然后在前面我们定义一个函数名叫keyboard，函数内容如下，函数体是有重复的代码组成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">keyboard</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key,<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> ShoveStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//定义一个静态变量（下一次进入函数，变量内容保持不变）</span></span><br><span class="line"><span class="comment">//步长为3.0f，即设定按一下按键角度变化3度</span></span><br><span class="line"><span class="keyword">if</span>(ShoveRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">ShoveRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ShoveRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">ShoveRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//这里作用是防止模型出现失真（比如铲子转着转着转到驾驶舱里去了）</span></span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:ShoveRot+=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:ShoveRot-=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是“某一按键”，是的话相应部分的转动角度增加（减少）一个步长。</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MainLinkStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(MainLinkRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">MainLinkRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MainLinkRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">MainLinkRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:MainLinkRot+=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:MainLinkRot-=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MainBodyStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(MainBodyRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">MainBodyRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MainBodyRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">MainBodyRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:MainBodyRot+=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:MainBodyRot-=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> GroundStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(GroundRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">GroundRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(GroundRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">GroundRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:GroundRot+=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:GroundRot-=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> FrontWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(FrontWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">FrontWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(FrontWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">FrontWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:FrontWheelsRot+=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:FrontWheelsRot-=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> BackWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(BackWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">BackWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(BackWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">BackWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:BackWheelsRot+=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:BackWheelsRot-=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就成功的读取到了按键并能够根据按键的不同，相应的角度变量发生改变（函数中的按键可以自己设置，根据个人喜好）<br>3、矩阵操作部分<br>首先来了解一下几个函数的用法<br><strong>glLoadIdentity();生成一个单位阵并设置为当前阵<br>glPushMatrix();保存当前的矩阵到一个不知名的地方<br>glPopMatrix();设置之前保存的矩阵为当前阵<br>glMultMatrixf(A);用A矩阵乘当前阵，结果设置为当前阵<br>glRotatef(角度值,0.0f,1.0f,0.0f);后面三个参数若第一个为1，则绕x轴旋转，第二个为1则绕y轴旋转，第三个为1则绕z轴旋转。</strong><br>还有一个平移的库函数我没记住；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">glPushMatrix();</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glPushMatrix();</span><br><span class="line">glCallList(MainBody);</span><br><span class="line"></span><br><span class="line">glPopMatrix();</span><br><span class="line">glPushMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-4.89</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">4.89</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(BackWheels);</span><br><span class="line"></span><br><span class="line">glLoadIdentity();</span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glPushMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-6.63</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">6.63</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(FrontWheels);</span><br><span class="line"></span><br><span class="line">    glPopMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="type">float</span>(<span class="number">-10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glRotatef(GroundRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="type">float</span>(<span class="number">10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(Ground);</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">21.74</span>/<span class="number">1000</span>),<span class="type">float</span>(<span class="number">4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(MainLinkRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-21.74</span>/<span class="number">1000</span>),<span class="type">float</span>(<span class="number">-4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(MainLink);</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">31.74</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-31.74</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(Shove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the matrix state</span></span><br><span class="line">glPopMatrix();</span><br><span class="line"><span class="comment">// Display the results</span></span><br><span class="line">glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码都可在博客开头的网盘里自行提取<br><img src="https://img.mahaofei.com/img/202112231018833-numerical-recipe-57.png" alt=""><br>（2）主体和两个轮子要和（1）分开，因为他们的位移没有叠加关系，具体可用glPushMatrix();和glPopMatrix();实现<br>这部分程序我自己理解的并不是很透彻，如有问题or不懂的请单独找我。</p><p><em><strong>Continue……</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础（三）_导入本地模型</title>
      <link href="/post/734f35e1.html"/>
      <url>/post/734f35e1.html</url>
      
        <content type="html"><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第三部分</p><h1>Chapter 6  导入本地模型</h1><p>图形的生成需要消耗一定的时间，简单的模型可能没有什么感觉，但是在模型十分复杂时，模型的生成就需要相当长的时间，这是我们不能忍受的。因此，将模型保存为本地文件，使用时直接加载进来，这就变得十分必要了，本节主要讲如何将创建一个列表以及如何加载一个列表。</p><h2 id="如何创建一个列表-2">如何创建一个列表</h2><p>列表的基本原理就是将之前写的<strong>从glPolygonMode、glBegin开始，到glEnd</strong>将这些代码<strong>用一行glCallList(DrawList)代替</strong>，其中DrawList内存放的就是之前生成四面体的代码了。glCallList就相当于把原来的四面体代码加载进来。<br>那如何将原来的四面体代码创建为一个列表供glCallList读取呢，过程十分简单，只需要按以下步骤即可：<br>1、在整个文件开头部分<strong>定义一个GLuint类型的全局变量</strong>（因为这个变量要在不同的函数使用，故须定义为全局变量）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLuint DrawList;</span><br></pre></td></tr></table></figure><p>2、将RenderScene函数（就是之前写glbegin和glEnd的地方）中的<strong>有关三角形的代码全部用glCallList函数代替</strong></p><p><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223100655803.png" alt="image-20211223100655803"><br>3、在SetupRC函数中的最后<strong>新建列表</strong>，<strong>框架</strong>如下<br><img src="https://img.mahaofei.com/img/202112231007333-numerical-recipe-27.png" alt=""><br>4、框架写好之后在图中注释位置<strong>插入画四面体的代码</strong>，插入后结果如下图<br><img src="https://img.mahaofei.com/img/202112231007814-numerical-28.png" alt=""><br>5、至此一个存有四面体列表就新建好了，点击调试运行即可看到和以前一样的四面体。<br><img src="https://img.mahaofei.com/img/202112231007227-numerical-recipe-29.png" alt=""></p><h2 id="如何读取本地模型-2">如何读取本地模型</h2><p>当我们需要读取本地文件中的模型时，如何操作呢<br>1、既然要读取文件中的模型，首先肯定要打开文件，在创建列表的代码之前插入如下三行代码<br><img src="https://img.mahaofei.com/img/202112231008514-numerical-recipe-30.png" alt=""><br>（注意，if stream的括号内为文件的路径，其中的\都要写成\，因为在C语言字符串中，\表示转义，\\才表示一个\）<br>（注意，ifstream若要使用需要先在开头插入以下两行引入头文件同时设置环境)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>2、在定义几个数组用来存放一会要读取的数据<br><img src="https://img.mahaofei.com/img/202112231008162-numerical-recipe-31.png" alt=""><br>3、然后，将之前画四面体的代码，更改为读取文件的代码，更换后的框架如下，其中in每次读取一串字符（到空格或换行停止)，<strong>in &gt;&gt; String0指的是将读取到的字符存入String0中</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DrawList = <span class="built_in">glGenLists</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glNewList</span>(DrawList,GL_COMPILE);</span><br><span class="line"><span class="built_in">glPolygonMode</span>(GL_BACK,GL_LINE);</span><br><span class="line"><span class="comment">//在↓插入代码</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0;<span class="comment">//这就表示将两个字符串先后存入到String0中</span></span><br><span class="line"><span class="comment">//因为如下图在读取到有用数据之前有两个没用的单词，需要读取两次</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;end&quot;</span>))<span class="comment">//读到的字符串为end则退出循环</span></span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//因为刚才已经读掉了前两个没用的字符串，因此直接读取三个坐标到Points里</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//如下图读完第一组坐标后会遇到 vertex这个单词，需要读到垃圾桶（String0）里再读坐标</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="built_in">glColor3ub</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">DrawTriangle</span>(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//这三行时画一个三角形，根据刚才读到的三个点</span></span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在↑插入代码</span></span><br><span class="line"><span class="built_in">glEndList</span>();</span><br></pre></td></tr></table></figure><p>（因为用到了strcmp函数，需要引入头文件#include&lt;string.h&gt;）<br><img src="https://img.mahaofei.com/img/202112231009244-numerical-recipe-32.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231009411-numerical-recipe-33.png" alt=""><br>注意一下，计算机里的图像<strong>无论是平面还是曲面，都是由无数个三角形组成的</strong>，只不过三角形数量无比多时，我们看起来它就是一个曲面，Part1.TXT文件中也是，每读取到三个点就画一个三角形，许许多多个三角形就会组成一个立体图形。<br>4、至此，如何从文件中导入立体模型就完成了，点击调试，即可看到一个正方体<br>6、那么对于给定的STL文件如何读取？首先右击Part2.STL，用记事本打开，看到文件内容如下<br><img src="https://img.mahaofei.com/img/202112231010481-numerical-recipe-34.png" alt=""><br>这看起来和之前差不多，只是他多给了一个法向量，没用的字符串多了一些而已，你可以不用他给的法向量，只读取三个坐标然后自己计算法向量，也可以读取法向量，这个时候 DrawTriangle函数就不需要计算法向量了，直接四行代码就ok，和之前一样，每一次in &gt;&gt; String0操作就读掉一个没用的字符串，自己编写代码就可实现将STL文件中的所有点全部读取出来<br>需要注意的是，<strong>每次循环结束</strong>的时候都要保证<strong>String内存放</strong>的是<strong>facet或者最后的endsolid</strong>这个单词，以保证循环可以正常退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//float n[3];</span></span><br><span class="line"><span class="comment">//project(a,b,c,n);</span></span><br><span class="line"><span class="built_in">glNormal3fv</span>(n);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(a);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(b);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS.如果程序出现错误，如何进行调试呢，首先在while循环里第一句前面设置断点，如下图<br><img src="https://img.mahaofei.com/img/202112231010555-numerical-recipe-35.png" alt=""><br>然后点击单步执行第二个按钮<br><img src="https://img.mahaofei.com/img/202112231010062-numerical-recipe-36.png" alt=""><br>每次循环读9个点,查看你读取到的点的值是否与文件中的坐标值一一对应，其中012对应第一行3个点，345对应第二行三个点，678对应第三行。<br><img src="https://img.mahaofei.com/img/202112231011562-numerical-recipe-37.png" alt=""></p><p><strong>Continue</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础（二）_点的投影</title>
      <link href="/post/838e5745.html"/>
      <url>/post/838e5745.html</url>
      
        <content type="html"><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第二部分</p><h1>Chapter4  用OpenGL生成点的投影</h1><h2 id="计算点的投影的基本原理-2">计算点的投影的基本原理</h2><p><img src="https://img.mahaofei.com/img/202112231003891-numerical-recipe-16.png" alt=""></p><h2 id="如何编写程序实现点的投影-2">如何编写程序实现点的投影</h2><p>1、我们要实现点的投影就要知道投影点的坐标，由上一节可知，需要计算<strong>P0P1矢量</strong>（这个直接调用上一讲求向量的函数），<strong>en向量</strong>（需要写一个单位化函数），<strong>向量点乘</strong>的函数<br>2、单位化，即将向量各个坐标除以它的模，函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Normalize</span><span class="params">(<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> length;</span><br><span class="line">length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//求向量的模</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">n[i] /= length;</span><br><span class="line"><span class="comment">//函数执行过后n[3]即变成单位法向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、进行向量点乘计算，并求N点坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProjectPointtoPoint</span><span class="params">(<span class="type">float</span> point[<span class="number">3</span>],<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>], <span class="type">float</span> ProjectPoint[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> vector_a_p[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> distance;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">vector_a_p[i] = point[i] - a[i];</span><br><span class="line"><span class="comment">//求面内一点与面外一点的向量,即P0P1</span></span><br><span class="line">distance = vector_a_p[<span class="number">0</span>]*n[<span class="number">0</span>]+vector_a_p[<span class="number">1</span>]*n[<span class="number">1</span>]+vector_a_p[<span class="number">2</span>]*n[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//做点乘运算求点到平面距离，即图中|P0N|</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">ProjectPoint[j] = point[j] - n[j]*distance;</span><br><span class="line"><span class="comment">//N点坐标=P0坐标 - en * |P0N|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、经过上述步骤之后就获得投影点坐标，然后就可调用库函数显示投影点，以下为显示一个点的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawPoint</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> point[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//求abc平面法向量</span></span><br><span class="line">Normalize(n);</span><br><span class="line"><span class="comment">//单位化法向量</span></span><br><span class="line"><span class="type">float</span> ProjectPoint[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//定义一个数组用来存放投影点坐标</span></span><br><span class="line">ProjectPointtoPoint(point,a,n,ProjectPoint);</span><br><span class="line"><span class="comment">//获得投影点坐标</span></span><br><span class="line">glVertex3fv(ProjectPoint);</span><br><span class="line"><span class="comment">//显示投影点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、同三角形，在RenderSenen()函数中的画三角形的glEnd()后面 <strong>再次写入glBegin()与glEnd()函数，并在二者之间插入显示点的代码</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> point[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;;</span><br><span class="line"><span class="comment">//定义要投影的点</span></span><br><span class="line">glColor3ub(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//显示的点的颜色</span></span><br><span class="line">glPointSize(<span class="number">6.0f</span>);</span><br><span class="line"><span class="comment">//显示的点的大小</span></span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line"><span class="comment">//开始生成点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line"><span class="comment">//根据第一个面3个点，画第一个投影点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>,point);</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure><p>6、调试成功，显示如图<br><img src="https://img.mahaofei.com/img/202112231003356-numerical-recipe-17.png" alt=""></p><h1>Chapter5  如何使用VS2010的调试功能</h1><p>假如我写完程序调试后发现点没有显示，那么可以一步步调试，找出错误的地方。<br>1、设置断点，在觉得可能出问题的代码处设置断点<br><img src="https://img.mahaofei.com/img/202112231004361-numerical-recipe-18.png" alt=""><br>2、点击调试，下图红框内左面按键为单步执行，点一下执行一句话，如果遇到函数就进入函数内部执行函数体的第一句；右面的按键，点一下执行一句，在遇到函数是直接将整个函数执行完，即将函数也当成一句话。<br><img src="https://img.mahaofei.com/img/202112231004424-numerical-recipe-19.png" alt=""><br>3、这里选择左面按键进入函数内部查看,黄色箭头表示当前执行到哪一句<br><img src="https://img.mahaofei.com/img/202112231004146-numerical-recipe-20.png" alt=""><br>4、按第二个按键将这个函数执行完（但不要退出这个函数，否则函数内部的变量内存会被释放，无法查看变量的值）<br><img src="https://img.mahaofei.com/img/202112231005406-numerical-recipe-21.png" alt=""><br>5、此时可以看到下面的监视窗口可以看到变量，单击+即可看到变量的值，图中展开的为第一个面的法向量和投影点坐标<br><img src="https://img.mahaofei.com/img/202112231005488-numerical-recipe-22.png" alt=""><br>第二个面的法向量和投影点坐标<br><img src="https://img.mahaofei.com/img/202112231005139-numerical-recipe-23.png" alt=""><br>第三个面<br><img src="https://img.mahaofei.com/img/202112231006139-numerical-recipe-24.png" alt=""><br>第四个<br><img src="https://img.mahaofei.com/img/202112231006058-numerical-recipe-25.png" alt=""></p><p><strong>Continue</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础（一）_基础操作与生成四面体</title>
      <link href="/post/f6312cba.html"/>
      <url>/post/f6312cba.html</url>
      
        <content type="html"><![CDATA[<p>全部教程链接：<br><a href="https://blog.csdn.net/weixin_44543463/article/details/102650117#_490">https://blog.csdn.net/weixin_44543463/article/details/102650117#_490</a><br>此为其中的第一部分</p><h1>Chapter1  VisualStudio2010 Express如何创建新工程</h1><p>1、新建一个win32 Console Application工程，选择建立一个空项目（带预编译头的也可以，只不过大多数人不太习惯）</p><p><img src="https://img.mahaofei.com/img/202112230957699-numerical-recipe-2.png" alt=""><br>2、在左侧解决方案资源管理器中右击Source-add-New item，创建一个C++文件</p><p><img src="https://img.mahaofei.com/img/202112230958908-numerical-recipe-3.png" alt=""><br>3、这样就用VS2010创建好了一个简单的工程！</p><h1>Chapter2 SB-WinSRC的使用方法</h1><p>1、解压压缩包，得到一个SB-WinSRC文件夹<br>2、打开SB-WinSrc\examples\projects\microsoft\chapt05\shinyjet文件夹中的shinyjet.vcproj文件，如出现以下对话框则一直Next到最后<br><img src="https://img.mahaofei.com/img/202112230958911-numerical-recipe-4.png" alt=""><br>3、打开shinyjet.cpp并进行编译（Build solution生成解决方案）<br><img src="https://img.mahaofei.com/img/202112230958652-numerical-recipe-5.png" alt=""><br>4、出现图示错误<br><img src="https://img.mahaofei.com/img/202112230959276-numerical-recipe-6.png" alt=""><br>5、打开目录\SB-WinSrc\examples\src\shared，找到freeglut_static.lib文件，将它复制到之前打开的shinyjet文件夹内<br><img src="https://img.mahaofei.com/img/202112230959001-numerical-recipe-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231000243-numerical-recipe-8.png" alt=""><br>6、再次进行编译（Build solution生成解决方案），出现下图错误<br><img src="https://img.mahaofei.com/img/202112231000076-numerical-recipe-9.png" alt=""><br>7、在左侧Solution Explorer（解决方案资源管理器）中右击shinyjet打开属性，将Linker-Input-忽略特定默认库一栏中输入LIBC.lib<br><img src="https://img.mahaofei.com/img/202112231000584-numerical-recipe-10.png" alt=""><br>8、再次编译，成功！</p><h1>Chapter3  用OpenGL生成四面体</h1><h2 id="已知3点求法向量-2">已知3点求法向量</h2><p>1、具体思路为先根据已知3点做差求出两个向量，利用两个向量叉乘运算求出法向量，实现过程中尽量避免将所有代码集中到一个函数中，因为后续的操作（如投影点的计算）还需用到求法向量的函数，到时可直接调用。<br>2、已知2点求向量的函数十分简单，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getvector</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> vec[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">vec[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、调用两次上述函数即可获得两个向量，接下来要做的就是拿这两个向量进行叉乘，以得到法向量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crossproject</span><span class="params">(<span class="type">float</span> vec1[<span class="number">3</span>],<span class="type">float</span> vec2[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、将上面两个函数简单封装一下如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">project</span><span class="params">(<span class="type">float</span> point1[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> vec1[<span class="number">3</span>],vec2[<span class="number">3</span>];</span><br><span class="line">getvector(a,b,vec1);</span><br><span class="line">getvector(b,c,vec2);</span><br><span class="line">crossproject(vec1,vec2,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、这样一个求法向量的函数就写好了，使用方法如下例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[<span class="number">3</span>] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> b[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> c[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//调用过project()函数之后，n[3]数组内的值即为法向量</span></span><br></pre></td></tr></table></figure><h2 id="生成四面体-2">生成四面体</h2><p>1、使用OpenGL生成四面体的基本方法为，<strong>给定三个点和一个法向量</strong>，调用OpenDL的库函数，即可<strong>生成一个由这三点围成的三角形平面</strong>，<strong>四个三角形平面即可组成一个四面体</strong>。<br>2、将课上的shinyjet.cpp模板复制到src相应的文件夹中（\SB-WinSrc\examples\src\chapt05\shinyjet），然后回到project对应文件夹中，打开shinyjet.vcxproj工程，点击调试，成功后出来的应该为一个蓝绿色底的对话框。<br><img src="https://img.mahaofei.com/img/202112231001853-numerical-recipe-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231001700-numerical-recipe-12.png" alt=""></p><p>3、在RenderSenen()函数中的下图位置 <strong>写入glBegin()与glEnd()函数，并在二者之间插入画三角形的代码</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231002123-numerical-recipe-13.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> rgfPoints4[<span class="number">12</span>] = &#123;<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,</span><br><span class="line"><span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line"><span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line"><span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">//这是定义了一个长为12的数组，每3个元素代表一个点坐标，共4个点</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置要生成图形的颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"><span class="comment">//开始生成三角形</span></span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>);</span><br><span class="line">DrawTriangle(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//↑函数功能：给定3个点生成一个三角形，调用4次生成4个三角形组成四面体</span></span><br><span class="line">   glEnd();</span><br><span class="line">   <span class="comment">//结束</span></span><br></pre></td></tr></table></figure><p>4、在这里，glColor3ub、glBegin，glEnd均是OpenGL的库函数，不需要我们定义，直接调用即可，<strong>需要我们写的是DrawTriangle函数</strong>，接下来我们就开始定义DrawTriangle()，前面已经提到，需要用<strong>3个点和一个法向量</strong>来确定一个平面，因此我们把第一节中生成法向量的函数复制到此文件的开头处，以便调用。<br><img src="https://img.mahaofei.com/img/202112231002324-numerical-recipe-14.png" alt=""><br>5、画三角形的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawTriangle</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];<span class="comment">//定义一个数组用来存放法向量</span></span><br><span class="line">project(a,b,c,n);<span class="comment">//调用生成法向量的函数由a,b,c三点生成法向量n</span></span><br><span class="line">glNormal3fv(n);</span><br><span class="line">glVertex3fv(a);</span><br><span class="line">glVertex3fv(b);</span><br><span class="line">glVertex3fv(c);<span class="comment">//此四行为利用用库函数，由法向量n和三个点abc生成一个平面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、完成上述步骤后，进行调试，即可得到一个四面体<br><img src="https://img.mahaofei.com/img/202112231003764-numerical-recipe-15.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字化方法基础教程</title>
      <link href="/post/1e786620.html"/>
      <url>/post/1e786620.html</url>
      
        <content type="html"><![CDATA[<p><strong>如果觉得这篇太长，可到以下各单独blog<br>（1）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727427">数字化方法基础（一）_基础操作与生成四面体（Chapter 1-3）</a><br>（2）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727368">数字化方法基础（二）_点的投影（Chapter 4-5）</a><br>（3）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727404">数字化方法基础（三）_导入本地模型（Chapter 6）</a><br>（4）<a href="https://blog.csdn.net/weixin_44543463/article/details/102727509">数字化方法基础（四）_矩阵操作（Chapter 7）</a></strong></p><p>ps.<a href="https://blog.csdn.net/weixin_44543463/article/details/102808548"><strong>常用函数请看这里</strong></a></p><p><strong>最近一次的代码（全）百度网盘：</strong><br><a href="https://pan.baidu.com/s/1cmQwrqrWzPwYdklb7snTkg">https://pan.baidu.com/s/1cmQwrqrWzPwYdklb7snTkg</a></p><h1>Chapter1  VisualStudio2010 Express如何创建新工程</h1><p>1、新建一个win32 Console Application工程，选择建立一个空项目（带预编译头的也可以，只不过大多数人不太习惯）</p><p><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223095734449.png" alt="image-20211223095734449"></p><p><img src="https://img.mahaofei.com/img/202112230957699-numerical-recipe-2.png" alt=""><br>2、在左侧解决方案资源管理器中右击Source-add-New item，创建一个C++文件</p><p><img src="https://img.mahaofei.com/img/202112230958908-numerical-recipe-3.png" alt=""><br>3、这样就用VS2010创建好了一个简单的工程！</p><h1>Chapter2 SB-WinSRC的使用方法</h1><p>1、解压压缩包，得到一个SB-WinSRC文件夹<br>2、打开SB-WinSrc\examples\projects\microsoft\chapt05\shinyjet文件夹中的shinyjet.vcproj文件，如出现以下对话框则一直Next到最后<br><img src="https://img.mahaofei.com/img/202112230958911-numerical-recipe-4.png" alt=""><br>3、打开shinyjet.cpp并进行编译（Build solution生成解决方案）<br><img src="https://img.mahaofei.com/img/202112230958652-numerical-recipe-5.png" alt=""><br>4、出现图示错误<br><img src="https://img.mahaofei.com/img/202112230959276-numerical-recipe-6.png" alt=""><br>5、打开目录\SB-WinSrc\examples\src\shared，找到freeglut_static.lib文件，将它复制到之前打开的shinyjet文件夹内<br><img src="https://img.mahaofei.com/img/202112230959001-numerical-recipe-7.png" alt=""><br><img src="https://img.mahaofei.com/img/202112231000243-numerical-recipe-8.png" alt=""><br>6、再次进行编译（Build solution生成解决方案），出现下图错误<br><img src="https://img.mahaofei.com/img/202112231000076-numerical-recipe-9.png" alt=""><br>7、在左侧Solution Explorer（解决方案资源管理器）中右击shinyjet打开属性，将Linker-Input-忽略特定默认库一栏中输入LIBC.lib<br><img src="https://img.mahaofei.com/img/202112231000584-numerical-recipe-10.png" alt=""><br>8、再次编译，成功！</p><h1>Chapter3  用OpenGL生成四面体</h1><h2 id="已知3点求法向量">已知3点求法向量</h2><p>1、具体思路为先根据已知3点做差求出两个向量，利用两个向量叉乘运算求出法向量，实现过程中尽量避免将所有代码集中到一个函数中，因为后续的操作（如投影点的计算）还需用到求法向量的函数，到时可直接调用。<br>2、已知2点求向量的函数十分简单，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getvector</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> vec[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">vec[i] = a[i] - b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、调用两次上述函数即可获得两个向量，接下来要做的就是拿这两个向量进行叉乘，以得到法向量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crossproject</span><span class="params">(<span class="type">float</span> vec1[<span class="number">3</span>],<span class="type">float</span> vec2[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">n[<span class="number">0</span>] = vec1[<span class="number">1</span>]*vec2[<span class="number">2</span>]-vec1[<span class="number">2</span>]*vec2[<span class="number">1</span>];</span><br><span class="line">n[<span class="number">1</span>] = vec1[<span class="number">2</span>]*vec2[<span class="number">0</span>]-vec1[<span class="number">0</span>]*vec2[<span class="number">2</span>];</span><br><span class="line">n[<span class="number">2</span>] = vec1[<span class="number">0</span>]*vec2[<span class="number">1</span>]-vec1[<span class="number">1</span>]*vec2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、将上面两个函数简单封装一下如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数中的法向量n[3]是提前在函数外定义的，通过调用函数给n[3]赋值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">project</span><span class="params">(<span class="type">float</span> point1[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> vec1[<span class="number">3</span>],vec2[<span class="number">3</span>];</span><br><span class="line">getvector(a,b,vec1);</span><br><span class="line">getvector(b,c,vec2);</span><br><span class="line">crossproject(vec1,vec2,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、这样一个求法向量的函数就写好了，使用方法如下例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a[<span class="number">3</span>] = &#123;<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> b[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> c[<span class="number">3</span>] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="type">double</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//调用过project()函数之后，n[3]数组内的值即为法向量</span></span><br></pre></td></tr></table></figure><h2 id="生成四面体">生成四面体</h2><p>1、使用OpenGL生成四面体的基本方法为，<strong>给定三个点和一个法向量</strong>，调用OpenDL的库函数，即可<strong>生成一个由这三点围成的三角形平面</strong>，<strong>四个三角形平面即可组成一个四面体</strong>。<br>2、将课上的shinyjet.cpp模板复制到src相应的文件夹中（\SB-WinSrc\examples\src\chapt05\shinyjet），然后回到project对应文件夹中，打开shinyjet.vcxproj工程，点击调试，成功后出来的应该为一个蓝绿色底的对话框。<br><img src="https://img.mahaofei.com/img/202112231001853-numerical-recipe-11.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231001700-numerical-recipe-12.png" alt=""></p><p>3、在RenderSenen()函数中的下图位置 <strong>写入glBegin()与glEnd()函数，并在二者之间插入画三角形的代码</strong>。</p><p><img src="https://img.mahaofei.com/img/202112231002123-numerical-recipe-13.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> rgfPoints4[<span class="number">12</span>] = &#123;<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,<span class="number">-0.6f</span>,</span><br><span class="line"><span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line"><span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,</span><br><span class="line"><span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;</span><br><span class="line"><span class="comment">//这是定义了一个长为12的数组，每3个元素代表一个点坐标，共4个点</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置要生成图形的颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line"><span class="comment">//开始生成三角形</span></span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>);</span><br><span class="line">DrawTriangle(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>);</span><br><span class="line">DrawTriangle(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>);</span><br><span class="line"><span class="comment">//↑函数功能：给定3个点生成一个三角形，调用4次生成4个三角形组成四面体</span></span><br><span class="line">   glEnd();</span><br><span class="line">   <span class="comment">//结束</span></span><br></pre></td></tr></table></figure><p>4、在这里，glColor3ub、glBegin，glEnd均是OpenGL的库函数，不需要我们定义，直接调用即可，<strong>需要我们写的是DrawTriangle函数</strong>，接下来我们就开始定义DrawTriangle()，前面已经提到，需要用<strong>3个点和一个法向量</strong>来确定一个平面，因此我们把第一节中生成法向量的函数复制到此文件的开头处，以便调用。<br><img src="https://img.mahaofei.com/img/202112231002324-numerical-recipe-14.png" alt=""><br>5、画三角形的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawTriangle</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];<span class="comment">//定义一个数组用来存放法向量</span></span><br><span class="line">project(a,b,c,n);<span class="comment">//调用生成法向量的函数由a,b,c三点生成法向量n</span></span><br><span class="line">glNormal3fv(n);</span><br><span class="line">glVertex3fv(a);</span><br><span class="line">glVertex3fv(b);</span><br><span class="line">glVertex3fv(c);<span class="comment">//此四行为利用用库函数，由法向量n和三个点abc生成一个平面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、完成上述步骤后，进行调试，即可得到一个四面体<br><img src="https://img.mahaofei.com/img/202112231003764-numerical-recipe-15.png" alt=""></p><h1>Chapter4  用OpenGL生成点的投影</h1><h2 id="计算点的投影的基本原理">计算点的投影的基本原理</h2><p><img src="https://img.mahaofei.com/img/202112231003891-numerical-recipe-16.png" alt=""></p><h2 id="如何编写程序实现点的投影">如何编写程序实现点的投影</h2><p>1、我们要实现点的投影就要知道投影点的坐标，由上一节可知，需要计算<strong>P0P1矢量</strong>（这个直接调用上一讲求向量的函数），<strong>en向量</strong>（需要写一个单位化函数），<strong>向量点乘</strong>的函数<br>2、单位化，即将向量各个坐标除以它的模，函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Normalize</span><span class="params">(<span class="type">float</span> n[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> length;</span><br><span class="line">length = <span class="built_in">sqrt</span>(n[<span class="number">0</span>]*n[<span class="number">0</span>]+n[<span class="number">1</span>]*n[<span class="number">1</span>]+n[<span class="number">2</span>]*n[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//求向量的模</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">n[i] /= length;</span><br><span class="line"><span class="comment">//函数执行过后n[3]即变成单位法向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、进行向量点乘计算，并求N点坐标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProjectPointtoPoint</span><span class="params">(<span class="type">float</span> point[<span class="number">3</span>],<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>], <span class="type">float</span> ProjectPoint[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> vector_a_p[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> distance;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">vector_a_p[i] = point[i] - a[i];</span><br><span class="line"><span class="comment">//求面内一点与面外一点的向量,即P0P1</span></span><br><span class="line">distance = vector_a_p[<span class="number">0</span>]*n[<span class="number">0</span>]+vector_a_p[<span class="number">1</span>]*n[<span class="number">1</span>]+vector_a_p[<span class="number">2</span>]*n[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//做点乘运算求点到平面距离，即图中|P0N|</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">ProjectPoint[j] = point[j] - n[j]*distance;</span><br><span class="line"><span class="comment">//N点坐标=P0坐标 - en * |P0N|</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、经过上述步骤之后就获得投影点坐标，然后就可调用库函数显示投影点，以下为显示一个点的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DrawPoint</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> point[<span class="number">3</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];</span><br><span class="line">project(a,b,c,n);</span><br><span class="line"><span class="comment">//求abc平面法向量</span></span><br><span class="line">Normalize(n);</span><br><span class="line"><span class="comment">//单位化法向量</span></span><br><span class="line"><span class="type">float</span> ProjectPoint[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//定义一个数组用来存放投影点坐标</span></span><br><span class="line">ProjectPointtoPoint(point,a,n,ProjectPoint);</span><br><span class="line"><span class="comment">//获得投影点坐标</span></span><br><span class="line">glVertex3fv(ProjectPoint);</span><br><span class="line"><span class="comment">//显示投影点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、同三角形，在RenderSenen()函数中的画三角形的glEnd()后面 <strong>再次写入glBegin()与glEnd()函数，并在二者之间插入显示点的代码</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> point[<span class="number">3</span>] = &#123;<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>&#125;;</span><br><span class="line"><span class="comment">//定义要投影的点</span></span><br><span class="line">glColor3ub(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//显示的点的颜色</span></span><br><span class="line">glPointSize(<span class="number">6.0f</span>);</span><br><span class="line"><span class="comment">//显示的点的大小</span></span><br><span class="line">glBegin(GL_POINTS);</span><br><span class="line"><span class="comment">//开始生成点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line"><span class="comment">//根据第一个面3个点，画第一个投影点</span></span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">3</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4+<span class="number">3</span>,rgfPoints4+<span class="number">9</span>,rgfPoints4+<span class="number">6</span>,point);</span><br><span class="line">DrawPoint(rgfPoints4,rgfPoints4+<span class="number">6</span>,rgfPoints4+<span class="number">9</span>,point);</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></figure><p>6、调试成功，显示如图<br><img src="https://img.mahaofei.com/img/202112231003356-numerical-recipe-17.png" alt=""></p><h1>Chapter5  如何使用VS2010的调试功能</h1><p>假如我写完程序调试后发现点没有显示，那么可以一步步调试，找出错误的地方。<br>1、设置断点，在觉得可能出问题的代码处设置断点<br><img src="https://img.mahaofei.com/img/202112231004361-numerical-recipe-18.png" alt=""><br>2、点击调试，下图红框内左面按键为单步执行，点一下执行一句话，如果遇到函数就进入函数内部执行函数体的第一句；右面的按键，点一下执行一句，在遇到函数是直接将整个函数执行完，即将函数也当成一句话。<br><img src="https://img.mahaofei.com/img/202112231004424-numerical-recipe-19.png" alt=""><br>3、这里选择左面按键进入函数内部查看,黄色箭头表示当前执行到哪一句<br><img src="https://img.mahaofei.com/img/202112231004146-numerical-recipe-20.png" alt=""><br>4、按第二个按键将这个函数执行完（但不要退出这个函数，否则函数内部的变量内存会被释放，无法查看变量的值）<br><img src="https://img.mahaofei.com/img/202112231005406-numerical-recipe-21.png" alt=""><br>5、此时可以看到下面的监视窗口可以看到变量，单击+即可看到变量的值，图中展开的为第一个面的法向量和投影点坐标<br><img src="https://img.mahaofei.com/img/202112231005488-numerical-recipe-22.png" alt=""><br>第二个面的法向量和投影点坐标<br><img src="https://img.mahaofei.com/img/202112231005139-numerical-recipe-23.png" alt=""><br>第三个面<br><img src="https://img.mahaofei.com/img/202112231006139-numerical-recipe-24.png" alt=""><br>第四个<br><img src="https://img.mahaofei.com/img/202112231006058-numerical-recipe-25.png" alt=""></p><h1>Chapter 6  导入本地模型</h1><p>图形的生成需要消耗一定的时间，简单的模型可能没有什么感觉，但是在模型十分复杂时，模型的生成就需要相当长的时间，这是我们不能忍受的。因此，将模型保存为本地文件，使用时直接加载进来，这就变得十分必要了，本节主要讲如何将创建一个列表以及如何加载一个列表。</p><h2 id="如何创建一个列表">如何创建一个列表</h2><p>列表的基本原理就是将之前写的<strong>从glPolygonMode、glBegin开始，到glEnd</strong>将这些代码<strong>用一行glCallList(DrawList)代替</strong>，其中DrawList内存放的就是之前生成四面体的代码了。glCallList就相当于把原来的四面体代码加载进来。<br>那如何将原来的四面体代码创建为一个列表供glCallList读取呢，过程十分简单，只需要按以下步骤即可：<br>1、在整个文件开头部分<strong>定义一个GLuint类型的全局变量</strong>（因为这个变量要在不同的函数使用，故须定义为全局变量）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLuint DrawList;</span><br></pre></td></tr></table></figure><p>2、将RenderScene函数（就是之前写glbegin和glEnd的地方）中的<strong>有关三角形的代码全部用glCallList函数代替</strong></p><p><img src="C:%5CUsers%5C82785%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211223100655803.png" alt="image-20211223100655803"><br>3、在SetupRC函数中的最后<strong>新建列表</strong>，<strong>框架</strong>如下<br><img src="https://img.mahaofei.com/img/202112231007333-numerical-recipe-27.png" alt=""><br>4、框架写好之后在图中注释位置<strong>插入画四面体的代码</strong>，插入后结果如下图<br><img src="https://img.mahaofei.com/img/202112231007814-numerical-28.png" alt=""><br>5、至此一个存有四面体列表就新建好了，点击调试运行即可看到和以前一样的四面体。<br><img src="https://img.mahaofei.com/img/202112231007227-numerical-recipe-29.png" alt=""></p><h2 id="如何读取本地模型">如何读取本地模型</h2><p>当我们需要读取本地文件中的模型时，如何操作呢<br>1、既然要读取文件中的模型，首先肯定要打开文件，在创建列表的代码之前插入如下三行代码<br><img src="https://img.mahaofei.com/img/202112231008514-numerical-recipe-30.png" alt=""><br>（注意，if stream的括号内为文件的路径，其中的\都要写成\，因为在C语言字符串中，\表示转义，\\才表示一个\）<br>（注意，ifstream若要使用需要先在开头插入以下两行引入头文件同时设置环境)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>2、在定义几个数组用来存放一会要读取的数据<br><img src="https://img.mahaofei.com/img/202112231008162-numerical-recipe-31.png" alt=""><br>3、然后，将之前画四面体的代码，更改为读取文件的代码，更换后的框架如下，其中in每次读取一串字符（到空格或换行停止)，<strong>in &gt;&gt; String0指的是将读取到的字符存入String0中</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DrawList = <span class="built_in">glGenLists</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">glNewList</span>(DrawList,GL_COMPILE);</span><br><span class="line"><span class="built_in">glPolygonMode</span>(GL_BACK,GL_LINE);</span><br><span class="line"><span class="comment">//在↓插入代码</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0;<span class="comment">//这就表示将两个字符串先后存入到String0中</span></span><br><span class="line"><span class="comment">//因为如下图在读取到有用数据之前有两个没用的单词，需要读取两次</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;end&quot;</span>))<span class="comment">//读到的字符串为end则退出循环</span></span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//因为刚才已经读掉了前两个没用的字符串，因此直接读取三个坐标到Points里</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//如下图读完第一组坐标后会遇到 vertex这个单词，需要读到垃圾桶（String0）里再读坐标</span></span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="built_in">glColor3ub</span>(<span class="number">200</span>,<span class="number">200</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line"><span class="built_in">DrawTriangle</span>(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line"><span class="comment">//这三行时画一个三角形，根据刚才读到的三个点</span></span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在↑插入代码</span></span><br><span class="line"><span class="built_in">glEndList</span>();</span><br></pre></td></tr></table></figure><p>（因为用到了strcmp函数，需要引入头文件#include&lt;string.h&gt;）<br><img src="https://img.mahaofei.com/img/202112231009244-numerical-recipe-32.png" alt=""></p><p><img src="https://img.mahaofei.com/img/202112231009411-numerical-recipe-33.png" alt=""><br>注意一下，计算机里的图像<strong>无论是平面还是曲面，都是由无数个三角形组成的</strong>，只不过三角形数量无比多时，我们看起来它就是一个曲面，Part1.TXT文件中也是，每读取到三个点就画一个三角形，许许多多个三角形就会组成一个立体图形。<br>4、至此，如何从文件中导入立体模型就完成了，点击调试，即可看到一个正方体<br>6、那么对于给定的STL文件如何读取？首先右击Part2.STL，用记事本打开，看到文件内容如下<br><img src="https://img.mahaofei.com/img/202112231010481-numerical-recipe-34.png" alt=""><br>这看起来和之前差不多，只是他多给了一个法向量，没用的字符串多了一些而已，你可以不用他给的法向量，只读取三个坐标然后自己计算法向量，也可以读取法向量，这个时候 DrawTriangle函数就不需要计算法向量了，直接四行代码就ok，和之前一样，每一次in &gt;&gt; String0操作就读掉一个没用的字符串，自己编写代码就可实现将STL文件中的所有点全部读取出来<br>需要注意的是，<strong>每次循环结束</strong>的时候都要保证<strong>String内存放</strong>的是<strong>facet或者最后的endsolid</strong>这个单词，以保证循环可以正常退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTriangle</span><span class="params">(<span class="type">float</span> a[<span class="number">3</span>],<span class="type">float</span> b[<span class="number">3</span>],<span class="type">float</span> c[<span class="number">3</span>],<span class="type">float</span> n[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//float n[3];</span></span><br><span class="line"><span class="comment">//project(a,b,c,n);</span></span><br><span class="line"><span class="built_in">glNormal3fv</span>(n);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(a);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(b);</span><br><span class="line"><span class="built_in">glVertex3fv</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS.如果程序出现错误，如何进行调试呢，首先在while循环里第一句前面设置断点，如下图<br><img src="https://img.mahaofei.com/img/202112231010555-numerical-recipe-35.png" alt=""><br>然后点击单步执行第二个按钮<br><img src="https://img.mahaofei.com/img/202112231010062-numerical-recipe-36.png" alt=""><br>每次循环读9个点,查看你读取到的点的值是否与文件中的坐标值一一对应，其中012对应第一行3个点，345对应第二行三个点，678对应第三行。<br><img src="https://img.mahaofei.com/img/202112231011562-numerical-recipe-37.png" alt=""></p><h1>Chapter 7 矩阵操作</h1><h2 id="利用矩阵实现向量平移">利用矩阵实现向量平移</h2><p>1、基本原理:如图，任意给定一个点的坐标（列向量）x,y,z。设置一个矩阵，利用矩阵的乘法运算即可将三个坐标进行平移<br>注意：过程中所设置的矩阵为单位阵的最后一列加上偏移量Tx，Ty，Tz。如下图，大家自己试一下矩阵乘法即可验证。<br><img src="https://img.mahaofei.com/img/202112231011567-numerical-recipe-38.png" alt=""></p><p>2、在了解了如何将一个列向量进行平移之后，我们就可以编写程序进行向量的平移操作了，我们打开生成螺旋线的程序，注意到螺旋线是由许许多多点组成的，下面这个for循环就是每次生成一个点，我们只需要吧每个点的坐标向量进行平移即可使整个螺旋线平移。<br><img src="https://img.mahaofei.com/img/202112231012895-numerical-recipe-39.png" alt=""><br>3、现在就开始写程序了，首先明确一下程序执行过程</p><p><strong>1. 获得一个点的坐标存入P0数组内<br>2. 设置一个矩阵Translation用来将坐标平移<br>3. 将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标</strong></p><p>4、第一步，获得一个点的坐标存入P0数组内，这一步十分简单（注：除函数定义外，其余代码均在for循环内）<code>float P0[3] = &#123;x,y,z&#125;;</code><br>5、第二步，设置一个矩阵Translation用来将坐标平移，我们需要一个下面这样的矩阵<br><img src="https://img.mahaofei.com/img/202112231012723-numerical-recipe-40.png" alt=""><br>如何操作呢，首先先初始化一个单位矩阵，然后将单位矩阵的最后一列赋值为需要偏移的量（我的代码十分简单粗暴，当然也可单独另写一个函数用于初始化一个单位矩阵)<br>注意：在OpenGL中，矩阵是按列数的，就是说我定义的I[16]中的前四个元素I[1]、I[2]、I[3]、I[4]实际上是矩阵的第一列，最后的I[12]、I[13]、I[14]、I[15]是矩阵的最后一列，而非上学期C语言中理解的最后一行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Translate</span><span class="params">(<span class="type">float</span> fx,<span class="type">float</span> fy,<span class="type">float</span> fz,<span class="type">float</span> Translation[<span class="number">16</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> I[<span class="number">16</span>] = &#123;<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>&#125;;<span class="comment">//定义一个四阶单位阵</span></span><br><span class="line">I[<span class="number">12</span>] = fx;<span class="comment">//将第四列第一行的元素赋fx</span></span><br><span class="line">I[<span class="number">13</span>] = fy;<span class="comment">//第四列第二行赋fy</span></span><br><span class="line">I[<span class="number">14</span>] = fz;<span class="comment">//第四列第三行赋fz</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)</span><br><span class="line">Translation[i] = I[i];<span class="comment">//将I数组的值循环赋给Translation数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作之后就获得了如上面图片中的数组了。<br>6、第三步，将上述两个矩阵相乘得到的结果存入P1数组内，此即为平移后的点的坐标，So我们要做的就是定义一个P1数组<code>float P1[3];</code>这十分简单，然后就是写一个矩阵乘法的运算，用Translation*P0，结果存入P1中。<br>实现代码如下，注意translation为4*4矩阵，P0为3*1矩阵，P1为4*1矩阵，<br>（为什么要四阶矩阵是因为我们需要矩阵运算平移，只有多加一行一列才能实现，而P0和P1我们实际只用前3个元素，）<br>故我们让P0的“第四个”元素默认为1，即下面代码中最后一项为1*translation[i+12]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ApplyMatrix</span><span class="params">(<span class="type">float</span> *P0,<span class="type">float</span> *translation,<span class="type">float</span> *P1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;++i)</span><br><span class="line">P1[i] = P0[<span class="number">0</span>]*translation[i]+P0[<span class="number">1</span>]*translation[i+<span class="number">4</span>]+P0[<span class="number">2</span>]*translation[i+<span class="number">8</span>]+translation[i+<span class="number">12</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、有了设置操作矩阵的函数Translate，和矩阵相乘的函数ApplyMatrix，我们就可以平移点了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;<span class="comment">//定义P0存放平移之前的点</span></span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];<span class="comment">//定义P1存放平移之后的点</span></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];<span class="comment">//存放一个4*4的操作矩阵</span></span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">30.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//设置操作矩阵为我们想要的格式（单位阵-&gt;最后一列赋值）</span></span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//操作矩阵和P0点相乘，结果放在P1内</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示平移之后的点</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为螺旋线平移步骤</p><h2 id="使用矩阵实现向量旋转">使用矩阵实现向量旋转</h2><p>1、如何进行向量旋转<br>首先了解一下二维坐标的旋转，设一个向量a的坐标是（x,y），长度为r，与x轴正向夹角为α，则：<br>xa = r cos α,<br>ya = r sin α.<br>如果把向量旋转一个角度φ，则新的向量b的坐标是<br>xb = r cos(α + φ) = r cos α cos φ - r sin α sin φ,<br>yb = r sin(α + φ) = r sin α cos φ + r cos α sin φ.<br><img src="https://img.mahaofei.com/img/202112231012454-numerical-recipe-41.png" alt=""><br>又因为xa = r cos α，ya = r sin α.所以容易看出来<br>xb = xa cos φ - ya sin φ,<br>yb = ya cos φ + xa sin φ.<br>而等式右边，又可写成两个矩阵的乘积<br><img src="https://img.mahaofei.com/img/202112231013633-numerical-recipe-42.png" alt=""><br>由此可知，等式中<strong>由sin和cos组成的二阶方阵</strong>，就<strong>可以实现将向量(xa ya,)旋转为(xb,yb,)</strong>，暂且叫做二阶的旋转操作矩阵<br>由此推导至三阶，<strong>三阶的旋转操作矩阵为以下三种</strong>（分别为绕x，y，z轴旋转），大家带入检验一下即可知道，<br><img src="https://img.mahaofei.com/img/202112231013952-numerical-recipe-43.png" alt=""><br>而为了与之前的平移操作统一，因此我们也把这个三阶旋转操作矩阵扩展为四阶的，如下<br><img src="https://img.mahaofei.com/img/202112231013016-numerical-recipe-44.png" alt=""><br>2、如何编写函数实现向量旋转呢<br>由刚才的推导我们知道，用旋转操作矩阵左乘一个列向量即可实现向量的旋转操作<br>现在我们来编写函数，以绕x轴为例，我们先来看一下“主函数”，这是生成螺旋线的那个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个数组（用于存放旋转操作矩阵）</span></span><br><span class="line"><span class="comment">//这里也可生成一个单位阵，那样就不用初始化为0了</span></span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//给定一个角度（-90°），生成旋转操作矩阵</span></span><br><span class="line">ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用旋转操作矩阵左乘P0，得到的结果P1即为旋转完成的向量坐标</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//显示旋转后的坐标对应的点</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们需要做的就是<strong>写一个函数</strong>，<strong>由参数（角度）生成一个旋转操作矩阵</strong>，这里需要注意的是，math.h头文件中有sin和cos的函数，直接sin（angle）即可调用，其中angle为弧度值，代码如下<br>（注意，函数里用到的PI是在开头宏定义的<code>#define PI 3.14159</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Rotate_x</span><span class="params">(<span class="type">float</span> angle,<span class="type">float</span> *rotation)</span></span><br><span class="line">&#123;</span><br><span class="line">angle = angle/<span class="number">180.0</span>*PI;</span><br><span class="line"><span class="comment">//将角度值转换为弧度值</span></span><br><span class="line">rotation[<span class="number">5</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">rotation[<span class="number">6</span>] = <span class="built_in">sin</span>(angle);</span><br><span class="line">rotation[<span class="number">9</span>] = -<span class="built_in">sin</span>(angle);</span><br><span class="line">rotation[<span class="number">10</span>] = <span class="built_in">cos</span>(angle);</span><br><span class="line">rotation[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//配置各个位置的数值，注意矩阵下标是竖着数的，第一行位置为0、4、8、12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们得到了旋转操作矩阵，经“主函数”调用即可实现向量的旋转</p><h2 id="如何让图形既平移又旋转">如何让图形既平移又旋转</h2><p>一个很简单的思路就是<strong>先后调用平移和旋转操作的函数</strong>，像下面这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> P2[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line">ApplyMatrix(P0,Translation,P1);</span><br><span class="line"><span class="comment">//进行平移操作，P0平移后为P1</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line">ApplyMatrix(P1,Rotation,P2);</span><br><span class="line"><span class="comment">//进行旋转操作，P1旋转后为P2</span></span><br><span class="line"></span><br><span class="line">glVertex3f(P2[<span class="number">0</span>], P2[<span class="number">1</span>], P2[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//最后输出P2的点即可</span></span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这显然不是我们想要的，我们想一步就完成平移操作，不需要中间P1的出现，那么就需要<strong>将平移操作矩阵和旋转操作矩阵相乘，得到的仍为一个四阶矩阵，再拿这个新的四阶矩阵左乘列向量xy，即可将列向量既平移又旋转</strong>。<br><strong>如何理解？</strong><br>我们知道平移操作矩阵和旋转操作矩阵都是可逆矩阵（det Rx ≠ 0，det T ≠ 0）<br><img src="https://img.mahaofei.com/img/202112231014359-numerical-recipe-45.png" alt=""><br>那么这两个矩阵都可以写成许多个初等矩阵的乘积，即<br>Rx = R1*R2*R3*……Rn * I<br>T = R1’*R2’*R3’……Rn’ * I<br>（其中R1，R1’……Rn，Rn’都为初等矩阵，初等矩阵还记得吧，刚学过的线代，只进行一次初等变换的矩阵；初等矩阵左乘一个矩阵即对他行变换）<br>那么我们知道平移操作为<br><img src="https://img.mahaofei.com/img/202112231014908-numerical-recipe-46.png" alt=""><br>同理旋转操作也可以写成<br><img src="https://img.mahaofei.com/img/202112231015626-numerical-recipe-47.png" alt=""><br>那么先平移，然后把平移得到的矩阵旋转就可以写成如下的形式<br><img src="https://img.mahaofei.com/img/202112231015778-numerical-recipe-48.png" alt=""><br>又因为Rx = R1<em>R2</em>R3*……Rn，T = R1’<em>R2’<em>R3’……Rn’<br>所以 Rx</em>T</em>列向量 就代表把列向量平移又旋转<br>那么我们现在要做的就是写一个四阶矩阵的乘法函数，以获取Rx*T的结果，拿这结果左乘列向量即一步实现平移旋转。<br>四阶矩阵的乘法代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">float</span> *rotation,<span class="type">float</span> *translation,<span class="type">float</span> *tran)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">tran[<span class="number">4</span>*i+j] += rotation[<span class="number">4</span>*k+j]*translation[<span class="number">4</span>*i+k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个是用16个元素的变量代表一个矩阵，下标表示比较麻烦，大家可以在纸上写一下<br>代码写法不唯一，也可以把它拆成四个循环单独写，当然也可以直接把每个元素赋值，赋值16次就完了<br>然后按照刚才的逻辑在“主函数”里调用一下就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(angle = <span class="number">0.0f</span>; angle &lt;= (<span class="number">2.0f</span>*GL_PI)*<span class="number">3.0f</span>; angle += <span class="number">0.1f</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">50.0f</span>*<span class="built_in">sin</span>(angle);</span><br><span class="line">y = <span class="number">50.0f</span>*<span class="built_in">cos</span>(angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the point and move the Z value up a little</span></span><br><span class="line">glVertex3f(x, y, z);</span><br><span class="line"><span class="type">float</span> P0[<span class="number">3</span>] = &#123;x,y,z&#125;;</span><br><span class="line"><span class="type">float</span> P1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.0f</span>,<span class="number">60.0f</span>,<span class="number">0.0f</span>,Translation);</span><br><span class="line"><span class="comment">//获得平移操作矩阵</span></span><br><span class="line"><span class="type">float</span> Rotation[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Rotate_x(<span class="number">-90</span>,Rotation);</span><br><span class="line"><span class="comment">//获得旋转操作矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> multi[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">mul(Rotation,Translation,multi);</span><br><span class="line"><span class="comment">//两矩阵相乘获得平移+旋转操作矩阵</span></span><br><span class="line">ApplyMatrix(P0,multi,P1);</span><br><span class="line"><span class="comment">//用平移+旋转操作矩阵左乘P0即可得到被平移且旋转之后的矩阵P1</span></span><br><span class="line">glVertex3f(P1[<span class="number">0</span>], P1[<span class="number">1</span>], P1[<span class="number">2</span>]);</span><br><span class="line">z += <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上即利用矩阵实现向量的平移与旋转操作</p><h2 id="坐标系的旋转">坐标系的旋转</h2><p><strong>1、目标</strong>：<br>给定一个向量（如(1,1,1)），将原坐标系旋转为以此向量为Z轴的坐标系。<br><strong>2、基本概念</strong>：<br>如图，左面的三阶方阵内每一列为新坐标轴的三个单位向量，用这个<strong>三阶方阵左乘一个原坐标系的点</strong>，即可<strong>将这个点坐标旋转为新坐标系的对应坐标</strong><br>由此，我们只需要生成一个左面的旋转坐标系的矩阵即可。<br><img src="https://img.mahaofei.com/img/202112231015231-numerical-recipe-49.png" alt=""><br><strong>3、如何生成Ruvw矩阵</strong><br>法一：<br>（1）先单位化已知矢量z<br>（2）然后把已知矢量z中的其中一个坐标变为1，这样就获得了两个在同一平面的向量<br>（3）然后用这两个向量叉乘，得到的结果就是和已知矢量z垂直的矢量y<br>（4）然后再用已知矢量z叉乘刚获得的向量y，得到与这两个向量都垂直的向量x。<br>（5）如此，将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br><img src="https://img.mahaofei.com/img/202112231016083-numerical-recipe-50.png" alt=""><br>法二：知道给定矢量的三个坐标(Zx,Zy,Zz),则和这个矢量垂直的向量之一的坐标是(Zy,-Zx,0)，这样同样可以获得两个相互垂直的矢量，然后这俩矢量叉乘得到第三个矢量，即为三坐标轴。将得到的三个坐标轴矢量组合成的形式（u为新x轴，v为新y轴，w为新z轴）<br>（注：代表新坐标轴的三个矢量均需要单位化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此为法二的代码，其中Rotation+4等地方用到了指针的技巧</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RotateCoor</span><span class="params">(<span class="type">float</span> *z,<span class="type">float</span> *Rotation)</span></span><br><span class="line">&#123;</span><br><span class="line">Rotation[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">Rotation[<span class="number">15</span>] = <span class="number">1</span>;</span><br><span class="line">Normalize(z);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">Rotation[<span class="number">8</span>+i] = z[i];</span><br><span class="line">Rotation[<span class="number">4</span>] = -z[<span class="number">1</span>];</span><br><span class="line">Rotation[<span class="number">5</span>] = z[<span class="number">0</span>];</span><br><span class="line">Normalize(Rotation+<span class="number">4</span>);</span><br><span class="line">crossproject(z,Rotation+<span class="number">4</span>,Rotation);</span><br><span class="line">Normalize(Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.mahaofei.com/img/202112231016916-numerical-recipe-51.png" alt=""><br>上图矩阵即为坐标系旋转操作矩阵，<strong>和之前平移与旋转一样</strong>，用<strong>这个矩阵×P0点</strong>，即可得到<strong>坐标轴旋转后的点P1</strong></p><h2 id="让图形显示在屏幕中心且绕中心转动">让图形显示在屏幕中心且绕中心转动</h2><p>1.首先我们要知道，OpenGL生成的对话框的长和宽是可以设置的，我们需要让对话框的宽高比与我们要生成的图像的宽高比相同，并且对话框要比图像稍大一些。<br>2、具体如下思路：<br>设模型的高为ModelHeight，宽为ModelWidth，生成的空间高为h，宽为w<br><strong>如果ModelHeight/h &gt; ModelWidth/w，说明对话框比较高（模型比较宽），因此要尽可能满足模型的宽</strong>，比如让<strong>对话框的宽为模型宽的2.5倍</strong>（让对话框稍大一些），则<strong>对话框的高就为 对话框的高/模型的高 * 模型的宽</strong>。<br>同理对话框比较扁也可以得到对称的结论，因此，用计算得到的对话框的宽和高就可生成一个合适的对话框。<br>3、如何编程更改对话框大小：<br>打开之前加载泵体的那个文件(chapt05\shinyjet)更改ChangeSize函数为以下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ChangeSize</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span><br><span class="line">    &#123;</span><br><span class="line">    GLfloat fAspect;</span><br><span class="line">    GLfloat lightPos[] = &#123; <span class="number">-50.f</span>, <span class="number">50.0f</span>, <span class="number">100.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a divide by zero</span></span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span>)</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set Viewport to window dimensions</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset coordinate system</span></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fAspect = (GLfloat) w / (GLfloat) h;</span><br><span class="line"><span class="comment">// Establish clipping volume (left, right, bottom, top, near, far)</span></span><br><span class="line"><span class="comment">//aspectRatio = (GLfloat)w / (GLfloat)h;</span></span><br><span class="line"><span class="comment">//这之上都不用动</span></span><br><span class="line"><span class="type">float</span> scale = <span class="number">2.5</span>;</span><br><span class="line"><span class="comment">//对话框与模型大小比例为2.5倍</span></span><br><span class="line"><span class="type">float</span> ScaleHeight,ScaleWidth,ModelWidth,ModelHeight;</span><br><span class="line"><span class="comment">//定义对话框的宽高，模型的宽高</span></span><br><span class="line">ModelWidth = PointMax[<span class="number">0</span>]-PointMin[<span class="number">0</span>];</span><br><span class="line">ModelHeight = PointMax[<span class="number">1</span>]-PointMin[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//模型宽的计算可由模型上最右的点坐标减最左点的坐标</span></span><br><span class="line"><span class="keyword">if</span>(w*ModelHeight &gt; h*ModelWidth)</span><br><span class="line">&#123;<span class="comment">//当ModelHeight/h &gt; ModelWidth/w时，模型比较宽，对话框比较高</span></span><br><span class="line">ScaleHeight = scale * ModelHeight;</span><br><span class="line"><span class="comment">//设置对话框的宽为模型宽的2.5倍</span></span><br><span class="line">ScaleWidth =  scale * ModelHeight * w / h;</span><br><span class="line"><span class="comment">//对话框的高为 对话框的高/模型的高 * 模型的宽</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ScaleWidth =  scale * ModelWidth;</span><br><span class="line">ScaleHeight = scale * ModelWidth * h / w;</span><br><span class="line">&#125;</span><br><span class="line">glOrtho(<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">0</span>] - PointMin[<span class="number">0</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) - <span class="number">0.5</span> * ScaleWidth,<span class="number">0.5</span> * (PointMax[<span class="number">1</span>] - PointMin[<span class="number">1</span>]) + <span class="number">0.5</span> * ScaleWidth,<span class="number">-2.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="comment">//定出模型的中心坐标，下面代码就根据中心坐标生成一个与模型中心位置相同的对话框</span></span><br><span class="line"><span class="comment">//这之下都不用动</span></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    </span><br><span class="line">    glLightfv(GL_LIGHT0,GL_POSITION,lightPos);</span><br><span class="line">    <span class="comment">//glTranslatef(0.0f, 0.0f, -150.0f);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、如何编程找出模型上对角线的两个点<br>将之前写过的读取文件里点的坐标的那个while循环中添加一部分内容，改成如下形式，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="comment">//以下为新加内容，作用为找到对角线上的两个点，存到PointMin和PointMax里</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMin[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMax[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上为新加内容</span></span><br><span class="line">glColor3ub(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>,n);</span><br><span class="line">glEnd();</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line">（注意，因为PointMin和PointMax既在SetupRC函数里使用又在Changesize函数里使用，故需要定义为全局变量，如下<span class="type">float</span> PointMin[<span class="number">3</span>] = &#123;<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f,<span class="number">1.0e38</span>f&#125;;<span class="type">float</span> PointMax[<span class="number">3</span>] = &#123;<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f,<span class="number">1.0e-38</span>f&#125;;）</span><br></pre></td></tr></table></figure><p>5、现在看起来可以了，我们把对话框设置成了和模型等比例，对称中心重合，但还需要更改一个地方就是，我们生成的<strong>模型中心和我们旋转轴的中心不是重合的</strong>，我们如何实现按下键盘时，让模型绕原点转动，而不是绕其他轴运动。<br>具体思路就是，我们<strong>要让模型绕自己中心旋转，可以先把模型平移到坐标轴原点处（原点与模型中心重合），进行旋转，然后在平移回原来位置，这样看上去就是模型绕自己中心旋转了</strong>，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">glPushMatrix();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Translation[<span class="number">16</span>];</span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glCallList(DrawList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the matrix state</span></span><br><span class="line">glPopMatrix();</span><br><span class="line"><span class="comment">// Display the results</span></span><br><span class="line">glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过修改这三个地方就实现了让模型能够正常的显示在屏幕中心且绕模型自己的中心转动</p><h1>Chapter 8 造小车</h1><h2 id="装配一个小车">装配一个小车</h2><p>组装小车开始了<br>在学习本节内容之前，<strong>请先掌握装载泵体模型的相关操作</strong><br>1.原理部分：我们知道了如何将一个模型文件装载进来同时显示出来，主要步骤是<strong>先新建一个列表DrawList</strong>，然后<strong>将模型存入此列表中</strong>，最后在<strong>通过glCallList()函数召唤列表即可生成一个模型</strong>。现在我们要做的就是同时生成许多个模型，那么<strong>如何同时生成许多模型呢，只要新建许多列表，然后把它们一个一个召唤出来（glCallList）就可以了</strong>。<br>2.既然我们需要新建好多个列表，那么我们最好定义一个函数用于生成列表，不然一大段代码赋值五六遍可不是一般的长。把之前在SetupRC函数里的新建列表的代码移出来，稍加修改封装成一个函数。新建列表的代码如下说明一下，函数第一个参数是文件名，也就是”&quot;F:\Works\Practice\数字化方法\Shove\Shovel.STL&quot;像这样的字符串，后面三个参数是RGB颜色，用于设置生成的模型的颜色，毕竟你也不想让整个小车变成一个颜色吧。最后一个参数是定义的列表变量的地址，或者说列表变量的指针<br>（注：为什么要用指针呢，我jo得这个可以参考上学期C++课上的内容，函数的形参只在函数体内有效，比如在主函数里定义了一个变量，把它传给一个函数并在函数内部改变它的值，主函数内的变量的值不会发生改变，因此只有把地址传过去才可以正常新建列表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatGLList</span><span class="params">(<span class="type">char</span> *filename,<span class="type">int</span> R,<span class="type">int</span> G,<span class="type">int</span> B,GLuint *listname)</span></span><br><span class="line">&#123;</span><br><span class="line">ifstream <span class="title function_">in</span><span class="params">(filename)</span>;</span><br><span class="line"><span class="comment">//要读取的文件是filename，例如如果参数是</span></span><br><span class="line"><span class="comment">//&quot;F:\\Works\\Practice\\数字化方法\\Shove\\Shovel.STL&quot;，</span></span><br><span class="line"><span class="comment">//那么会读取F:\\Works\\Practice\\数字化方法\\Shove这个目录下的Shove1.STL文件。</span></span><br><span class="line"><span class="keyword">if</span> (!in)</span><br><span class="line">_ASSERT(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> String0[<span class="number">30</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line"></span><br><span class="line">*listname = glGenLists(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//参数listname是一个指针，*listname才是列表变量</span></span><br><span class="line"><span class="type">float</span> Points[<span class="number">12</span>];</span><br><span class="line"><span class="type">float</span> n[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">glNewList(*listname,GL_COMPILE);</span><br><span class="line">glPolygonMode(GL_BACK,GL_LINE);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">strcmp</span>(String0,<span class="string">&quot;endsolid&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; String0;</span><br><span class="line">in &gt;&gt; n[<span class="number">0</span>] &gt;&gt; n[<span class="number">1</span>] &gt;&gt; n[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; String0 &gt;&gt; Points[<span class="number">0</span>] &gt;&gt; Points[<span class="number">1</span>] &gt;&gt; Points[<span class="number">2</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">3</span>] &gt;&gt; Points[<span class="number">4</span>] &gt;&gt; Points[<span class="number">5</span>];</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; Points[<span class="number">6</span>] &gt;&gt; Points[<span class="number">7</span>] &gt;&gt; Points[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> * point = Points + <span class="number">3</span>;point &lt; Points + <span class="number">11</span>;point += <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&lt;PointMin[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMin[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Points[j]&gt;PointMax[j])</span><br><span class="line">&#123;</span><br><span class="line">PointMax[j] = Points[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glColor3ub(R,G,B);</span><br><span class="line"><span class="comment">//根据函数的参数设置模型颜色</span></span><br><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">DrawTriangle(Points,Points+<span class="number">3</span>,Points+<span class="number">6</span>);</span><br><span class="line">glEnd();</span><br><span class="line">in &gt;&gt; String0 &gt;&gt; String0&gt;&gt; String0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glEndList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们有了新建列表的函数之后，然后就可以加载文件了……吗？注意，<strong>在使用函数之前先在文件开头定义几个列表变量（GLuint类型变量）</strong>，这个几个变量是用来存放各个模型的，没有这些变量就调用函数，软件会在参数上划红线，也就是它不知道把模型读取进来之后存到哪里去。<br><img src="https://img.mahaofei.com/img/202112231016256-numerical-recipe-52.png" alt=""><br>做好了这两个准备工作之后就可以开始新建模型列表and召唤模型列表了。在SetupRC函数原来加载文件的那个地方就可以用一句简单的CreatGLList(“F:\Works\Practice\数字化方法\Shove\Shovel.STL”,255,255,0,&amp;Shove);代替了。<strong>新建六个模型列表就用六次这个函数就可以了</strong>，比直接复制一大段读取模型的文件简化了不少。就像下面这样<br><img src="https://img.mahaofei.com/img/202112231017247-numerical-recipe-53.png" alt=""><br>建好了这六个模型列表，那我们就可以直接召唤它们了，在RenderScene函数里直接调用六个glCallList就可以把这六个模型召唤出来了<br><img src="https://img.mahaofei.com/img/202112231017471-numerical-recipe-54.png" alt=""><br>这么召唤神龙，sorry召唤模型，出来就直接是装配好的小车的样子，（虽然我也不知是为什么<br>这一节到此为止。</p><h2 id="让小车动起来">让小车动起来</h2><p>本节的目的是让小车动起来！难度稍大，各位仔细听我娓娓道来<br>1、理论部分，我们想让这个模型通过按键盘上不同的按键让他动起来，肯定要有<strong>函数用来读取按键</strong>，<strong>读取之后利用平移旋转之类的矩阵各个部分运动起来</strong>。<br>2、键盘部分：在写函数之前先在文件开头定义一些全局变量（各部分的转动角度），用于以后的旋转矩阵。<br><img src="https://img.mahaofei.com/img/202112231018223-numerical-recipe-55.png" alt=""><br>然后我们先写一下读取按键的函数。请大家先在最下方main函数里添加如下的一行代码，这个是库函数，用于读取按键的。<br><img src="https://img.mahaofei.com/img/202112231018145-numerical-recipe-56.png" alt=""><br>然后在前面我们定义一个函数名叫keyboard，函数内容如下，函数体是有重复的代码组成的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">keyboard</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> key,<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> ShoveStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//定义一个静态变量（下一次进入函数，变量内容保持不变）</span></span><br><span class="line"><span class="comment">//步长为3.0f，即设定按一下按键角度变化3度</span></span><br><span class="line"><span class="keyword">if</span>(ShoveRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">ShoveRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ShoveRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">ShoveRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="comment">//这里作用是防止模型出现失真（比如铲子转着转着转到驾驶舱里去了）</span></span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:ShoveRot+=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:ShoveRot-=ShoveStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是“某一按键”，是的话相应部分的转动角度增加（减少）一个步长。</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MainLinkStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(MainLinkRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">MainLinkRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MainLinkRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">MainLinkRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:MainLinkRot+=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:MainLinkRot-=MainLinkStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MainBodyStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(MainBodyRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">MainBodyRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(MainBodyRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">MainBodyRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;j&#x27;</span>:MainBodyRot+=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:MainBodyRot-=MainBodyStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> GroundStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(GroundRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">GroundRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(GroundRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">GroundRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:GroundRot+=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:GroundRot-=GroundStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> FrontWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(FrontWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">FrontWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(FrontWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">FrontWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;z&#x27;</span>:FrontWheelsRot+=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:FrontWheelsRot-=FrontWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> BackWheelsStep = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(BackWheelsRot &gt; <span class="number">60.0f</span>)</span><br><span class="line">BackWheelsRot = <span class="number">-3.0f</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(BackWheelsRot &lt; <span class="number">-60.0f</span>)</span><br><span class="line">BackWheelsRot = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">switch</span>(key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:BackWheelsRot+=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:BackWheelsRot-=BackWheelsStep;glutPostRedisplay();<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就成功的读取到了按键并能够根据按键的不同，相应的角度变量发生改变（函数中的按键可以自己设置，根据个人喜好）<br>3、矩阵操作部分<br>首先来了解一下几个函数的用法<br><strong>glLoadIdentity();生成一个单位阵并设置为当前阵<br>glPushMatrix();保存当前的矩阵到一个不知名的地方<br>glPopMatrix();设置之前保存的矩阵为当前阵<br>glMultMatrixf(A);用A矩阵乘当前阵，结果设置为当前阵<br>glRotatef(角度值,0.0f,1.0f,0.0f);后面三个参数若第一个为1，则绕x轴旋转，第二个为1则绕y轴旋转，第三个为1则绕z轴旋转。</strong><br>还有一个平移的库函数我没记住；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RenderScene</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Clear the window with current clearing color</span></span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the matrix state and do the rotations</span></span><br><span class="line">glPushMatrix();</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line"></span><br><span class="line">glPushMatrix();</span><br><span class="line">glCallList(MainBody);</span><br><span class="line"></span><br><span class="line">glPopMatrix();</span><br><span class="line">glPushMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-4.89</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">4.89</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">39.75</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(BackWheels);</span><br><span class="line"></span><br><span class="line">glLoadIdentity();</span><br><span class="line">Translate(<span class="number">0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glRotatef(xRot,<span class="number">1.0f</span>,<span class="number">0.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line">glRotatef(yRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">-0.5f</span> * (PointMax[<span class="number">0</span>] + PointMin[<span class="number">0</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">1</span>] + PointMin[<span class="number">1</span>]),<span class="number">-0.5f</span> * (PointMax[<span class="number">2</span>] + PointMin[<span class="number">2</span>]),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glPushMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-6.63</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">6.63</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-16.50</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(FrontWheels);</span><br><span class="line"></span><br><span class="line">    glPopMatrix();</span><br><span class="line">Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="type">float</span>(<span class="number">-10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glRotatef(GroundRot,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="number">0</span>,<span class="type">float</span>(<span class="number">10</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(Ground);</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">21.74</span>/<span class="number">1000</span>),<span class="type">float</span>(<span class="number">4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(MainLinkRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-21.74</span>/<span class="number">1000</span>),<span class="type">float</span>(<span class="number">-4.06</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(MainLink);</span><br><span class="line"></span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">31.74</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">Rotate_x(ShoveRot,Rotation);</span><br><span class="line">glMultMatrixf(Rotation);</span><br><span class="line">Translate(<span class="number">0</span>,<span class="type">float</span>(<span class="number">-31.74</span>/<span class="number">1000.0</span>),<span class="type">float</span>(<span class="number">-53.46</span>/<span class="number">1000.0</span>),Translation);</span><br><span class="line">glMultMatrixf(Translation);</span><br><span class="line">glCallList(Shove);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the matrix state</span></span><br><span class="line">glPopMatrix();</span><br><span class="line"><span class="comment">// Display the results</span></span><br><span class="line">glutSwapBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码都可在博客开头的网盘里自行提取<br><img src="https://img.mahaofei.com/img/202112231018833-numerical-recipe-57.png" alt=""><br>（2）主体和两个轮子要和（1）分开，因为他们的位移没有叠加关系，具体可用glPushMatrix();和glPopMatrix();实现<br>这部分程序我自己理解的并不是很透彻，如有问题or不懂的请单独找我。</p><p><em><strong>Continue……</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数字化方法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
